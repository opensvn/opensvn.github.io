<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Language on 招财猫的博客</title>
    <link>https://gitop.cc/categories/Language/</link>
    <description>Recent content in Language on 招财猫的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 24 Jul 2019 20:30:19 +0800</lastBuildDate>
    
	<atom:link href="https://gitop.cc/categories/Language/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>重构、测试和调试</title>
      <link>https://gitop.cc/posts/refactoring-testing-debugging/</link>
      <pubDate>Wed, 24 Jul 2019 20:30:19 +0800</pubDate>
      
      <guid>https://gitop.cc/posts/refactoring-testing-debugging/</guid>
      <description>重构以提高可读性和灵活性 提高代码的可读性 我们介绍三个简单的重构，使用lambda、方法引用和流，将它们应用到代码中，以提高代码的可读性： 将匿名类重构为lambda表达式 将lambda表达式重构为方法引用 将命令式数据处理重构为流处理 从匿名类到lambda表达式 下面是使用匿名类创建一</description>
    </item>
    
    <item>
      <title>Collection API增强</title>
      <link>https://gitop.cc/posts/collection-api-enhancements/</link>
      <pubDate>Wed, 24 Jul 2019 14:22:44 +0800</pubDate>
      
      <guid>https://gitop.cc/posts/collection-api-enhancements/</guid>
      <description>Collection工厂 Java 9引入了一些创建小型集合对象的方法，比如Arrays.asList()： List&amp;lt;String&amp;gt; friends = Arrays.asList(&amp;#34;Raphael&amp;#34;, &amp;#34;Olivia&amp;#34;, &amp;#34;Thibaut&amp;#34;); Arrays.asList()返回一个固定大小的列表，可以对其进行更新，但不能添加或删除元素，否则抛出UnsupportedModificationException异常</description>
    </item>
    
    <item>
      <title>并行数据处理和性能</title>
      <link>https://gitop.cc/posts/parallel-data-processing-and-performance/</link>
      <pubDate>Tue, 23 Jul 2019 20:00:47 +0800</pubDate>
      
      <guid>https://gitop.cc/posts/parallel-data-processing-and-performance/</guid>
      <description>并行流 通过调用parallelStream方法，可以将集合转换为并行流。并行流是将元素分割成多个块的流，使用不同的线程处理每个块。因此，你可以自动划分指定操作的工作负载在多核处理器的所有核心上，并使它们一样忙。 public long sequentialSum(long n) { return Stream.iterate(1L, i -&amp;gt; i + 1).limit(n).reduce(0L, Long::sum); } 将顺序流转为并行流 调用parallel方法</description>
    </item>
    
    <item>
      <title>使用流收集数据</title>
      <link>https://gitop.cc/posts/collecting-data-with-streams/</link>
      <pubDate>Tue, 23 Jul 2019 13:04:54 +0800</pubDate>
      
      <guid>https://gitop.cc/posts/collecting-data-with-streams/</guid>
      <description>假设有一个事务列表，你希望根据货币对它们进行分组。在Java 8之前，即使是这样一个简单的例子也很难实现，如下所示： Map&amp;lt;Currency, List&amp;lt;Transaction&amp;gt;&amp;gt; transactionsByCurrencies = new HashMap&amp;lt;&amp;gt;(); for (Transaction transaction : transactions) { Currency currency = transaction.getCurrency(); List&amp;lt;Transaction&amp;gt; transactionsForCurrency = transactionsByCurrencies.get(currency); if (transactionsForCurrency == null) { transactionsForCurrency = new ArrayList&amp;lt;&amp;gt;(); transactionsByCurrencies.put(currency, transactionsForCurrency); } transactionsForCurrency.add(transaction); } 在Java 8之后，仅用一条语句就可以获得完全相同的结果： Map&amp;lt;Currency, List&amp;lt;Transaction&amp;gt;&amp;gt; transactionsByCurrencies = transactions.stream().collect(groupingBy(Transaction::getCurrency)); Collector接口提供了三个</description>
    </item>
    
    <item>
      <title>使用流</title>
      <link>https://gitop.cc/posts/working-with-streams/</link>
      <pubDate>Thu, 11 Jul 2019 08:39:11 +0800</pubDate>
      
      <guid>https://gitop.cc/posts/working-with-streams/</guid>
      <description>过滤 使用谓词过滤 filter方法接受一个谓词函数为参数，并返回包含所有匹配谓词的元素的流。如下例： List&amp;lt;Dish&amp;gt; vegetarianMenu = menu.stream().filter(Dish::isVegetarian).collect(toList()); 如下图所示： 过滤唯一元素 distinct方法返回包含唯一元素的流。如下例： List&amp;lt;Integer&amp;gt; numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4); numbers.stream().filter(i -&amp;gt; i % 2 == 0).distinct().forEach(System.out::println); 如下图所示： 切分流 Java 9添加了两个新方法takeWhile和drop</description>
    </item>
    
    <item>
      <title>流介绍</title>
      <link>https://gitop.cc/posts/introducing-streams/</link>
      <pubDate>Wed, 10 Jul 2019 17:22:30 +0800</pubDate>
      
      <guid>https://gitop.cc/posts/introducing-streams/</guid>
      <description>流是什么 流是对Java API的更新，允许你以声明式的方式操作数据集合。首先看一个例子，假设你想获得所有热量低于400卡的菜肴的名字，并按热量排序。在Java 8之前，你可以这样做： List&amp;lt;Dish&amp;gt; lowCaloricDishes = new ArrayList&amp;lt;&amp;gt;(); for (Dish dish : menu) { if (dish.getCalories() &amp;lt; 400) { lowCaloricDishes.add(dish); } } Collections.sort(lowCaloricDishes, new Comparator&amp;lt;Dish&amp;gt;() { public int compare(Dish dish1, Dish dish2) { return Integer.compare(dish1.getCalories(), dish2.getCalories()); } }); List&amp;lt;String&amp;gt; lowCaloricDishesName = new ArrayList&amp;lt;&amp;gt;(); for (Dish dish : lowCaloricDishes) { lowCaloricDishesName.add(dish.getName()); } 在Ja</description>
    </item>
    
    <item>
      <title>Lambda表达式</title>
      <link>https://gitop.cc/posts/lambda-expressions/</link>
      <pubDate>Wed, 10 Jul 2019 08:48:55 +0800</pubDate>
      
      <guid>https://gitop.cc/posts/lambda-expressions/</guid>
      <description>Lambda概述 lambda表达式没有名称，但是它有参数列表，函数体和返回类型，还可能包含一个异常列表。 匿名，lambda表达式不像方法一样有一个显式的名字 函数，lambda表达式不像方法一样关联到一个特定的类 传递，lambda表达式可以像函数参数一样传递，或者保存到变量里面 简洁</description>
    </item>
    
    <item>
      <title>数组</title>
      <link>https://gitop.cc/posts/arrays/</link>
      <pubDate>Mon, 12 Nov 2018 19:37:34 +0800</pubDate>
      
      <guid>https://gitop.cc/posts/arrays/</guid>
      <description>创建数组 创建数组的最简单方法是使用数组字面值： var empty = []; // An array with no elements var primes = [2, 3, 5, 7, 11]; // An array with 5 numeric elements var misc = [1.1, true, &amp;#34;a&amp;#34;,]; // 3 elements of various types + trailing comma 数组字面值中的元素可以是任意的表达式。如果数组中有省略的元素，其值为undefined： var count = [1,,3]; // An array with 3 elements, the middle one undefined. var undefs = [,,]; // An array with 2 elements, both undefined. 另一种方式是使</description>
    </item>
    
    <item>
      <title>对象</title>
      <link>https://gitop.cc/posts/objects/</link>
      <pubDate>Sat, 03 Nov 2018 21:39:25 +0800</pubDate>
      
      <guid>https://gitop.cc/posts/objects/</guid>
      <description>对象的属性也有属性： 可写属性指定属性的值是否可以设置。 枚举属性指定属性名是否能由for/in循环返回。 可配置属性指定属性是否可以删除和更改。 在ES5之前，自己代码创建的对象中的所有属性都是可写的、可枚举的和可配置的。每个对象都有三个相关的对象属性： 对象的prototype是对另一</description>
    </item>
    
    <item>
      <title>语句</title>
      <link>https://gitop.cc/posts/statements/</link>
      <pubDate>Tue, 30 Oct 2018 21:16:04 +0800</pubDate>
      
      <guid>https://gitop.cc/posts/statements/</guid>
      <description>JavaScript语句以分号结束。表达式被计算以产生值，但是语句被执行以使某些事情发生。 表达式语句 JavaScript中最简单的语句是具有副作用的表达式，比如赋值语句、自增自减运算符、delete操作符和函数调用： greeting = &amp;#34;Hello &amp;#34; + name; i *= 3; counter++; delete o.x; window.close(); 复合语句和空语句 复合语句是包含在大括号</description>
    </item>
    
    <item>
      <title>表达式和操作符</title>
      <link>https://gitop.cc/posts/expressions_and_operators/</link>
      <pubDate>Sun, 28 Oct 2018 21:07:21 +0800</pubDate>
      
      <guid>https://gitop.cc/posts/expressions_and_operators/</guid>
      <description>表达式是JavaScript的一个短语，JavaScript解释器可以对其进行求值。 主表达式 最简单的表达式，称为主表达式，是那些独立的表达式——它们不包含任何简单的表达式。JavaScript中的主要表达式是常量或文字值、特定语言关键字和变量引用。 true // Evalutes to the boolean true value false // Evaluates to the boolean false value</description>
    </item>
    
    <item>
      <title>类型、值和变量</title>
      <link>https://gitop.cc/posts/types_values_variables/</link>
      <pubDate>Sun, 28 Oct 2018 14:24:21 +0800</pubDate>
      
      <guid>https://gitop.cc/posts/types_values_variables/</guid>
      <description>Javascript类型可以分为两大类：原始类型和对象类型。JavaScript原始类型包括数字、字符串、布尔值、null和undefined。null和undefined是它们自己类型的唯一成员。任何不是原始类型的Javascript值都是一个对象。每个对象都是类型Object</description>
    </item>
    
    <item>
      <title>词法结构</title>
      <link>https://gitop.cc/posts/lexical_structure/</link>
      <pubDate>Tue, 16 Oct 2018 08:29:23 +0800</pubDate>
      
      <guid>https://gitop.cc/posts/lexical_structure/</guid>
      <description>介绍 JavaScript是一门大小写敏感的语言 JavaScript程序使用Unicode字符集编写 JavaScript使用\u后跟4位16进制数字代表任何16位Unicode码点 字面值 字面值是程序中直接出现的数据值，下列这些都是字面值： 12 // The number twelve 1.2 // The number one point two &amp;#34;hello world&amp;#34; // A string of text &amp;#39;Hi&amp;#39; // Another</description>
    </item>
    
    <item>
      <title>第12章 动态内存</title>
      <link>https://gitop.cc/posts/cpp-primer-12/</link>
      <pubDate>Fri, 28 Oct 2016 14:46:23 +0000</pubDate>
      
      <guid>https://gitop.cc/posts/cpp-primer-12/</guid>
      <description>静态内存用来存储静态局部对象，类静态成员和全局对象。栈内存用于定义在函数内的非静态对象。静态内存和栈内存分配的对象由编译器自动创建和销毁。栈对象只当其定义的块在执行时存在。静态对象在被使用之前已经创建，当程序结束时销毁。 除了静态内存和栈内存，每一个程序还有一个自由存储区或叫堆。程</description>
    </item>
    
    <item>
      <title>第17章 特殊的库设施</title>
      <link>https://gitop.cc/posts/cpp-primer-17/</link>
      <pubDate>Mon, 17 Oct 2016 09:15:58 +0000</pubDate>
      
      <guid>https://gitop.cc/posts/cpp-primer-17/</guid>
      <description>17.1 tuple类型 tuple是一个类似pair的模板。每一个pair类型有2个不同类型的成员。一个tuple同样有不同类型的成员，但是它可以有任意数量的成员。tuple类型定义在tuple头文件。 注解 tuple可以认为是一个“快捷且脏”的数据结构。 17.1.1 定义和初始化tuple 当我们定义</description>
    </item>
    
    <item>
      <title>第2章 变量和基本类型</title>
      <link>https://gitop.cc/posts/cpp-primer-2/</link>
      <pubDate>Mon, 21 Mar 2016 20:27:17 +0000</pubDate>
      
      <guid>https://gitop.cc/posts/cpp-primer-2/</guid>
      <description>2.1 基础内置类型 C++定义了一组基础类型，包括算术类型和一个特殊的void类型。算术类型表示字符，整型，布尔值和浮点数类型。void类型不关联任何值，而且只能用在一些场合，最常见是用作函数的返回类型。 2.1.1 算术类型 算术类型分为2类：整型（包含了字符和布尔值）和浮点数类型。算术类型的大小</description>
    </item>
    
    <item>
      <title>Python核心编程 第3章</title>
      <link>https://gitop.cc/posts/Core-Python-3/</link>
      <pubDate>Fri, 25 Dec 2015 13:28:23 +0000</pubDate>
      
      <guid>https://gitop.cc/posts/Core-Python-3/</guid>
      <description>3.1 语句和语法 关于Python语句的一些规则和符号： 井号（#）指示Python注释。 换行（\n）是标准行分隔符（一个语句一行） 反斜杠（\）延续一行 分号（;）将2个语句连接在一行 冒号（:）分隔标题行和其单元 单元通过缩进界定 Python文件组织成模块 3.1.1 注释（#） Python注释以井号开</description>
    </item>
    
    <item>
      <title>Python核心编程 第2章</title>
      <link>https://gitop.cc/posts/Core-Python-2/</link>
      <pubDate>Thu, 24 Dec 2015 09:46:13 +0000</pubDate>
      
      <guid>https://gitop.cc/posts/Core-Python-2/</guid>
      <description>命令行选项 -d 提供调试输出 -O 生成优化字节码（产生.pyo文件） -S 启动时不要运行导入地址查询Python路径 -v 详细输出（详细追踪import语句） -m mod 将模块当脚本运行 -Q opt 除法选项 -c cmd 将cmd字符串当Python脚本执行 file 从指定文件运行Python脚本 2.1 程序输出，print语句和&amp;qu</description>
    </item>
    
    <item>
      <title>21世纪C语言 第2章 调试，测试，文档</title>
      <link>https://gitop.cc/posts/21st-c-2/</link>
      <pubDate>Fri, 18 Dec 2015 15:48:18 +0000</pubDate>
      
      <guid>https://gitop.cc/posts/21st-c-2/</guid>
      <description>使用调试器 关于调试器的第一个简明提示：总是使用调试器。 一个调试侦探故事 调试代码： #include &amp;lt;math.h&amp;gt;#include &amp;lt;stdio.h&amp;gt; //size_t typedef struct meanvar {double mean, var;} meanvar; meanvar mean_and_var(const double *data){ long double avg = 0, avg2 = 0; long double ratio; size_t count= 0; for(size_t i=0; !isnan(data[i]); i++){ ratio = count/(count+1); count ++; avg *= ratio; avg2 *= ratio; avg += data[i]/(count +0.0); avg2 += pow(data[i], 2)/(count +0.0); } return (meanvar){.mean = avg, .var = avg2 - pow(avg, 2)}; //E[x^2] - E^2[x] } int main(){ double d[] = { 34124.75, 34124.48, 34124.90, 34125.31, 34125.05, 34124.98, NAN}; meanvar mv = mean_and_var(d); printf(&amp;#34;mean: %.10g var: %.10g\n&amp;#34;, mv.mean, mv.var*6/5.); double d2[] = { 4.75, 4.48, 4.90, 5.31, 5.05,</description>
    </item>
    
    <item>
      <title>21世纪C语言 第1章 便利编译配置</title>
      <link>https://gitop.cc/posts/21st-c-1/</link>
      <pubDate>Tue, 15 Dec 2015 19:55:08 +0000</pubDate>
      
      <guid>https://gitop.cc/posts/21st-c-1/</guid>
      <description>使用包管理器 必须获取的包： 编译器。必须安装gcc；clang可能也有用。 gdb，调试器 Valgrind，测试C内存使用错误。 gprof，一个分析工具 make，你永远不需要直接调用编译器 pkg-config，查找库 Doxygen，文档生成 文本编辑器。Emacs或vim。 自动工具：A</description>
    </item>
    
    <item>
      <title>第16章 模板和泛型编程</title>
      <link>https://gitop.cc/posts/cpp-primer-16/</link>
      <pubDate>Mon, 14 Dec 2015 10:34:42 +0000</pubDate>
      
      <guid>https://gitop.cc/posts/cpp-primer-16/</guid>
      <description>面向对象编程和泛型编程都是处理程序编写时类型未知的情况。两者的区别是面向对象编程直到运行时类型才能知道，而泛型编程类型在编译期间知道。 容器，迭代器和算法都是泛型编程的例子。当编写一个泛型程序，我们用一种独立于任何类型的方式编写代码。当使用一个泛型程序，我们提供程序的实例将操作的类</description>
    </item>
    
    <item>
      <title>第15章 面向对象编程</title>
      <link>https://gitop.cc/posts/cpp-primer-15/</link>
      <pubDate>Mon, 21 Sep 2015 09:04:53 +0000</pubDate>
      
      <guid>https://gitop.cc/posts/cpp-primer-15/</guid>
      <description>15.1 OOP概述 面向对象编程的关键思想是数据抽象，继承和动态绑定。使用数据抽象，我们可以定义接口和实现分离的类。通过继承，我们可以定义相似类之间的关系模型。通过动态绑定，我们可以使用这些类对象而忽略它们之间的差别。 继承 通过继承联系的类构成一个层级关系。典型地，有一个基类在层级的顶端，</description>
    </item>
    
    <item>
      <title>第14章 重载操作和转换</title>
      <link>https://gitop.cc/posts/cpp-primer-14/</link>
      <pubDate>Sun, 20 Sep 2015 10:47:02 +0000</pubDate>
      
      <guid>https://gitop.cc/posts/cpp-primer-14/</guid>
      <description>基本概念 重载操作符是具有特殊名字的函数：关键字operator后面跟着需要被定义的操作符的符号。像其它函数一样，重载操作符有返回值，参数列表和函数体。 重载操作符的参数和操作符的操作数一样多。除了函数调用操作符(operator())，重载操作符没有默认实参。 注意 当重载操作符是成员</description>
    </item>
    
  </channel>
</rss>