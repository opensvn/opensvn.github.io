<!DOCTYPE html>
<html lang="en-us">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c">

<meta itemprop="name" content="第2章 变量和基本类型">
<meta itemprop="description" content="2.1 基础内置类型 C&#43;&#43;定义了一组基础类型，包括算术类型和一个特殊的void类型。算术类型表示字符，整型，布尔值和浮点数类型。void类型不关联">


<meta itemprop="datePublished" content="2016-03-21T20:27:17&#43;00:00" />
<meta itemprop="dateModified" content="2016-03-21T20:27:17&#43;00:00" />
<meta itemprop="wordCount" content="6570">



<meta itemprop="keywords" content="C&#43;&#43;," />
<meta property="og:title" content="第2章 变量和基本类型" />
<meta property="og:description" content="2.1 基础内置类型 C&#43;&#43;定义了一组基础类型，包括算术类型和一个特殊的void类型。算术类型表示字符，整型，布尔值和浮点数类型。void类型不关联" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://gitop.cc/posts/cpp-primer-2/" />
<meta property="article:published_time" content="2016-03-21T20:27:17&#43;00:00"/>
<meta property="article:modified_time" content="2016-03-21T20:27:17&#43;00:00"/>
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="第2章 变量和基本类型"/>
<meta name="twitter:description" content="2.1 基础内置类型 C&#43;&#43;定义了一组基础类型，包括算术类型和一个特殊的void类型。算术类型表示字符，整型，布尔值和浮点数类型。void类型不关联"/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>第2章 变量和基本类型</title>
	<link rel="stylesheet" href="http://gitop.cc/css/style.min.568c54a56780af2a70c45272522247710b69dbfc080b315211fb98381e3796f8.css" integrity="sha256-VoxUpWeArypwxFJyUiJHcQtp2/wICzFSEfuYOB43lvg=">
	
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp faster">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="http://gitop.cc">静心</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="http://gitop.cc/posts/">Posts</a>
				<a href="http://gitop.cc/about/">About</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<span class="hdr-social hide-in-mobile"><a href="https://github.com/opensvn" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="http://gitop.cc/posts/">Posts</a></li>
			<li><a href="http://gitop.cc/about/">About</a></li>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Mar 21, 2016</span></div>
				<h1>第2章 变量和基本类型</h1>
			</header>
			<div class="content">
				

<h2 id="2-1-基础内置类型">2.1 基础内置类型<a href="#2-1-基础内置类型" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>C++定义了一组基础类型，包括算术类型和一个特殊的void类型。算术类型表示字符，整型，布尔值和浮点数类型。void类型不关联任何值，而且只能用在一些场合，最常见是用作函数的返回类型。</p>

<h3 id="2-1-1-算术类型">2.1.1 算术类型<a href="#2-1-1-算术类型" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>算术类型分为2类：整型（包含了字符和布尔值）和浮点数类型。算术类型的大小不同机器可能不一样。</p>

<table>
<thead>
<tr>
<th align="left">Type</th>
<th align="left">Meaning</th>
<th align="left">Minimum Size</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">bool</td>
<td align="left">boolean</td>
<td align="left">NA</td>
</tr>

<tr>
<td align="left">char</td>
<td align="left">character</td>
<td align="left">8 bits</td>
</tr>

<tr>
<td align="left">wchar_t</td>
<td align="left">wide character</td>
<td align="left">16 bits</td>
</tr>

<tr>
<td align="left">char16_t</td>
<td align="left">Unicode character</td>
<td align="left">16 bits</td>
</tr>

<tr>
<td align="left">char32_t</td>
<td align="left">Unicode character</td>
<td align="left">32 bits</td>
</tr>

<tr>
<td align="left">short</td>
<td align="left">short integer</td>
<td align="left">16 bits</td>
</tr>

<tr>
<td align="left">int</td>
<td align="left">integer</td>
<td align="left">16 bits</td>
</tr>

<tr>
<td align="left">long</td>
<td align="left">long integer</td>
<td align="left">32 bits</td>
</tr>

<tr>
<td align="left">long long</td>
<td align="left">long integer</td>
<td align="left">64 bits</td>
</tr>

<tr>
<td align="left">float</td>
<td align="left">single-precision floating-point</td>
<td align="left">6 significant digits</td>
</tr>

<tr>
<td align="left">double</td>
<td align="left">double-precision floating-point</td>
<td align="left">10 significant digits</td>
</tr>

<tr>
<td align="left">long double</td>
<td align="left">extended-precision floating-point</td>
<td align="left">10 significant digits</td>
</tr>
</tbody>
</table>

<p>bool类型代表了真值true和false。</p>

<p>基本的字符类型是char。一个char保证足够大来保存机器的基本字符集。也就是一个char和一个机器字节一样大。剩下的字符类型wchar_t，char16_t和char32_t用于扩展字符集。wchar_t保证可以存放机器最大扩展字符集中任意字符。char16_t和char32_t被用于Unicode字符。</p>

<p>剩下的整型表示不同大小的整数。C++保证int至少和short一样大，long至少和int一样大，long long至少和long一样大。long long类型由新标准引入。</p>

<p>浮点数类型表示单精度，双精度和扩展精度的值。标准指定了一个最小数量的有效数字。大多数编译器提供更高的精确度。典型地，float占32位，double占64位，long double占96或128位。float和double通常产生7位和16位有效数字。</p>

<p><strong>有符号和无符号类型</strong></p>

<p>除了bool和扩展的字符类型，整型可以是有符号或无符号的。有符号类型表示负值或正值（包括0），无符号的类型的值大于或等于0。</p>

<p>在整型前面加上unsigned关键字就得到相应的无符号类型。unsigned int可以简写为unsigned。</p>

<p>和其他整型不一样，有3种不一样的基本字符类型：char, signed char和unsigned char。char类型使用signed char或unsigned char其中一种表示。</p>

<p>标准没有定义signed类型如何表示，但是明确了signed类型的正值和负值范围应该一样大。</p>

<blockquote>
<p><strong>建议</strong>：决定使用哪种类型</p>
</blockquote>

<ul>
<li>当你知道值不可能是负的时，使用unsigned类型</li>
<li>使用int做整型运算。short通常太小，long通常和int一样大小。如果超过int范围，则使用long long。</li>
<li>在算术表达式中不要使用char或bool。使用char计算尤其容易出问题，因为在一些机器上char是有符号的，而在另一些机器上char是无符号的。</li>
<li>使用double做浮点计算。float通常精度不够，而且计算double的开销与float相比可以忽略。</li>
</ul>

<h3 id="2-1-2-类型转换">2.1.2 类型转换<a href="#2-1-2-类型转换" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>一个对象的类型定义了这个对象可能包含的数据以及它能执行的操作。在诸多类型支持的操作中的一个是转换为其他相关类型的能力。</p>

<p>类型转换自动发生在当我们使用一种类型的对象在期待另一种类型的地方。</p>

<p>当我们将一种算术类型赋值给另一种算术类型时，会发生什么取决于等号左边类型允许的值的范围：</p>

<ul>
<li>当将非bool算术类型赋值给bool对象时，如果值为0，则结果是false，否则为true。</li>
<li>当将bool赋值给其他算术类型时，如果bool为true，则结果为1，否则为0。</li>
<li>当将浮点数类型赋值给整型时，小数点后面的部分被截断。</li>
<li>当将整型值赋值给浮点数类型时，小数部分为0。如果整型有比浮点数有效数字更多数字时，可能会损失精度。</li>
<li>如果将超出范围的值赋值给无符号类型时，结果为改值和目标类型最大值的余数。</li>
<li>如果将超出范围的值赋值给有符号类型时，结果是未定义的。</li>
</ul>

<blockquote>
<p><strong>建议</strong>：避免未定义的依赖具体实现的行为</p>
</blockquote>

<p><strong>涉及无符号类型的表达式</strong></p>

<p>尽管我们不太可能有意地将一个负值赋值给一个无符号类型，但是我们非常容易写出代码隐式地这样做。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">unsigned</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">42</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// prints -84
</span><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">u</span> <span class="o">+</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// if 32-bit ints, prints 4294967264
</span></code></pre></div>

<p>不管一个或者两个操作数是无符号的，当用无符号数减去一个数时，我们必须确保结果不能是负数：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">unsigned</span> <span class="n">u1</span> <span class="o">=</span> <span class="mi">42</span><span class="p">,</span> <span class="n">u2</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">u1</span> <span class="o">-</span> <span class="n">u2</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// ok: result is 32
</span><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">u2</span> <span class="o">-</span> <span class="n">u1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// ok: but the result will wrap around
</span></code></pre></div>

<p>无符号数不可能小于0也影响我们如何写循环。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// WRONG: u can never be less than 0; the condition will always succeed
</span><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">u</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">u</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">u</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div>

<blockquote>
<p><strong>注意</strong>：不要混合使用signed和unsigned类型
需要记住signed值会自动转换为unsigned值。</p>
</blockquote>

<h3 id="2-1-3-字面值">2.1.3 字面值<a href="#2-1-3-字面值" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>一个值，比如42，被称为字面值，因为它的值是不证自明的。每一个字面值都有一个类型。一个字面值的形式和值确定了它的类型。</p>

<p><strong>整型和浮点型字面值</strong></p>

<p>我们可以使用十进制，八进制或十六进制表示法来写整型字面值。八进制字面值以0开始，十六进制字面值以0x或0X开始。</p>

<p>默认地，十进制字面值是有符号的，而八进制和十六进制字面值可以使有符号或无符号的。十进制字面值类型为适合其值的最小整型，八进制字面值和十六进制字面值类型为适合其值的最小有符号或无符号整型。没有short类型的字面值。</p>

<p><em>Table 2.2 指定字面值的类型</em></p>

<table>
<thead>
<tr>
<th align="left">Prefix</th>
<th align="left">Meaning</th>
<th align="left">Type</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">u</td>
<td align="left">Unicode 16 character</td>
<td align="left">char16_t</td>
</tr>

<tr>
<td align="left">U</td>
<td align="left">Unicode 32 character</td>
<td align="left">char32_t</td>
</tr>

<tr>
<td align="left">L</td>
<td align="left">wide character</td>
<td align="left">wchar_t</td>
</tr>

<tr>
<td align="left">u8</td>
<td align="left">utf-8(string literals only)</td>
<td align="left">char</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th align="left">Suffix</th>
<th align="left">Minimum Type</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">u or U</td>
<td align="left">unsigned</td>
</tr>

<tr>
<td align="left">l or L</td>
<td align="left">long</td>
</tr>

<tr>
<td align="left">ll or LL</td>
<td align="left">long long</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th align="left">Suffix</th>
<th align="left">Type</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">f or F</td>
<td align="left">float</td>
</tr>

<tr>
<td align="left">l or L</td>
<td align="left">long double</td>
</tr>
</tbody>
</table>

<p>浮点数字面值包含小数点或指数(E或e)指定使用科学计数法。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="mf">3.14159</span>    <span class="mf">3.14159E0</span>    <span class="mf">0.</span>    <span class="mf">0e0</span>    <span class="mf">.001</span>
</code></pre></div>

<p>浮点数字面值默认为double类型。我们可以添加后缀覆盖默认行为。</p>

<p><strong>字符和字符串字面值</strong></p>

<p>一个单引号包含的字符是一个类型为char的字面值。0个或多个双引号包含的字符是字符串字面值：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="sc">&#39;a&#39;</span>  <span class="c1">// character literal
</span><span class="c1"></span><span class="s">&#34;Hello World!&#34;</span>  <span class="c1">// string literal
</span></code></pre></div>

<p>一个字符串字面值的类型是一个const char数组。编译器给每一个字符串字面值追加一个空字符(&rsquo;\0&rsquo;)。</p>

<p>两个相邻的仅仅由空白符分割的字符串字面值连接为一个字面值。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// multiline string literal
</span><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;a really, really long string literal &#34;</span>
             <span class="s">&#34;that spans two lines&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div>

<p><strong>转义序列</strong></p>

<table>
<thead>
<tr>
<th align="left">Escape Sequence</th>
<th align="left">Meaning</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">\n</td>
<td align="left">newline</td>
</tr>

<tr>
<td align="left">\t</td>
<td align="left">horizontal tab</td>
</tr>

<tr>
<td align="left">\a</td>
<td align="left">alert(bell)</td>
</tr>

<tr>
<td align="left">\v</td>
<td align="left">vertical tab</td>
</tr>

<tr>
<td align="left">\b</td>
<td align="left">backspace</td>
</tr>

<tr>
<td align="left">\&rdquo;</td>
<td align="left">double quote</td>
</tr>

<tr>
<td align="left">\<br></td>
<td align="left">backslash</td>
</tr>

<tr>
<td align="left">\?</td>
<td align="left">question mark</td>
</tr>

<tr>
<td align="left">\&rsquo;</td>
<td align="left">single quote</td>
</tr>

<tr>
<td align="left">\r</td>
<td align="left">carriage return</td>
</tr>

<tr>
<td align="left">\f</td>
<td align="left">formfeed</td>
</tr>
</tbody>
</table>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">newline</span>            <span class="err">\</span><span class="n">n</span>     <span class="n">horizontal</span> <span class="n">tab</span>      <span class="err">\</span><span class="n">t</span>     <span class="n">alert</span> <span class="p">(</span><span class="n">bell</span><span class="p">)</span>       <span class="err">\</span><span class="n">a</span>
<span class="n">vertical</span> <span class="n">tab</span>       <span class="err">\</span><span class="n">v</span>     <span class="n">backspace</span>          <span class="err">\</span><span class="n">b</span>     <span class="kt">double</span> <span class="n">quote</span>  <span class="err">\</span><span class="s">&#34;</span><span class="err">
</span><span class="err"></span><span class="s">backslash         </span><span class="se">\\</span><span class="s">     question mark     \?     single quote    </span><span class="se">\&#39;</span><span class="err">
</span><span class="err"></span><span class="s">carriage return   </span><span class="se">\r</span><span class="s">     formfeed       </span><span class="se">\f</span><span class="s">&#34;</span>
</code></pre></div>

<p>我们也可以写通用的转义序列，即\x后跟一个或多个16进制数字或者\后跟1至3个8进制数字。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="err">\</span><span class="mi">7</span> <span class="p">(</span><span class="n">bell</span><span class="p">)</span>    <span class="err">\</span><span class="mi">12</span> <span class="p">(</span><span class="n">newline</span><span class="p">)</span>     <span class="err">\</span><span class="mi">40</span> <span class="p">(</span><span class="n">blank</span><span class="p">)</span>
<span class="err">\</span><span class="mi">0</span> <span class="p">(</span><span class="n">null</span><span class="p">)</span>    <span class="err">\</span><span class="mi">115</span> <span class="p">(</span><span class="sc">&#39;M&#39;</span><span class="p">)</span>    <span class="err">\</span><span class="n">x4d</span> <span class="p">(</span><span class="sc">&#39;M&#39;</span><span class="p">)</span>
</code></pre></div>

<p>注意如果\后面后跟3个以上8进制数字，只有前3个有效。相反\x使用所有后续16进制数字。</p>

<p><strong>指定字面值的类型</strong></p>

<p>我们可以提供前缀或后缀来覆盖整数，浮点数或字符字面值的默认类型。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="sa">L</span><span class="sc">&#39;a&#39;</span>     <span class="c1">// wide character literal, type is wchar_t
</span><span class="c1"></span><span class="sa">u8</span><span class="s">&#34;hi!&#34;</span>  <span class="c1">// utf-8 string literal (utf-8 encodes a Unicode character in 8 bits)
</span><span class="c1"></span><span class="mi">42ULL</span>    <span class="c1">// unsigned integer literal, type is unsigned long long
</span><span class="c1"></span><span class="mf">1E-3</span><span class="n">F</span>    <span class="c1">// single-precision floating-point literal, type is float
</span><span class="c1"></span><span class="mf">3.14159</span><span class="n">L</span> <span class="c1">// extended-precision floating-point literal, type is long double
</span></code></pre></div>

<blockquote>
<p><strong>最佳实践</strong>
当写一个long字面值时，使用大写的L，小写l和1容易混淆。</p>
</blockquote>

<p><strong>布尔类型和指针类型字面值</strong></p>

<p>true和false是布尔类型的字面值，nullptr是指针的字面值。</p>

<h2 id="2-2-变量">2.2 变量<a href="#2-2-变量" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>一个变量给我们提供了程序能够操作的命名存储空间。C++中每一个变量都有一个类型。类型决定了变量的大小和在内存种的布局，以及可以应用到变量的一组操作。</p>

<h3 id="2-2-1-变量定义">2.2.1 变量定义<a href="#2-2-1-变量定义" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>一个简单的变量定义由类型说明符，一个或多个由逗号分隔的变量名组成，由分号结束。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="c1">// sum, value, and units_sold have type int
</span><span class="c1"></span>    <span class="n">units_sold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// sum and units_sold have initial value 0
</span><span class="c1"></span><span class="n">Sales_item</span> <span class="n">item</span><span class="p">;</span>    <span class="c1">// item has type Sales_item (see § 1.5.1 (p. 20))
</span><span class="c1">// string is a library type, representing a variable-length sequence of characters
</span><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">book</span><span class="p">(</span><span class="s">&#34;0-201-78345-X&#34;</span><span class="p">);</span> <span class="c1">// book initialized from string literal
</span></code></pre></div>

<p><strong>初始化式</strong></p>

<p>一个被初始化的对象在它创建时获得指定的值。用来初始化一个变量的值可以是任意复杂的表达式。当一个定义语句定义多个变量时，前面定义的变量对后面的变量可见。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// ok: price is defined and initialized before it is used to initialize discount
</span><span class="c1"></span><span class="kt">double</span> <span class="n">price</span> <span class="o">=</span> <span class="mf">109.99</span><span class="p">,</span> <span class="n">discount</span> <span class="o">=</span> <span class="n">price</span> <span class="o">*</span> <span class="mf">0.16</span><span class="p">;</span>
<span class="c1">// ok: call applyDiscount and use the return value to initialize salePrice
</span><span class="c1"></span><span class="kt">double</span> <span class="n">salePrice</span> <span class="o">=</span> <span class="n">applyDiscount</span><span class="p">(</span><span class="n">price</span><span class="p">,</span> <span class="n">discount</span><span class="p">);</span>
</code></pre></div>

<blockquote>
<p><strong>警告</strong>
初始化不是赋值。初始化发生在一个变量创建时给定一个值。赋值抹掉对象当前的值并用新值替代。</p>
</blockquote>

<p><strong>列表初始化</strong></p>

<p>初始化的一个复杂主题是语言定义了几种不同形式的初始化方式。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">units_sold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">units_sold</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">units_sold</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="kt">int</span> <span class="nf">units_sold</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div>

<p>新标准引入花括号作为普遍使用的初始化方式。这种初始化方式称为列表初始化。列表初始化现在可以用在任何时候初始化一个对象以及某些情况下赋值给一个对象。</p>

<p>当使用内置类型的变量时，列表初始化有一个重要的性质：编译器不允许会导致精度损失的内置类型列表初始化。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">long</span> <span class="kt">double</span> <span class="n">ld</span> <span class="o">=</span> <span class="mf">3.1415926536</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">{</span><span class="n">ld</span><span class="p">},</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="n">ld</span><span class="p">};</span> <span class="c1">// error: narrowing conversion required
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">c</span><span class="p">(</span><span class="n">ld</span><span class="p">),</span> <span class="n">d</span> <span class="o">=</span> <span class="n">ld</span><span class="p">;</span>   <span class="c1">// ok: but value will be truncated
</span></code></pre></div>

<p><strong>默认初始化</strong></p>

<p>当我们定义变量没有提供初始化式时，变量被默认初始化。这些变量被给予默认值。默认值取决于变量的类型以及在哪里定义变量。</p>

<p>内置类型对象的默认值取决于变量在哪里定义。定义在任何函数外的变量初始化为0。定义在函数内的变量未初始化。内置类型对象未初始化的值是未定义的。</p>

<p>每一个类控制如何初始化类对象。大多数类允许我们定义对象时不用显式指定初始化式。这些类为我们提供合适的默认值。</p>

<blockquote>
<p><strong>注解</strong>
定义在函数内的未初始化的内置类型对象拥有未定义的值。没有显式初始化的类对象拥有类定义好的值。</p>

<p><strong>警告</strong>
未初始化的变量会引起运行时的问题</p>

<p><strong>提示</strong>
我们建议初始化每一个内置类型对象的值。这并不总是必要的，但是它更安全。</p>
</blockquote>

<h3 id="2-2-2-变量声明与定义">2.2.2 变量声明与定义<a href="#2-2-2-变量声明与定义" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>为了允许程序按不同逻辑部分来写，C++支持所谓的分离编译（separate compilation）。分离编译允许我们将程序分解为多个文件，每一个文件可以独立编译。</p>

<p>为了支持分离编译，C++区分声明和定义。一个声明使得一个名字被程序知道。一个定义创建关联的实体。</p>

<p>为了获得一个声明而不是定义，可以添加extern关键字且不需要提供初始化式：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">extern</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>   <span class="c1">// declares but does not define i
</span><span class="c1"></span><span class="kt">int</span> <span class="n">j</span><span class="p">;</span>          <span class="c1">// declares and defines j
</span></code></pre></div>

<p>任何包含显式初始化式的声明都是一个定义。一个有初始化式的extern是一个定义：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">extern</span> <span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.1416</span><span class="p">;</span> <span class="c1">// definition
</span></code></pre></div>

<p>在函数内给extern提供初始化式是错误的。</p>

<blockquote>
<p><strong>注解</strong>
变量必须仅定义一次但是可以声明多次。</p>
</blockquote>

<h3 id="2-2-3-标识符">2.2.3 标识符<a href="#2-2-3-标识符" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>C++中标识符由字母，数字和下划线组成。语言没有限制标识符的长度。标识符必须以字母或下划线开始。标识符是区分大小写的。</p>

<p>C++预留了一组名字给语言本身用，这些名字不能用作标识符。</p>

<p><em>C++关键字</em></p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">alignas</span>          <span class="k">continue</span>         <span class="k">friend</span>           <span class="k">register</span>         <span class="nb">true</span>
<span class="k">alignof</span>          <span class="k">decltype</span>         <span class="k">goto</span>             <span class="k">reinterpret_cast</span> <span class="k">try</span>
<span class="k">asm</span>              <span class="k">default</span>          <span class="k">if</span>               <span class="k">return</span>           <span class="k">typedef</span>
<span class="k">auto</span>             <span class="k">delete</span>           <span class="kr">inline</span>           <span class="kt">short</span>            <span class="k">typeid</span>
<span class="kt">bool</span>             <span class="k">do</span>               <span class="kt">int</span>              <span class="kt">signed</span>           <span class="k">typename</span>
<span class="k">break</span>            <span class="kt">double</span>           <span class="kt">long</span>             <span class="k">sizeof</span>           <span class="k">union</span>
<span class="k">case</span>             <span class="k">dynamic_cast</span>     <span class="k">mutable</span>          <span class="k">static</span>           <span class="kt">unsigned</span>
<span class="k">catch</span>            <span class="k">else</span>             <span class="k">namespace</span>        <span class="k">static_assert</span>    <span class="k">using</span>
<span class="kt">char</span>             <span class="k">enum</span>             <span class="k">new</span>              <span class="k">static_cast</span>      <span class="k">virtual</span>
<span class="kt">char16_t</span>         <span class="k">explicit</span>         <span class="k">noexcept</span>         <span class="k">struct</span>           <span class="kt">void</span>
<span class="kt">char32_t</span>         <span class="k">export</span>           <span class="k">nullptr</span>          <span class="k">switch</span>           <span class="k">volatile</span>
<span class="k">class</span><span class="err">            </span><span class="nc">extern</span>           <span class="k">operator</span>         <span class="k">template</span>         <span class="n">wchar_t</span>
<span class="k">const</span>            <span class="nb">false</span>            <span class="k">private</span>          <span class="k">this</span>             <span class="k">while</span>
<span class="k">constexpr</span>        <span class="kt">float</span>            <span class="k">protected</span>        <span class="k">thread_local</span>
<span class="k">const_cast</span>       <span class="k">for</span>              <span class="k">public</span>           <span class="k">throw</span>
</code></pre></div>

<p><em>C++可选操作符名字</em></p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">and</span>    <span class="n">bitand</span> <span class="n">compl</span> <span class="n">not_eq</span> <span class="n">or_eq</span> <span class="n">xor_eq</span>
<span class="n">and_eq</span> <span class="n">bitor</span>  <span class="n">not</span>   <span class="n">or</span>     <span class="n">xor</span>
</code></pre></div>

<p>标准也同样保留了一组名字用于标准库。我们自己的程序最好不要使用两个连续的下划线或一个下划线紧跟一个大写字母开头的标识符。此外定义在函数外的标识符不要以下划线开头。</p>

<p><strong>变量名的约定</strong></p>

<p>有一些大家都接收的变量名约定，遵循这些约定可以提高程序的可读性。</p>

<ul>
<li>标识符应该给它的含义一些提示。</li>
<li>变量名通常是小写的。</li>
<li>类名通常以大写字母开头，比如Sales_item。</li>
<li>多个单词组成的标识符应该能在视觉上区分每一个单词，比如student_loan或studentLoan。</li>
</ul>

<blockquote>
<p><strong>最佳实践</strong>
当一致遵循的时候，命名约定最有用。</p>
</blockquote>

<h3 id="2-2-4-名字的作用域">2.2.4 名字的作用域<a href="#2-2-4-名字的作用域" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>一个作用域是程序的一部分，在其中一个名字有特定的意义。C++种大多数作用域由花括号分隔。相同的名字可以引用不同作用域中的不同实体。名字从声明的地方开始可见，直到离开这个作用域。</p>

<blockquote>
<p><strong>建议：在第一次使用的地方定义变量</strong></p>
</blockquote>

<p><strong>嵌套作用域</strong></p>

<p>作用域可以包含其他作用域。被包含的作用域称为内部作用域，包含的作用域称为外部作用域。外部作用域的名字对内部作用域可见。当名字相同时，内部作用域中的名字隐藏外部作用域的名字。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">reused</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>  <span class="c1">// reused has global scope
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">reused</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// global reused
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">reused</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// local reused hides global one
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">reused</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">::</span><span class="n">reused</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// explicitly requests the global reused
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<blockquote>
<p><strong>警告</strong>
定义一个与全局变量同名的局部变量几乎总是坏想法。</p>
</blockquote>

<h2 id="2-3-复合类型">2.3 复合类型<a href="#2-3-复合类型" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>复合类型是依据其它类型定义的类型。C++有多种复合类型，指针和引用就是其中2种。</p>

<h3 id="2-3-1-引用">2.3.1 引用<a href="#2-3-1-引用" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>引用定义了对象的一个别名。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">ival</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">refVal</span> <span class="o">=</span> <span class="n">ival</span><span class="p">;</span>  <span class="c1">// refVal refers to (is another name for) ival
</span><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">refVal2</span><span class="p">;</span>        <span class="c1">// error: a reference must be initialized
</span></code></pre></div>

<p>当定义一个引用时，我们将引用绑定到初始化对象上。引用一旦初始化后，就不能绑定到其他对象了。因此，引用必须初始化。</p>

<p><strong>引用是一个别名</strong></p>

<p>引用不是一个对象，它仅仅是一个已经存在的对象的另一个名字。当引用被定义后，所有对引用的操作实际上是操作引用绑定的对象。因为引用不是一个对象，我们不能定义一个引用的引用。</p>

<p><strong>引用定义</strong></p>

<p>我们可以在一个定义里面定义多个引用。每一个标识符前面必须是&amp;。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">i2</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">;</span>  <span class="c1">// i and i2 are both ints
</span><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">i2</span><span class="p">;</span>      <span class="c1">// r is a reference bound to i; r2 is an int
</span><span class="c1"></span><span class="kt">int</span> <span class="n">i3</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ri</span> <span class="o">=</span> <span class="n">i3</span><span class="p">;</span>  <span class="c1">// i3 is an int; ri is a reference bound to i3
</span><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">r3</span> <span class="o">=</span> <span class="n">i3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r4</span> <span class="o">=</span> <span class="n">i2</span><span class="p">;</span>   <span class="c1">// both r3 and r4 are references
</span></code></pre></div>

<p>除了2个例外，引用的类型和它绑定对象的类型必须完全一致。而且引用只能绑定到一个对象，不能绑定到字面值或表达式的结果上。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="o">&amp;</span><span class="n">refVal4</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>   <span class="c1">// error: initializer must be an object
</span><span class="c1"></span><span class="kt">double</span> <span class="n">dval</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">refVal5</span> <span class="o">=</span> <span class="n">dval</span><span class="p">;</span> <span class="c1">// error: initializer must be an int object
</span></code></pre></div>

<h3 id="2-3-2-指针">2.3.2 指针<a href="#2-3-2-指针" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>指针是一个指向其他类型的复合类型。和引用一样，指针也是用来间接访问其他对象。和引用不一样的是，指针本身是一个对象。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="o">*</span><span class="n">ip1</span><span class="p">,</span> <span class="o">*</span><span class="n">ip2</span><span class="p">;</span>  <span class="c1">// both ip1 and ip2 are pointers to int
</span><span class="c1"></span><span class="kt">double</span> <span class="n">dp</span><span class="p">,</span> <span class="o">*</span><span class="n">dp2</span><span class="p">;</span> <span class="c1">// dp2 is a pointer to double; dp is a double
</span></code></pre></div>

<p><strong>获取对象的地址</strong></p>

<p>指针保存了另一个对象的地址。我们使用取地址符获得一个对象的地址：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">ival</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ival</span><span class="p">;</span> <span class="c1">// p holds the address of ival; p is a pointer to ival
</span></code></pre></div>

<p>因为引用不是对象，它们没有地址。因此不能定义指向引用的指针。</p>

<p>除了2个例外，指针的类型和它指向的对象的类型必须匹配：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">double</span> <span class="n">dval</span><span class="p">;</span>
<span class="kt">double</span> <span class="o">*</span><span class="n">pd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dval</span><span class="p">;</span>  <span class="c1">// ok: initializer is the address of a double
</span><span class="c1"></span><span class="kt">double</span> <span class="o">*</span><span class="n">pd2</span> <span class="o">=</span> <span class="n">pd</span><span class="p">;</span>    <span class="c1">// ok: initializer is a pointer to double
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">pd</span><span class="p">;</span>  <span class="c1">// error: types of pi and pd differ
</span><span class="c1"></span><span class="n">pi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dval</span><span class="p">;</span>    <span class="c1">// error: assigning the address of a double to a pointer to int
</span></code></pre></div>

<p><strong>指针值</strong></p>

<p>存储在指针里面的值可以是以下4种状态种的一个：
1. 它可以指向一个对象。
2. 它可以指向紧跟一个对象后面的空间。
3. 它可以是空指针，指示它没有绑定到任何对象。
4. 它可以是非法的。除了上面3种值，其他值都是非法的。</p>

<p><strong>使用指针访问一个对象</strong></p>

<p>我们可以使用一个解引用操作符访问指针指向的对象：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">ival</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ival</span><span class="p">;</span> <span class="c1">// p holds the address of ival; p is a pointer to ival
</span><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>     <span class="c1">// * yields the object to which p points; prints 42
</span></code></pre></div>

<blockquote>
<p><strong>注解</strong>
我们只能解引用一个合法的指针。</p>
</blockquote>

<p><strong>空指针</strong></p>

<p>空指针不指向任何对象。在使用指针之前，代码可以检查指针是不是空指针。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="c1">// equivalent to int *p1 = 0;
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>       <span class="c1">// directly initializes p2 from the literal constant 0
</span><span class="c1">// must #include cstdlib
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">p3</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>    <span class="c1">// equivalent to int *p3 = 0;
</span></code></pre></div>

<p>将一个整数变量赋值给指针是非法的，即使这个变量碰巧值为0。</p>

<blockquote>
<p><strong>建议：初始化所有指针</strong></p>
</blockquote>

<p><strong>赋值和指针</strong></p>

<p>当赋值给指针时，我们给指针本身一个新值。赋值使得指针指向一个不同的对象。</p>

<p><strong>其他指针操作</strong></p>

<p>常量表达式是一个值不能改变且能在编译期间计算出值的表达式。</p>

<p>constexpr变量
由constexpr声明的变量隐式为const并且必须由常量表达式初始化。</p>

<p>指针和constexpr</p>

<p>当我们在constexpr声明中定义一个指针时，constexpr指示符应用到指针，而不是指针指向的对象。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>     <span class="c1">// p is a pointer to a const int
</span><span class="c1"></span><span class="k">constexpr</span> <span class="kt">int</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="c1">// q is a const pointer to int
</span></code></pre></div>

<p>constexpr产生一个top-level const。</p>

<h1 id="2-5-处理类型">2.5 处理类型<a href="#2-5-处理类型" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>

<h2 id="2-5-1-类型别名">2.5.1 类型别名<a href="#2-5-1-类型别名" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>传统上我们使用typedef定义类型别名</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>     <span class="c1">// p is a pointer to a const int
</span><span class="c1"></span><span class="k">constexpr</span> <span class="kt">int</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="c1">// q is a const pointer to int
</span></code></pre></div>

<p>C++11引入另一种定义类型别名的方法。别名声明。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">using</span> <span class="n">SI</span> <span class="o">=</span> <span class="n">Sales_item</span><span class="p">;</span>  <span class="c1">// SI is a synonym for Sales_item
</span><span class="c1"></span>
<span class="k">typedef</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pstring</span><span class="p">;</span>
<span class="k">const</span> <span class="n">pstring</span> <span class="n">cstr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// cstr is a constant pointer to char
</span><span class="c1"></span><span class="k">const</span> <span class="n">pstring</span> <span class="o">*</span><span class="n">ps</span><span class="p">;</span>      <span class="c1">// ps is a pointer to a constant pointer to char
</span></code></pre></div>

<h2 id="2-5-2-auto类型限定符">2.5.2 auto类型限定符<a href="#2-5-2-auto类型限定符" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>auto告诉编译器从初始值推导出类型。这暗示了使用auto的变量必须有一个初始值。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="n">item</span> <span class="o">=</span> <span class="n">val1</span> <span class="o">+</span> <span class="n">val2</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>      <span class="c1">// ok: i is int and p is a pointer to int
</span><span class="c1"></span><span class="k">auto</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>   <span class="c1">// error: inconsistent types for sz and pi
</span></code></pre></div>

<h3 id="复合类型-const和auto">复合类型，const和auto<a href="#复合类型-const和auto" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>  <span class="c1">// a is an int (r is an alias for i, which has type int)
</span></code></pre></div>

<p>auto一般忽略top-level const。low-level const保留。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="kt">int</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cr</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>  <span class="c1">// b is an int (top-level const in ci is dropped)
</span><span class="c1"></span><span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cr</span><span class="p">;</span>  <span class="c1">// c is an int (cr is an alias for ci whose const is top-level)
</span><span class="c1"></span><span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>  <span class="c1">// d is an int*(&amp; of an int object is int*)
</span><span class="c1"></span><span class="k">auto</span> <span class="n">e</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="p">;</span> <span class="c1">// e is const int*(&amp; of a const object is low-level const)
</span></code></pre></div>

<p>如果想要推导的类型有top-level const，必须显式指定</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span> <span class="c1">// deduced type of ci is int; f has type const int
</span></code></pre></div>

<p>我们也可以指定自动推导的类型为引用。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="o">&amp;</span><span class="n">g</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>       <span class="c1">// g is a const int&amp; that is bound to ci
</span><span class="c1"></span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">h</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>       <span class="c1">// error: we can&#39;t bind a plain reference to a literal
</span><span class="c1"></span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">j</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">// ok: we can bind a const reference to a literal
</span><span class="c1"></span>
<span class="k">auto</span> <span class="n">k</span> <span class="o">=</span> <span class="n">ci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>    <span class="c1">// k is int; l is int&amp;
</span><span class="c1"></span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">m</span> <span class="o">=</span> <span class="n">ci</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="p">;</span> <span class="c1">// m is a const int&amp;;p is a pointer to const int
</span><span class="c1">// error: type deduced from i is int; type deduced from &amp;ci is const int
</span><span class="c1"></span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">n</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="p">;</span>
</code></pre></div>

<h2 id="2-5-3-decltype类型说明符">2.5.3 decltype类型说明符<a href="#2-5-3-decltype类型说明符" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">decltype</span><span class="p">(</span><span class="n">f</span><span class="p">())</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// sum has whatever type f returns
</span></code></pre></div>

<p>decltype处理top-level const和引用的方式和auto有着微妙的区别。当给变量应用
decltype时，decltype返回这个变量的类型，包括top-level const和引用。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="kt">int</span> <span class="n">ci</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cj</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">ci</span><span class="p">)</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// x has type const int
</span><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="n">cj</span><span class="p">)</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// y has type const int&amp; and is bound to x
</span><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="n">cj</span><span class="p">)</span> <span class="n">z</span><span class="p">;</span>     <span class="c1">// error: z is a reference and must be initialized
</span></code></pre></div>

<h3 id="decltype和引用">decltype和引用<a href="#decltype和引用" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>当我们应用decltype到非变量的表达式时，我们得到表达式产生的类型。decltype返回一个引用当表达式产生可以作为左值的对象时。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span> <span class="n">b</span><span class="p">;</span>  <span class="c1">// ok: addition yields an int; b is an (uninitialized) int
</span><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="n">c</span><span class="p">;</span>     <span class="c1">// error: c is int&amp; and must be initialized
</span><span class="c1"></span>
<span class="c1">// decltype of a parenthesized variable is always a reference
</span><span class="c1"></span><span class="k">decltype</span><span class="p">((</span><span class="n">i</span><span class="p">))</span> <span class="n">d</span><span class="p">;</span>    <span class="c1">// error: d is int&amp; and must be initialized
</span><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="n">e</span><span class="p">;</span>      <span class="c1">// ok: e is an (uninitialized) int
</span></code></pre></div>

<p>类内初始值 被限制于只能用在花括号里面或等号后面，不能使用圆括号。
头文件通常包含在任意文件里面只能定义一次的实体，比如类定义，const和constexpr变量。</p>

			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="http://gitop.cc/tags/c&#43;&#43;">C&#43;&#43;</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>6570 Words</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2016-03-22 04:27 &#43;0800</p>
			</footer>
		</article>
		<div class="post-nav thin">
			<a class="next-post" href="http://gitop.cc/posts/mysql-cookbook-1/">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>&nbsp;Newer</span><br><span>MySQL Cookbook 第1章 使用mysql客户端</span>
			</a>
			<a class="prev-post" href="http://gitop.cc/posts/asio-network-programming-2/">
				<span class="post-nav-label">Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>Boost.Asio网络编程 第2章</span>
			</a>
		</div>
		<div id="comments" class="thin">
</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2019 <a href="http://gitop.cc">gitop</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="http://gitop.cc/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>


	<script src="http://gitop.cc/js/main.min.35ccbf1cdceb91e4c64c06b5d009d6e2977fafe56beda7762febd4e67528d2ac.js" integrity="sha256-Ncy/HNzrkeTGTAa10AnW4pd/r+Vr7ad2L+vU5nUo0qw="></script>

</body>

</html>
