<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>第14章 重载操作和转换 | 招财猫的博客</title>
    <meta property="og:title" content="第14章 重载操作和转换 - 招财猫的博客">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2015-09-20T10:47:02&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2015-09-20T10:47:02&#43;08:00'>
        
    <meta name="Keywords" content="C,C&#43;&#43;,Python,Golang">
    <meta name="description" content="第14章 重载操作和转换">
        
    <meta name="author" content="招财猫">
    <meta property="og:url" content="https://gitop.cc/posts/cpp-primer-14/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
    (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-4031353640611810",
        enable_page_level_ads: true
    });
    </script>
    


    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://gitop.cc">
                        招财猫的博客
                    </a>
                
                <p class="description">专注于C&#43;&#43;、Python、Golang</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://gitop.cc">首页</a>
                    
                    <a  href="https://gitop.cc/archives/" title="归档">归档</a>
                    
                    <a  href="https://gitop.cc/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    <style type="text/css">
    .post-toc {
        position: fixed;
        width: 200px;
        margin-left: -210px;
        padding: 5px 10px;
        font-family: Athelas, STHeiti, Microsoft Yahei, serif;
        font-size: 12px;
        border: 1px solid rgba(0, 0, 0, .07);
        border-radius: 5px;
        background-color: rgba(255, 255, 255, 0.98);
        background-clip: padding-box;
        -webkit-box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        word-wrap: break-word;
        white-space: nowrap;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
        z-index: 999;
        cursor: pointer;
        max-height: 70%;
        overflow-y: auto;
        overflow-x: hidden;
    }

    .post-toc .post-toc-title {
        width: 100%;
        margin: 0 auto;
        font-size: 20px;
        font-weight: 400;
        text-transform: uppercase;
        text-align: center;
    }

    .post-toc .post-toc-content {
        font-size: 15px;
    }

    .post-toc .post-toc-content>nav>ul {
        margin: 10px 0;
    }

    .post-toc .post-toc-content ul {
        padding-left: 20px;
        list-style: square;
        margin: 0.5em;
        line-height: 1.8em;
    }

    .post-toc .post-toc-content ul ul {
        padding-left: 15px;
        display: none;
    }

    @media print,
    screen and (max-width:1057px) {
        .post-toc {
            display: none;
        }
    }
</style>
<div class="post-toc" style="position: absolute; top: 188px;">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
        <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#直接调用重载操作符函数">直接调用重载操作符函数</a></li>
        <li><a href="#有些操作符不应该重载">有些操作符不应该重载</a></li>
        <li><a href="#使用和内置操作符意思一致的定义">使用和内置操作符意思一致的定义</a></li>
        <li><a href="#选择成员或非成员实现">选择成员或非成员实现</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#重载输出操作符-">重载输出操作符 &laquo;</a></li>
        <li><a href="#io操作符必须是非成员函数">IO操作符必须是非成员函数</a></li>
        <li><a href="#重载输入操作符-">重载输入操作符 &raquo;</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#相等操作符">相等操作符</a></li>
        <li><a href="#关系操作符">关系操作符</a></li>
        <li><a href="#赋值操作符">赋值操作符</a></li>
        <li><a href="#下标操作符">下标操作符</a></li>
        <li><a href="#自增和自减操作符">自增和自减操作符</a></li>
        <li><a href="#成员访问操作符">成员访问操作符</a></li>
        <li><a href="#函数调用操作符">函数调用操作符</a></li>
        <li><a href="#lambdas是函数对象">Lambdas是函数对象</a></li>
        <li><a href="#类表示lambdas带捕获成员">类表示Lambdas带捕获成员</a></li>
        <li><a href="#标准库定义的函数对象">标准库定义的函数对象</a></li>
        <li><a href="#算法中使用标准库函数对象">算法中使用标准库函数对象</a></li>
        <li><a href="#可调用对象和函数">可调用对象和函数</a></li>
        <li><a href="#标准库function类型">标准库function类型</a></li>
        <li><a href="#重载函数和function">重载函数和function</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#转换操作符">转换操作符</a></li>
        <li><a href="#定义一个具有转换操作符的类">定义一个具有转换操作符的类</a></li>
        <li><a href="#转换操作符可以产生惊人的结果">转换操作符可以产生惊人的结果</a></li>
        <li><a href="#explicit转换操作符">explicit转换操作符</a></li>
        <li><a href="#转换为bool类型">转换为bool类型</a></li>
        <li><a href="#避免歧义的转换">避免歧义的转换</a></li>
        <li><a href="#函数匹配和操作符重载">函数匹配和操作符重载</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
</div>
<script type="text/javascript">
    $(document).ready(function () {
        var postToc = $(".post-toc");
        if (postToc.length) {
            var leftPos = $("#main").offset().left;
            if(leftPos<220){
                postToc.css({"width":leftPos-10,"margin-left":(0-leftPos)})
            }

            var t = postToc.offset().top - 20,
                a = {
                    start: {
                        position: "absolute",
                        top: t
                    },
                    process: {
                        position: "fixed",
                        top: 20
                    },
                };
            $(window).scroll(function () {
                var e = $(window).scrollTop();
                e < t ? postToc.css(a.start) : postToc.css(a.process)
            })
        }
    })
</script>
    <article class="post">
        <header>
            <h1 class="post-title">第14章 重载操作和转换</h1>
        </header>
        <date class="post-meta meta-date">
            2015年9月20日
        </date>
        
        <div class="post-meta">
            <span>|</span>
            
            <span class="meta-category"><a href='https://gitop.cc/categories/Language'>Language</a></span>
            
        </div>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            <h1 id="基本概念">基本概念</h1>
<p>重载操作符是具有特殊名字的函数：关键字<strong>operator</strong>后面跟着需要被定义的操作符的符号。像其它函数一样，重载操作符有返回值，参数列表和函数体。</p>
<p>重载操作符的参数和操作符的操作数一样多。除了函数调用操作符(<strong>operator()</strong>)，重载操作符没有默认实参。</p>
<blockquote>
<p><strong>注意</strong>
当重载操作符是成员函数时，<strong>this</strong>绑定到左操作数。因此，成员操作符函数少一个操作数。</p>
</blockquote>
<p>操作符函数必须为类的成员或至少有一个类类型参数：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#998;font-style:italic">// error: cannot redefine the built-in operator for ints
</span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">operator</span><span style="color:#000;font-weight:bold">+</span>(<span style="color:#458;font-weight:bold">int</span>, <span style="color:#458;font-weight:bold">int</span>);
</code></pre></div>
<p>我们可以重载大多数操作符，而且只能重载已经存在的操作符：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">              <span style="color:#998;font-style:italic">//可以重载的操作符
</span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">+</span>       <span style="color:#000;font-weight:bold">-</span>       <span style="color:#000;font-weight:bold">*</span>       <span style="color:#000;font-weight:bold">/</span>       <span style="color:#000;font-weight:bold">%</span>       <span style="color:#000;font-weight:bold">^</span>
<span style="color:#000;font-weight:bold">&amp;</span>       <span style="color:#000;font-weight:bold">|</span>       <span style="color:#000;font-weight:bold">~</span>       <span style="color:#000;font-weight:bold">!</span>       ,       <span style="color:#000;font-weight:bold">=</span>
<span style="color:#000;font-weight:bold">&lt;</span>       <span style="color:#000;font-weight:bold">&gt;</span>       <span style="color:#000;font-weight:bold">&lt;=</span>      <span style="color:#000;font-weight:bold">&gt;=</span>      <span style="color:#000;font-weight:bold">++</span>      <span style="color:#000;font-weight:bold">--</span>
<span style="color:#000;font-weight:bold">&lt;&lt;</span>      <span style="color:#000;font-weight:bold">&gt;&gt;</span>      <span style="color:#000;font-weight:bold">==</span>      <span style="color:#000;font-weight:bold">!=</span>      <span style="color:#000;font-weight:bold">&amp;&amp;</span>      <span style="color:#000;font-weight:bold">||</span>
<span style="color:#000;font-weight:bold">+=</span>      <span style="color:#000;font-weight:bold">-=</span>      <span style="color:#000;font-weight:bold">/=</span>      <span style="color:#000;font-weight:bold">%=</span>      <span style="color:#000;font-weight:bold">^=</span>      <span style="color:#000;font-weight:bold">&amp;=</span>
<span style="color:#000;font-weight:bold">|=</span>      <span style="color:#000;font-weight:bold">*=</span>      <span style="color:#000;font-weight:bold">&lt;&lt;=</span>     <span style="color:#000;font-weight:bold">&gt;&gt;=</span>     []      ()
<span style="color:#000;font-weight:bold">-&gt;</span>      <span style="color:#000;font-weight:bold">-&gt;*</span>     <span style="color:#000;font-weight:bold">new</span>     <span style="color:#000;font-weight:bold">new</span>[]   <span style="color:#000;font-weight:bold">delete</span>  <span style="color:#000;font-weight:bold">delete</span>[]
              <span style="color:#998;font-style:italic">//不能重载的操作符
</span><span style="color:#998;font-style:italic"></span>        <span style="color:#000;font-weight:bold">::</span>      .<span style="color:#000;font-weight:bold">*</span>      .       <span style="color:#000;font-weight:bold">?:</span>
</code></pre></div>
<p>重载操作符和相应的内置操作符有相同的优先级和结合性。</p>
<h3 id="直接调用重载操作符函数">直接调用重载操作符函数</h3>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">data1 <span style="color:#000;font-weight:bold">+</span> data2;           <span style="color:#998;font-style:italic">// 表达式调用
</span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">operator</span><span style="color:#000;font-weight:bold">+</span>(data1, data2); <span style="color:#998;font-style:italic">// 等价的函数调用
</span><span style="color:#998;font-style:italic"></span>data1 <span style="color:#000;font-weight:bold">+=</span> data2;          <span style="color:#998;font-style:italic">// 表达式调用
</span><span style="color:#998;font-style:italic"></span>data1.<span style="color:#000;font-weight:bold">operator</span><span style="color:#000;font-weight:bold">+=</span>(data2); <span style="color:#998;font-style:italic">// 等价的成员函数调用
</span></code></pre></div>
<h3 id="有些操作符不应该重载">有些操作符不应该重载</h3>
<p>重载操作符不保留求值顺序或短路求值。</p>
<blockquote>
<p><strong>最佳实践</strong>
通常，逗号（,），取地址（&amp;），逻辑与（&amp;&amp;）和逻辑或（||）不应该重载。</p>
</blockquote>
<h3 id="使用和内置操作符意思一致的定义">使用和内置操作符意思一致的定义</h3>
<ul>
<li>如果类使用IO，定义与内置类型IO操作一致的<strong>shift</strong>操作符</li>
<li>如果类有测试相等的操作，定义<strong>operator==</strong>。如果类有<strong>operator==</strong>，通常也应该定义<strong>operator!=</strong>。</li>
<li>如果类有单一的自然顺序的操作，定义<strong>operator&lt;</strong>。如果类有<strong>operator&lt;</strong>，通常也应该定义其它关系操作符。</li>
<li>重载操作符的返回类型应该和内置操作符的返回类型兼容：逻辑操作符和关系操作符应该返回<strong>bool</strong>，算术操作符应该返回类的值，赋值操作符应该返回左操作数的引用。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：明智地使用操作符重载
当内置操作符和类的操作有逻辑映射的时候，操作符重载最有用。</p>
</blockquote>
<h3 id="选择成员或非成员实现">选择成员或非成员实现</h3>
<p>以下指导方针能够帮助我们决定是否将一个操作符定义为成员函数或普通的非成员函数：</p>
<ul>
<li>赋值操作符（=），下标操作符（[]），调用操作符（()），成员访问操作符（-&gt;）必须定义为成员。</li>
<li>复合赋值操作符通常应该定义为成员，但是没有要求一定这样。</li>
<li>改变对象状态或与类对象联系紧密的操作符，通常应该定义为成员。比如++，&ndash;和解引用（*）。</li>
<li>那些可能转换操作数的对称的操作符，比如算术操作符，关系操作符，位操作符，通常应该定义为非成员。</li>
</ul>
<h1 id="输入输出操作符">输入输出操作符</h1>
<h3 id="重载输出操作符-">重载输出操作符 &laquo;</h3>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">ostream <span style="color:#000;font-weight:bold">&amp;</span><span style="color:#000;font-weight:bold">operator</span><span style="color:#000;font-weight:bold">&lt;&lt;</span>(ostream <span style="color:#000;font-weight:bold">&amp;</span>os, <span style="color:#000;font-weight:bold">const</span> Sales_data <span style="color:#000;font-weight:bold">&amp;</span>item)
{
    os <span style="color:#000;font-weight:bold">&lt;&lt;</span> item.isbn() <span style="color:#000;font-weight:bold">&lt;&lt;</span> <span style="color:#d14">&#34; &#34;</span> <span style="color:#000;font-weight:bold">&lt;&lt;</span> item.units_sold <span style="color:#000;font-weight:bold">&lt;&lt;</span> <span style="color:#d14">&#34; &#34;</span>
        <span style="color:#000;font-weight:bold">&lt;&lt;</span> item.revenue <span style="color:#000;font-weight:bold">&lt;&lt;</span> <span style="color:#d14">&#34; &#34;</span> <span style="color:#000;font-weight:bold">&lt;&lt;</span> item.avg_price();
    <span style="color:#000;font-weight:bold">return</span> os;
}
</code></pre></div>
<blockquote>
<p><strong>最佳实践</strong>
通常输出操作符应该最小格式化输出对象的内容，不应该打印换行。</p>
</blockquote>
<h3 id="io操作符必须是非成员函数">IO操作符必须是非成员函数</h3>
<p>输入输出操作符遵循库<strong>iostream</strong>的惯例必须为普通的非成员函数。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Sales_data data;
data <span style="color:#000;font-weight:bold">&lt;&lt;</span> cout; <span style="color:#998;font-style:italic">// 如果operator&lt;&lt;是Sales_data的一个成员
</span></code></pre></div>
<p>如果这些操作符是任意一个类的成员，那它们应该是<strong>istream</strong>或<strong>ostream</strong>的成员，但是我们无法给标准库添加成员。输入输出操作符通常需要读或写非公开的数据成员。因此，IO操作符通常必须声明为<strong>friend</strong>。</p>
<h3 id="重载输入操作符-">重载输入操作符 &raquo;</h3>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">istream <span style="color:#000;font-weight:bold">&amp;</span><span style="color:#000;font-weight:bold">operator</span><span style="color:#000;font-weight:bold">&gt;&gt;</span>(istream <span style="color:#000;font-weight:bold">&amp;</span>is, Sales_data <span style="color:#000;font-weight:bold">&amp;</span>item)
{
    <span style="color:#458;font-weight:bold">double</span> price;
    is <span style="color:#000;font-weight:bold">&gt;&gt;</span> item.bookNo <span style="color:#000;font-weight:bold">&gt;&gt;</span> item.units_sold <span style="color:#000;font-weight:bold">&gt;&gt;</span> price;
    <span style="color:#000;font-weight:bold">if</span> (is)        <span style="color:#998;font-style:italic">// 检查输入是否成功
</span><span style="color:#998;font-style:italic"></span>        item.revenue <span style="color:#000;font-weight:bold">=</span> item.units_sold <span style="color:#000;font-weight:bold">*</span> price;
    <span style="color:#000;font-weight:bold">else</span>
        item <span style="color:#000;font-weight:bold">=</span> Sales_data(); <span style="color:#998;font-style:italic">// 输入失败：给对象一个默认值
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">return</span> is;
}
</code></pre></div>
<blockquote>
<p><strong>注意</strong>
输入操作符必须处理输入失败的可能性。输出操作符通常没有这个困扰。</p>
</blockquote>
<p>我们选择在读取了所有数据之后，使用数据之前来检查流状态。</p>
<blockquote>
<p><strong>最佳实践</strong>
输入操作符应该决定做什么错误恢复。当错误发生时，使对象处于一个合法状态尤其重要，因为对象可能被部分修改。</p>
</blockquote>
<p>通常输入操作符应该只设置<strong>failbit</strong>。<strong>eofbit</strong>和<strong>badbit</strong>最好是留给IO库去指示。</p>
<h1 id="算术和关系操作符">算术和关系操作符</h1>
<p>通常我们将算术和关系操作符定义为非成员函数，以允许转换左右操作符中的一个。这些操作符不需要修改操作数的状态，所以参数通常为**const
**引用。定义了算术操作符的类通常也要定义相应的复合赋值操作符。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Sales_data
<span style="color:#000;font-weight:bold">operator</span><span style="color:#000;font-weight:bold">+</span>(<span style="color:#000;font-weight:bold">const</span> Sales_data <span style="color:#000;font-weight:bold">&amp;</span>lhs, <span style="color:#000;font-weight:bold">const</span> Sales_data <span style="color:#000;font-weight:bold">&amp;</span>rhs)
{
    Sales_data sum <span style="color:#000;font-weight:bold">=</span> lhs;
    sum <span style="color:#000;font-weight:bold">+=</span> rhs;
    <span style="color:#000;font-weight:bold">return</span> sum;
}
</code></pre></div>
<blockquote>
<p><strong>提示</strong>
定义了算术操作符和相应的复合赋值操作符的类，应该使用复合赋值操作符来实现算术操作符。</p>
</blockquote>
<h3 id="相等操作符">相等操作符</h3>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#458;font-weight:bold">bool</span> <span style="color:#000;font-weight:bold">operator</span><span style="color:#000;font-weight:bold">==</span>(<span style="color:#000;font-weight:bold">const</span> Sales_data <span style="color:#000;font-weight:bold">&amp;</span>lhs, <span style="color:#000;font-weight:bold">const</span> Sales_data <span style="color:#000;font-weight:bold">&amp;</span>rhs)
{
    <span style="color:#000;font-weight:bold">return</span> lhs.isbn() <span style="color:#000;font-weight:bold">==</span> rhs.isbn() <span style="color:#000;font-weight:bold">&amp;&amp;</span>
        lhs.units_sold <span style="color:#000;font-weight:bold">==</span> rhs.units_sold <span style="color:#000;font-weight:bold">&amp;&amp;</span>
        lhs.revenue <span style="color:#000;font-weight:bold">==</span> rhs.revenue;
}
<span style="color:#458;font-weight:bold">bool</span> <span style="color:#000;font-weight:bold">operator</span><span style="color:#000;font-weight:bold">!=</span>(<span style="color:#000;font-weight:bold">const</span> Sales_data <span style="color:#000;font-weight:bold">&amp;</span>lhs, <span style="color:#000;font-weight:bold">const</span> Sales_data <span style="color:#000;font-weight:bold">&amp;</span>rhs)
{
    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">!</span>(lhs <span style="color:#000;font-weight:bold">==</span> rhs);
}
</code></pre></div>
<p>相等操作符的设计原理：</p>
<ul>
<li>如果一个类有一个确定2个对象是否相等的操作，那么该类应该定义<strong>operator==</strong>，而不是命名函数，而且可以容易使用标准库容器和算法。</li>
<li>如果一个类定义了<strong>operator==</strong>，这个操作符通常应该确定给定的对象是否包含相同的数据。</li>
<li>通常地，相等操作符应该是可传递的， 比如如果a == b, b == c， 则a == c。</li>
<li>如果一个类定义了<strong>operator==</strong>，那也应该定义<strong>operator!=</strong>，反之也一样。</li>
<li>相等或不等操作符应该将实际工作委托给另一个。</li>
</ul>
<blockquote>
<p><strong>最佳实践</strong>
相等性具有逻辑意义的类通常应该定义<strong>operator==</strong>，定义了<strong>operator==</strong>的类使得用户容易使用标准库算法。</p>
</blockquote>
<h3 id="关系操作符">关系操作符</h3>
<p>定义了相等操作符的类通常（不总是）也会定义关系操作符。特别地，关系容器和有些算法使用<strong>&lt;</strong>操作符，定义<strong>operator&lt;</strong>会很有用。</p>
<p>通常关系操作符应该：</p>
<ul>
<li>定义一个顺序关系和关联容器的key的需求一致。</li>
<li>定义一个关系和<strong>==</strong>一致，如果类2种操作符都定义了。特别地，如果2个对象**!=**，则其中一个应该**&lt;**另一个。</li>
</ul>
<blockquote>
<p><strong>最佳实践</strong>
如果只有一个逻辑定义<strong>&lt;</strong>存在，类通常应该定义<strong>&lt;</strong>操作符。然而，如果类也有<strong>==</strong>，只有当<strong>&lt;</strong>和<strong>==</strong>产生的结果一致时，定义<strong>&lt;</strong>。</p>
</blockquote>
<h3 id="赋值操作符">赋值操作符</h3>
<p>除了**copy-<strong>和</strong>move-**赋值操作符之外，类还可以定义其它的赋值操作符允许其它类型作为右操作数。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">vector<span style="color:#000;font-weight:bold">&lt;</span>string<span style="color:#000;font-weight:bold">&gt;</span> v;
v <span style="color:#000;font-weight:bold">=</span> {<span style="color:#d14">&#34;a&#34;</span>, <span style="color:#d14">&#34;an&#34;</span>, <span style="color:#d14">&#34;the&#34;</span>};
<span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">StrVec</span> {
<span style="color:#000;font-weight:bold">public</span><span style="color:#000;font-weight:bold">:</span>
    StrVec <span style="color:#000;font-weight:bold">&amp;</span><span style="color:#000;font-weight:bold">operator</span><span style="color:#000;font-weight:bold">=</span>(std<span style="color:#000;font-weight:bold">::</span>initializer_list<span style="color:#000;font-weight:bold">&lt;</span>std<span style="color:#000;font-weight:bold">::</span>string<span style="color:#000;font-weight:bold">&gt;</span>);
};
StrVec <span style="color:#000;font-weight:bold">&amp;</span>StrVec<span style="color:#000;font-weight:bold">::</span><span style="color:#000;font-weight:bold">operator</span><span style="color:#000;font-weight:bold">=</span>(initializer_list<span style="color:#000;font-weight:bold">&lt;</span>string<span style="color:#000;font-weight:bold">&gt;</span> il)
{
    <span style="color:#000;font-weight:bold">auto</span> data <span style="color:#000;font-weight:bold">=</span> alloc_n_copy(il.begin(), il.end());
    free();
    elements <span style="color:#000;font-weight:bold">=</span> data.first;
    first_free <span style="color:#000;font-weight:bold">=</span> cap <span style="color:#000;font-weight:bold">=</span> data.second;
    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">*</span><span style="color:#000;font-weight:bold">this</span>;
}
</code></pre></div>
<p>不像**copy-<strong>和</strong>move-**赋值操作符，这个操作符不需要检查自我赋值。</p>
<blockquote>
<p><strong>注意</strong>
赋值操作符可以被重载。不管参数类型是什么，赋值操作符必须定义为成员函数。</p>
</blockquote>
<p>复合赋值操作符不需要是类成员。然而，我们倾向于定义所有的赋值操作符，包括复合赋值操作符为类成员。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Sales_data<span style="color:#000;font-weight:bold">&amp;</span> Sales_data<span style="color:#000;font-weight:bold">::</span><span style="color:#000;font-weight:bold">operator</span><span style="color:#000;font-weight:bold">+=</span>(<span style="color:#000;font-weight:bold">const</span> Sales_data <span style="color:#000;font-weight:bold">&amp;</span>rhs)
{
    units_sold <span style="color:#000;font-weight:bold">+=</span> rhs.units_sold;
    revenue <span style="color:#000;font-weight:bold">+=</span> rhs.revenue;
    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">*</span><span style="color:#000;font-weight:bold">this</span>;
}
</code></pre></div>
<blockquote>
<p><strong>最佳实践</strong>
赋值操作符必须，而且通常复合赋值操作符应该，定义为成员。这些操作符应该返回左操作数的引用。</p>
</blockquote>
<h3 id="下标操作符">下标操作符</h3>
<p>可以通过位置来获取元素的代表容器的类，通常定义下标操作符，<strong>operater[]</strong>。</p>
<blockquote>
<p><strong>注意</strong>
下标操作符必须为成员函数。</p>
</blockquote>
<blockquote>
<p><strong>最佳实践</strong>
如果一个类有下标操作符，它通常应该定义2个版本：一个返回普通引用，一个返回const引用。</p>
</blockquote>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">StrVec</span> {
<span style="color:#000;font-weight:bold">public</span><span style="color:#000;font-weight:bold">:</span>
    std<span style="color:#000;font-weight:bold">::</span>string<span style="color:#000;font-weight:bold">&amp;</span> <span style="color:#000;font-weight:bold">operator</span>[](std<span style="color:#000;font-weight:bold">::</span>size_t n)
    { <span style="color:#000;font-weight:bold">return</span> elements[n]; }
    <span style="color:#000;font-weight:bold">const</span> std<span style="color:#000;font-weight:bold">::</span>string<span style="color:#000;font-weight:bold">&amp;</span> <span style="color:#000;font-weight:bold">operator</span>[](std<span style="color:#000;font-weight:bold">::</span>size_t n) <span style="color:#000;font-weight:bold">const</span>
    { <span style="color:#000;font-weight:bold">return</span> elements[n]; }
<span style="color:#000;font-weight:bold">private</span><span style="color:#000;font-weight:bold">:</span>
    std<span style="color:#000;font-weight:bold">::</span>string <span style="color:#000;font-weight:bold">*</span>elements; <span style="color:#998;font-style:italic">// 指向数组第一个元素
</span><span style="color:#998;font-style:italic"></span>};
 
<span style="color:#000;font-weight:bold">const</span> StrVec cvec <span style="color:#000;font-weight:bold">=</span> svec;
<span style="color:#000;font-weight:bold">if</span> (svec.size() <span style="color:#000;font-weight:bold">&amp;&amp;</span> svec[<span style="color:#099">0</span>].empty())  {
    svec[<span style="color:#099">0</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;zero&#34;</span>; <span style="color:#998;font-style:italic">// ok: 返回一个普通引用
</span><span style="color:#998;font-style:italic"></span>    cvec[<span style="color:#099">0</span>] <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;Zip&#34;</span>;  <span style="color:#998;font-style:italic">// error: 返回一个const引用
</span><span style="color:#998;font-style:italic"></span>}
</code></pre></div>
<h3 id="自增和自减操作符">自增和自减操作符</h3>
<p>自增和自减操作符最常被迭代器类实现。语言并没要要求这些操作符是成员，但是由于这些操作符改变它们操作的对象的状态，我们选择将它们定义为成员。</p>
<blockquote>
<p><strong>最佳实践</strong>
定义自增或自减操作符的类应该定义<strong>prefix</strong>和<strong>postfix</strong>版本。这些操作符应该定义为成员。</p>
</blockquote>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">StrBlobPtr</span> {
<span style="color:#000;font-weight:bold">public</span><span style="color:#000;font-weight:bold">:</span>
    StrBlobPtr<span style="color:#000;font-weight:bold">&amp;</span> <span style="color:#000;font-weight:bold">operator</span><span style="color:#000;font-weight:bold">++</span>(); <span style="color:#998;font-style:italic">// 前自增操作符
</span><span style="color:#998;font-style:italic"></span>    StrBlobPtr<span style="color:#000;font-weight:bold">&amp;</span> <span style="color:#000;font-weight:bold">operator</span><span style="color:#000;font-weight:bold">--</span>(); <span style="color:#998;font-style:italic">// 前自减操作符
</span><span style="color:#998;font-style:italic"></span>};

StrBlobPtr<span style="color:#000;font-weight:bold">&amp;</span> StrBlobPtr<span style="color:#000;font-weight:bold">::</span><span style="color:#000;font-weight:bold">operator</span><span style="color:#000;font-weight:bold">++</span>()
{
    check(curr, <span style="color:#d14">&#34;increment past end of StrBlobPtr&#34;</span>);
    <span style="color:#000;font-weight:bold">++</span>curr;
    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">*</span><span style="color:#000;font-weight:bold">this</span>;
}

StrBlobPtr<span style="color:#000;font-weight:bold">&amp;</span> StrBlobPtr<span style="color:#000;font-weight:bold">::</span><span style="color:#000;font-weight:bold">operator</span><span style="color:#000;font-weight:bold">--</span>()
{
    <span style="color:#000;font-weight:bold">--</span>curr;
    check(<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>, <span style="color:#d14">&#34;decrement past begin of StrBlobPtr&#34;</span>);
    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">*</span><span style="color:#000;font-weight:bold">this</span>;
}
</code></pre></div>
<blockquote>
<p><strong>最佳实践</strong>
为了和内置操作符一致，前置操作符应该返回自增过或自减过的对象的引用。</p>
</blockquote>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">StrBlobPtr</span> {
<span style="color:#000;font-weight:bold">public</span><span style="color:#000;font-weight:bold">:</span>
    StrBlobPtr <span style="color:#000;font-weight:bold">operator</span><span style="color:#000;font-weight:bold">++</span>(<span style="color:#458;font-weight:bold">int</span>);    <span style="color:#998;font-style:italic">// 后置操作符
</span><span style="color:#998;font-style:italic"></span>    StrBlobPtr <span style="color:#000;font-weight:bold">operator</span><span style="color:#000;font-weight:bold">--</span>(<span style="color:#458;font-weight:bold">int</span>);
};

StrBlobPtr StrBlobPtr<span style="color:#000;font-weight:bold">::</span><span style="color:#000;font-weight:bold">operator</span><span style="color:#000;font-weight:bold">++</span>(<span style="color:#458;font-weight:bold">int</span>)
{
    StrBlobPtr ret <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">*</span><span style="color:#000;font-weight:bold">this</span>;
    <span style="color:#000;font-weight:bold">++*</span><span style="color:#000;font-weight:bold">this</span>;
    <span style="color:#000;font-weight:bold">return</span> ret;
}

StrBlobPtr StrBlobPtr<span style="color:#000;font-weight:bold">::</span><span style="color:#000;font-weight:bold">operator</span><span style="color:#000;font-weight:bold">--</span>(<span style="color:#458;font-weight:bold">int</span>)
{
    StrBlobPtr ret <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">*</span><span style="color:#000;font-weight:bold">this</span>;
    <span style="color:#000;font-weight:bold">--*</span><span style="color:#000;font-weight:bold">this</span>;
    <span style="color:#000;font-weight:bold">return</span> ret;
}
</code></pre></div>
<blockquote>
<p><strong>最佳实践</strong>
为了和内置操作符一致，后置操作符应该返回旧的（未自增或自减）值，而不是引用。</p>
</blockquote>
<blockquote>
<p><strong>注意</strong>
<strong>int</strong>参数没有用到，所以没有给它一个名字。</p>
</blockquote>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">StrBlobPtr <span style="color:#900;font-weight:bold">p</span>(a1);
p.<span style="color:#000;font-weight:bold">operator</span><span style="color:#000;font-weight:bold">++</span>(<span style="color:#099">0</span>);  <span style="color:#998;font-style:italic">// 调用后自增操作符
</span><span style="color:#998;font-style:italic"></span>p.<span style="color:#000;font-weight:bold">operator</span><span style="color:#000;font-weight:bold">++</span>();   <span style="color:#998;font-style:italic">// 调用前自增操作符
</span></code></pre></div>
<h3 id="成员访问操作符">成员访问操作符</h3>
<p>解引用（*）和箭头（-&gt;）操作符经常使用在迭代器类和智能指针类中。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">StrBlobPtr</span> {
<span style="color:#000;font-weight:bold">public</span><span style="color:#000;font-weight:bold">:</span>
    std<span style="color:#000;font-weight:bold">::</span>string<span style="color:#000;font-weight:bold">&amp;</span> <span style="color:#000;font-weight:bold">operator</span><span style="color:#000;font-weight:bold">*</span>() <span style="color:#000;font-weight:bold">const</span>
    { 
        <span style="color:#000;font-weight:bold">auto</span> p <span style="color:#000;font-weight:bold">=</span> check(curr, <span style="color:#d14">&#34;dereference past end&#34;</span>);
        <span style="color:#000;font-weight:bold">return</span> (<span style="color:#000;font-weight:bold">*</span>p)[curr];  <span style="color:#998;font-style:italic">// (*p)是这个对象指向的vector
</span><span style="color:#998;font-style:italic"></span>    }
    std<span style="color:#000;font-weight:bold">::</span>string<span style="color:#000;font-weight:bold">*</span> <span style="color:#000;font-weight:bold">operator</span><span style="color:#000;font-weight:bold">-&gt;</span>() <span style="color:#000;font-weight:bold">const</span>
    {
        <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">&amp;</span> <span style="color:#000;font-weight:bold">this</span><span style="color:#000;font-weight:bold">-&gt;</span><span style="color:#000;font-weight:bold">operator</span><span style="color:#000;font-weight:bold">*</span>(); <span style="color:#998;font-style:italic">// 将实际工作委托给解引用操作符
</span><span style="color:#998;font-style:italic"></span>    }
};
</code></pre></div>
<blockquote>
<p><strong>注意</strong>
箭头操作符必须定义为成员，没有要求解引用为成员但通常也应该为成员。</p>
</blockquote>
<p>值得注意的是我们定义这些操作符为<strong>const</strong>成员，获取一个元素不会改变这个对象的状态。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">StrBlob a1 <span style="color:#000;font-weight:bold">=</span> {<span style="color:#d14">&#34;hi&#34;</span>, <span style="color:#d14">&#34;bye&#34;</span>, <span style="color:#d14">&#34;now&#34;</span>};
StrBlobPtr <span style="color:#900;font-weight:bold">p</span>(a1);            <span style="color:#998;font-style:italic">// p指向a1里面的vector
</span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">*</span>p <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#34;okay&#34;</span>;                 <span style="color:#998;font-style:italic">// 给a1中第一个元素赋值
</span><span style="color:#998;font-style:italic"></span>cout <span style="color:#000;font-weight:bold">&lt;&lt;</span> p<span style="color:#000;font-weight:bold">-&gt;</span>size() <span style="color:#000;font-weight:bold">&lt;&lt;</span> endl;   <span style="color:#998;font-style:italic">// 第一个元素的size()
</span><span style="color:#998;font-style:italic"></span>cout <span style="color:#000;font-weight:bold">&lt;&lt;</span> (<span style="color:#000;font-weight:bold">*</span>p).size() <span style="color:#000;font-weight:bold">&lt;&lt;</span> endl; <span style="color:#998;font-style:italic">// 等价于p-&gt;size()
</span></code></pre></div>
<p>当我们写<strong>point-&gt;mem</strong>时，<strong>point</strong>必须是指向一个类对象的指针或是一个重载了<strong>operator-&gt;</strong>的类的对象。取决于<strong>point</strong>的类型，<strong>point-&gt;mem</strong>等价于：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">(<span style="color:#000;font-weight:bold">*</span>point).mem;          <span style="color:#998;font-style:italic">// point是一个内置指针类型
</span><span style="color:#998;font-style:italic"></span>point.<span style="color:#000;font-weight:bold">operator</span>()<span style="color:#000;font-weight:bold">-&gt;</span>mem; <span style="color:#998;font-style:italic">// point是一个类的对象
</span></code></pre></div>
<blockquote>
<p><strong>注意</strong>
箭头操作符必须返回一个指向类类型的指针或一个定义了自己的箭头操作符的类类型的对象。</p>
</blockquote>
<h3 id="函数调用操作符">函数调用操作符</h3>
<p>重载了函数调用操作符的类允许它的对象像函数一样使用。因为这种类可以保存状态，它们比普通函数更灵活。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000;font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">absInt</span> {
    <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">operator</span>()(<span style="color:#458;font-weight:bold">int</span> val) <span style="color:#000;font-weight:bold">const</span> {
        <span style="color:#000;font-weight:bold">return</span> val <span style="color:#000;font-weight:bold">&lt;</span> <span style="color:#099">0</span> <span style="color:#000;font-weight:bold">?</span> <span style="color:#000;font-weight:bold">-</span><span style="color:#900;font-weight:bold">val</span> : val;
    }
};
</code></pre></div>
<p>定义了函数调用操作符的类的对象被称为函数对象，我们可以像函数调用一样提供一个参数列表给函数对象：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">-</span><span style="color:#099">42</span>;
absInt absObj;
<span style="color:#458;font-weight:bold">int</span> ui <span style="color:#000;font-weight:bold">=</span> absObj(i);
</code></pre></div>
<blockquote>
<p><strong>注意</strong>
函数调用操作符必须是成员函数。一个类可以定义多个版本的调用操作符，每一个参数类型或数量必须不一样。</p>
</blockquote>
<p>和其他类一样，一个函数对象类除了<strong>operator()</strong>，还可以有其它成员。函数对象类通常包含其它成员用来调整函数调用操作符的操作。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">PrintString</span> {
<span style="color:#000;font-weight:bold">public</span><span style="color:#000;font-weight:bold">:</span>
    PrintString(ostream <span style="color:#000;font-weight:bold">&amp;</span>o <span style="color:#000;font-weight:bold">=</span> cout, <span style="color:#458;font-weight:bold">char</span> c <span style="color:#000;font-weight:bold">=</span> <span style="color:#d14">&#39; &#39;</span>)<span style="color:#000;font-weight:bold">:</span>
        os(o), sep(c) { }
    <span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">operator</span>()(<span style="color:#000;font-weight:bold">const</span> string <span style="color:#000;font-weight:bold">&amp;</span>s) <span style="color:#000;font-weight:bold">const</span> { os <span style="color:#000;font-weight:bold">&lt;&lt;</span> s <span style="color:#000;font-weight:bold">&lt;&lt;</span> sep;}
<span style="color:#000;font-weight:bold">private</span><span style="color:#000;font-weight:bold">:</span>
    ostream <span style="color:#000;font-weight:bold">&amp;</span>os;   <span style="color:#998;font-style:italic">// stream on which to write
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">char</span> sep;      <span style="color:#998;font-style:italic">// character to print after each output
</span><span style="color:#998;font-style:italic"></span>};

PrintString printer;   <span style="color:#998;font-style:italic">// uses the defaults; prints to cout
</span><span style="color:#998;font-style:italic"></span>printer(s);            <span style="color:#998;font-style:italic">// prints s followed by a space on cout
</span><span style="color:#998;font-style:italic"></span>PrintString <span style="color:#900;font-weight:bold">errors</span>(cerr, <span style="color:#d14">&#39;\n&#39;</span>);
errors(s);             <span style="color:#998;font-style:italic">// prints s followed by a newline on cerr
</span></code></pre></div>
<p>函数对象最常用于泛型算法的参数：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">for_each(vs.begin(), vs.end(), PrintString(cerr, <span style="color:#d14">&#39;\n&#39;</span>));
</code></pre></div>
<h3 id="lambdas是函数对象">Lambdas是函数对象</h3>
<p>当我们写一个<strong>lambda</strong>时，编译器将表达式翻译成一个匿名类的匿名对象。由<strong>lambda</strong>生成的类包含了一个重载的函数调用操作符。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">stable_sort(words.begin(), words.end(),
            [](<span style="color:#000;font-weight:bold">const</span> string <span style="color:#000;font-weight:bold">&amp;</span>a, <span style="color:#000;font-weight:bold">const</span> string <span style="color:#000;font-weight:bold">&amp;</span>b)
              { <span style="color:#000;font-weight:bold">return</span> a.size() <span style="color:#000;font-weight:bold">&lt;</span> b.size();});
</code></pre></div>
<p>行为就像一个匿名对象的类，看起来像：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">ShorterString</span> {
<span style="color:#000;font-weight:bold">public</span><span style="color:#000;font-weight:bold">:</span>
    <span style="color:#458;font-weight:bold">bool</span> <span style="color:#000;font-weight:bold">operator</span>()(<span style="color:#000;font-weight:bold">const</span> string <span style="color:#000;font-weight:bold">&amp;</span>s1, <span style="color:#000;font-weight:bold">const</span> string <span style="color:#000;font-weight:bold">&amp;</span>s2) <span style="color:#000;font-weight:bold">const</span>
    { <span style="color:#000;font-weight:bold">return</span> s1.size() <span style="color:#000;font-weight:bold">&lt;</span> s2.size(); }
};

stable_sort(words.begin(), words.end(), ShorterString());
</code></pre></div>
<h3 id="类表示lambdas带捕获成员">类表示Lambdas带捕获成员</h3>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000;font-weight:bold">auto</span> wc <span style="color:#000;font-weight:bold">=</span> find_if(words.begin(), words.end(),
            [sz](<span style="color:#000;font-weight:bold">const</span> string <span style="color:#000;font-weight:bold">&amp;</span>a){ <span style="color:#000;font-weight:bold">return</span> a.size() <span style="color:#000;font-weight:bold">&gt;=</span> sz;});
</code></pre></div>
<p>会生成像这样的类：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">SizeComp</span> {
<span style="color:#000;font-weight:bold">public</span><span style="color:#000;font-weight:bold">:</span>
    SizeComp(size_t n)<span style="color:#000;font-weight:bold">:</span> sz(n) { } <span style="color:#998;font-style:italic">// parameter for each captured variable
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#458;font-weight:bold">bool</span> <span style="color:#900;font-weight:bold">operator</span>()(<span style="color:#000;font-weight:bold">const</span> string <span style="color:#000;font-weight:bold">&amp;</span>s) <span style="color:#000;font-weight:bold">const</span>
        { <span style="color:#000;font-weight:bold">return</span> s.size() <span style="color:#000;font-weight:bold">&gt;=</span> sz; }
<span style="color:#000;font-weight:bold">private</span><span style="color:#000;font-weight:bold">:</span>
    size_t sz; <span style="color:#998;font-style:italic">// a data member for each variable captured by value
</span><span style="color:#998;font-style:italic"></span>};

<span style="color:#000;font-weight:bold">auto</span> wc <span style="color:#000;font-weight:bold">=</span> find_if(words.begin(), words.end(), SizeComp(sz));
</code></pre></div>
<p>由lambda表达式生成的类有一个<strong>deleted</strong>默认构造函数，<strong>deleted</strong>赋值操作符和一个默认析构函数。是否有<strong>deleted</strong>或默认的<strong>copy/move</strong>构造函数取决于捕获的数据成员。</p>
<h3 id="标准库定义的函数对象">标准库定义的函数对象</h3>
<p>标准库定义了一个类集合，表示算术，关系和逻辑运算符。
<strong>plus</strong>类有一个函数调用操作符，应用<strong>+</strong>操作符。
<strong>modulus</strong>类有一个函数调用操作符，应用**%**操作符。
**equal_to**类有一个函数调用操作符，应用**==**操作符。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">plus<span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">&gt;</span> intAdd;       <span style="color:#998;font-style:italic">// function object that can add two int values
</span><span style="color:#998;font-style:italic"></span>negate<span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">&gt;</span> intNegate;  <span style="color:#998;font-style:italic">// function object that can negate an int value
</span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> sum <span style="color:#000;font-weight:bold">=</span> intAdd(<span style="color:#099">10</span>, <span style="color:#099">20</span>);         <span style="color:#998;font-style:italic">// sum = 30
</span><span style="color:#998;font-style:italic"></span>sum <span style="color:#000;font-weight:bold">=</span> intNegate(intAdd(<span style="color:#099">10</span>, <span style="color:#099">20</span>));  <span style="color:#998;font-style:italic">// sum = -30
</span><span style="color:#998;font-style:italic"></span>sum <span style="color:#000;font-weight:bold">=</span> intAdd(<span style="color:#099">10</span>, intNegate(<span style="color:#099">10</span>));  <span style="color:#998;font-style:italic">// sum = 0
</span></code></pre></div>
<h3 id="算法中使用标准库函数对象">算法中使用标准库函数对象</h3>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#998;font-style:italic">// passes a temporary function object that applies the &lt; operator to two strings
</span><span style="color:#998;font-style:italic"></span>sort(svec.begin(), svec.end(), greater<span style="color:#000;font-weight:bold">&lt;</span>string<span style="color:#000;font-weight:bold">&gt;</span>());
</code></pre></div>
<p>标准库函数对象保证对指针也有作用。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">vector<span style="color:#000;font-weight:bold">&lt;</span>string <span style="color:#000;font-weight:bold">*&gt;</span> nameTable;  <span style="color:#998;font-style:italic">// vector of pointers
</span><span style="color:#998;font-style:italic">// error: the pointers in nameTable are unrelated, so &lt; is undefined
</span><span style="color:#998;font-style:italic"></span>sort(nameTable.begin(), nameTable.end(),
     [](string <span style="color:#000;font-weight:bold">*</span>a, string <span style="color:#000;font-weight:bold">*</span>b) { <span style="color:#000;font-weight:bold">return</span> a <span style="color:#000;font-weight:bold">&lt;</span> b; });
<span style="color:#998;font-style:italic">// ok: library guarantees that less on pointer types is well defined
</span><span style="color:#998;font-style:italic"></span>sort(nameTable.begin(), nameTable.end(), less<span style="color:#000;font-weight:bold">&lt;</span>string<span style="color:#000;font-weight:bold">*&gt;</span>());
</code></pre></div>
<p>值得注意的是关联容器使用<strong>less&lt;key_type&gt;</strong>排序它们的元素。因此，我们能定义一个指针集合，或者使用一个指针作为<strong>key</strong>的<strong>map</strong>容器而不用直接指定<strong>less</strong>。</p>
<h3 id="可调用对象和函数">可调用对象和函数</h3>
<p>C++有几种可调用对象：函数和函数指针，lambdas，由<strong>bind</strong>创建的对象和重载了函数调用操作符的类。</p>
<p>不同类型可以有相同的调用签名：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">add</span>(<span style="color:#458;font-weight:bold">int</span> i, <span style="color:#458;font-weight:bold">int</span> j) { <span style="color:#000;font-weight:bold">return</span> i <span style="color:#000;font-weight:bold">+</span> j; } <span style="color:#998;font-style:italic">// 普通函数
</span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">auto</span> mod <span style="color:#000;font-weight:bold">=</span> [](<span style="color:#458;font-weight:bold">int</span> i, <span style="color:#458;font-weight:bold">int</span> j) { <span style="color:#000;font-weight:bold">return</span> i <span style="color:#000;font-weight:bold">%</span> j; }; <span style="color:#998;font-style:italic">// 匿名函数
</span><span style="color:#998;font-style:italic">// 函数对象类
</span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">div</span> {
    <span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">operator</span>()(<span style="color:#458;font-weight:bold">int</span> denominator, <span style="color:#458;font-weight:bold">int</span> divisor) {
        <span style="color:#000;font-weight:bold">return</span> denominator <span style="color:#000;font-weight:bold">/</span> divisor;
    }
};

map<span style="color:#000;font-weight:bold">&lt;</span>string, <span style="color:#458;font-weight:bold">int</span>(<span style="color:#000;font-weight:bold">*</span>)(<span style="color:#458;font-weight:bold">int</span>,<span style="color:#458;font-weight:bold">int</span>)<span style="color:#000;font-weight:bold">&gt;</span> binops;
   
binops.insert({<span style="color:#d14">&#34;+&#34;</span>, add}); <span style="color:#998;font-style:italic">// ok: add是一个指向合适类型的函数指针
</span><span style="color:#998;font-style:italic"></span>binops.insert({<span style="color:#d14">&#34;%&#34;</span>, mod}); <span style="color:#998;font-style:italic">// error: mod不是一个指向函数的指针
</span></code></pre></div>
<h3 id="标准库function类型">标准库function类型</h3>
<p>function定义在头文件functional里面。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">function<span style="color:#000;font-weight:bold">&lt;</span>T<span style="color:#000;font-weight:bold">&gt;</span> f;          <span style="color:#998;font-style:italic">//空函数对象。
</span><span style="color:#998;font-style:italic"></span>function<span style="color:#000;font-weight:bold">&lt;</span>T<span style="color:#000;font-weight:bold">&gt;</span> f(<span style="color:#000;font-weight:bold">nullptr</span>); <span style="color:#998;font-style:italic">//显式构造空函数对象。
</span><span style="color:#998;font-style:italic"></span>function<span style="color:#000;font-weight:bold">&lt;</span>T<span style="color:#000;font-weight:bold">&gt;</span> f(obj);     <span style="color:#998;font-style:italic">//保存一个obj的副本。
</span><span style="color:#998;font-style:italic"></span>f                       <span style="color:#998;font-style:italic">//true当f拥有一个可调用对象，否则false。
</span><span style="color:#998;font-style:italic"></span>f(args)                 <span style="color:#998;font-style:italic">//传递参数args，调用函数。
</span><span style="color:#998;font-style:italic"></span>
<span style="color:#998;font-style:italic">//定义为function&lt;T&gt;的成员的类型
</span><span style="color:#998;font-style:italic"></span>result_type             <span style="color:#998;font-style:italic">//可调用对象的返回类型。
</span><span style="color:#998;font-style:italic"></span>argument_type           <span style="color:#998;font-style:italic">//当参数为1个或2个时的类型。
</span><span style="color:#998;font-style:italic"></span>first_argument_type
second_argument_type
</code></pre></div>
<p><strong>function</strong>是一个模板。和其它模板一样，我们必须指定<strong>function</strong>的函数类型。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">function<span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span>(<span style="color:#458;font-weight:bold">int</span>, <span style="color:#458;font-weight:bold">int</span>)<span style="color:#000;font-weight:bold">&gt;</span> f1 <span style="color:#000;font-weight:bold">=</span> add;    <span style="color:#998;font-style:italic">// 函数指针
</span><span style="color:#998;font-style:italic"></span>function<span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span>(<span style="color:#458;font-weight:bold">int</span>, <span style="color:#458;font-weight:bold">int</span>)<span style="color:#000;font-weight:bold">&gt;</span> f2 <span style="color:#000;font-weight:bold">=</span> div();  <span style="color:#998;font-style:italic">// 函数对象
</span><span style="color:#998;font-style:italic"></span>function<span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span>(<span style="color:#458;font-weight:bold">int</span>, <span style="color:#458;font-weight:bold">int</span>)<span style="color:#000;font-weight:bold">&gt;</span> f3 <span style="color:#000;font-weight:bold">=</span> [](<span style="color:#458;font-weight:bold">int</span> i, <span style="color:#458;font-weight:bold">int</span> j) { <span style="color:#000;font-weight:bold">return</span> i <span style="color:#000;font-weight:bold">*</span> j;}; <span style="color:#998;font-style:italic">// 匿名函数
</span><span style="color:#998;font-style:italic"></span>cout <span style="color:#000;font-weight:bold">&lt;&lt;</span> f1(<span style="color:#099">4</span>,<span style="color:#099">2</span>) <span style="color:#000;font-weight:bold">&lt;&lt;</span> endl; <span style="color:#998;font-style:italic">// prints 6
</span><span style="color:#998;font-style:italic"></span>cout <span style="color:#000;font-weight:bold">&lt;&lt;</span> f2(<span style="color:#099">4</span>,<span style="color:#099">2</span>) <span style="color:#000;font-weight:bold">&lt;&lt;</span> endl; <span style="color:#998;font-style:italic">// prints 2
</span><span style="color:#998;font-style:italic"></span>cout <span style="color:#000;font-weight:bold">&lt;&lt;</span> f3(<span style="color:#099">4</span>,<span style="color:#099">2</span>) <span style="color:#000;font-weight:bold">&lt;&lt;</span> endl; <span style="color:#998;font-style:italic">// prints 8
</span><span style="color:#998;font-style:italic"></span>
map<span style="color:#000;font-weight:bold">&lt;</span>string, function<span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span>(<span style="color:#458;font-weight:bold">int</span>, <span style="color:#458;font-weight:bold">int</span>)<span style="color:#000;font-weight:bold">&gt;&gt;</span> binops <span style="color:#000;font-weight:bold">=</span> {
    {<span style="color:#d14">&#34;+&#34;</span>, add},                  <span style="color:#998;font-style:italic">// function pointer
</span><span style="color:#998;font-style:italic"></span>    {<span style="color:#d14">&#34;-&#34;</span>, std<span style="color:#000;font-weight:bold">::</span>minus<span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">&gt;</span>()},    <span style="color:#998;font-style:italic">// library function object
</span><span style="color:#998;font-style:italic"></span>    {<span style="color:#d14">&#34;/&#34;</span>,  div()},               <span style="color:#998;font-style:italic">// user-defined function object
</span><span style="color:#998;font-style:italic"></span>    {<span style="color:#d14">&#34;*&#34;</span>, [](<span style="color:#458;font-weight:bold">int</span> i, <span style="color:#458;font-weight:bold">int</span> j) { <span style="color:#000;font-weight:bold">return</span> i <span style="color:#000;font-weight:bold">*</span> j; }}, <span style="color:#998;font-style:italic">// unnamed lambda
</span><span style="color:#998;font-style:italic"></span>    {<span style="color:#d14">&#34;%&#34;</span>, mod} };                <span style="color:#998;font-style:italic">// named lambda object
</span><span style="color:#998;font-style:italic"></span>
binops[<span style="color:#d14">&#34;+&#34;</span>](<span style="color:#099">10</span>, <span style="color:#099">5</span>); <span style="color:#998;font-style:italic">// calls add(10, 5)
</span><span style="color:#998;font-style:italic"></span>binops[<span style="color:#d14">&#34;-&#34;</span>](<span style="color:#099">10</span>, <span style="color:#099">5</span>); <span style="color:#998;font-style:italic">// uses the call operator of the minus&lt;int&gt; object
</span><span style="color:#998;font-style:italic"></span>binops[<span style="color:#d14">&#34;/&#34;</span>](<span style="color:#099">10</span>, <span style="color:#099">5</span>); <span style="color:#998;font-style:italic">// uses the call operator of the div object
</span><span style="color:#998;font-style:italic"></span>binops[<span style="color:#d14">&#34;*&#34;</span>](<span style="color:#099">10</span>, <span style="color:#099">5</span>); <span style="color:#998;font-style:italic">// calls the lambda function object
</span><span style="color:#998;font-style:italic"></span>binops[<span style="color:#d14">&#34;%&#34;</span>](<span style="color:#099">10</span>, <span style="color:#099">5</span>); <span style="color:#998;font-style:italic">// calls the lambda function object
</span></code></pre></div>
<h3 id="重载函数和function">重载函数和function</h3>
<p>我们不能直接保存一个重载函数的函数名：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#458;font-weight:bold">int</span> <span style="color:#900;font-weight:bold">add</span>(<span style="color:#458;font-weight:bold">int</span> i, <span style="color:#458;font-weight:bold">int</span> j) { <span style="color:#000;font-weight:bold">return</span> i <span style="color:#000;font-weight:bold">+</span> j; }
Sales_data <span style="color:#900;font-weight:bold">add</span>(<span style="color:#000;font-weight:bold">const</span> Sales_data<span style="color:#000;font-weight:bold">&amp;</span>, <span style="color:#000;font-weight:bold">const</span> Sales_data<span style="color:#000;font-weight:bold">&amp;</span>);
map<span style="color:#000;font-weight:bold">&lt;</span>string, function<span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span>(<span style="color:#458;font-weight:bold">int</span>, <span style="color:#458;font-weight:bold">int</span>)<span style="color:#000;font-weight:bold">&gt;&gt;</span> binops;
binops.insert({<span style="color:#d14">&#34;+&#34;</span>, add}); <span style="color:#998;font-style:italic">// error: which add?
</span></code></pre></div>
<p>解决二义性的一个方法是存储函数指针：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#458;font-weight:bold">int</span> (<span style="color:#000;font-weight:bold">*</span>fp)(<span style="color:#458;font-weight:bold">int</span>,<span style="color:#458;font-weight:bold">int</span>) <span style="color:#000;font-weight:bold">=</span> add;
binops.insert({<span style="color:#d14">&#34;+&#34;</span>, fp});
</code></pre></div>
<p>或者使用lambda消除歧义：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">binops.insert({<span style="color:#d14">&#34;+&#34;</span>, [](<span style="color:#458;font-weight:bold">int</span> a, <span style="color:#458;font-weight:bold">int</span> b) {<span style="color:#000;font-weight:bold">return</span> <span style="color:#900;font-weight:bold">add</span>(a, b);}});
</code></pre></div>
<h1 id="重载转换和操作符">重载，转换和操作符</h1>
<p>转换构造函数和转换操作符定义了类类型的转换。这种转换又叫做用户定义的转换。</p>
<h3 id="转换操作符">转换操作符</h3>
<p>转换操作符是一种特殊的成员函数，将一个类类型的值转换为其它类型的值。一个典型的转换函数具有形式：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000;font-weight:bold">operator</span> <span style="color:#900;font-weight:bold">type</span>() <span style="color:#000;font-weight:bold">const</span>;
</code></pre></div>
<p>转换操作符可以为任意（除了<strong>void</strong>）函数返回的类型定义转换。不允许转换为数组或函数类型。允许转换为指针（数据指针和函数指针）和引用。</p>
<blockquote>
<p><strong>注意</strong>
转换函数必须是一个成员函数，不能指定返回类型，参数列表必须为空，通常为const。</p>
</blockquote>
<h3 id="定义一个具有转换操作符的类">定义一个具有转换操作符的类</h3>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">SmallInt</span> {
<span style="color:#000;font-weight:bold">public</span><span style="color:#000;font-weight:bold">:</span>
    SmallInt(<span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>)<span style="color:#000;font-weight:bold">:</span> val(i)
    {
        <span style="color:#000;font-weight:bold">if</span> (i <span style="color:#000;font-weight:bold">&lt;</span> <span style="color:#099">0</span> <span style="color:#000;font-weight:bold">||</span> i <span style="color:#000;font-weight:bold">&gt;</span> <span style="color:#099">255</span>)
            <span style="color:#000;font-weight:bold">throw</span> std<span style="color:#000;font-weight:bold">::</span>out_of_range(<span style="color:#d14">&#34;Bad SmallInt value&#34;</span>);
    }
    <span style="color:#000;font-weight:bold">operator</span> <span style="color:#900;font-weight:bold">int</span>() <span style="color:#000;font-weight:bold">const</span> { <span style="color:#000;font-weight:bold">return</span> val; }
<span style="color:#000;font-weight:bold">private</span><span style="color:#000;font-weight:bold">:</span>
    std<span style="color:#000;font-weight:bold">::</span>size_t val;
};

SmallInt si;
si <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">4</span>; <span style="color:#998;font-style:italic">// implicitly converts 4 to SmallInt then calls SmallInt::operator=
</span><span style="color:#998;font-style:italic"></span>si <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">3</span>; <span style="color:#998;font-style:italic">// implicitly converts si to int followed by integer addition
</span></code></pre></div>
<p>尽管编译器每次只应用一个用户定义的转换操作，隐式调用用户定义的转换可以在之前或之后跟着一个标准转换。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">SmallInt si <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">3.14</span>;
si <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">3.14</span>;
</code></pre></div>
<p>因为转换操作符是隐式调用的，没有办法给它们传递参数。因此，转换操作符不带参数。尽管转换函数没有指定返回值，每一个转换函数必须返回相应的转换类型。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">SmallInt</span> {
<span style="color:#000;font-weight:bold">public</span><span style="color:#000;font-weight:bold">:</span>
    <span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">operator</span> <span style="color:#458;font-weight:bold">int</span>() <span style="color:#000;font-weight:bold">const</span>;            <span style="color:#998;font-style:italic">// error: return type
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">operator</span> <span style="color:#900;font-weight:bold">int</span>(<span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>) <span style="color:#000;font-weight:bold">const</span>;         <span style="color:#998;font-style:italic">// error: parameter list
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">operator</span> <span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">*</span>() <span style="color:#000;font-weight:bold">const</span> { <span style="color:#000;font-weight:bold">return</span> <span style="color:#099">42</span>; } <span style="color:#998;font-style:italic">// error: 42 is not a pointer
</span><span style="color:#998;font-style:italic"></span>};
<span style="color:#000;font-weight:bold">operator</span> <span style="color:#900;font-weight:bold">int</span>(SmallInt<span style="color:#000;font-weight:bold">&amp;</span>);                 <span style="color:#998;font-style:italic">// error: nonmember
</span></code></pre></div>
<blockquote>
<p><strong>警告</strong>
避免滥用转换函数。</p>
</blockquote>
<h3 id="转换操作符可以产生惊人的结果">转换操作符可以产生惊人的结果</h3>
<p>实际上，类很少定义转换操作符。然而一个例外是：类定义转换为bool类型并不罕见。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">42</span>;
cin <span style="color:#000;font-weight:bold">&lt;&lt;</span> i; <span style="color:#998;font-style:italic">// this code would be legal if the conversion to bool were not explicit!
</span></code></pre></div>
<h3 id="explicit转换操作符">explicit转换操作符</h3>
<p>为了防止前面的问题，新标准引入<strong>explicit</strong>转换。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">SmallInt</span> {
<span style="color:#000;font-weight:bold">public</span><span style="color:#000;font-weight:bold">:</span>
    <span style="color:#998;font-style:italic">// the compiler won&#39;t automatically apply this conversion
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">explicit</span> <span style="color:#000;font-weight:bold">operator</span> <span style="color:#458;font-weight:bold">int</span>() <span style="color:#000;font-weight:bold">const</span> { <span style="color:#000;font-weight:bold">return</span> val; }
};

SmallInt si <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">3</span>;  <span style="color:#998;font-style:italic">// ok: the SmallInt constructor is not explicit
</span><span style="color:#998;font-style:italic"></span>si <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">3</span>; <span style="color:#998;font-style:italic">// error: implicit conversion is required, but operator int is explicit
</span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">static_cast</span><span style="color:#000;font-weight:bold">&lt;</span><span style="color:#458;font-weight:bold">int</span><span style="color:#000;font-weight:bold">&gt;</span>(si) <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">3</span>; <span style="color:#998;font-style:italic">// ok: explicitly request the conversion
</span></code></pre></div>
<p>如果转换操作符是<code>explicit</code>的，我们只能通过<strong>cast</strong>来显式转换。一个例外是编译器会在条件测试中应用显式转换：</p>
<ul>
<li><code>if</code>，<code>while</code>或<code>do while</code>条件测试</li>
<li><code>for</code>的条件表达式</li>
<li>逻辑非<code>!</code>，逻辑与<code>&amp;&amp;</code>或逻辑或<code>||</code>的操作数</li>
<li>条件运算符<code>?:</code>条件测试</li>
</ul>
<h3 id="转换为bool类型">转换为bool类型</h3>
<p>当我们在条件测试中使用流对象，我们使用定义在IO类型里面的<strong>operator bool</strong>转换操作：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000;font-weight:bold">while</span> (std<span style="color:#000;font-weight:bold">::</span>cin <span style="color:#000;font-weight:bold">&gt;&gt;</span> value)
</code></pre></div>
<blockquote>
<p><strong>最佳实践</strong>
通常转换为<strong>bool</strong>是有意用于条件测试的。因此，<strong>operator bool</strong>通常应该定义为<strong>explicit</strong>。</p>
</blockquote>
<h3 id="避免歧义的转换">避免歧义的转换</h3>
<p>有两种方法会发生多个转换路径的情况。第一个就是当2个类提供了相互的转换。第二个就是定义了多个转换，其转换类型之间也可以转换。</p>
<blockquote>
<p><strong>警告</strong>
通常，类定义相互转换或定义了多个从算术类型或到算术类型的转换是个坏主意。</p>
</blockquote>
<h4 id="参数匹配和相互转换">参数匹配和相互转换</h4>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000;font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">B</span>;
<span style="color:#000;font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">A</span> {
    A() <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">default</span>;
    A(<span style="color:#000;font-weight:bold">const</span> B<span style="color:#000;font-weight:bold">&amp;</span>);        <span style="color:#998;font-style:italic">// converts a B to an A
</span><span style="color:#998;font-style:italic"></span>};
<span style="color:#000;font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">B</span> {
    <span style="color:#000;font-weight:bold">operator</span> <span style="color:#900;font-weight:bold">A</span>() <span style="color:#000;font-weight:bold">const</span>; <span style="color:#998;font-style:italic">// also converts a B to an A
</span><span style="color:#998;font-style:italic"></span>};

A <span style="color:#900;font-weight:bold">f</span>(<span style="color:#000;font-weight:bold">const</span> A<span style="color:#000;font-weight:bold">&amp;</span>);
B b;
A a <span style="color:#000;font-weight:bold">=</span> f(b); <span style="color:#998;font-style:italic">// error ambiguous: f(B::operator A())
</span><span style="color:#998;font-style:italic"></span>            <span style="color:#998;font-style:italic">//          or f(A::A(const B&amp;))
</span><span style="color:#998;font-style:italic"></span>
A a1 <span style="color:#000;font-weight:bold">=</span> f(b.<span style="color:#000;font-weight:bold">operator</span> A()); <span style="color:#998;font-style:italic">// ok: use B&#39;s conversion operator
</span><span style="color:#998;font-style:italic"></span>A a2 <span style="color:#000;font-weight:bold">=</span> f(A(b));           <span style="color:#998;font-style:italic">// ok: use A&#39;s constructor
</span></code></pre></div>
<p>需要注意的是我们不能通过<strong>cast</strong>来解决这个二义性，因为<strong>cast</strong>有着一样的歧义。</p>
<h4 id="内置类型的多个转换和歧义">内置类型的多个转换和歧义</h4>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000;font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">A</span> {
    A(<span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>);   <span style="color:#998;font-style:italic">// usually a bad idea to have two
</span><span style="color:#998;font-style:italic"></span>    A(<span style="color:#458;font-weight:bold">double</span>);    <span style="color:#998;font-style:italic">// conversions from arithmetic types
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">operator</span> <span style="color:#900;font-weight:bold">int</span>() <span style="color:#000;font-weight:bold">const</span>;    <span style="color:#998;font-style:italic">// usually a bad idea to have two
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">operator</span> <span style="color:#900;font-weight:bold">double</span>() <span style="color:#000;font-weight:bold">const</span>; <span style="color:#998;font-style:italic">// conversions to arithmetic types
</span><span style="color:#998;font-style:italic"></span>};

<span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">f2</span>(<span style="color:#458;font-weight:bold">long</span> <span style="color:#458;font-weight:bold">double</span>);
A a;
f2(a); <span style="color:#998;font-style:italic">// error ambiguous: f(A::operator int())
</span><span style="color:#998;font-style:italic"></span>       <span style="color:#998;font-style:italic">//          or f(A::operator double())
</span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">long</span> lg;
A <span style="color:#900;font-weight:bold">a2</span>(lg); <span style="color:#998;font-style:italic">// error ambiguous: A::A(int) or A::A(double)
</span><span style="color:#998;font-style:italic"></span>
<span style="color:#458;font-weight:bold">short</span> s <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">42</span>;
<span style="color:#998;font-style:italic">// promoting short to int is better than converting short to double
</span><span style="color:#998;font-style:italic"></span>A <span style="color:#900;font-weight:bold">a3</span>(s);  <span style="color:#998;font-style:italic">// uses A::A(int)
</span></code></pre></div>
<blockquote>
<p><strong>注意</strong>
当使用2个用户定义的转换时，如果有标准转换，使用标准转换的级别来选择最佳匹配。</p>
</blockquote>
<blockquote>
<p>转换和操作符：</p>
<ul>
<li>不要定义类之间的相互转换</li>
<li>避免定义多个到内置算术类型的转换。</li>
</ul>
</blockquote>
<blockquote>
<p>最简单的规则就是：除了显式转换为<strong>bool</strong>类型外，避免定义转换函数和限制那些看起来对的隐式构造函数。</p>
</blockquote>
<h4 id="重载函数和转换构造函数">重载函数和转换构造函数</h4>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000;font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">C</span> {
    C(<span style="color:#458;font-weight:bold">int</span>);
};
<span style="color:#000;font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">D</span> {
    D(<span style="color:#458;font-weight:bold">int</span>);
};

<span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">manip</span>(<span style="color:#000;font-weight:bold">const</span> C<span style="color:#000;font-weight:bold">&amp;</span>);
<span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">manip</span>(<span style="color:#000;font-weight:bold">const</span> D<span style="color:#000;font-weight:bold">&amp;</span>);

manip(<span style="color:#099">10</span>); <span style="color:#998;font-style:italic">// error ambiguous: manip(C(10)) or manip(D(10))
</span><span style="color:#998;font-style:italic"></span>manip(C(<span style="color:#099">10</span>)); <span style="color:#998;font-style:italic">// ok: calls manip(const C&amp;)
</span></code></pre></div>
<blockquote>
<p><strong>警告</strong>
需要频繁地在函数调用中使用构造函数或强制转换来转换参数一个坏设计的表现。</p>
</blockquote>
<h4 id="重载函数和用户定义的转换">重载函数和用户定义的转换</h4>
<p>在重载函数调用中，如果有2个或更多用户定义的转换提供可行的匹配，转换被认为是一样好。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000;font-weight:bold">struct</span> <span style="color:#458;font-weight:bold">E</span> {
    E(<span style="color:#458;font-weight:bold">double</span>);
};
<span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">manip2</span>(<span style="color:#000;font-weight:bold">const</span> C<span style="color:#000;font-weight:bold">&amp;</span>);
<span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">manip2</span>(<span style="color:#000;font-weight:bold">const</span> E<span style="color:#000;font-weight:bold">&amp;</span>);
<span style="color:#998;font-style:italic">// error ambiguous: two different user-defined conversions could be used
</span><span style="color:#998;font-style:italic"></span>manip2(<span style="color:#099">10</span>); <span style="color:#998;font-style:italic">// manip2(C(10) or manip2(E(double(10)))
</span></code></pre></div>
<blockquote>
<p><strong>注意</strong>
在重载函数调用中，附加的标准转换级别有作用仅当可行函数是同一个用户定义的转换。如果是不同的用户定义的转换，则调用有歧义。</p>
</blockquote>
<h3 id="函数匹配和操作符重载">函数匹配和操作符重载</h3>
<p>如果a是一个类类型，a sym b表达式可能是：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">a.operatorsym(b); <span style="color:#998;font-style:italic">// a has operatorsym as a member function
</span><span style="color:#998;font-style:italic"></span>operatorsym(a, b); <span style="color:#998;font-style:italic">// operatorsym is an ordinary function
</span></code></pre></div>
<blockquote>
<p><strong>注意</strong>
在候选函数集中表达式中的操作符可以是成员或非成员函数。</p>
</blockquote>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000;font-weight:bold">class</span> <span style="color:#458;font-weight:bold">SmallInt</span> {
    <span style="color:#000;font-weight:bold">friend</span> SmallInt <span style="color:#000;font-weight:bold">operator</span><span style="color:#000;font-weight:bold">+</span>(<span style="color:#000;font-weight:bold">const</span> SmallInt<span style="color:#000;font-weight:bold">&amp;</span>, <span style="color:#000;font-weight:bold">const</span> SmallInt<span style="color:#000;font-weight:bold">&amp;</span>);
<span style="color:#000;font-weight:bold">public</span><span style="color:#000;font-weight:bold">:</span>
    SmallInt(<span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>);                   <span style="color:#998;font-style:italic">// conversion from int
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">operator</span> <span style="color:#900;font-weight:bold">int</span>() <span style="color:#000;font-weight:bold">const</span> { <span style="color:#000;font-weight:bold">return</span> val; } <span style="color:#998;font-style:italic">// conversion to int
</span><span style="color:#998;font-style:italic"></span><span style="color:#000;font-weight:bold">private</span><span style="color:#000;font-weight:bold">:</span>
    std<span style="color:#000;font-weight:bold">::</span>size_t val;
};

SmallInt s1, s2;
SmallInt s3 <span style="color:#000;font-weight:bold">=</span> s1 <span style="color:#000;font-weight:bold">+</span> s2;  <span style="color:#998;font-style:italic">// uses overloaded operator+
</span><span style="color:#998;font-style:italic"></span><span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> s3 <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">0</span>;         <span style="color:#998;font-style:italic">// error: ambiguous
</span></code></pre></div>
<blockquote>
<p><strong>警告</strong>
既提供了到算术类型的转换，又重载了相应的算术操作符，可能会导致二义性</p>
</blockquote>

        </div>

        
<div class="post-archive">
    <ul class="post-copyright">
        <li><strong>原文作者：</strong><a rel="author" href="https://gitop.cc">招财猫</a></li>
        <li style="word-break:break-all"><strong>原文链接：</strong><a href="https://gitop.cc/posts/cpp-primer-14/">https://gitop.cc/posts/cpp-primer-14/</a></li>
        <li><strong>版权声明：</strong>本作品采用<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li>
    </ul>
</div>
<br/>



        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/syntax/">Markdown语法</a></li>
        
        <li><a href="/archives/">归档</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://gitop.cc/tags/C&#43;&#43;'>C&#43;&#43;</a></li>
                
            </ul>
            
        </div>
    </article>
    
    <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "yourdiscussshortname" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "your github repo"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
</div>

                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://gitop.cc/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://gitop.cc">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://gitop.cc/posts/scrapy-fundamental/" title="Scrapy爬虫基础">Scrapy爬虫基础</a>
    </li>
    
    <li>
        <a href="https://gitop.cc/posts/xpath/" title="XPath教程">XPath教程</a>
    </li>
    
    <li>
        <a href="https://gitop.cc/posts/refactoring-testing-debugging/" title="重构、测试和调试">重构、测试和调试</a>
    </li>
    
    <li>
        <a href="https://gitop.cc/posts/collection-api-enhancements/" title="Collection API增强">Collection API增强</a>
    </li>
    
    <li>
        <a href="https://gitop.cc/posts/parallel-data-processing-and-performance/" title="并行数据处理和性能">并行数据处理和性能</a>
    </li>
    
    <li>
        <a href="https://gitop.cc/posts/collecting-data-with-streams/" title="使用流收集数据">使用流收集数据</a>
    </li>
    
    <li>
        <a href="https://gitop.cc/posts/working-with-streams/" title="使用流">使用流</a>
    </li>
    
    <li>
        <a href="https://gitop.cc/posts/introducing-streams/" title="流介绍">流介绍</a>
    </li>
    
    <li>
        <a href="https://gitop.cc/posts/lambda-expressions/" title="Lambda表达式">Lambda表达式</a>
    </li>
    
    <li>
        <a href="https://gitop.cc/posts/git-multi-sshkey/" title="Git配置多个SSH-Key">Git配置多个SSH-Key</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
    <li><a href="https://gitop.cc/categories/Crawler/">Crawler (1)</a></li>
    
    <li><a href="https://gitop.cc/categories/Database/">Database (12)</a></li>
    
    <li><a href="https://gitop.cc/categories/GUI/">GUI (5)</a></li>
    
    <li><a href="https://gitop.cc/categories/Gist/">Gist (1)</a></li>
    
    <li><a href="https://gitop.cc/categories/Language/">Language (23)</a></li>
    
    <li><a href="https://gitop.cc/categories/Linux/">Linux (3)</a></li>
    
    <li><a href="https://gitop.cc/categories/Network/">Network (4)</a></li>
    
    <li><a href="https://gitop.cc/categories/Tool/">Tool (4)</a></li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="https://gitop.cc/tags/C/">C</a>
    
    <a href="https://gitop.cc/tags/C&#43;&#43;/">C&#43;&#43;</a>
    
    <a href="https://gitop.cc/tags/CentOS/">CentOS</a>
    
    <a href="https://gitop.cc/tags/Docker/">Docker</a>
    
    <a href="https://gitop.cc/tags/Git/">Git</a>
    
    <a href="https://gitop.cc/tags/Greenplum/">Greenplum</a>
    
    <a href="https://gitop.cc/tags/Idea/">Idea</a>
    
    <a href="https://gitop.cc/tags/Java/">Java</a>
    
    <a href="https://gitop.cc/tags/Javascript/">Javascript</a>
    
    <a href="https://gitop.cc/tags/Markdown/">Markdown</a>
    
    <a href="https://gitop.cc/tags/MySQL/">MySQL</a>
    
    <a href="https://gitop.cc/tags/PostgreSQL/">PostgreSQL</a>
    
    <a href="https://gitop.cc/tags/ProjectEuler/">ProjectEuler</a>
    
    <a href="https://gitop.cc/tags/Python/">Python</a>
    
    <a href="https://gitop.cc/tags/Scrapy/">Scrapy</a>
    
    <a href="https://gitop.cc/tags/Ubuntu/">Ubuntu</a>
    
    <a href="https://gitop.cc/tags/XPath/">XPath</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://gitop.cc/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
    <footer id="footer">
    <div class="container">
        &copy; 2020 <a href="https://gitop.cc">招财猫的博客 By 招财猫</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/flysnow-org/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>


<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




</body>

</html>