<!DOCTYPE html>
<html lang="en-us">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c">

<meta itemprop="name" content="并行数据处理和性能">
<meta itemprop="description" content="并行流 通过调用parallelStream方法，可以将集合转换为并行流。并行流是将元素分割成多个块的流，使用不同的线程处理每个块。因此，你可">


<meta itemprop="datePublished" content="2019-07-23T20:00:47&#43;08:00" />
<meta itemprop="dateModified" content="2019-07-23T20:00:47&#43;08:00" />
<meta itemprop="wordCount" content="4080">



<meta itemprop="keywords" content="Java," />
<meta property="og:title" content="并行数据处理和性能" />
<meta property="og:description" content="并行流 通过调用parallelStream方法，可以将集合转换为并行流。并行流是将元素分割成多个块的流，使用不同的线程处理每个块。因此，你可" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://gitop.cc/posts/parallel-data-processing-and-performance/" />
<meta property="article:published_time" content="2019-07-23T20:00:47&#43;08:00"/>
<meta property="article:modified_time" content="2019-07-23T20:00:47&#43;08:00"/>
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="并行数据处理和性能"/>
<meta name="twitter:description" content="并行流 通过调用parallelStream方法，可以将集合转换为并行流。并行流是将元素分割成多个块的流，使用不同的线程处理每个块。因此，你可"/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>并行数据处理和性能</title>
	<link rel="stylesheet" href="http://gitop.cc/css/style.min.568c54a56780af2a70c45272522247710b69dbfc080b315211fb98381e3796f8.css" integrity="sha256-VoxUpWeArypwxFJyUiJHcQtp2/wICzFSEfuYOB43lvg=">
	
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp faster">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="http://gitop.cc">静心</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="http://gitop.cc/posts/">Posts</a>
				<a href="http://gitop.cc/tags/">Tags</a>
				<a href="http://gitop.cc/about/">About</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<span class="hdr-social hide-in-mobile"><a href="https://github.com/opensvn" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="http://gitop.cc/posts/">Posts</a></li>
			<li><a href="http://gitop.cc/tags/">Tags</a></li>
			<li><a href="http://gitop.cc/about/">About</a></li>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Jul 23, 2019</span></div>
				<h1>并行数据处理和性能</h1>
			</header>
			<div class="content">
				

<h2 id="并行流">并行流<a href="#并行流" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>通过调用<code>parallelStream</code>方法，可以将集合转换为并行流。并行流是将元素分割成多个块的流，使用不同的线程处理每个块。因此，你可以自动划分指定操作的工作负载在多核处理器的所有核心上，并使它们一样忙。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">long</span> <span class="nf">sequentialSum</span><span class="o">(</span><span class="kt">long</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">Stream</span><span class="o">.</span><span class="na">iterate</span><span class="o">(</span><span class="n">1L</span><span class="o">,</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">).</span><span class="na">limit</span><span class="o">(</span><span class="n">n</span><span class="o">).</span><span class="na">reduce</span><span class="o">(</span><span class="n">0L</span><span class="o">,</span> <span class="nl">Long:</span><span class="o">:</span><span class="n">sum</span><span class="o">);</span>
<span class="o">}</span></code></pre></div>
<h3 id="将顺序流转为并行流">将顺序流转为并行流<a href="#将顺序流转为并行流" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>调用<code>parallel</code>方法可以将顺序流转为并行流：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">long</span> <span class="nf">parallelSum</span><span class="o">(</span><span class="kt">long</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">Stream</span><span class="o">.</span><span class="na">iterate</span><span class="o">(</span><span class="n">1L</span><span class="o">,</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">).</span><span class="na">limit</span><span class="o">(</span><span class="n">n</span><span class="o">).</span><span class="na">parallel</span><span class="o">().</span><span class="na">reduce</span><span class="o">(</span><span class="n">0L</span><span class="o">,</span> <span class="nl">Long:</span><span class="o">:</span><span class="n">sum</span><span class="o">);</span>
<span class="o">}</span></code></pre></div>
<p>实际上，在顺序流上并行<code>parallel</code>方法并没有对流进行任何转换。在内部设置一个布尔值，标志<code>parallel</code>后面所有的操作需要并行处理。你也许会认为通过<code>sequential</code>方法和<code>parallel</code>方法可以更精细的控制流操作，比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">stream</span><span class="o">.</span><span class="na">parallel</span><span class="o">().</span><span class="na">filter</span><span class="o">(...).</span><span class="na">sequential</span><span class="o">().</span><span class="na">map</span><span class="o">(...).</span><span class="na">parallel</span><span class="o">().</span><span class="na">reduce</span><span class="o">();</span></code></pre></div>
<p>但是<code>parallel</code>或<code>sequential</code>的最后一次调用获胜并影响整个流管道。</p>

<blockquote>
<p>配置并行流使用的线程池</p>

<p>并行流在内部使用默认的ForkJoinPool。默认情况下，它的线程数与处理器的数量相同，由Runtime.getRuntime().availableprocessors()返回。</p>

<p>但是你可以修改系统属性java.util.concurrent.ForkJoinPool.common.parallelism修改线程池大小，比如：System.setProperty(&ldquo;java.util.concurrent.ForkJoinPool.common.parallelism&rdquo;, &ldquo;12&rdquo;);</p>

<p>这是一个全局设置，因此它将影响代码中的所有并行流。不推荐修改这个值。</p>
</blockquote>

<h3 id="测量流处理性能">测量流处理性能<a href="#测量流处理性能" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>如果使用Maven作为构建工具，那么要在项目中使用JMH，需要向pom.xml文件添加几个依赖项：</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;dependency&gt;</span>
  <span class="nt">&lt;groupId&gt;</span>org.openjdk.jmh<span class="nt">&lt;/groupId&gt;</span>
  <span class="nt">&lt;artifactId&gt;</span>jmh-core<span class="nt">&lt;/artifactId&gt;</span>
  <span class="nt">&lt;version&gt;</span>1.17.4<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
  <span class="nt">&lt;groupId&gt;</span>org.openjdk.jmh<span class="nt">&lt;/groupId&gt;</span>
  <span class="nt">&lt;artifactId&gt;</span>jmh-generator-annprocess<span class="nt">&lt;/artifactId&gt;</span>
  <span class="nt">&lt;version&gt;</span>1.17.4<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>

<span class="nt">&lt;build&gt;</span>
  <span class="nt">&lt;plugins&gt;</span>
    <span class="nt">&lt;plugin&gt;</span>
      <span class="nt">&lt;groupId&gt;</span>org.apache.maven.plugins<span class="nt">&lt;/groupId&gt;</span>
      <span class="nt">&lt;artifactId&gt;</span>maven-shade-plugin<span class="nt">&lt;/artifactId&gt;</span>
      <span class="nt">&lt;executions&gt;</span>
        <span class="nt">&lt;execution&gt;</span>
          <span class="nt">&lt;phase&gt;</span>package<span class="nt">&lt;/phase&gt;</span>
          <span class="nt">&lt;goals&gt;&lt;goal&gt;</span>shade<span class="nt">&lt;/goal&gt;&lt;/goals&gt;</span>
          <span class="nt">&lt;configuration&gt;</span>
            <span class="nt">&lt;finalName&gt;</span>benchmarks<span class="nt">&lt;/finalName&gt;</span>
            <span class="nt">&lt;transformers&gt;</span>
              <span class="nt">&lt;transformer</span> <span class="na">implementation=</span><span class="s">&#34;org.apache.maven.plugins.shade.
</span><span class="s">resource.ManifestResourceTransformer&#34;</span><span class="nt">&gt;</span>
                <span class="nt">&lt;mainClass&gt;</span>org.openjdk.jmh.Main<span class="nt">&lt;/mainClass&gt;</span>
              <span class="nt">&lt;/transformer&gt;</span>
            <span class="nt">&lt;/transformers&gt;</span>
          <span class="nt">&lt;/configuration&gt;</span>
        <span class="nt">&lt;/execution&gt;</span>
      <span class="nt">&lt;/executions&gt;</span>
    <span class="nt">&lt;/plugin&gt;</span>
  <span class="nt">&lt;/plugins&gt;</span>
<span class="nt">&lt;/build&gt;</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@BenchmarkMode</span><span class="o">(</span><span class="n">Mode</span><span class="o">.</span><span class="na">AverageTime</span><span class="o">)</span>
<span class="nd">@OutputTimeUnit</span><span class="o">(</span><span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">)</span>
<span class="nd">@Fork</span><span class="o">(</span><span class="n">2</span><span class="o">,</span> <span class="n">jvmArgs</span> <span class="o">=</span> <span class="o">{</span><span class="s">&#34;-Xms4G&#34;</span><span class="o">,</span> <span class="s">&#34;-Xmx4G&#34;</span><span class="o">})</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ParallelStreamBenchmark</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">N</span> <span class="o">=</span> <span class="n">10_000_000L</span><span class="o">;</span>

    <span class="nd">@Benchmark</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">sequentialSum</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Stream</span><span class="o">.</span><span class="na">iterate</span><span class="o">(</span><span class="n">1L</span><span class="o">,</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">).</span><span class="na">limit</span><span class="o">(</span><span class="n">N</span><span class="o">).</span><span class="na">reduce</span><span class="o">(</span><span class="n">0L</span><span class="o">,</span> <span class="nl">Long:</span><span class="o">:</span><span class="n">sum</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Benchmark</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">iterativeSum</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1L</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@TearDown</span><span class="o">(</span><span class="n">Level</span><span class="o">.</span><span class="na">Invocation</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">tearDown</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">gc</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p>这说明了并行编程是多么棘手，有时甚至违反直觉。当被误用时，可能会降低程序的整体性能，因此必须了解调用并行方法的背后发生了什么。</p>

<h4 id="使用更专业的方法">使用更专业的方法<a href="#使用更专业的方法" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p><code>LongStream.rangeClosed</code>相比<code>iterate</code>有2个好处：</p>

<ul>
<li>LongStream.rangeClosed直接处理原始类型long，因此没有装箱和拆箱开销。</li>
<li>LongStream.rangeClosed产生一个范围的数字，可以很容易地划分为独立的块。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Benchmark</span>
<span class="kd">public</span> <span class="kt">long</span> <span class="nf">rangedSum</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">LongStream</span><span class="o">.</span><span class="na">rangeClosed</span><span class="o">(</span><span class="n">1</span><span class="o">,</span> <span class="n">N</span><span class="o">).</span><span class="na">reduce</span><span class="o">(</span><span class="n">0L</span><span class="o">,</span> <span class="nl">Long:</span><span class="o">:</span><span class="n">sum</span><span class="o">);</span>
<span class="o">}</span>

<span class="nd">@Benchmark</span>
<span class="kd">public</span> <span class="kt">long</span> <span class="nf">parallelRangedSum</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">LongStream</span><span class="o">.</span><span class="na">rangeClosed</span><span class="o">(</span><span class="n">1</span><span class="o">,</span> <span class="n">N</span><span class="o">).</span><span class="na">parallel</span><span class="o">().</span><span class="na">reduce</span><span class="o">(</span><span class="n">0L</span><span class="o">,</span> <span class="nl">Long:</span><span class="o">:</span><span class="n">sum</span><span class="o">);</span>
<span class="o">}</span></code></pre></div>
<h3 id="正确使用并行流">正确使用并行流<a href="#正确使用并行流" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>误用并行流产生错误的主要原因是使用了改变某些共享状态的算法。下面是一种方法通过修改共享累加器来求前n个自然数之和：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">long</span> <span class="nf">sideEffectSum</span><span class="o">(</span><span class="kt">long</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Accumulator</span> <span class="n">accumulator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Accumulator</span><span class="o">();</span>
    <span class="n">LongStream</span><span class="o">.</span><span class="na">rangeClosed</span><span class="o">(</span><span class="n">1</span><span class="o">,</span> <span class="n">n</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="nl">accumulator:</span><span class="o">:</span><span class="n">add</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">accumulator</span><span class="o">.</span><span class="na">total</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Accumulator</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="n">total</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">long</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span> <span class="n">total</span> <span class="o">+=</span> <span class="n">value</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p>请记住，避免共享可变状态可以确保并行流产生正确的结果。</p>

<h3 id="有效地使用并行流">有效地使用并行流<a href="#有效地使用并行流" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>以下是使用并行流的一些建议：</p>

<ul>
<li>并行流并不总是比相应的顺序流快，因此在选择顺序流和并行流时，最重要的建议是使用适当的基准测试它们的性能。</li>
<li>自动装箱和拆箱操作会极大地影响性能。可能使用IntStream、LongStream和DoubleStream。</li>
<li>有些操作在并行流上的性能比在顺序流上差。特别是依赖于元素顺序的limit和findFirst之类的操作在并行流中非常昂贵。</li>
<li>考虑流管道操作的总成本，成本越高，使用并行流性能越好。</li>
<li>对于少量数据，选择并行流不是个好决定。并行处理只有几个元素的优势不足以补偿并行化过程带来的额外成本。</li>
<li>考虑流下面的数据结构是否容易分解。比如ArrayList比LinkedList更容易分割。原始类型流的<code>range</code>方法能快速分解。你也可以实现自己的<code>Spliterator</code>来完全控制分解过程。</li>
<li>流的特征以及管道的中间操作如何修改它们，会改变分解过程的性能。比如一个固定大小的流可以分成多个相等的部分，然后可以更有效地并行处理每个部分，但是<code>filter</code>操作会丢弃不可预知的元素数量，从而使流本身的大小未知。</li>
<li>考虑终端操作的合并步骤是否昂贵。</li>
</ul>

<p>下表从可分解性的角度总结了某些集合的并行友好性。</p>

<table>
<thead>
<tr>
<th>数据源</th>
<th>可分解性</th>
</tr>
</thead>

<tbody>
<tr>
<td>ArrayList</td>
<td>极好</td>
</tr>

<tr>
<td>LinkedList</td>
<td>差</td>
</tr>

<tr>
<td>IntStream.range</td>
<td>极好</td>
</tr>

<tr>
<td>Stream.iterate</td>
<td>差</td>
</tr>

<tr>
<td>HashSet</td>
<td>好</td>
</tr>

<tr>
<td>TreeSet</td>
<td>好</td>
</tr>
</tbody>
</table>

<h2 id="fork-join框架">fork/join框架<a href="#fork-join框架" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>fork/join框架的设计目的是递归地将一个可并行化的任务分解为更小的任务，然后将每个子任务的结果组合起来，以生成总体结果。它是ExecutorService接口的实现，该接口将这些子任务分发给线程池（称为ForkJoinPool）中的工作线程。</p>

<h3 id="使用recursivetask">使用RecursiveTask<a href="#使用recursivetask" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>想要提交任务到线程池，你需要创建一个<code>RecursiveTask&lt;R&gt;</code>子类，其中R是并行任务产生的结果类型。如果任务不返回任何结果，则需要创建<code>RecursiveAction</code>的子类。要定义<code>RecursiveTask</code>，只需要实现它的一个抽象方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">protected</span> <span class="kd">abstract</span> <span class="n">R</span> <span class="nf">compute</span><span class="o">();</span></code></pre></div>
<p>该方法定义了将任务分解为子任务的逻辑，以及生成单个子任务结果的算法。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ForkJoinSumCalculator</span> <span class="kd">extends</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">concurrent</span><span class="o">.</span><span class="na">RecursiveTask</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span><span class="o">[]</span> <span class="n">numbers</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">start</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">end</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">THRESHOLD</span> <span class="o">=</span> <span class="n">10_000</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">ForkJoinSumCalculator</span><span class="o">(</span><span class="kt">long</span><span class="o">[]</span> <span class="n">numbers</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">(</span><span class="n">numbers</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">numbers</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nf">ForkJoinSumCalculator</span><span class="o">(</span><span class="kt">long</span><span class="o">[]</span> <span class="n">numbers</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">numbers</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">end</span> <span class="o">=</span> <span class="n">end</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="n">Long</span> <span class="nf">compute</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">length</span> <span class="o">&lt;=</span> <span class="n">THRESHOLD</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">computeSequentially</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">ForkJoinSumCalculator</span> <span class="n">leftTask</span> <span class="o">=</span>
            <span class="k">new</span> <span class="n">ForkJoinSumCalculator</span><span class="o">(</span><span class="n">numbers</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">length</span> <span class="o">/</span> <span class="n">2</span><span class="o">);</span>
        <span class="n">leftTask</span><span class="o">.</span><span class="na">fork</span><span class="o">();</span>
        <span class="n">ForkJoinSumCalculator</span> <span class="n">rightTask</span> <span class="o">=</span>
            <span class="k">new</span> <span class="n">ForkJoinSumCalculator</span><span class="o">(</span><span class="n">numbers</span><span class="o">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">length</span> <span class="o">/</span> <span class="n">2</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>
        <span class="n">Long</span> <span class="n">rightResult</span> <span class="o">=</span> <span class="n">rightTask</span><span class="o">.</span><span class="na">compute</span><span class="o">();</span>
        <span class="n">Long</span> <span class="n">leftResult</span> <span class="o">=</span> <span class="n">leftTask</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">leftResult</span> <span class="o">+</span> <span class="n">rightResult</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">long</span> <span class="nf">computeSequentially</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">forkJoinSum</span><span class="o">(</span><span class="kt">long</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">long</span><span class="o">[]</span> <span class="n">numbers</span> <span class="o">=</span> <span class="n">LongStream</span><span class="o">.</span><span class="na">rangeClosed</span><span class="o">(</span><span class="n">1</span><span class="o">,</span> <span class="n">n</span><span class="o">).</span><span class="na">toArray</span><span class="o">();</span>
    <span class="n">ForkJoinTask</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">task</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ForkJoinSumCalculator</span><span class="o">(</span><span class="n">numbers</span><span class="o">);</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">ForkJoinPool</span><span class="o">().</span><span class="na">invoke</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
<span class="o">}</span></code></pre></div>
<h3 id="使用fork-join框架的最佳实践">使用fork/join框架的最佳实践<a href="#使用fork-join框架的最佳实践" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>尽管fork/join框架相对容易使用，但它也很容易被误用。下面是一些有效使用它的最佳实践：</p>

<ul>
<li>在任务上调用<code>join</code>方法会阻塞调用者，直到该任务生成的结果就绪为止。因此必须在启动两个子任务的计算之后调用它。</li>
<li>不应该在<code>RecursiveTask</code>中调用<code>ForkJoinPool</code>的<code>invoke</code>方法。只有顺序代码才应该使用<code>invoke</code>开始并行计算。</li>
<li>在子任务上调用fork方法实际上是将任务放入ForkJoinPool。在其中一个子任务上直接调用compute可以重用一个的线程，避免在池中不必要地分配另一个任务而造成的开销。</li>
<li>调试使用fort/join框架的并行计算比较棘手，因为在不同的线程执行计算。</li>
<li>和使用并行流一样，不能想当然地认为在多核处理器上使用fork/join框架进行计算比顺序处理会更快。一个任务应该可以分解为几个独立的子任务，以便能够获得相应的性能提升。这些子任务的执行时间应该比创建一个新任务时间要长。</li>
</ul>

<h3 id="工作窃取">工作窃取<a href="#工作窃取" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>ForkJoinPool中每个线程都持有一个双链表，包含分配给它的任务。每完成一个任务，线程从队列头部取出另一个任务并开始执行。但是由于一些原因，一个线程可能比其他线程更快地完成分配给它的所有任务，这意味着当其他线程仍然非常忙时，它的队列将变为空。在这种情况下，该线程会随机选择另一个线程的工作队列，并从队列尾部“窃取”任务。这个过程一直进行直到所有任务都完成。这就是为什么有许多较小的任务，而不是只有几个较大的任务，可以帮助更好地平衡工作线程之间的工作负载。</p>

<h2 id="spliterator">Spliterator<a href="#spliterator" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>Spliterator是Java 8新增的一个接口。Collection接口提供了一个默认方法spliterator()，返回一个spliterator对象。Spliterator接口定义了几个方法，如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Spliterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="nf">tryAdvance</span><span class="o">(</span><span class="n">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">);</span>
    <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">trySplit</span><span class="o">();</span>
    <span class="kt">long</span> <span class="nf">estimateSize</span><span class="o">();</span>
    <span class="kt">int</span> <span class="nf">characteristics</span><span class="o">();</span>
<span class="o">}</span></code></pre></div>
<p><code>tryAdvance</code>方法与普通迭代器类似，用于顺序遍历Spliterator的元素，如果还有其他元素要遍历，则返回true。</p>

<p><code>trySplit</code>方法用于将其部分元素分割到第二个Spliterator，从而允许并行处理这两个Spliterator。</p>

<p><code>estimateSize</code>方法估计剩余要遍历的元素的数量。</p>

<h3 id="分裂过程">分裂过程<a href="#分裂过程" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>将一个流分成多个部分是一个递归过程。首先，在第一个Spliterator上调用trySplit并生成第二个Spliterator。然后在这两个spliterator上再次调用trySplit，得到四个Spliterator。不断调用方法trySplit，直到返回null，说明正在处理的数据是不可再分割的。当所有Spliterators调用trySplit返回null时，分裂过程终止。分裂过程会受到Spliterator本身的特性的影响，它们由<code>characteristics</code>方法声明的。</p>

<h4 id="spliterator特征">Spliterator特征<a href="#spliterator特征" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p><code>characteristics</code>方法返回一个int，包含一组Spliterator的特征。可以使用这些特性更好地控制和优化Spliterator使用。</p>

<table>
<thead>
<tr>
<th>特征</th>
<th>意义</th>
</tr>
</thead>

<tbody>
<tr>
<td>ORDERED</td>
<td>元素有顺序，因此Spliterator在遍历和分区时保持这个顺序</td>
</tr>

<tr>
<td>DISTINCT</td>
<td>所有元素唯一</td>
</tr>

<tr>
<td>SORTED</td>
<td>遍历的元素遵循预定义的排序顺序</td>
</tr>

<tr>
<td>SIZED</td>
<td>遍历的元素大小已知</td>
</tr>

<tr>
<td>NON_NULL</td>
<td>元素非空</td>
</tr>

<tr>
<td>IMMUTABLE</td>
<td>数据源不能修改</td>
</tr>

<tr>
<td>CONCURRENT</td>
<td>可并行</td>
</tr>

<tr>
<td>SUBSIZED</td>
<td>所有的Spliterator大小已知</td>
</tr>
</tbody>
</table>

<h3 id="实现自己的spliterator">实现自己的Spliterator<a href="#实现自己的spliterator" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>我们将开发一个简单的方法来计算字符串中的单词数量。其迭代版如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">int</span> <span class="nf">countWordsIteratively</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    <span class="kt">boolean</span> <span class="n">lastSpace</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">s</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">Character</span><span class="o">.</span><span class="na">isWhitespace</span><span class="o">(</span><span class="n">c</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">lastSpace</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">lastSpace</span><span class="o">)</span> <span class="n">counter</span><span class="o">++;</span>
            <span class="n">lastSpace</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">counter</span><span class="o">;</span>
<span class="o">}</span></code></pre></div>
<h4 id="函数风格重写单词计数器">函数风格重写单词计数器<a href="#函数风格重写单词计数器" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p>首先，需要将字符串转换为流</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Stream</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">SENTENCE</span><span class="o">.</span><span class="na">length</span><span class="o">()).</span><span class="na">mapToObj</span><span class="o">(</span><span class="nl">SENTENCE:</span><span class="o">:</span><span class="n">charAt</span><span class="o">);</span></code></pre></div>
<p>定义一个类WordCounter用于携带2个状态，一个是目前为止找到的单词数量，一个是最后字符是否为空格。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">WordCounter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">counter</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">lastSpace</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">WordCounter</span><span class="o">(</span><span class="kt">int</span> <span class="n">counter</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">lastSpace</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">counter</span> <span class="o">=</span> <span class="n">counter</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">lastSpace</span> <span class="o">=</span> <span class="n">lastSpace</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">WordCounter</span> <span class="nf">accumulate</span><span class="o">(</span><span class="n">Character</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">Character</span><span class="o">.</span><span class="na">isWhitespace</span><span class="o">(</span><span class="n">c</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">lastSpace</span> <span class="o">?</span> <span class="k">this</span> <span class="o">:</span> <span class="k">new</span> <span class="n">WordCounter</span><span class="o">(</span><span class="n">counter</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">lastSpace</span> <span class="o">?</span> <span class="k">new</span> <span class="n">WordCounter</span><span class="o">(</span><span class="n">counter</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="kc">false</span><span class="o">)</span> <span class="o">:</span> <span class="k">this</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">WordCounter</span> <span class="nf">combine</span><span class="o">(</span><span class="n">WordCounter</span> <span class="n">wordCounter</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">WordCounter</span><span class="o">(</span><span class="n">counter</span> <span class="o">+</span> <span class="n">wordCounter</span><span class="o">.</span><span class="na">counter</span><span class="o">,</span>
            <span class="n">wordCounter</span><span class="o">.</span><span class="na">lastSpace</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getCounter</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">counter</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<p>如下所示计算流中的单词数：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kt">int</span> <span class="nf">countWords</span><span class="o">(</span><span class="n">Stream</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">stream</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">WordCounter</span> <span class="n">wordCounter</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="k">new</span> <span class="n">WordCounter</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="kc">true</span><span class="o">),</span><span class="nl">
</span><span class="nl">        WordCounter:</span><span class="o">:</span><span class="n">accumulate</span><span class="o">,</span><span class="nl">
</span><span class="nl">        WordCounter:</span><span class="o">:</span><span class="n">combine</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">wordCounter</span><span class="o">.</span><span class="na">getCounter</span><span class="o">();</span>
<span class="o">}</span></code></pre></div>
<h4 id="使单词计数器并行工作">使单词计数器并行工作<a href="#使单词计数器并行工作" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p>解决方案需确保字符串不是在随机位置拆分，而只在单词末尾拆分。所以需要实现一个字符Spliterator，只在两个单词之间分割字符串，然后从中创建并行流。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">WordCounterSpliterator</span> <span class="kd">implements</span> <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">string</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">currentChar</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">WordCounterSpliterator</span><span class="o">(</span><span class="n">String</span> <span class="n">string</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">string</span> <span class="o">=</span> <span class="n">string</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">tryAdvance</span><span class="o">(</span><span class="n">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">Character</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">action</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">string</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">currentChar</span><span class="o">++));</span>
        <span class="k">return</span> <span class="n">currentChar</span> <span class="o">&lt;</span> <span class="n">string</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="nf">trySplit</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">currentSize</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="n">currentChar</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">currentSize</span> <span class="o">&lt;</span> <span class="n">10</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">splitPos</span> <span class="o">=</span> <span class="n">currentSize</span> <span class="o">/</span> <span class="n">2</span> <span class="o">+</span> <span class="n">currentChar</span><span class="o">;</span>
             <span class="n">splitPos</span> <span class="o">&lt;</span> <span class="n">string</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">splitPos</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">Character</span><span class="o">.</span><span class="na">isWhitespace</span><span class="o">(</span><span class="n">string</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">splitPos</span><span class="o">)))</span> <span class="o">{</span>
                <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">spliterator</span> <span class="o">=</span>
                    <span class="k">new</span> <span class="n">WordCounterSpliterator</span><span class="o">(</span><span class="n">string</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">currentChar</span><span class="o">,</span>
                        <span class="n">splitPos</span><span class="o">));</span>
                <span class="n">currentChar</span> <span class="o">=</span> <span class="n">splitPos</span><span class="o">;</span>
                <span class="k">return</span> <span class="n">spliterator</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">estimateSize</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">string</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="n">currentChar</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">characteristics</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">ORDERED</span> <span class="o">+</span> <span class="n">SIZED</span> <span class="o">+</span> <span class="n">SUBSIZED</span> <span class="o">+</span> <span class="n">NON_NULL</span> <span class="o">+</span> <span class="n">IMMUTABLE</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>
<h4 id="使单词计数器spliterator工作">使单词计数器Spliterator工作<a href="#使单词计数器spliterator工作" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p>现在可以使用这个并行流，如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">spliterator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WordCounterSpliterator</span><span class="o">(</span><span class="n">SENTENCE</span><span class="o">);</span>
<span class="n">Stream</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">StreamSupport</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">spliterator</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span></code></pre></div>
<p>Spliterator的最后一个显著特性是，可以绑定要在第一次遍历、第一次拆分或第一次查询时(而不是在创建时)遍历的元素的数据源，称为后期绑定Spliterator。</p>

			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="http://gitop.cc/tags/java">Java</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>4080 Words</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2019-07-23 20:00 &#43;0800</p>
			</footer>
		</article>
		<div class="post-nav thin">
			<a class="prev-post" href="http://gitop.cc/posts/collecting-data-with-streams/">
				<span class="post-nav-label">Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>使用流收集数据</span>
			</a>
		</div>
		<div id="comments" class="thin">
</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2019 <a href="http://gitop.cc">gitop</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="http://gitop.cc/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>


	<script src="http://gitop.cc/js/main.min.35ccbf1cdceb91e4c64c06b5d009d6e2977fafe56beda7762febd4e67528d2ac.js" integrity="sha256-Ncy/HNzrkeTGTAa10AnW4pd/r+Vr7ad2L+vU5nUo0qw="></script>

</body>

</html>
