<!DOCTYPE html>
<html lang="en-us">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c">

<meta itemprop="name" content="第16章 模板和泛型编程">
<meta itemprop="description" content="面向对象编程和泛型编程都是处理程序编写时类型未知的情况。两者的区别是面向对象编程直到运行时类型才能知道，而泛型编程类型在编译期间知道。 容器，">


<meta itemprop="datePublished" content="2015-12-14T10:34:42&#43;00:00" />
<meta itemprop="dateModified" content="2015-12-14T10:34:42&#43;00:00" />
<meta itemprop="wordCount" content="16677">



<meta itemprop="keywords" content="C&#43;&#43;," />
<meta property="og:title" content="第16章 模板和泛型编程" />
<meta property="og:description" content="面向对象编程和泛型编程都是处理程序编写时类型未知的情况。两者的区别是面向对象编程直到运行时类型才能知道，而泛型编程类型在编译期间知道。 容器，" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://gitop.cc/posts/cpp-primer-16/" />
<meta property="article:published_time" content="2015-12-14T10:34:42&#43;00:00"/>
<meta property="article:modified_time" content="2015-12-14T10:34:42&#43;00:00"/>
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="第16章 模板和泛型编程"/>
<meta name="twitter:description" content="面向对象编程和泛型编程都是处理程序编写时类型未知的情况。两者的区别是面向对象编程直到运行时类型才能知道，而泛型编程类型在编译期间知道。 容器，"/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>第16章 模板和泛型编程</title>
	<link rel="stylesheet" href="http://gitop.cc/css/style.min.568c54a56780af2a70c45272522247710b69dbfc080b315211fb98381e3796f8.css" integrity="sha256-VoxUpWeArypwxFJyUiJHcQtp2/wICzFSEfuYOB43lvg=">
	
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp faster">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="http://gitop.cc">静心</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="http://gitop.cc/posts/">Posts</a>
				<a href="http://gitop.cc/about/">About</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<span class="hdr-social hide-in-mobile"><a href="https://github.com/opensvn" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="http://gitop.cc/posts/">Posts</a></li>
			<li><a href="http://gitop.cc/about/">About</a></li>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Dec 14, 2015</span></div>
				<h1>第16章 模板和泛型编程</h1>
			</header>
			<div class="content">
				

<p>面向对象编程和泛型编程都是处理程序编写时类型未知的情况。两者的区别是面向对象编程直到运行时类型才能知道，而泛型编程类型在编译期间知道。</p>

<p>容器，迭代器和算法都是泛型编程的例子。当编写一个泛型程序，我们用一种独立于任何类型的方式编写代码。当使用一个泛型程序，我们提供程序的实例将操作的类型或值。</p>

<p>模板是C++中泛型编程的基础。模板是一个创建类或函数的公式或蓝图。当我们使用一个泛型类型，我们提供将蓝图转换为指定类或函数所需的信息。这个转换发生在编译期间。</p>

<h1 id="16-1-定义一个模板">16.1 定义一个模板<a href="#16-1-定义一个模板" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>

<p>想象我们要写一个函数比较两个值的大小。实际中，我们要定义多个这样的函数，每一个比较指定类型的值。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// returns 0 if the values are equal, -1 if v1 is smaller, 1 if v2 is smaller
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v1</span> <span class="o">&lt;</span> <span class="n">v2</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v2</span> <span class="o">&lt;</span> <span class="n">v1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v1</span> <span class="o">&lt;</span> <span class="n">v2</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v2</span> <span class="o">&lt;</span> <span class="n">v1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>这样的函数几乎相同：唯一不同是参数的类型不同，每一个函数体都相同。</p>

<h2 id="16-1-1-函数模板">16.1.1 函数模板<a href="#16-1-1-函数模板" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>我们定义一个函数模板而不是为每一种类型定义一个新函数。一个函数模板是一个公式，从这个公式我们能够生成指定类型的函数。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v1</span> <span class="o">&lt;</span> <span class="n">v2</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v2</span> <span class="o">&lt;</span> <span class="n">v1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>模板定义开始于关键字<strong>template</strong>后面跟着模板参数列表。模板参数列表由&lt;&gt;括起来，逗号分隔的一个或多个模板参数组成。</p>

<blockquote>
<p><strong>注释</strong>
在模板定义中，模板参数列表不能为空。</p>
</blockquote>

<p>模板参数列表的行为非常像函数的参数列表。模板参数表示用在类或函数定义中的类型或值。当我们使用一个模板，我们指定一个（隐式或显式）模板实参绑定到模板参数。</p>

<h3 id="实例化函数模板">实例化函数模板<a href="#实例化函数模板" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>当我们调用一个函数模板，编译器使用函数调用的实参为我们推导模板实参。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">compare</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>       <span class="c1">// T is int
</span></code></pre></div>

<p>编译器使用推导的模板参数来为我们实例化指定版本的函数。当编译器实例化一个模板，它使用实际的模板实参创建一个新的模板实例代替相应的模板参数。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// instantiates int compare(const int&amp;, const int&amp;)
</span><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">compare</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>       <span class="c1">// T is int
</span><span class="c1">// instantiates int compare(const vector&lt;int&gt;&amp;, const vector&lt;int&gt;&amp;)
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec1</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="n">vec2</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">compare</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// T is vector&lt;int&gt;
</span></code></pre></div>

<h3 id="模板类型参数">模板类型参数<a href="#模板类型参数" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>一般而言，我们可以和使用内置类型或类类型一样的方式使用类型参数作为类型说明符。特别地，类型参数可以用来命名一个返回类型，函数参数类型，变量声明或函数内类型转换。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// ok: same type used for the return type and parameter
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">foo</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="c1">// tmp will have the type to which p points
</span><span class="c1"></span>    <span class="c1">// ...
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>每一个类型参数之前必须有<strong>class</strong>或<strong>typename</strong>关键字。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// error: must precede U with either typename or class
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">calc</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">U</span><span class="o">&amp;</span><span class="p">);</span>
</code></pre></div>

<p>使用关键字<strong>typename</strong>指定模板类型参数比<strong>class</strong>似乎更直观。毕竟我们可以使用内置（非类类型）类型作为模板的类型实参。而且<strong>typename</strong>更加清晰地指示了跟在它后面的名字是一个类型名。但是，<strong>typename</strong>是在模板广泛使用之后才被加入C++的。</p>

<h3 id="非类型模板参数">非类型模板参数<a href="#非类型模板参数" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>除了定义类型参数，我们还能定义非类型的模板参数。一个非类型参数代表一个值而不是类型。非类型参数由一个指定的类型名指定而不是<strong>class</strong>或<strong>typename</strong>关键字。</p>

<p>当模板实例化时，非类型参数被用户提供的或编译器推导的一个值替换。这些值必须是常量表达式，以允许编译器在编译期间实例化模板。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="n">N</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">M</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">p1</span><span class="p">)[</span><span class="n">N</span><span class="p">],</span> <span class="k">const</span> <span class="kt">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">p2</span><span class="p">)[</span><span class="n">M</span><span class="p">])</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">compare</span><span class="p">(</span><span class="s">&#34;hi&#34;</span><span class="p">,</span> <span class="s">&#34;mom&#34;</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">p1</span><span class="p">)[</span><span class="mi">3</span><span class="p">],</span> <span class="k">const</span> <span class="kt">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">p2</span><span class="p">)[</span><span class="mi">4</span><span class="p">])</span>
</code></pre></div>

<p>一个非类型参数可能是整型，对象或函数的指针或（左值）引用。绑定到非类型的整型参数的实参必须是常量表达式。绑定到指针或引用的非类型参数必须拥有静态生命周期。不能使用普通（非静态）局部对象或动态分配的对象作为模板实参传给指针或引用的非类型模板参数。指针参数也能用<strong>nullptr</strong>或0值常量表达式初始化。</p>

<blockquote>
<p><strong>注释</strong>
用于非类型模板参数的模板实参必须是常量表达式。</p>
</blockquote>

<h3 id="inline和constexpr函数模板">inline和constexpr函数模板<a href="#inline和constexpr函数模板" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>和非模板函数一样，函数模板可以被声明为<strong>inline</strong>或<strong>constexpr</strong>。<strong>inline</strong>或<strong>constexpr</strong>限定符跟在模板参数列表之后，函数返回类型之前。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// ok: inline specifier follows the template parameter list
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kr">inline</span> <span class="n">T</span> <span class="n">min</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
<span class="c1">// error: incorrect placement of the inline specifier
</span><span class="c1"></span><span class="kr">inline</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">min</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
</code></pre></div>

<h3 id="编写类型独立的代码">编写类型独立的代码<a href="#编写类型独立的代码" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>尽管简单，compare函数展示了编写泛型代码的两个重要原则：
* 模板中的函数参数是const引用
* 函数体中的比较只使用&lt;</p>

<p>只使用&lt;运算符，我们降低了对使用compare函数的类型的要求。这些类型只需要支持&lt;，没有必要支持&gt;。实际上，如果我们真正关心类型独立和可移植性，我们可能应该使用<strong>less</strong>定义函数。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// version of compare that will be correct even if used on pointers; see § 14.8.2 (p.
</span><span class="c1"></span><span class="mi">575</span><span class="p">)</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">less</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">))</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">less</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v1</span><span class="p">))</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<blockquote>
<p><strong>最佳实践</strong>
模板程序应该尽量减少作用在参数类型的要求的数量。</p>
</blockquote>

<h3 id="模板编译">模板编译<a href="#模板编译" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>当编译器看到模板的定义，并没有生成代码。只有当实例化一个指定的模板实例的时候生成代码。只有使用模板时生成代码的事实影响我们如何组织源代码和如何检测错误。</p>

<p>通常当我们调用一个函数，编译器只需要看到函数的声明。类似地，当我们使用类对象，类定义必须可用，但是成员函数的定义不需要提供。因此，我们把类定义和函数声明放在头文件而普通函数和成员函数放在源文件。</p>

<p>模板不一样：为了生成一个模板实例，编译器需要定义函数模板或类模板成员函数的代码。因此不像非模板代码，模板头文件既包含了定义也包含了声明。</p>

<blockquote>
<p><strong>注释</strong>
函数模板和类模板成员函数的定义通常放进头文件。</p>

<p><strong>关键概念：模板和头文件</strong>
模板包含两种名字：
* 那些不依赖模板参数的名字
* 那些依赖模板参数的名字</p>

<p>由模板的提供者保证当模板使用时所有不依赖模板参数的名字可见。而且，模板的提供者必须保证当模板实例化的时候模板的定义，包括类模板成员的定义可见。由模板的用户保证用来实例化模板所有的函数，类型和类型相关的操作符可见。
模板的作者应该提供一个头文件，包含模板定义，连同所有类模板或成员定义中使用的名字的声明。模板用户必须包含模板头文件和任意用来实例化模板的类型。</p>
</blockquote>

<h3 id="实例化期间最常报的编译错误">实例化期间最常报的编译错误<a href="#实例化期间最常报的编译错误" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>第一个阶段是编译模板自己的时候。编译器在这个阶段通常不能找到很多错误。编译器能查找出语法错误，比如忘记标点或变量拼写错误。</p>

<p>第二个阶段是编译器看到模板的使用的时候。这个阶段也没有很多需要检查。对于一个函数模板调用，编译器只是检查参数的个数是否合适。也可以检查两个类型应该一样的参数是否真的相同。对于类模板，编译器能检查正确的模板参数个数。</p>

<p>第三个阶段是实例化的时候。只有这个时候类型相关的错误才能被发现。取决于编译器如何处理实例化，这些错误可能会在链接时报告。</p>

<blockquote>
<p><strong>警告</strong>
由调用者保证传递给模板的参数支持模板使用到的任意操作，且这些操作在模板使用的上下文环境表现正确。</p>
</blockquote>

<h2 id="16-1-2-类模板">16.1.2 类模板<a href="#16-1-2-类模板" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>类模板是产生类的蓝图。和函数模板不同，编译器不能为类模板推导模板参数。因此为了使用类模板，我们必须在模板名字后面的尖括号里面提供额外的信息。这些信息就是用来代替模板参数的模板实参列表。</p>

<h3 id="定义一个类模板">定义一个类模板<a href="#定义一个类模板" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>和函数模板一样，类模板以<strong>template</strong>关键字开头，后跟一个模板参数列表。在类模板（和它的成员）的定义中，我们使用模板参数作为当模板使用时提供的类型或值的替身。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span><span class="err"> </span><span class="nc">Blob</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">typedef</span> <span class="n">T</span> <span class="n">value_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">size_type</span> <span class="n">size_type</span><span class="p">;</span>
    <span class="c1">// constructors
</span><span class="c1"></span>    <span class="n">Blob</span><span class="p">();</span>
    <span class="n">Blob</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span>
    <span class="c1">// number of elements in the Blob
</span><span class="c1"></span>    <span class="n">size_type</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">();</span> <span class="p">}</span>
    <span class="c1">// add and remove elements
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">t</span><span class="p">);}</span>
    <span class="c1">// move version; see § 13.6.3 (p. 548)
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t</span><span class="p">));</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">pop_back</span><span class="p">();</span>
    <span class="c1">// element access
</span><span class="c1"></span>    <span class="n">T</span><span class="o">&amp;</span> <span class="n">back</span><span class="p">();</span>
    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">size_type</span> <span class="n">i</span><span class="p">);</span> <span class="c1">// defined in § 14.5 (p. 566)
</span><span class="c1"></span><span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">data</span><span class="p">;</span>
    <span class="c1">// throws msg if data[i] isn&#39;t valid
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">check</span><span class="p">(</span><span class="n">size_type</span> <span class="n">i</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="实例化一个类模板">实例化一个类模板<a href="#实例化一个类模板" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>当我们使用一个类模板时，必须提供额外的信息。这些额外的信息是显式模板实参列表。编译器使用这些模板实参来实例化一个指定类。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Blob</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ia</span><span class="p">;</span>                <span class="c1">// empty Blob&lt;int&gt;
</span><span class="c1"></span><span class="n">Blob</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ia2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span> <span class="c1">// Blob&lt;int&gt; with five elements
</span><span class="c1"></span>
<span class="k">template</span> <span class="o">&lt;&gt;</span> <span class="k">class</span><span class="err"> </span><span class="nc">Blob</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">size_type</span> <span class="n">size_type</span><span class="p">;</span>
    <span class="n">Blob</span><span class="p">();</span>
    <span class="n">Blob</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="kt">int</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">size_type</span> <span class="n">i</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">data</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">check</span><span class="p">(</span><span class="n">size_type</span> <span class="n">i</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>当编译器从Blob模板实例化一个类时，它重写了Blob模板，用int替换掉每一个模板参数T。编译器为每一个我们指定的类型生成一个不同的类。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// these definitions instantiate two distinct Blob types
</span><span class="c1"></span><span class="n">Blob</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">names</span><span class="p">;</span> <span class="c1">// Blob that holds strings
</span><span class="c1"></span><span class="n">Blob</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">prices</span><span class="p">;</span><span class="c1">// different element type
</span></code></pre></div>

<blockquote>
<p><strong>注释</strong>
每一个类模板的实例化构成了一个独立的类。类型Blob<string>和任何其它的Blob类型没有关系，也没有任何特殊权限访问其它Blob类型的成员。</p>
</blockquote>

<h3 id="模板作用域中模板类型的引用">模板作用域中模板类型的引用<a href="#模板作用域中模板类型的引用" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>类模板用来实例化一个类型，且被实例化的类型总是包含模板实参。类模板中的代码通常不使用实际类型（或值）的名字作为模板实参。相反，我们经常使用模板自己的参数作为模板实参。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">data</span><span class="p">;</span>
<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span>
</code></pre></div>

<h3 id="类模板成员函数">类模板成员函数<a href="#类模板成员函数" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>和任意其它类一样，我们能够在类里面或外面定义类模板的成员函数。定义在类里面的成员函数默认为<strong>inline</strong>。类模板成员函数本身是个普通函数。但是类模板每一个实例都拥有自己版本的成员。因此类模板的成员函数拥有和类模板相同的模板参数。所以定义在类模板外面的成员函数以关键字<strong>template</strong>开头，后接类模板参数列表。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">ret</span><span class="o">-</span><span class="n">type</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">member</span><span class="o">-</span><span class="n">name</span><span class="p">(</span><span class="n">parm</span><span class="o">-</span><span class="n">list</span><span class="p">)</span>
</code></pre></div>

<h3 id="check和元素访问成员">check和元素访问成员<a href="#check和元素访问成员" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">check</span><span class="p">(</span><span class="n">size_type</span> <span class="n">i</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">())</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="o">&amp;</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">back</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">check</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&#34;back on empty Blob&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="o">&amp;</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">operator</span><span class="p">[](</span><span class="n">size_type</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// if i is too big, check will throw, preventing access to a nonexistent element
</span><span class="c1"></span>    <span class="n">check</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s">&#34;subscript out of range&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> 
<span class="kt">void</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">pop_back</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">check</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&#34;pop_back on empty Blob&#34;</span><span class="p">);</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">pop_back</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="blob构造函数">Blob构造函数<a href="#blob构造函数" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>和其它定义在类模板外面的成员函数一样，构造函数以声明模板参数开始。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Blob</span><span class="p">()</span><span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">())</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Blob</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">)</span><span class="o">:</span>
              <span class="n">data</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">il</span><span class="p">))</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div>

<h3 id="类模板成员函数实例化">类模板成员函数实例化<a href="#类模板成员函数实例化" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>默认地，类模板的成员函数只有在程序使用这个函数时实例化。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// instantiates Blob&lt;int&gt; and the initializer_list&lt;int&gt; constructor
</span><span class="c1"></span><span class="n">Blob</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">squares</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span>
<span class="c1">// instantiates Blob&lt;int&gt;::size() const
</span><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">squares</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">squares</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">;</span> <span class="c1">// instantiates Blob&lt;int&gt;::operator[](size_t)
</span></code></pre></div>

<p>成员只有在使用时实例化这个事实使我们可以用一个可能不满足某些模板操作要求的类型实例化一个类。</p>

<blockquote>
<p><strong>注释</strong>
默认地，一个实例化的类模板的成员只有当成员使用时才实例化。</p>
</blockquote>

<h3 id="类代码里面简化模板类名的使用">类代码里面简化模板类名的使用<a href="#类代码里面简化模板类名的使用" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>使用一个类模板类型必须提供一个模板实参有一个例外，在类模板作用域里面，我们可以不带模板实参使用模板名字。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// BlobPtr throws an exception on attempts to access a nonexistent element
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span><span class="err"> </span><span class="nc">BlobPtr</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">BlobPtr</span><span class="p">()</span><span class="o">:</span> <span class="n">curr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="n">BlobPtr</span><span class="p">(</span><span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span>
            <span class="n">wptr</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">data</span><span class="p">),</span> <span class="n">curr</span><span class="p">(</span><span class="n">sz</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span> <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">check</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="s">&#34;dereference past end&#34;</span><span class="p">);</span>
      <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="n">curr</span><span class="p">];</span>  <span class="c1">// (*p) is the vector to which this object points
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="c1">// increment and decrement
</span><span class="c1"></span>    <span class="n">BlobPtr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">();</span>        <span class="c1">// prefix operators
</span><span class="c1"></span>    <span class="n">BlobPtr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">--</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="c1">// check returns a shared_ptr to the vector if the check succeeds
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
        <span class="n">check</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">// store a weak_ptr, which means the underlying vector might be destroyed
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">wptr</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">curr</span><span class="p">;</span>      <span class="c1">// current position within the array
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div>

<h3 id="在类模板外面使用类模板名字">在类模板外面使用类模板名字<a href="#在类模板外面使用类模板名字" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>当我们在类模板外面定义成员时，必须记住我们不在类的作用域直到类名被看见。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// postfix: increment/decrement the object but return the unchanged value
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">BlobPtr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">BlobPtr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// no check needed here; the call to prefix increment will do the check
</span><span class="c1"></span>    <span class="n">BlobPtr</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>  <span class="c1">// save the current value
</span><span class="c1"></span>    <span class="o">++*</span><span class="k">this</span><span class="p">;</span>    <span class="c1">// advance one element; prefix ++ checks the increment
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>  <span class="c1">// return the saved state
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<p>当我们没有提供模板实参，编译器假设我们使用成员实例化一样的类型。因此，ret的定义就好像：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">BlobPtr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</code></pre></div>

<blockquote>
<p><strong>注释</strong>
在类模板作用域里面，我们可以使用模板，而不指定模板实参。</p>
</blockquote>

<h3 id="类模板和友元">类模板和友元<a href="#类模板和友元" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>当一个类包含友元声明时，类和友元各自可以是模板或非模板。一个有非模板的友元的类模板授予其友元访问模板所有实例。当友元本身也是模板时，授予友元关系的类控制友元模板所有实例或指定实例友元关系。</p>

<h3 id="一对一友元关系">一对一友元关系<a href="#一对一友元关系" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>从一个类模板到另一个模板（类模板或函数模板）建立相应实例之间的友元关系是最常见友元关系形式。为了引用一个指定的模板实例（类模板或函数模板），我们必须先声明模板。一个模板声明包含模板参数列表。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// forward declarations needed for friend declarations in Blob
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span><span class="err"> </span><span class="nc">BlobPtr</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span><span class="err"> </span><span class="nc">Blob</span><span class="p">;</span> <span class="c1">// needed for parameters in operator==
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span><span class="err"> </span><span class="nc">Blob</span> <span class="p">{</span>
    <span class="c1">// each instantiation of Blob grants access to the version of
</span><span class="c1"></span>    <span class="c1">// BlobPtr and the equality operator instantiated with the same type
</span><span class="c1"></span>    <span class="k">friend</span> <span class="k">class</span><span class="err"> </span><span class="nc">BlobPtr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==&lt;</span><span class="n">T</span><span class="o">&gt;</span>
           <span class="p">(</span><span class="k">const</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">);</span>
    <span class="c1">// other members as in § 12.1.1 (p. 456)
</span><span class="c1"></span><span class="p">};</span>

<span class="n">Blob</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">ca</span><span class="p">;</span> <span class="c1">// BlobPtr&lt;char&gt; and operator==&lt;char&gt; are friends
</span><span class="c1"></span><span class="n">Blob</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ia</span><span class="p">;</span>  <span class="c1">// BlobPtr&lt;int&gt; and operator==&lt;int&gt; are friends
</span></code></pre></div>

<h3 id="通用和指定模板友元">通用和指定模板友元<a href="#通用和指定模板友元" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>一个类也可以指定另一个模板的每一个实例为友元，或限制指定实例为友元：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// forward declaration necessary to befriend a specific instantiation of a template
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span><span class="err"> </span><span class="nc">Pal</span><span class="p">;</span>
<span class="k">class</span><span class="err"> </span><span class="nc">C</span> <span class="p">{</span>  <span class="c1">//  C is an ordinary, nontemplate class
</span><span class="c1"></span>    <span class="k">friend</span> <span class="k">class</span><span class="err"> </span><span class="nc">Pal</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">// Pal instantiated with class C is a friend to C
</span><span class="c1"></span>    <span class="c1">// all instances of Pal2 are friends to C;
</span><span class="c1"></span>    <span class="c1">// no forward declaration required when we befriend all instantiations
</span><span class="c1"></span>    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">friend</span> <span class="k">class</span><span class="err"> </span><span class="nc">Pal2</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span><span class="err"> </span><span class="nc">C2</span> <span class="p">{</span> <span class="c1">// C2 is itself a class template
</span><span class="c1"></span>    <span class="c1">// each instantiation of C2 has the same instance of Pal as a friend
</span><span class="c1"></span>    <span class="k">friend</span> <span class="k">class</span><span class="err"> </span><span class="nc">Pal</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">// a template declaration for Pal must be in scope
</span><span class="c1"></span>    <span class="c1">// all instances of Pal2 are friends of each instance of C2, prior declaration needed
</span><span class="c1"></span>    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">X</span><span class="o">&gt;</span> <span class="k">friend</span> <span class="k">class</span><span class="err"> </span><span class="nc">Pal2</span><span class="p">;</span>
    <span class="c1">// Pal3 is a nontemplate class that is a friend of every instance of C2
</span><span class="c1"></span>    <span class="k">friend</span> <span class="k">class</span><span class="err"> </span><span class="nc">Pal3</span><span class="p">;</span>    <span class="c1">// prior declaration for Pal3 not needed
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div>

<p>为了允许所有的实例都是友元，友元声明必须使用跟类不一样的模板参数。</p>

<h3 id="模板类型参数作为友元">模板类型参数作为友元<a href="#模板类型参数作为友元" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>在新标准下，我们可以将模板类型参数作为友元：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="o">&gt;</span> <span class="k">class</span><span class="err"> </span><span class="nc">Bar</span> <span class="p">{</span>
<span class="k">friend</span> <span class="n">Type</span><span class="p">;</span> <span class="c1">// grants access to the type used to instantiate Bar
</span><span class="c1"></span>    <span class="c1">//  ...
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div>

<p>值得注意的是尽管友元通常必须是一个类或函数，用内置类型实例化类Bar也可以，因此友元为内置类型在这种情况也允许。</p>

<h3 id="模板类型别名">模板类型别名<a href="#模板类型别名" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>类模板的一个实例定义了一个类类型，和其它类类型一样，我们可以使用<strong>typedef</strong>引用它：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">StrBlob</span><span class="p">;</span>
</code></pre></div>

<p>因为模板不是一个类型，我们不能使用<strong>typedef</strong>引用一个模板，即没有办法用<strong>typedef</strong>引用Blob<T>。但是新标准允许我们为类模板定义一个类型别名：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">using</span> <span class="n">twin</span> <span class="o">=</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">twin</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">authors</span><span class="p">;</span> <span class="c1">// authors is a pair&lt;string, string&gt;
</span></code></pre></div>

<p>模板类型别名是一个类家庭的同义词：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">twin</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">win_loss</span><span class="p">;</span>  <span class="c1">// win_loss is a pair&lt;int, int&gt;
</span><span class="c1"></span><span class="n">twin</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">area</span><span class="p">;</span>   <span class="c1">// area is a pair&lt;double, double&gt;
</span></code></pre></div>

<p>当我们定义一个模板类型别名，我们可以固定一个或多个模板参数：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">using</span> <span class="n">partNo</span> <span class="o">=</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">unsigned</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">partNo</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">books</span><span class="p">;</span>  <span class="c1">// books is a pair&lt;string, unsigned&gt;
</span><span class="c1"></span><span class="n">partNo</span><span class="o">&lt;</span><span class="n">Vehicle</span><span class="o">&gt;</span> <span class="n">cars</span><span class="p">;</span>  <span class="c1">// cars is a pair&lt;Vehicle, unsigned&gt;
</span><span class="c1"></span><span class="n">partNo</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">kids</span><span class="p">;</span>  <span class="c1">// kids is a pair&lt;Student, unsigned&gt;
</span></code></pre></div>

<h3 id="类模板的静态成员">类模板的静态成员<a href="#类模板的静态成员" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>和其它类一样，类模板可以声明静态成员：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span><span class="err"> </span><span class="nc">Foo</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">count</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ctr</span><span class="p">;</span> <span class="p">}</span>
   <span class="c1">// other interface members
</span><span class="c1"></span><span class="k">private</span><span class="o">:</span>
   <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">ctr</span><span class="p">;</span>
   <span class="c1">// other implementation members
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div>

<p>每一个Foo的实例都有自己静态成员。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// instantiates static members Foo&lt;string&gt;::ctr and Foo&lt;string&gt;::count
</span><span class="c1"></span><span class="n">Foo</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">fs</span><span class="p">;</span>
<span class="c1">// all three objects share the same Foo&lt;int&gt;::ctr and Foo&lt;int&gt;::count members
</span><span class="c1"></span><span class="n">Foo</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">fi</span><span class="p">,</span> <span class="n">fi2</span><span class="p">,</span> <span class="n">fi3</span><span class="p">;</span>
</code></pre></div>

<p>和其它静态数据成员一样，类模板的每一个静态数据成员必须只有一个定义。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">size_t</span> <span class="n">Foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">ctr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// define and initialize ctr
</span></code></pre></div>

<p>必须引用指定的实例来访问静态成员。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Foo</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">fi</span><span class="p">;</span>                 <span class="c1">// instantiates Foo&lt;int&gt; class
</span><span class="c1"></span>                             <span class="c1">// and the static data member ctr
</span><span class="c1"></span><span class="k">auto</span> <span class="n">ct</span> <span class="o">=</span> <span class="n">Foo</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">count</span><span class="p">();</span> <span class="c1">// instantiates Foo&lt;int&gt;::count
</span><span class="c1"></span><span class="n">ct</span> <span class="o">=</span> <span class="n">fi</span><span class="p">.</span><span class="n">count</span><span class="p">();</span>             <span class="c1">// uses Foo&lt;int&gt;::count
</span><span class="c1"></span><span class="n">ct</span> <span class="o">=</span> <span class="n">Foo</span><span class="o">::</span><span class="n">count</span><span class="p">();</span>           <span class="c1">// error: which template instantiation?
</span></code></pre></div>

<p>和其它成员函数一样，静态成员函数只有在程序中使用时才实例化。</p>

<h2 id="16-1-3-模板参数">16.1.3 模板参数<a href="#16-1-3-模板参数" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>和函数参数的名字一样，模板参数的名字没有实质意义。我们通常命名类型参数为T，也可以使用人用名字：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Foo</span><span class="o">&gt;</span> <span class="n">Foo</span> <span class="n">calc</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Foo</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// tmp has the same type as the parameters and return type
</span><span class="c1"></span>    <span class="c1">// ...
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>  <span class="c1">// return type and parameters have the same type
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<h3 id="模板参数和作用域">模板参数和作用域<a href="#模板参数和作用域" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>模板参数遵循正常的作用域规则。模板参数的名字在声明之后直到模板声明或定义结束之前都能使用。和其它名字一样，模板参数名隐藏任何外围声明的名字。但是一个被用来作为模板参数的名字在模板内不能被重复使用。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="kt">double</span> <span class="n">A</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">B</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">A</span> <span class="n">a</span><span class="p">,</span> <span class="n">B</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">A</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// tmp has same type as the template parameter A, not double
</span><span class="c1"></span>    <span class="kt">double</span> <span class="n">B</span><span class="p">;</span>  <span class="c1">// error: redeclares template parameter B
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<p>因为模板参数名不能重复使用，模板参数列表中的每一个模板参数名只能出现一次：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// error: illegal reuse of template parameter name V
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">V</span><span class="p">,</span> <span class="k">typename</span> <span class="n">V</span><span class="o">&gt;</span> <span class="c1">// ...
</span></code></pre></div>

<h3 id="模板声明">模板声明<a href="#模板声明" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>模板声明必须包含模板参数：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// declares but does not define compare and Blob
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span><span class="err"> </span><span class="nc">Blob</span><span class="p">;</span>
</code></pre></div>

<p>和函数参数一样，模板参数名不需要和定义中的模板参数名一样：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// all three uses of calc refer to the same function template
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">calc</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// declaration
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span> <span class="n">U</span> <span class="n">calc</span><span class="p">(</span><span class="k">const</span> <span class="n">U</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">U</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// declaration
</span><span class="c1">// definition of the template
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Type</span> <span class="n">calc</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* . . . */</span> <span class="p">}</span>
</code></pre></div>

<p>当然，模板的每一个声明和定义参数的数量和种类（类型或非类型）必须一样。</p>

<blockquote>
<p><strong>最佳实践</strong>
一个文件需要的所有模板的声明通常应该一起出现在文件开头，在任何代码使用这些名字之前。</p>
</blockquote>

<h3 id="使用为类型的类成员">使用为类型的类成员<a href="#使用为类型的类成员" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>我们可以使用作用域操作符（::）访问<strong>static</strong>成员和类型成员。假设T是一个模板类型参数，当编译器看到T::mem时，在实例化前它不知道mem是一个类型还是静态数据成员。但是为了处理模板，编译器必须知道一个名字是否代表类型。比如下面这个例子：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">T</span><span class="o">::</span><span class="n">size_type</span> <span class="o">*</span> <span class="n">p</span><span class="p">;</span>
</code></pre></div>

<p>编译器需要知道这是定义一个变量p还是静态数据成员与p相乘。语言默认假设通过作用域操作符访问的名字不是一个类型。因此如果我们想要使用模板类型参数的类型成员，我们必须显式告诉编译器这个名字是一个类型。我们使用关键字<strong>typename</strong>来做这件事：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span> <span class="n">top</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<blockquote>
<p><strong>注释</strong>
当我们通知编译器一个名字代表类型时，必须使用关键字<strong>typename</strong>，而不是<strong>class</strong>。</p>
</blockquote>

<h3 id="默认模板实参">默认模板实参<a href="#默认模板实参" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>就像我们能够给函数参数提供默认实参，我们也能提供默认模板实参。新标准下，我们能给函数模板和类模板提供默认实参。早先的版本只允许类模板有默认实参。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// compare has a default template argument, less&lt;T&gt;
</span><span class="c1">// and a default function argument, F()
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">F</span> <span class="o">=</span> <span class="n">less</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
<span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">v2</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span> <span class="o">=</span> <span class="n">F</span><span class="p">())</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">))</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v1</span><span class="p">))</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">i</span> <span class="o">=</span> <span class="n">compare</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span> <span class="c1">// uses less; i is -1
</span><span class="c1">// result depends on the isbns in item1 and item2
</span><span class="c1"></span><span class="n">Sales_data</span> <span class="nf">item1</span><span class="p">(</span><span class="n">cin</span><span class="p">),</span> <span class="n">item2</span><span class="p">(</span><span class="n">cin</span><span class="p">);</span>
<span class="kt">bool</span> <span class="n">j</span> <span class="o">=</span> <span class="n">compare</span><span class="p">(</span><span class="n">item1</span><span class="p">,</span> <span class="n">item2</span><span class="p">,</span> <span class="n">compareIsbn</span><span class="p">);</span>
</code></pre></div>

<h3 id="模板默认实参和类模板">模板默认实参和类模板<a href="#模板默认实参和类模板" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>不管什么时候使用类模板，我们必须在模板名后面跟尖括号。尖括号指示类必须从模板实例化。特别地，如果一个类模板为所有模板参数提供了默认实参，且我们使用这些默认值，我们必须在模板名后面放一对空的尖括号：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">T</span> <span class="o">=</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="k">class</span><span class="err"> </span><span class="nc">Numbers</span> <span class="p">{</span>   <span class="c1">// by default T is int
</span><span class="c1"></span><span class="k">public</span><span class="o">:</span>
    <span class="n">Numbers</span><span class="p">(</span><span class="n">T</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="c1">// various operations on numbers
</span><span class="c1"></span><span class="k">private</span><span class="o">:</span>
    <span class="n">T</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">Numbers</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">lots_of_precision</span><span class="p">;</span>
<span class="n">Numbers</span><span class="o">&lt;&gt;</span> <span class="n">average_precision</span><span class="p">;</span> <span class="c1">// empty &lt;&gt; says we want the default type
</span></code></pre></div>

<h2 id="16-1-4-成员模板">16.1.4 成员模板<a href="#16-1-4-成员模板" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>一个类（不管是普通类还是类模板）可能有本身是模板的成员函数。这种成员被称为成员模板。成员模板不能是虚函数。</p>

<h3 id="普通类的成员模板">普通类的成员模板<a href="#普通类的成员模板" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// function-object class that calls delete on a given pointer
</span><span class="c1"></span><span class="k">class</span><span class="err"> </span><span class="nc">DebugDelete</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">DebugDelete</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">s</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="p">)</span><span class="o">:</span> <span class="n">os</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="c1">// as with any function template, the type of T is deduced by the compiler
</span><span class="c1"></span>    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">T</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="k">const</span>
      <span class="p">{</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;deleting unique_ptr&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>和其他模板一样，一个成员模板以它自己的模板参数列表开始。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">double</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">;</span>
<span class="n">DebugDelete</span> <span class="n">d</span><span class="p">;</span>    <span class="c1">// an object that can act like a delete expression
</span><span class="c1"></span><span class="n">d</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// calls DebugDelete::operator()(double*), which deletes p
</span><span class="c1"></span><span class="kt">int</span><span class="o">*</span> <span class="n">ip</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span>
<span class="c1">// calls operator()(int*) on a temporary DebugDelete object
</span><span class="c1"></span><span class="n">DebugDelete</span><span class="p">()(</span><span class="n">ip</span><span class="p">);</span>

<span class="c1">// destroying the the object to which p points
</span><span class="c1">// instantiates DebugDelete::operator()&lt;int&gt;(int *)
</span><span class="c1"></span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">DebugDelete</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">,</span> <span class="n">DebugDelete</span><span class="p">());</span>
<span class="c1">// destroying the the object to which sp points
</span><span class="c1">// instantiates DebugDelete::operator()&lt;string&gt;(string*)
</span><span class="c1"></span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="n">DebugDelete</span><span class="o">&gt;</span> <span class="n">sp</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">,</span> <span class="n">DebugDelete</span><span class="p">());</span>
</code></pre></div>

<p><strong>unique_ptr</strong>的析构函数会调用DebugDelete的调用操作符。因此，当<strong>unique_ptr</strong>析构函数实例化时，DebugDelete的调用操作符也会实例化。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// sample instantiations for member templates of DebugDelete
</span><span class="c1"></span><span class="kt">void</span> <span class="n">DebugDelete</span><span class="o">::</span><span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">p</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">DebugDelete</span><span class="o">::</span><span class="k">operator</span><span class="p">()(</span><span class="n">string</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">p</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div>

<h3 id="类模板的成员模板">类模板的成员模板<a href="#类模板的成员模板" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>我们也可以定义一个类模板的成员模板。这种情况下，类和成员都有它们自己的独立的模板参数。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span><span class="err"> </span><span class="nc">Blob</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">It</span><span class="o">&gt;</span> <span class="n">Blob</span><span class="p">(</span><span class="n">It</span> <span class="n">b</span><span class="p">,</span> <span class="n">It</span> <span class="n">e</span><span class="p">);</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div>

<p>不同于类模板的普通函数成员，成员模板是函数模板。当我们在类模板外面定义一个成员模板，我们必须为类模板和函数模板提供模板参数列表。类模板参数列表在前，后面跟成员模板参数列表：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>     <span class="c1">// type parameter for the class
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">It</span><span class="o">&gt;</span>    <span class="c1">// type parameter for the constructor
</span><span class="c1"></span>    <span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Blob</span><span class="p">(</span><span class="n">It</span> <span class="n">b</span><span class="p">,</span> <span class="n">It</span> <span class="n">e</span><span class="p">)</span><span class="o">:</span>
              <span class="n">data</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="成员模板的实例化">成员模板的实例化<a href="#成员模板的实例化" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>为了实例化一个类模板的成员模板，我们必须为类模板和成员模板的模板参数提供实参。和以前一样，类模板参数的实参由调用成员模板的对象类型决定。同样，编译器通过传递给成员模板的实参推导出成员模板参数的实参。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">ia</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span> <span class="n">vi</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span>
<span class="n">list</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span> <span class="n">w</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;now&#34;</span><span class="p">,</span> <span class="s">&#34;is&#34;</span><span class="p">,</span> <span class="s">&#34;the&#34;</span><span class="p">,</span> <span class="s">&#34;time&#34;</span><span class="p">};</span>
<span class="c1">// instantiates the Blob&lt;int&gt; class
</span><span class="c1">// and the Blob&lt;int&gt; constructor that has two int* parameters
</span><span class="c1"></span><span class="n">Blob</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a1</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">ia</span><span class="p">));</span>
<span class="c1">// instantiates the Blob&lt;int&gt; constructor that has
</span><span class="c1">// two vector&lt;long&gt;::iterator parameters
</span><span class="c1"></span><span class="n">Blob</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a2</span><span class="p">(</span><span class="n">vi</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vi</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="c1">// instantiates the Blob&lt;string&gt; class and the Blob&lt;string&gt;
</span><span class="c1">// constructor that has two (list&lt;const char*&gt;::iterator parameters
</span><span class="c1"></span><span class="n">Blob</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">a3</span><span class="p">(</span><span class="n">w</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">w</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</code></pre></div>

<h2 id="16-1-5-控制实例化">16.1.5 控制实例化<a href="#16-1-5-控制实例化" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>当模板被使用时才生成实例意味着同一个实例可能出现在多个对象文件。当两个或更多单独编译的源文件用相同的模板实参使用同一个模板时，在每一个文件中有一个模板实例。</p>

<p>在大型系统中，在多个文件中实例化同一个模板的开销将变得非常明显。在新标准下，我们可以使用显式实例化避免这种开销。显式实例化具有形式：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">extern</span> <span class="k">template</span> <span class="n">declaration</span><span class="p">;</span> <span class="c1">// instantiation declaration
</span><span class="c1"></span><span class="k">template</span> <span class="n">declaration</span><span class="p">;</span>        <span class="c1">// instantiation definition
</span></code></pre></div>

<p>declaration是一个类或函数声明，其模板参数被模板实参替换。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// instantion declaration and definition
</span><span class="c1"></span><span class="k">extern</span> <span class="k">template</span> <span class="k">class</span><span class="err"> </span><span class="nc">Blob</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">;</span>             <span class="c1">// declaration
</span><span class="c1"></span><span class="k">template</span> <span class="kt">int</span> <span class="nf">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">);</span>   <span class="c1">// definition
</span></code></pre></div>

<p>当编译器看到一个<strong>extern</strong>模板声明，它不会在那个文件生成实例化代码。将一个模板实例声明为<strong>extern</strong>承诺程序的其它地方存在一个<strong>nonextern</strong>的实例。对于一个指定的实例可以有多个<strong>extern</strong>声明但是只能存在一个实例的定义。</p>

<p>因为编译器使用模板时自动实例化，<strong>extern</strong>声明必须出现在任何使用实例的代码之前：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// Application.cc
</span><span class="c1">// these template types must be instantiated elsewhere in the program
</span><span class="c1"></span><span class="k">extern</span> <span class="k">template</span> <span class="k">class</span><span class="err"> </span><span class="nc">Blob</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">template</span> <span class="kt">int</span> <span class="nf">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">);</span>
<span class="n">Blob</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">sa1</span><span class="p">,</span> <span class="n">sa2</span><span class="p">;</span> <span class="c1">// instantiation will appear elsewhere
</span><span class="c1">// Blob&lt;int&gt; and its initializer_list constructor instantiated in this file
</span><span class="c1"></span><span class="n">Blob</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span>
<span class="n">Blob</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a2</span><span class="p">(</span><span class="n">a1</span><span class="p">);</span>  <span class="c1">// copy constructor instantiated in this file
</span><span class="c1"></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">compare</span><span class="p">(</span><span class="n">a1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a2</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// instantiation will appear elsewhere定义
</span></code></pre></div>

<blockquote>
<p><strong>警告</strong>
对于每一个实例声明，在程序的其它地方必须有一个显式实例定义。</p>
</blockquote>

<h3 id="实例定义实例化所有成员">实例定义实例化所有成员<a href="#实例定义实例化所有成员" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>一个类模板的实例定义实例化其所有成员包括内联成员函数。当编译器看到一个实例定义，它不知道哪一个成员函数会被用到，因此编译器实例化所有成员。</p>

<blockquote>
<p><strong>注释</strong>
实例定义只能用在类模板所有成员函数都能使用的类型。</p>
</blockquote>

<h2 id="16-1-6-效率和灵活性">16.1.6 效率和灵活性<a href="#16-1-6-效率和灵活性" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>标准库的智能指针提供了一个关于模板设计者面临的设计选择的很好说明。</p>

<h1 id="16-2-模板实参推导">16.2 模板实参推导<a href="#16-2-模板实参推导" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h1>

<p>在模板实参推导期间，编译器使用实参的类型查找模板参数并生成最符合的函数。</p>

<h2 id="16-2-1-转换和模板类型参数">16.2.1 转换和模板类型参数<a href="#16-2-1-转换和模板类型参数" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>使用模板类型参数的函数参数具有特殊的初始化规则。只有非常有限数量的转换被自动应用到这种参数。编译器生成一个新的实例而不是转换实参。</p>

<p>和以往一样，不管是形参还是实参的上层const都被忽略。在一个函数模板调用中执行的唯一其它转换有：
* const转换：引用（或指针）const对象的函数参数可以传递引用（或指针）非const对象。
* 数组到指针或函数到指针的转换：如果函数参数不是引用类型，则普通指针转换将被应用到参数为数组或函数类型上。数组参数被转换为指向第一个元素的指针。类似地，函数参数被转换为指向函数类型的指针。</p>

<p>其它转换比如算术转换，派生类到基类转换和用户自定义的转换都不会执行。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">fobj</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span> <span class="c1">// arguments are copied
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">fref</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// references
</span><span class="c1"></span><span class="n">string</span> <span class="nf">s1</span><span class="p">(</span><span class="s">&#34;a value&#34;</span><span class="p">);</span>
<span class="k">const</span> <span class="n">string</span> <span class="nf">s2</span><span class="p">(</span><span class="s">&#34;another value&#34;</span><span class="p">);</span>
<span class="n">fobj</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">);</span> <span class="c1">// calls fobj(string, string); const is ignored
</span><span class="c1"></span><span class="n">fref</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">);</span> <span class="c1">// calls fref(const string&amp;, const string&amp;)
</span><span class="c1"></span>              <span class="c1">// uses premissible conversion to const on s1
</span><span class="c1"></span><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">42</span><span class="p">];</span>
<span class="n">fobj</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// calls f(int*, int*)
</span><span class="c1"></span><span class="n">fref</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// error: array types don&#39;t match
</span></code></pre></div>

<blockquote>
<p><strong>注释</strong>
const转换和数组或函数到指针的转换是模板类型唯一的实参到形参自动转换。</p>
</blockquote>

<h3 id="使用相同模板参数类型的函数参数">使用相同模板参数类型的函数参数<a href="#使用相同模板参数类型的函数参数" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>一个模板类型参数可以被多个函数参数使用。因为转换非常有限，这种参数的实参必须具有一样的类型。如果推导的参数类型不匹配，那么调用出错。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">long</span> <span class="n">lng</span><span class="p">;</span>
<span class="n">compare</span><span class="p">(</span><span class="n">lng</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span> <span class="c1">// error: cannot instantiate compare(long, int)
</span><span class="c1"></span>
<span class="c1">// argument types can differ but must be compatible
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">B</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">flexibleCompare</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v1</span> <span class="o">&lt;</span> <span class="n">v2</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v2</span> <span class="o">&lt;</span> <span class="n">v1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">long</span> <span class="n">lng</span><span class="p">;</span>
<span class="n">flexibleCompare</span><span class="p">(</span><span class="n">lng</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span> <span class="c1">// ok: calls flexibleCompare(long, int)
</span></code></pre></div>

<h3 id="应用到普通实参的正常转换">应用到普通实参的正常转换<a href="#应用到普通实参的正常转换" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>函数模板可以有普通类型的参数，就是与模板类型参数无关的参数。这些参数不需要特殊处理，它们的转换规则和以前一样。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">ostream</span> <span class="o">&amp;</span><span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span>
<span class="o">&amp;</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">print</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span> <span class="c1">// instantiates print(ostream&amp;, int)
</span><span class="c1"></span><span class="n">ofstream</span> <span class="nf">f</span><span class="p">(</span><span class="s">&#34;output&#34;</span><span class="p">);</span>
<span class="n">print</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>    <span class="c1">// uses print(ostream&amp;, int); converts f to ostream&amp;
</span></code></pre></div>

<h2 id="16-2-2-函数模板显式参数">16.2.2 函数模板显式参数<a href="#16-2-2-函数模板显式参数" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>在某些情况下，编译器不可能推导出模板参数的类型。另一些情况，我们想要允许用户控制模板实例化。当一个函数返回类型不同于参数列表中的类型时，这两种情况经常出现。</p>

<h3 id="指定一个显式模板参数">指定一个显式模板参数<a href="#指定一个显式模板参数" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// T1 cannot be deduced: it doesn&#39;t appear in the function parameter list
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T3</span><span class="o">&gt;</span>
<span class="n">T1</span> <span class="n">sum</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">T3</span><span class="p">);</span>
</code></pre></div>

<p>这个例子中，没有用来推导T1类型的实参，调用者必须提供一个显式模板实参。我们可以像定义类模板实例那样，给一个函数调用提供显式模板实参。显式模板实参在尖括号中指定，在函数名之后，参数列表之前：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// T1 is explicitly specified; T2 and T3 are inferred from the argument types
</span><span class="c1"></span><span class="k">auto</span> <span class="n">val3</span> <span class="o">=</span> <span class="n">sum</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">lng</span><span class="p">);</span> <span class="c1">// long long sum(int, long)
</span></code></pre></div>

<p>显式模板实参从左到右匹配相应的模板参数，</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// poor design: users must explicitly specify all three template parameters
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T3</span><span class="o">&gt;</span>
<span class="n">T3</span> <span class="n">alternative_sum</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">T1</span><span class="p">);</span>

<span class="c1">// error: can&#39;t infer initial template parameters
</span><span class="c1"></span><span class="k">auto</span> <span class="n">val3</span> <span class="o">=</span> <span class="n">alternative_sum</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">lng</span><span class="p">);</span>
<span class="c1">// ok: all three parameters are explicitly specified
</span><span class="c1"></span><span class="k">auto</span> <span class="n">val2</span> <span class="o">=</span> <span class="n">alternative_sum</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">lng</span><span class="p">);</span>
</code></pre></div>

<h3 id="显式指定参数应用普通转换">显式指定参数应用普通转换<a href="#显式指定参数应用普通转换" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>和普通类型参数允许普通转换的原因一样，显式指定参数也可以应用其实参的普通转换：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">long</span> <span class="n">lng</span><span class="p">;</span>
<span class="n">compare</span><span class="p">(</span><span class="n">lng</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>       <span class="c1">// error: template parameters don&#39;t match
</span><span class="c1"></span><span class="n">compare</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lng</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span> <span class="c1">// ok: instantiates compare(long, long)
</span><span class="c1"></span><span class="n">compare</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lng</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>  <span class="c1">// ok: instantiates compare(int, int)
</span></code></pre></div>

<h2 id="16-2-3-尾返回类型和类型转换">16.2.3 尾返回类型和类型转换<a href="#16-2-3-尾返回类型和类型转换" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>使用显式模板参数来表示模板函数的返回类型工作得很好。另外一些情况下，需要有一个显式模板参数给用户强加了负担。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">It</span><span class="o">&gt;</span>
<span class="o">???</span> <span class="o">&amp;</span><span class="n">fcn</span><span class="p">(</span><span class="n">It</span> <span class="n">beg</span><span class="p">,</span> <span class="n">It</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// process the range
</span><span class="c1"></span>    <span class="k">return</span> <span class="o">*</span><span class="n">beg</span><span class="p">;</span>  <span class="c1">// return a reference to an element from the range
</span><span class="c1"></span><span class="p">}</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vi</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
<span class="n">Blob</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">ca</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&#34;hi&#34;</span><span class="p">,</span> <span class="s">&#34;bye&#34;</span> <span class="p">};</span>
<span class="k">auto</span> <span class="o">&amp;</span><span class="n">i</span> <span class="o">=</span> <span class="n">fcn</span><span class="p">(</span><span class="n">vi</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vi</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">// fcn should return int&amp;
</span><span class="c1"></span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">s</span> <span class="o">=</span> <span class="n">fcn</span><span class="p">(</span><span class="n">ca</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ca</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">// fcn should return string&amp;
</span><span class="c1"></span>
<span class="c1">// a trailing return lets us declare the return type after the parameter list is seen
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">It</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">fcn</span><span class="p">(</span><span class="n">It</span> <span class="n">beg</span><span class="p">,</span> <span class="n">It</span> <span class="n">end</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">beg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// process the range
</span><span class="c1"></span>    <span class="k">return</span> <span class="o">*</span><span class="n">beg</span><span class="p">;</span>  <span class="c1">// return a reference to an element from the range
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<h3 id="类型转换标准库模板类">类型转换标准库模板类<a href="#类型转换标准库模板类" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>有时候我们不能直接访问到我们需要的类型。比如我们可能想要写一个类似fcn的函数返回一个元素的值而不是引用。编写这样的函数我们面临的问题是我们几乎不了解我们传递的参数类型。为了获取元素类型，我们可以使用库类型转换模板。这些模板定义在<strong>type_traits</strong>头文件。通常头文件<strong>type_traits</strong>中的类被用来所谓的元编程。</p>

<table>
<thead>
<tr>
<th>For Mod&lt;T&gt;, Mod is</th>
<th align="left">If T is</th>
<th align="left">Then Mod&lt;T&gt;::type is</th>
</tr>
</thead>

<tbody>
<tr>
<td>remove_reference</td>
<td align="left">X&amp; or X&amp;&amp;<br>otherwise</td>
<td align="left">X<br>T</td>
</tr>

<tr>
<td>add_const</td>
<td align="left">X&amp;, const X, or function<br>otherwise</td>
<td align="left">T<br>const T</td>
</tr>

<tr>
<td>add_lvalue_reference</td>
<td align="left">X&amp;<br>X&amp;&amp;<br>otherwise</td>
<td align="left">T<br>X&amp;<br>T&amp;</td>
</tr>

<tr>
<td>add_rvalue_reference</td>
<td align="left">X&amp; or X&amp;&amp;<br>otherwise</td>
<td align="left">T<br>T&amp;&amp;</td>
</tr>

<tr>
<td>remove_pointer</td>
<td align="left">X*<br>otherwise</td>
<td align="left">X<br>const T</td>
</tr>

<tr>
<td>add_pointer</td>
<td align="left">X&amp; or X&amp;&amp;<br>otherwise</td>
<td align="left">X*<br>T*</td>
</tr>

<tr>
<td>make_signed</td>
<td align="left">unsigned X<br>otherwise</td>
<td align="left">X<br>T</td>
</tr>

<tr>
<td>make_unsigned</td>
<td align="left">signed type<br>otherwise</td>
<td align="left">unsigned T<br>T</td>
</tr>

<tr>
<td>remove_extent</td>
<td align="left">X[n]<br>otherwise</td>
<td align="left">X<br>T</td>
</tr>

<tr>
<td>remove_all_extents</td>
<td align="left">X[n1][n2]&hellip;<br>otherwise</td>
<td align="left">X<br>T</td>
</tr>
</tbody>
</table>

<p>在这个例子中，我们可以使用<strong>remove_reference</strong>获取元素类型。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">remove_reference</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">beg</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span>

<span class="c1">// must use typename to use a type member of a template parameter; see § 16.1.3 (p.
</span><span class="c1"></span><span class="mi">670</span><span class="p">)</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">It</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">fcn2</span><span class="p">(</span><span class="n">It</span> <span class="n">beg</span><span class="p">,</span> <span class="n">It</span> <span class="n">end</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">beg</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span>
<span class="p">{</span>
    <span class="c1">// process the range
</span><span class="c1"></span>    <span class="k">return</span> <span class="o">*</span><span class="n">beg</span><span class="p">;</span>  <span class="c1">// return a copy of an element from the range
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<p>注意type是一个依赖模板参数的类成员。因此我们必须在返回类型的声明中使用<strong>typename</strong>来告诉编译器type代表一个类型。</p>

<p>每一个上表中描述的类型转换模板和<strong>remove_reference</strong>类似工作。每一个模板都有一个公开的type成员代表一个类型。如果不可能（或没必要）转换一个模板参数，则type成员就是模板参数本身。</p>

<h2 id="16-2-4-函数指针和实参推导">16.2.4 函数指针和实参推导<a href="#16-2-4-函数指针和实参推导" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>当我们从一个函数模板初始化或赋值一个函数指针时，编译器使用函数指针的类型推导模板实参。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
<span class="c1">// pf1 points to the instantiation int compare(const int&amp;, const int&amp;)
</span><span class="c1"></span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pf1</span><span class="p">)(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="n">compare</span><span class="p">;</span>
</code></pre></div>

<p>如果从函数指针类型不能决定模板实参则出错：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// overloaded versions of func; each takes a different function pointer type
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">));</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">));</span>
<span class="n">func</span><span class="p">(</span><span class="n">compare</span><span class="p">);</span> <span class="c1">// error: which instantiation of compare?
</span></code></pre></div>

<p>我们可以使用显式模板实参使得调用无二义性：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// ok: explicitly specify which version of compare to instantiate
</span><span class="c1"></span><span class="n">func</span><span class="p">(</span><span class="n">compare</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">);</span>  <span class="c1">// passing compare(const int&amp;, const int&amp;)
</span></code></pre></div>

<blockquote>
<p><strong>注释</strong>
当一个函数模板实例的地址被使用时，其应用环境必须是只允许唯一类型或值可以确定每一个模板参数。</p>
</blockquote>

<h2 id="16-2-5-模板实参推导和引用">16.2.5 模板实参推导和引用<a href="#16-2-5-模板实参推导和引用" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>为了理解下例函数类型推导，需要记住两点，一是正常的引用绑定规则，二是const是低层次不是高层次的。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
</code></pre></div>

<h3 id="左值引用函数参数类型推导">左值引用函数参数类型推导<a href="#左值引用函数参数类型推导" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>当一个函数参数是普通的左值引用模板参数，我们只能传递左值给它。如果实参是const，则T被推导为一个const类型。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f1</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>  <span class="c1">// argument must be an lvalue
</span><span class="c1">// calls to f1 use the referred-to type of the argument as the template parameter type
</span><span class="c1"></span><span class="n">f1</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>   <span class="c1">//  i is an int; template parameter T is int
</span><span class="c1"></span><span class="n">f1</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>  <span class="c1">//  ci is a const int; template parameter T is const int
</span><span class="c1"></span><span class="n">f1</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>   <span class="c1">//  error: argument to a &amp; parameter must be an lvalue
</span></code></pre></div>

<p>如果一个函数参数是const T&amp;，则可以传递任何种类给它。如果实参是const，则T被推导为普通类型。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f2</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// can take an rvalue
</span><span class="c1">// parameter in f2 is const &amp;; const in the argument is irrelevant
</span><span class="c1">// in each of these three calls, f2&#39;s function parameter is inferred as const int&amp;
</span><span class="c1"></span><span class="n">f2</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>  <span class="c1">// i is an int; template parameter T is int
</span><span class="c1"></span><span class="n">f2</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span> <span class="c1">// ci is a const int, but template parameter T is int
</span><span class="c1"></span><span class="n">f2</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>  <span class="c1">// a const &amp; parameter can be bound to an rvalue; T is int)
</span></code></pre></div>

<h3 id="右值引用函数参数类型推导">右值引用函数参数类型推导<a href="#右值引用函数参数类型推导" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>当一个函数参数是右值引用，正常绑定规则告诉我们可以传递一个右值给函数参数。类型推导的行为和普通左值引用类似。被推导的类型T是右值的类型。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f3</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">);</span>
<span class="n">f3</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="c1">// argument is an rvalue of type int; template parameter T is int
</span></code></pre></div>

<h3 id="引用折叠和右值引用参数">引用折叠和右值引用参数<a href="#引用折叠和右值引用参数" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>C++在正常绑定规则上定义了2种特例，允许将右值引用绑定到左值上。</p>

<p>第一种特例是关于右值引用如何推导的。当传递一个左值给右值引用模板参数，编译器推导模板参数类型为实参的左值引用。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">f3</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>  <span class="c1">// argument is an lvalue; template parameter T is int&amp;
</span><span class="c1"></span><span class="n">f3</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span> <span class="c1">// argument is an lvalue; template parameter T is const int&amp;
</span></code></pre></div>

<p>第二种特例是如果我们间接地创建了一个引用的引用，则这些引用“折叠”。
对于一个给定类型X：
* X&amp; &amp;, X&amp; &amp;&amp;和X&amp;&amp; &amp;折叠为X&amp;
* X&amp;&amp; &amp;&amp;折叠为X&amp;&amp;</p>

<blockquote>
<p><strong>注释</strong>
引用折叠仅仅应用在间接创建了一个引用的引用，比如通过类型别名或模板参数。</p>
</blockquote>

<p>这两个特例产生两个重要结果：
* 一个是右值引用的函数模板参数可以绑定到左值上
* 如果实参是一个左值，则模板实参类型被推导为左值引用，且函数参数被实例化为左值引用参数</p>

<p>这也意味着可以传递任意类型给T&amp;&amp;函数参数。</p>

<h3 id="编写右值引用参数模板函数">编写右值引用参数模板函数<a href="#编写右值引用参数模板函数" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>模板参数可以被推导为引用类型这个事实，对于在模板内编写代码有惊人的冲击：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f3</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">t</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>  <span class="c1">// copy or binding a reference?
</span><span class="c1"></span>    <span class="n">t</span> <span class="o">=</span> <span class="n">fcn</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="c1">// does the assignment change only t or val and t?
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span> <span class="c1">// always true if T is a reference type
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<p>实际上，右值引用参数被用在2个场景，一个是模板转发它的实参，另一个是模板重载。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">);</span>      <span class="c1">// binds to nonconst
</span><span class="c1"></span><span class="n">rvalues</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// lvalues and const
</span><span class="c1"></span><span class="n">rvalues</span>
</code></pre></div>

<h2 id="16-2-6-理解std-move">16.2.6 理解std::move<a href="#16-2-6-理解std-move" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>库函数move是一个展示右值引用模板参数的好例子。</p>

<h3 id="std-move是如何定义的">std::move是如何定义的<a href="#std-move是如何定义的" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>标准库定义move如下：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// for the use of typename in the return type and the cast see § 16.1.3 (p. 670)
</span><span class="c1">// remove_reference is covered in § 16.2.3 (p. 684)
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;&amp;</span> <span class="n">move</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// static_cast covered in § 4.11.3 (p. 163)
</span><span class="c1"></span>    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="std-move是如何工作的">std::move是如何工作的<a href="#std-move是如何工作的" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">string</span> <span class="nf">s1</span><span class="p">(</span><span class="s">&#34;hi!&#34;</span><span class="p">),</span> <span class="n">s2</span><span class="p">;</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="s">&#34;bye!&#34;</span><span class="p">));</span> <span class="c1">// ok: moving from an rvalue
</span><span class="c1"></span><span class="n">s2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span>  <span class="c1">// ok: but after the assigment s1 has indeterminate value
</span></code></pre></div>

<p>第一个赋值，传递给move的实参是一个右值：
* T推导的类型为string
* remove_reference<string>::type是string
* move的返回类型是string&amp;&amp;
* move的函数参数t类型为string&amp;&amp;
因此这个调用实例化的move是string&amp;&amp; move(string&amp;&amp; t)</p>

<p>第二个赋值，传递给move的实参是一个左值：
* T推导的类型为string&amp;
* remove_reference<string&>::type是string
* move的返回类型是string&amp;&amp;
* move的函数参数t类型为string&amp; &amp;&amp;，折叠为string&amp;
因此这个调用实例化的move是string&amp;&amp; move(string&amp; t)</p>

<h4 id="static-cast一个左值引用为右值引用是允许的">static_cast一个左值引用为右值引用是允许的<a href="#static-cast一个左值引用为右值引用是允许的" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>

<p>不能隐式将左值引用转换为右值引用，必须使用static_cast。</p>

<h2 id="16-2-7-转发">16.2.7 转发<a href="#16-2-7-转发" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>有些函数需要转发一个或多个参数给其他函数。这种情况下，我们需要保存被转发参数的所有信息。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// template that takes a callable and two parameters
</span><span class="c1">// and calls the given callable with the parameters &#39;&#39;flipped&#39;&#39;
</span><span class="c1">// flip1 is an incomplete implementation: top-level const and references are lost
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">flip1</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">,</span> <span class="n">T1</span> <span class="n">t1</span><span class="p">,</span> <span class="n">T2</span> <span class="n">t2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">t1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>这个模板工作得很好直到调用一个有引用参数的函数：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">v1</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">v2</span><span class="p">)</span> <span class="c1">// note v2 is a reference
</span><span class="c1"></span><span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v1</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="o">++</span><span class="n">v2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>f改变了v2的值，但是如果通过flip1调用f，则f做的改变不影响原来的实参：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">f</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>        <span class="c1">// f changes its argument i
</span><span class="c1"></span><span class="n">flip1</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span> <span class="c1">// f called through flip1 leaves j unchanged
</span></code></pre></div>

<h3 id="定义保留类型信息的函数参数">定义保留类型信息的函数参数<a href="#定义保留类型信息的函数参数" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>我们可以定义函数参数为模板类型的右值引用保留实参的所有类型信息。使用引用参数可以保存const属性，通过引用折叠可以保存左值或右值属性。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">flip2</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">,</span> <span class="n">T1</span><span class="o">&amp;&amp;</span> <span class="n">t1</span><span class="p">,</span> <span class="n">T2</span><span class="o">&amp;&amp;</span> <span class="n">t2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">t1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<blockquote>
<p><strong>注解</strong>
函数的一个右值引用的模板类型参数保留实参的const属性和左值或右值属性。</p>
</blockquote>

<p>flip2函数只解决了一半问题。flip2函数当函数参数为左值引用时工作很好，但是不能调用有右值引用参数的函数，比如：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="n">i</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">j</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">flip2</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span> <span class="c1">// error: can&#39;t initialize int&amp;&amp; from an lvalue
</span></code></pre></div>

<p>函数参数和任何其他变量一样，是一个左值表达式。结果flip2中的g调用传递一个左值给g的右值引用参数。</p>

<h3 id="使用std-forward在函数调用种保留类型信息">使用std::forward在函数调用种保留类型信息<a href="#使用std-forward在函数调用种保留类型信息" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>我们可以使用一个新的库工具forward传递给flip2的函数参数并保留类型信息。和move一样，forward定义在utility头文件。与move不一样的是，forward调用时必须显示指定模板实参。forward返回其模板实参的右值引用，即forward<T>返回类型为T&amp;&amp;</p>

<p>通常我们使用forward来传递定义为右值引用模板类型的函数参数。通过返回类型的引用折叠，forward保留了指定实参的类型：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="o">&gt;</span> <span class="n">intermediary</span><span class="p">(</span><span class="n">Type</span><span class="o">&amp;&amp;</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">finalFcn</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg</span><span class="p">));</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<blockquote>
<p><em>注解</em>
当使用函数参数为右值引用模板类型时，forward保留实参类型的所有信息</p>
</blockquote>

<p>使用forward，我们可以重写flip函数为：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">flip</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">,</span> <span class="n">T1</span><span class="o">&amp;&amp;</span> <span class="n">t1</span><span class="p">,</span> <span class="n">T2</span><span class="o">&amp;&amp;</span> <span class="n">t2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t2</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t1</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>

<blockquote>
<p><em>注解</em>
和std::move一样，不提供using声明使用std::forward是个好主意</p>
</blockquote>

<h2 id="16-3-重载和模板">16.3 重载和模板<a href="#16-3-重载和模板" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>函数模板可以被其他模板或普通的非模板函数重载。和以往一样，同名函数的参数个数或类型必须不一样。</p>

<p>函数匹配受函数模板的影响，表现为下面几点：
* 候选函数包含任何成功实例化的模板函数。
* 候选函数模板总是可行的，因为模板实参会去除任何不可行的模板。
* 和以往一样，可行函数（模板和非模板）通过转换评级。
* 如果仅有一个函数比其他更匹配，则这个函数被选中。如果有多个函数匹配，则：
1. 如果只有一个非模板函数，则该函数被选中。
2. 如果没有非模板函数，且其中某个比其他更特例，则该函数被选中。
3. 调用有歧义。</p>

<blockquote>
<p><strong>警告</strong>
正确定义一组重载函数模板需要很好地理解类型之间的关系和函数模板参数转换的限制。</p>
</blockquote>

<h3 id="编写重载模板">编写重载模板<a href="#编写重载模板" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>作为一个例子，我们将定义一组调试时有用的函数</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// print any type we don&#39;t otherwise handle
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">string</span> <span class="n">debug_rep</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ostringstream</span> <span class="n">ret</span><span class="p">;</span> <span class="c1">// see § 8.3 (p. 321)
</span><span class="c1"></span>    <span class="n">ret</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">;</span> <span class="c1">// uses T&#39;s output operator to print a representation of t
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">ret</span><span class="p">.</span><span class="n">str</span><span class="p">();</span> <span class="c1">// return a copy of the string to which ret is bound
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<p>这个函数可以用来生成任何具有输出操作符类型的字符串表示。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// print pointers as their pointer value, followed by the object to which the pointer points
</span><span class="c1">// NB: this function will not work properly with char*; see § 16.3 (p. 698)
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">string</span> <span class="n">debug_rep</span><span class="p">(</span><span class="n">T</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ostringstream</span> <span class="n">ret</span><span class="p">;</span>
    <span class="n">ret</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;pointer: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">;</span>         <span class="c1">// print the pointer&#39;s own value
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">debug_rep</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span> <span class="c1">// print the value to which p points
</span><span class="c1"></span>    <span class="k">else</span>
        <span class="n">ret</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; null pointer&#34;</span><span class="p">;</span>      <span class="c1">// or indicate that the p is null
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">ret</span><span class="p">.</span><span class="n">str</span><span class="p">();</span> <span class="c1">// return a copy of the string to which ret is bound
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<p>这是一个指针版本。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">string</span> <span class="nf">s</span><span class="p">(</span><span class="s">&#34;hi&#34;</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">debug_rep</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></div>

<p>对于这个调用，只有第一个版本可行。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">debug_rep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></div>

<p>对于这个调用，两个函数都可行：
* debug_rep(const string* &amp;)，第一个函数实例化，T推导为string*
* debug_rep(string*)，第二个函数实例化，T推导为string</p>

<p>第二个版本实例化对于这个调用完全匹配，第一个版本需要将普通指针转换为const。</p>

<h3 id="多个可行模板">多个可行模板<a href="#多个可行模板" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>作为另一个例子，考虑以下调用：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="n">string</span><span class="o">*</span> <span class="n">sp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">debug_rep</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></div>

<p>这里2个模板都可行且都完全匹配：
* debug_rep(const string* &amp;)，T推导为const string*
* debug_rep(const string*)，T推导为const string</p>

<p>这种情况下，普通函数匹配不能区分这2个调用。然而由于重载函数模板的特殊规则，这个调用确认为debug_rep(T*)，即这个更特殊的模板。理由是，如果没有这个规则，将没有办法调用指针版本的debug_rep。</p>

<blockquote>
<p><strong>注解</strong>
当有多个重载模板对于一个调用提供同样好的匹配时，更特殊的模板版本被选择。</p>
</blockquote>

<h3 id="非模板和模板重载">非模板和模板重载<a href="#非模板和模板重载" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>我们定义一个普通的非模板版本的debug_rep：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// print strings inside double quotes
</span><span class="c1"></span><span class="n">string</span> <span class="nf">debug_rep</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="sc">&#39;&#34;&#39;</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="sc">&#39;&#34;&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>当我们使用string调用debug_rep时：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">string</span> <span class="nf">s</span><span class="p">(</span><span class="s">&#34;hi&#34;</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">debug_rep</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></div>

<p>有两个可行的函数：
* debug_rep<string>(const string&amp;)，第一个模板T绑定到string
* debug_rep(const string&amp;)，普通的非模板函数</p>

<p>这种情况下，普通的非模板函数被选择。出于同样的原因，同样好的匹配的函数，更特殊的被选择。</p>

<blockquote>
<p><strong>注解</strong>
当一个非模板函数对于一个调用提供和函数模板一样好的匹配时，非模板函数被选择。</p>
</blockquote>

<h3 id="重载模板和转换">重载模板和转换<a href="#重载模板和转换" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>有一种情况还没有谈到，指向C风格字符串的指针和字符串字面值。考虑下面这个调用：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">debug_rep</span><span class="p">(</span><span class="s">&#34;hi world!&#34;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// calls debug_rep(T*)
</span></code></pre></div>

<p>有3个debug_rep函数可行：
* debug_rep(const T&amp;)，T绑定到char[10]
* debug_rep(T*)，T绑定到const char
* debug_rep(const string&amp;)，需要将const char*转换到string</p>

<p>2个模板版本的函数提供完全匹配，非函数模板需要用户定义的转换，因此更特殊的模板版本被选择。</p>

<p>如果像将字符指针处理为string，可以再定义2个非模板重载函数：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// convert the character pointers to string and call the string version of debug_rep
</span><span class="c1"></span><span class="n">string</span> <span class="nf">debug_rep</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">debug_rep</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">string</span> <span class="nf">debug_rep</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">debug_rep</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="缺失声明可导致程序表现异常">缺失声明可导致程序表现异常<a href="#缺失声明可导致程序表现异常" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>值得注意的是为了char*版本的debug_rep正常工作，当char*版本函数定义时，debug_rep(const stirng&amp;)声明必须在作用域内。否则模板版本将被调用：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">string</span> <span class="n">debug_rep</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">string</span> <span class="n">debug_rep</span><span class="p">(</span><span class="n">T</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="c1">// the following declaration must be in scope
</span><span class="c1">// for the definition of debug_rep(char*) to do the right thing
</span><span class="c1"></span><span class="n">string</span> <span class="nf">debug_rep</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="n">string</span> <span class="nf">debug_rep</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// if the declaration for the version that takes a const string&amp; is not in scope
</span><span class="c1"></span>    <span class="c1">// the return will call debug_rep(const T&amp;) with T instantiated to string
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">debug_rep</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>

<blockquote>
<p><strong>提示</strong>
定义任何函数之前声明重载集中每一个函数。这样就不用担心编译器看到你想用的函数之前实例化一个函数。</p>
</blockquote>

<h2 id="16-4-变长模板">16.4 变长模板<a href="#16-4-变长模板" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p><strong>C++ 11:</strong> 变长模板是一个模板函数或类拥有可变数量的参数。可变参数被称为参数包。有两种参数包，模板参数包表示0个或多个模板参数，函数参数包表示0个或多个函数参数。</p>

<p>我们使用&hellip;表示模板或函数参数包。在模板参数列表中，class&hellip;或typename&hellip;指示接下来的参数表示0个或多个类型；类型名后面跟&hellip;表示0个或多个非类型参数列表。在函数参数列表中，类型为模板参数包的参数是一个函数参数包：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// Args is a template parameter pack; rest is a function parameter pack
</span><span class="c1">// Args represents zero or more template type parameters
</span><span class="c1">// rest represents zero or more function parameters
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span> <span class="p">...</span> <span class="n">rest</span><span class="p">);</span>
</code></pre></div>

<p>通常，编译器从函数实参中推导模板参数类型。对于一个变长模板，编译器同样推导出参数包中的参数个数：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span> <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&#34;how now brown cow&#34;</span><span class="p">;</span>
<span class="n">foo</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>    <span class="c1">// three parameters in the pack
</span><span class="c1"></span><span class="n">foo</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="s">&#34;hi&#34;</span><span class="p">);</span>    <span class="c1">// two parameters in the pack
</span><span class="c1"></span><span class="n">foo</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>           <span class="c1">// one parameter in the pack
</span><span class="c1"></span><span class="n">foo</span><span class="p">(</span><span class="s">&#34;hi&#34;</span><span class="p">);</span>           <span class="c1">// empty pack
</span></code></pre></div>

<p>编译器将实例化4个不同的foo：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span>
<span class="kt">double</span><span class="o">&amp;</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">&amp;</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">&amp;</span><span class="p">);</span>
</code></pre></div>

<h3 id="sizeof-操作符">sizeof&hellip;操作符<a href="#sizeof-操作符" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p><strong>C++ 11:</strong> 当我们想要直到参数包中有多少个元素时，可以使用sizeof&hellip;操作符。和sizeof一样，sizeof&hellip;返回一个常量，而且不会计算实参：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">g</span><span class="p">(</span><span class="n">Args</span> <span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">Args</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">// number of type parameters
</span><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">args</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">// number of function parameters
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<h3 id="编写变长函数模板">编写变长函数模板<a href="#编写变长函数模板" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>我们定义一个变长函数print，打印实参列表的值。变长函数通常是递归的，第一个调用处理参数包中第一个参数，然后用剩下的参数调用自己。为了终止递归，我们需要定义一个非变长的print函数：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// function to end the recursion and print the last element
</span><span class="c1">// this function must be declared before the variadic version of print is defined
</span><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">ostream</span> <span class="o">&amp;</span><span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">;</span> <span class="c1">// no separator after the last element in the pack
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">// this version of print will be called for all but the last element in the pack
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="n">ostream</span> <span class="o">&amp;</span><span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">rest</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, &#34;</span><span class="p">;</span>           <span class="c1">// print the first argument
</span><span class="c1"></span>    <span class="k">return</span> <span class="nf">print</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">rest</span><span class="p">...);</span> <span class="c1">// recursive call; print the other arguments
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<blockquote>
<p><strong>警告</strong>
当print的变长版本定义时，print的非变长版本必须在作用域中，否则变长函数将无限递归。</p>
</blockquote>

<h3 id="包展开">包展开<a href="#包展开" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>除了获取包的大小，对参数包可以做的唯一的另外一件事就是包展开。当我们展开一个包时，我们也可以提供一个模式用在每一个被展开的元素。将&hellip;放在模式右边触发包展开。</p>

<p>例如，print函数包含2个展开：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="n">ostream</span><span class="o">&amp;</span> <span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">rest</span><span class="p">)</span><span class="c1">// expand Args
</span><span class="c1"></span><span class="p">{</span>
    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, &#34;</span><span class="p">;</span>
    <span class="k">return</span> <span class="nf">print</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">rest</span><span class="p">...);</span> <span class="c1">// expand rest
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<p>Args的展开应用模式const Args&amp;到每一个元素。第二个展开应用模式函数参数包的名字。</p>

<h3 id="理解包展开">理解包展开<a href="#理解包展开" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>print的函数参数包展开仅仅是将包展开为它的组成部分。更复杂的模式也是可能的，比如：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// call debug_rep on each argument in the call to print
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="n">ostream</span> <span class="o">&amp;</span><span class="n">errorMsg</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">rest</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// print(os, debug_rep(a1), debug_rep(a2), ..., debug_rep(an)
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">print</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">debug_rep</span><span class="p">(</span><span class="n">rest</span><span class="p">)...);</span>
<span class="p">}</span>
</code></pre></div>

<p>print的调用中使用模式debug_rep(rest)。这个模式对函数参数包的每一个元素调用debug_rep。</p>

<blockquote>
<p><strong>注解</strong>
展开的模式单独地作用于包中的每一个元素</p>
</blockquote>

<h3 id="转发参数包">转发参数包<a href="#转发参数包" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>在新标准下，我们可以使用变长模板和forward一起编写函数，将实参不变地传递给其他函数。作为展示，我们将添加一个emplace_back成员函数到StrVec类。标准库容器的emplace_back成员是一个变长的模板成员函数，它使用其实参在容器的内存空间直接构造元素。</p>

<p>我们知道，保存类型信息有2个步骤。第一，为了保存实参的类型信息，必须定义函数参数为右值模板参数。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span><span class="err"> </span><span class="nc">StrVec</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Args</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">emplace_back</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...);</span>
    <span class="c1">// remaining members as in § 13.5 (p. 526)
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div>

<p>第二，当emplace_back将实参传递给构造函数时，必须使用forward保存实参的原有类型</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Args</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">StrVec</span><span class="o">::</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">chk_n_alloc</span><span class="p">();</span> <span class="c1">// reallocates the StrVec if necessary
</span><span class="c1"></span>    <span class="n">alloc</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">first_free</span><span class="o">++</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="p">}</span>
</code></pre></div>

<blockquote>
<p><strong>建议: 转发和变长模板</strong>
变长函数通常转发它们的参数给其他函数。这种函数一般具有和emplace_back函数类似的形式：</p>
</blockquote>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// fun has zero or more parameters each of which is
</span><span class="c1">// an rvalue reference to a template parameter type
</span><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">fun</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="c1">// expands Args as a list of rvalue references
</span><span class="c1"></span><span class="p">{</span>
    <span class="c1">// the argument to work expands both Args and args
</span><span class="c1"></span>    <span class="n">work</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="16-5-模板特化">16.5 模板特化<a href="#16-5-模板特化" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>一个模板并不总是适合每一个模板实参。某些情况下，通用的模板定义对于一个类型是错的，可能不能编译或做的事情是错的。有时候我们可能想利用一些特有的知识来写比模板实例化更有效的代码。当我们不能（或不想）使用模板版本时，我们可以模板的特殊版本。</p>

<p>compare函数是一个通用函数模板定义不能满足特定类型的很好例子。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// first version; can compare any two types
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
<span class="c1">// second version to handle string literals
</span><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="n">size_t</span> <span class="n">N</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">M</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="p">)[</span><span class="n">N</span><span class="p">],</span> <span class="k">const</span> <span class="kt">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="p">)[</span><span class="n">M</span><span class="p">]);</span>
</code></pre></div>

<p>带非类型模板参数版本的compare只会被字符串字面值或字符数组调用，如果使用字符指针调用compare，则第一个版本被调用：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="s">&#34;hi&#34;</span><span class="p">,</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="s">&#34;mom&#34;</span><span class="p">;</span>
<span class="n">compare</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span>      <span class="c1">// calls the first template
</span><span class="c1"></span><span class="n">compare</span><span class="p">(</span><span class="s">&#34;hi&#34;</span><span class="p">,</span> <span class="s">&#34;mom&#34;</span><span class="p">);</span> <span class="c1">// calls the template with two nontype parameters
</span></code></pre></div>

<p>为了处理字符指针，我们可以定义第一个compare版本的一个模板特化。模板特化是模板的一个独立定义，它的一个或多个模板参数被指定为特定类型。</p>

<h3 id="定义函数模板特化">定义函数模板特化<a href="#定义函数模板特化" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>当我们特化一个函数模板时，必须提供原模板中每个模板参数的实参类型。我们使用template &lt;&gt;表示模板特化。空&lt;&gt;指示将提供所有模板参数的实参：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// special version of compare to handle pointers to character arrays
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">p1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>当我们定义一个特化时，函数模板参数类型必须匹配之前声明的模板。</p>

<h3 id="函数重载vs模板特化">函数重载VS模板特化<a href="#函数重载vs模板特化" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>当我们定义一个函数模板特化时，本质上我们接管了编译器的工作。特化是一个实例，它不是函数名的重载。</p>

<blockquote>
<p><strong>注解</strong>
特化实例化一个模板，而不是重载函数。因此特化不影响函数匹配。</p>

<p><strong>关键概念: 普通作用域规则适用于特化</strong>
为了特化一个模板，原模板的声明在作用域中必须可见。而且，特化的声明必须在任何使用该模板实例的代码作用域之前可见。</p>

<p><strong>最佳实践</strong>
模板和它的特化应该在同一个头文件中声明。模板通用声明应该先出现，后跟任意模板特化。</p>
</blockquote>

<h3 id="类模板特化">类模板特化<a href="#类模板特化" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>除了特化函数模板，我们也可以特化类模板。作为一个例子，我们定义库hash模板的一个特化，使得可以将Sales_data对象存到一个unordered容器。特化的hash类必须定义：
* 一个重载调用操作符，接收容器的键类型对象并返回size_t
* 2个类型成员，result_type和argument_type，它们是调用操作符的返回类型和实参类型。
* 默认构造函数和赋值操作符，可被隐式定义。</p>

<p>定义hash特化唯一复杂之处是，当我们特化一个模板时，必须和原有模板在同一个命名空间。因此我们必须先打开命名空间：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// open the std namespace so we can specialize std::hash
</span><span class="c1"></span><span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
<span class="p">}</span>  <span class="c1">// close the std namespace; note: no semicolon after the close curly
</span></code></pre></div>

<p>任何在花括号之间的定义将成为命名空间std的一部分。下面定义对于Sales_data类型hash的一个特化：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// open the std namespace so we can specialize std::hash
</span><span class="c1"></span><span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;&gt;</span>  <span class="c1">// we&#39;re defining a specialization with
</span><span class="c1"></span><span class="k">struct</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">Sales_data</span><span class="o">&gt;</span> <span class="c1">// the template parameter of Sales_data
</span><span class="c1"></span><span class="p">{</span>
    <span class="c1">// the type used to hash an unordered container must define these types
</span><span class="c1"></span>    <span class="k">typedef</span> <span class="n">size_t</span> <span class="n">result_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">Sales_data</span> <span class="n">argument_type</span><span class="p">;</span> <span class="c1">// by default, this type needs ==
</span><span class="c1"></span>    <span class="n">size_t</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Sales_data</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">// our class uses synthesized copy control and default constructor
</span><span class="c1"></span><span class="p">};</span>
<span class="n">size_t</span>
<span class="n">hash</span><span class="o">&lt;</span><span class="n">Sales_data</span><span class="o">&gt;::</span><span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Sales_data</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">s</span><span class="p">.</span><span class="n">bookNo</span><span class="p">)</span> <span class="o">^</span>
        <span class="n">hash</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">s</span><span class="p">.</span><span class="n">units_sold</span><span class="p">)</span> <span class="o">^</span>
        <span class="n">hash</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">s</span><span class="p">.</span><span class="n">revenue</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span> <span class="c1">// close the std namespace; note: no semicolon after the close curly
</span></code></pre></div>

<p>hash<Sales_data>定义以template&lt;&gt;开始，它指示我们定义一个完全特化的模板。</p>

<blockquote>
<p><strong>注解</strong>
为了使Sales_data的用户可以使用hash的特例，我们应该在Sales_data的头文件中定义这个特化。</p>
</blockquote>

<h3 id="类模板偏特化">类模板偏特化<a href="#类模板偏特化" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>和函数模板不同的是，类模板特化可以不必提供每一个模板参数的实参。我们可以指定一部分而不是全部。一个类模板偏特化本身是一个模板。用户必须提供那些没有固定在特化中的模板参数。</p>

<blockquote>
<p><strong>注解</strong>
我们只能部分特化一个类模板，不能部分特化一个函数模板。</p>
</blockquote>

<p>标准库remove_reference类型就是通过一系列特化工作的：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// original, most general template
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">remove_reference</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="n">T</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// partial specializations that will be used for lvalue and rvalue references
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&gt;</span>  <span class="c1">// lvalue references
</span><span class="c1"></span><span class="p">{</span> <span class="k">typedef</span> <span class="n">T</span> <span class="n">type</span><span class="p">;</span> <span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span> <span class="c1">// rvalue references
</span><span class="c1"></span><span class="p">{</span> <span class="k">typedef</span> <span class="n">T</span> <span class="n">type</span><span class="p">;</span> <span class="p">};</span>
</code></pre></div>

<p>因为模板偏特化是一个模板，我们还是以定义模板参数开始。模板偏特化的参数列表和原模板是一样的。在类名后，我们指定特化模板的实参。这些实参包括在&lt;&gt;之中，且和圆模板的参数位置对应。</p>

<p>模板偏特化的参数列表是原模板的一个子集。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="c1">// decltype(42) is int, uses the original template
</span><span class="c1"></span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">a</span><span class="p">;</span>
<span class="c1">// decltype(i) is int&amp;, uses first (T&amp;) partial specialization
</span><span class="c1"></span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">b</span><span class="p">;</span>
<span class="c1">// decltype(std::move(i)) is int&amp;&amp;, uses second (i.e., T&amp;&amp;) partial specialization
</span><span class="c1"></span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">c</span><span class="p">;</span>
</code></pre></div>

<h3 id="特化成员而不是类">特化成员而不是类<a href="#特化成员而不是类" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>我们可以仅仅特化指定的成员函数，而不是特化整个类模板。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="n">Foo</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span> <span class="o">=</span> <span class="n">T</span><span class="p">())</span><span class="o">:</span> <span class="n">mem</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">Bar</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
    <span class="n">T</span> <span class="n">mem</span><span class="p">;</span>
    <span class="c1">// other members of Foo
</span><span class="c1"></span><span class="p">};</span>
<span class="k">template</span><span class="o">&lt;&gt;</span>           <span class="c1">// we&#39;re specializing a template
</span><span class="c1"></span><span class="kt">void</span> <span class="n">Foo</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">Bar</span><span class="p">()</span> <span class="c1">// we&#39;re specializing the Bar member of Foo&lt;int&gt;
</span><span class="c1"></span><span class="p">{</span>
    <span class="c1">// do whatever specialized processing that applies to ints
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<p>这里我们仅仅特化Foo<int>类的一个成员，其他成员由Foo模板提供：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Foo</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">fs</span><span class="p">;</span>  <span class="c1">// instantiates Foo&lt;string&gt;::Foo()
</span><span class="c1"></span><span class="n">fs</span><span class="p">.</span><span class="n">Bar</span><span class="p">();</span>        <span class="c1">// instantiates Foo&lt;string&gt;::Bar()
</span><span class="c1"></span><span class="n">Foo</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">fi</span><span class="p">;</span>     <span class="c1">// instantiates Foo&lt;int&gt;::Foo()
</span><span class="c1"></span><span class="n">fi</span><span class="p">.</span><span class="n">Bar</span><span class="p">();</span>        <span class="c1">// uses our specialization of Foo&lt;int&gt;::Bar()
</span></code></pre></div>

			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="http://gitop.cc/tags/c&#43;&#43;">C&#43;&#43;</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>16677 Words</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2015-12-14 18:34 &#43;0800</p>
			</footer>
		</article>
		<div class="post-nav thin">
			<a class="next-post" href="http://gitop.cc/posts/21st-c-1/">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>&nbsp;Newer</span><br><span>21世纪C语言 第1章 便利编译配置</span>
			</a>
			<a class="prev-post" href="http://gitop.cc/posts/pygame-6/">
				<span class="post-nav-label">Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>Pygame第6章 接受用户输入</span>
			</a>
		</div>
		<div id="comments" class="thin">
</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2019 <a href="http://gitop.cc">gitop</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="http://gitop.cc/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>


	<script src="http://gitop.cc/js/main.min.35ccbf1cdceb91e4c64c06b5d009d6e2977fafe56beda7762febd4e67528d2ac.js" integrity="sha256-Ncy/HNzrkeTGTAa10AnW4pd/r+Vr7ad2L+vU5nUo0qw="></script>

</body>

</html>
