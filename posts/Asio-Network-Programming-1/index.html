<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Boost.Asio网络编程 第1章 | 招财猫的博客</title>
    <meta property="og:title" content="Boost.Asio网络编程 第1章 - 招财猫的博客">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2016-03-13T10:55:46&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2016-03-13T10:55:46&#43;08:00'>
        
    <meta name="Keywords" content="C,C&#43;&#43;,Python,Golang">
    <meta name="description" content="Boost.Asio网络编程 第1章">
        
    <meta name="author" content="招财猫">
    <meta property="og:url" content="https://gitop.cc/posts/Asio-Network-Programming-1/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
    (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-4031353640611810",
        enable_page_level_ads: true
    });
    </script>
    


    
    
</head>


<body>
    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://gitop.cc">
                        招财猫的博客
                    </a>
                
                <p class="description">专注于C&#43;&#43;、Python、Golang</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="https://gitop.cc">首页</a>
                    
                    <a  href="https://gitop.cc/archives/" title="归档">归档</a>
                    
                    <a  href="https://gitop.cc/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    <style type="text/css">
    .post-toc {
        position: fixed;
        width: 200px;
        margin-left: -210px;
        padding: 5px 10px;
        font-family: Athelas, STHeiti, Microsoft Yahei, serif;
        font-size: 12px;
        border: 1px solid rgba(0, 0, 0, .07);
        border-radius: 5px;
        background-color: rgba(255, 255, 255, 0.98);
        background-clip: padding-box;
        -webkit-box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        word-wrap: break-word;
        white-space: nowrap;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
        z-index: 999;
        cursor: pointer;
        max-height: 70%;
        overflow-y: auto;
        overflow-x: hidden;
    }

    .post-toc .post-toc-title {
        width: 100%;
        margin: 0 auto;
        font-size: 20px;
        font-weight: 400;
        text-transform: uppercase;
        text-align: center;
    }

    .post-toc .post-toc-content {
        font-size: 15px;
    }

    .post-toc .post-toc-content>nav>ul {
        margin: 10px 0;
    }

    .post-toc .post-toc-content ul {
        padding-left: 20px;
        list-style: square;
        margin: 0.5em;
        line-height: 1.8em;
    }

    .post-toc .post-toc-content ul ul {
        padding-left: 15px;
        display: none;
    }

    @media print,
    screen and (max-width:1057px) {
        .post-toc {
            display: none;
        }
    }
</style>
<div class="post-toc" style="position: absolute; top: 188px;">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
        <nav id="TableOfContents">
  <ul>
    <li><a href="#重要的宏-">重要的宏</a></li>
  </ul>
</nav>
    </div>
</div>
<script type="text/javascript">
    $(document).ready(function () {
        var postToc = $(".post-toc");
        if (postToc.length) {
            var leftPos = $("#main").offset().left;
            if(leftPos<220){
                postToc.css({"width":leftPos-10,"margin-left":(0-leftPos)})
            }

            var t = postToc.offset().top - 20,
                a = {
                    start: {
                        position: "absolute",
                        top: t
                    },
                    process: {
                        position: "fixed",
                        top: 20
                    },
                };
            $(window).scroll(function () {
                var e = $(window).scrollTop();
                e < t ? postToc.css(a.start) : postToc.css(a.process)
            })
        }
    })
</script>
    <article class="post">
        <header>
            <h1 class="post-title">Boost.Asio网络编程 第1章</h1>
        </header>
        <date class="post-meta meta-date">
            2016年3月13日
        </date>
        
        <div class="post-meta">
            <span>|</span>
            
            <span class="meta-category"><a href='https://gitop.cc/categories/Network'>Network</a></span>
            
        </div>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            <h1 id="什么是boostasio-">什么是Boost.Asio</h1>
<p>简单来说，Boost.Asio是一个跨平台的C++库，主要是为了网络编程和一些其它低级输入/输出编程。</p>
<p>Boost.Asio成功地抽象出输入和输出的概念，不仅仅是网络，还有COM串行端口，文件等。在此之上，你可以同步或异步进行输入或输出编程：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">read(stream, buffer [, extra options])
async_read(stream, buffer [, extra options], handler)
write(stream, buffer [, extra options])
async_write(stream, buffer [, extra options], handler)
</code></pre></div>
<p>正如你在上一个代码片段看到，这些函数接受一个stream实例，它可以是任何东西（不仅仅是socket，只要我们能够读取或写入它）。</p>
<h1 id="依赖-">依赖</h1>
<p>Boost.Asio依赖以下库：</p>
<ul>
<li>Boost.System：这个库为Boost库提供操作系统支持。</li>
<li>Boost.Regex：可选，如果你使用带有boost::regex参数的read_until()或async_read_until()的重载版本。</li>
<li>Boost.DateTime：可选，如果你使用Boost.Asio计时器。</li>
<li>OpenSSL：可选，如果你决定使用Boost.Asio提供的SSL支持。</li>
</ul>
<h1 id="编译boostasio-">编译Boost.Asio</h1>
<p>Boost.Asio是只有头文件的库。然而，取决于你的编译器和程序的大小，你可以选择作为源文件嵌入Boost.Asio。可以使用下述方式减少编译次数：</p>
<ul>
<li>只在一个文件#include &lt;boost/asio/impl/src.hpp&gt;（如果使用SSL，也要包含&lt;boost/asio/ssl/impl/src.hpp&gt;）</li>
<li>在所有文件中使用#define BOOST_ASIO_SEPARATE_COMPILATION</li>
</ul>
<h2 id="重要的宏-">重要的宏</h2>
<p>BOOST_ASIO_DISABLE_THREADS如果被定义，它会禁止Boost.Asio中线程支持，不管Boost是否编译了线程支持。</p>
<h1 id="同步vs异步-">同步VS异步</h1>
<p>首先，异步编程与同步编程非常不同。在同步编程中，顺序执行操作，比如从socket读取请求，然后把回复写到socket。每一个操作都是阻塞的。因为操作是阻塞的，为了在读或写一个socket时不打断主程序，通常需要创建一个或多个线程处理socket的输入/输出。因此同步server/client通常是多线程的。</p>
<p>相反，异步编程是事件驱动的。你开始一个操作，但是不知道它什么时候结束；你提供一个回调函数，它会在操作结束时被API调用，连同操作结果。因此，在异步编程中，你没必要需要一个线程以上。</p>
<p>以下是一个基本的同步客户端例子：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000;font-weight:bold">using</span> boost<span style="color:#000;font-weight:bold">::</span>asio;
io_service service;
ip<span style="color:#000;font-weight:bold">::</span>tcp<span style="color:#000;font-weight:bold">::</span>endpoint ep(ip<span style="color:#000;font-weight:bold">::</span>address<span style="color:#000;font-weight:bold">::</span>from_string(<span style="color:#d14">&#34;127.0.0.1&#34;</span>), <span style="color:#099">2001</span>);
ip<span style="color:#000;font-weight:bold">::</span>tcp<span style="color:#000;font-weight:bold">::</span>socket sock(service);
sock.connect(ep);
</code></pre></div>
<p>首先，程序需要至少一个io_service实例。Boost.Asio使用io_service与操作系统输入/输出服务对话。通常一个io_service实例就足够了。</p>
<p>以下是一个简单的同步服务器例子：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000;font-weight:bold">typedef</span> boost<span style="color:#000;font-weight:bold">::</span>shared_ptr<span style="color:#000;font-weight:bold">&lt;</span>ip<span style="color:#000;font-weight:bold">::</span>tcp<span style="color:#000;font-weight:bold">::</span>socket<span style="color:#000;font-weight:bold">&gt;</span> socket_ptr;
io_service service;
ip<span style="color:#000;font-weight:bold">::</span>tcp<span style="color:#000;font-weight:bold">::</span>endpoint ep(ip<span style="color:#000;font-weight:bold">::</span>tcp<span style="color:#000;font-weight:bold">::</span>v4(), <span style="color:#099">2001</span>)); <span style="color:#998;font-style:italic">// listen on 2001
</span><span style="color:#998;font-style:italic"></span>ip<span style="color:#000;font-weight:bold">::</span>tcp<span style="color:#000;font-weight:bold">::</span>acceptor acc(service, ep);
<span style="color:#000;font-weight:bold">while</span> (<span style="color:#0086b3">true</span>) {
    socket_ptr <span style="color:#900;font-weight:bold">sock</span>(<span style="color:#000;font-weight:bold">new</span> ip<span style="color:#000;font-weight:bold">::</span>tcp<span style="color:#000;font-weight:bold">::</span>socket(service));
    acc.accept(<span style="color:#000;font-weight:bold">*</span>sock);
    boost<span style="color:#000;font-weight:bold">::</span><span style="color:#000;font-weight:bold">thread</span>(boost<span style="color:#000;font-weight:bold">::</span>bind(client_session, sock));
}
<span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">client_session</span>(socket_ptr sock) {
    <span style="color:#000;font-weight:bold">while</span> (<span style="color:#0086b3">true</span>) {
        <span style="color:#458;font-weight:bold">char</span> data[<span style="color:#099">512</span>];
        size_t len <span style="color:#000;font-weight:bold">=</span> sock<span style="color:#000;font-weight:bold">-&gt;</span>read_some(buffer(data));
        <span style="color:#000;font-weight:bold">if</span> (len <span style="color:#000;font-weight:bold">&gt;</span> <span style="color:#099">0</span>)
            write(<span style="color:#000;font-weight:bold">*</span>sock, buffer(<span style="color:#d14">&#34;ok&#34;</span>, <span style="color:#099">2</span>));
    }
}
</code></pre></div>
<p>创建一个异步客户端，类似下面这样：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000;font-weight:bold">using</span> boost<span style="color:#000;font-weight:bold">::</span>asio;
io_service service;
ip<span style="color:#000;font-weight:bold">::</span>tcp<span style="color:#000;font-weight:bold">::</span>endpoint ep(ip<span style="color:#000;font-weight:bold">::</span>address<span style="color:#000;font-weight:bold">::</span>from_string(<span style="color:#d14">&#34;127.0.0.1&#34;</span>), <span style="color:#099">2001</span>);
ip<span style="color:#000;font-weight:bold">::</span>tcp<span style="color:#000;font-weight:bold">::</span>socket sock(service);
sock.async_connect(ep, connect_handler);
service.run();
<span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">connect_handler</span>(<span style="color:#000;font-weight:bold">const</span> boost<span style="color:#000;font-weight:bold">::</span>system<span style="color:#000;font-weight:bold">::</span>error_code <span style="color:#000;font-weight:bold">&amp;</span> ec) {
    <span style="color:#998;font-style:italic">// here we know we connected successfully
</span><span style="color:#998;font-style:italic"></span>    <span style="color:#998;font-style:italic">// if ec indicates success
</span><span style="color:#998;font-style:italic"></span>}
</code></pre></div>
<p>注意service.run()循环会一直运行，只要还有异步操作加入。在前一个例子中，只有一个async_connect异步操作。在此之后，service.run()退出。</p>
<p>每一个异步操作都有一个完成处理器，一个在操作完成时被调用的函数。</p>
<p>以下是一个基本异步服务器：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000;font-weight:bold">using</span> boost<span style="color:#000;font-weight:bold">::</span>asio;
<span style="color:#000;font-weight:bold">typedef</span> boost<span style="color:#000;font-weight:bold">::</span>shared_ptr<span style="color:#000;font-weight:bold">&lt;</span>ip<span style="color:#000;font-weight:bold">::</span>tcp<span style="color:#000;font-weight:bold">::</span>socket<span style="color:#000;font-weight:bold">&gt;</span> socket_ptr;
io_service service;
ip<span style="color:#000;font-weight:bold">::</span>tcp<span style="color:#000;font-weight:bold">::</span>endpoint ep(ip<span style="color:#000;font-weight:bold">::</span>tcp<span style="color:#000;font-weight:bold">::</span>v4(), <span style="color:#099">2001</span>)); <span style="color:#998;font-style:italic">// listen on 2001
</span><span style="color:#998;font-style:italic"></span>ip<span style="color:#000;font-weight:bold">::</span>tcp<span style="color:#000;font-weight:bold">::</span>acceptor acc(service, ep);
socket_ptr <span style="color:#900;font-weight:bold">sock</span>(<span style="color:#000;font-weight:bold">new</span> ip<span style="color:#000;font-weight:bold">::</span>tcp<span style="color:#000;font-weight:bold">::</span>socket(service));
start_accept(sock);
service.run();
<span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">start_accept</span>(socket_ptr sock) {
    acc.async_accept(<span style="color:#000;font-weight:bold">*</span>sock, boost<span style="color:#000;font-weight:bold">::</span>bind(handle_accept, sock, _1));
}
<span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">handle_accept</span>(socket_ptr sock, <span style="color:#000;font-weight:bold">const</span> boost<span style="color:#000;font-weight:bold">::</span>system<span style="color:#000;font-weight:bold">::</span>error_code <span style="color:#000;font-weight:bold">&amp;</span>err) {
    <span style="color:#000;font-weight:bold">if</span> (err) <span style="color:#000;font-weight:bold">return</span>;
    <span style="color:#998;font-style:italic">// at this point, you can read/write to the socket
</span><span style="color:#998;font-style:italic"></span>    socket_ptr sock(<span style="color:#000;font-weight:bold">new</span> ip<span style="color:#000;font-weight:bold">::</span>tcp<span style="color:#000;font-weight:bold">::</span>socket(service));
    start_accept(sock);
}
</code></pre></div>
<p>handle_accept里面，在socket使用后，创建一个新的socket，并再次调用start_accept()，它添加另一个async_accept操作，保持service.run()忙碌下去。</p>
<h1 id="异常vs错误码-">异常VS错误码</h1>
<p>Boost.Asio允许异常或错误码。所有同步函数重载了抛出异常或返回错误码的版本。这些函数抛出boost::system::system_error错误。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000;font-weight:bold">using</span> boost<span style="color:#000;font-weight:bold">::</span>asio;
ip<span style="color:#000;font-weight:bold">::</span>tcp<span style="color:#000;font-weight:bold">::</span>endpoint ep;
ip<span style="color:#000;font-weight:bold">::</span>tcp<span style="color:#000;font-weight:bold">::</span>socket sock(service);
sock.connect(ep); <span style="color:#998;font-style:italic">// Line 1
</span><span style="color:#998;font-style:italic"></span>boost<span style="color:#000;font-weight:bold">::</span>system<span style="color:#000;font-weight:bold">::</span>error_code err;
sock.connect(ep, err); <span style="color:#998;font-style:italic">// Line 2
</span></code></pre></div>
<p>在前面的代码中，sock.connect(ep)在发生错误时抛出异常，而sock.connect(ep, err)返回错误码。</p>
<p>所有异步函数返回一个错误码，你可以在回调中检查它。异步函数从不抛出异常，因为这不合理，谁来捕捉异常？</p>
<p>所有Boost.Asio错误码在命名空间boost::asio::error。</p>
<h1 id="boostasio中的线程-">Boost.Asio中的线程</h1>
<p>当提到Boost.Asio中的线程，我们会讨论：</p>
<ul>
<li>io_service：io_service类是线程安全的。多个线程可以调用io_service::run()。大多数时候你可能从单个线程调用io_service::run()，它一直阻塞直到所有异步操作完成。然而你可以从多个线程里面调用io_service::run()，这会阻塞所有调用了io_service::run()的线程。所有回调都将在线程自己的上下文环境中被调用。</li>
<li>socket：socket类不是线程安全的。因此你应该避免在一个线程中读，然后写到另一个线程中去。</li>
<li>utility：utility类不是线程安全的，通常在多个线程中使用它不合理。它们中的大多数都是短时间使用，然后被回收。</li>
</ul>
<p>Boost.Asio库自己可以使用多个非用户的线程，它保证在这些线程里面不会调用任何你的代码。这意味着回调只会被调用了io_service::run()的线程调用。</p>
<h1 id="不仅仅是网络-">不仅仅是网络</h1>
<p>除了网络，Boost.Asio提供其他输入/输出设施。</p>
<p>Boost.Asio允许等待信号，比如SIGTERM，SIGINT，SIGSEGV等：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">signal_handler</span>(<span style="color:#000;font-weight:bold">const</span> boost<span style="color:#000;font-weight:bold">::</span>system<span style="color:#000;font-weight:bold">::</span>error_code <span style="color:#000;font-weight:bold">&amp;</span> err, <span style="color:#458;font-weight:bold">int</span> signal)
{
    <span style="color:#998;font-style:italic">// log this, and terminate application
</span><span style="color:#998;font-style:italic"></span>}
boost<span style="color:#000;font-weight:bold">::</span>asio<span style="color:#000;font-weight:bold">::</span>signal_set sig(service, SIGINT, SIGTERM);
sig.async_wait(signal_handler);
</code></pre></div>
<p>使用Boost.Asio可以很容易地连接串行端口：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">io_service service;
serial_port <span style="color:#900;font-weight:bold">sp</span>(service, <span style="color:#d14">&#34;COM7&#34;</span>);
<span style="color:#998;font-style:italic">// serial_port sp(service, &#34;/dev/ttyS0&#34;);
</span><span style="color:#998;font-style:italic"></span>serial_port<span style="color:#000;font-weight:bold">::</span>baud_rate rate(<span style="color:#099">9600</span>);
sp.set_option(rate);
<span style="color:#458;font-weight:bold">char</span> data[<span style="color:#099">512</span>];
read(sp, buffer(data, <span style="color:#099">512</span>));
</code></pre></div>
<p>Boost.Asio也允许连接Windows文件：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">HANDLE h <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">::</span>OpenFile(...);
windows<span style="color:#000;font-weight:bold">::</span>stream_handle sh(service, h);
<span style="color:#458;font-weight:bold">char</span> data[<span style="color:#099">512</span>];
read(h, buffer(data, <span style="color:#099">512</span>));
</code></pre></div>
<p>你可以同样操作POSIX文件描述符，比如管道，标准I/O，各种设备：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">posix<span style="color:#000;font-weight:bold">::</span>stream_descriptor sd_in(service, <span style="color:#000;font-weight:bold">::</span>dup(STDIN_FILENO));
<span style="color:#458;font-weight:bold">char</span> data[<span style="color:#099">512</span>];
read(sd_in, buffer(data, <span style="color:#099">512</span>));
</code></pre></div>
<h1 id="计时器-">计时器</h1>
<p>一些I/O操作可以有一个完成的最后期限，这个概念只能用到异步操作。</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#458;font-weight:bold">bool</span> read <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">false</span>;
<span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">deadline_handler</span>(<span style="color:#000;font-weight:bold">const</span> boost<span style="color:#000;font-weight:bold">::</span>system<span style="color:#000;font-weight:bold">::</span>error_code <span style="color:#000;font-weight:bold">&amp;</span>) {
    std<span style="color:#000;font-weight:bold">::</span>cout <span style="color:#000;font-weight:bold">&lt;&lt;</span> (read <span style="color:#000;font-weight:bold">?</span> <span style="color:#d14">&#34;read successfully&#34;</span> <span style="color:#000;font-weight:bold">:</span> <span style="color:#d14">&#34;read failed&#34;</span>) <span style="color:#000;font-weight:bold">&lt;&lt;</span>
    std<span style="color:#000;font-weight:bold">::</span>endl;
}
<span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">read_handler</span>(<span style="color:#000;font-weight:bold">const</span> boost<span style="color:#000;font-weight:bold">::</span>system<span style="color:#000;font-weight:bold">::</span>error_code <span style="color:#000;font-weight:bold">&amp;</span>) {
    read <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">true</span>;
}
ip<span style="color:#000;font-weight:bold">::</span>tcp<span style="color:#000;font-weight:bold">::</span>socket sock(service);
<span style="color:#a61717;background-color:#e3d2d2">…</span>
read <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">false</span>;
<span style="color:#458;font-weight:bold">char</span> data[<span style="color:#099">512</span>];
sock.async_read_some(buffer(data, <span style="color:#099">512</span>));
deadline_timer <span style="color:#900;font-weight:bold">t</span>(service, boost<span style="color:#000;font-weight:bold">::</span>posix_time<span style="color:#000;font-weight:bold">::</span>milliseconds(<span style="color:#099">100</span>));
t.async_wait(<span style="color:#000;font-weight:bold">&amp;</span>deadline_handler);
service.run();
</code></pre></div>
<p>Boost.Asio同样允许同步计时器，但它们通常等价于sleep操作。以下2个等价：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">boost<span style="color:#000;font-weight:bold">::</span>this_thread<span style="color:#000;font-weight:bold">::</span>sleep(<span style="color:#099">500</span>);
deadline_timer <span style="color:#900;font-weight:bold">t</span>(service, boost<span style="color:#000;font-weight:bold">::</span>posix_time<span style="color:#000;font-weight:bold">::</span>milliseconds(<span style="color:#099">500</span>));
t.wait();
</code></pre></div>
<h1 id="io_service类-">io_service类</h1>
<p>io_service是Boost.Asio最重要的类，它跟操作系统打交道，等待一个异步操作结束并调用相应的回调函数。</p>
<p>你可以以几种方式使用io_service：</p>
<ul>
<li>单线程，1个io_service和单处理线程：
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">io_service service_;
<span style="color:#998;font-style:italic">// all the socket operations are handled by service_
</span><span style="color:#998;font-style:italic"></span>ip<span style="color:#000;font-weight:bold">::</span>tcp<span style="color:#000;font-weight:bold">::</span>socket sock1(service_);
<span style="color:#998;font-style:italic">// all the socket operations are handled by service_
</span><span style="color:#998;font-style:italic"></span>ip<span style="color:#000;font-weight:bold">::</span>tcp<span style="color:#000;font-weight:bold">::</span>socket sock2(service_);
sock1.async_connect(ep, connect_handler);
sock2.async_connect(ep, connect_handler);
deadline_timer <span style="color:#900;font-weight:bold">t</span>(service_, boost<span style="color:#000;font-weight:bold">::</span>posix_time<span style="color:#000;font-weight:bold">::</span>seconds(<span style="color:#099">5</span>));
t.async_wait(timeout_handler);
service_.run();
</code></pre></div></li>
<li>多线程，单个io_service和多个处理线程：
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">io_service service_;
ip<span style="color:#000;font-weight:bold">::</span>tcp<span style="color:#000;font-weight:bold">::</span>socket sock1(service_);
ip<span style="color:#000;font-weight:bold">::</span>tcp<span style="color:#000;font-weight:bold">::</span>socket sock2(service_);
sock1.async_connect(ep, connect_handler);
sock2.async_connect(ep, connect_handler);
deadline_timer <span style="color:#900;font-weight:bold">t</span>(service_, boost<span style="color:#000;font-weight:bold">::</span>posix_time<span style="color:#000;font-weight:bold">::</span>seconds(<span style="color:#099">5</span>));
t.async_wait(timeout_handler);
<span style="color:#000;font-weight:bold">for</span> ( <span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;</span> <span style="color:#099">5</span>; <span style="color:#000;font-weight:bold">++</span>i)
    boost<span style="color:#000;font-weight:bold">::</span><span style="color:#000;font-weight:bold">thread</span>(run_service);
<span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">run_service</span>() {
    service_.run();
}
</code></pre></div></li>
<li>多个线程，多个io_service和多个处理线程：
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">io_service service_[<span style="color:#099">2</span>];
ip<span style="color:#000;font-weight:bold">::</span>tcp<span style="color:#000;font-weight:bold">::</span>socket sock1(service_[<span style="color:#099">0</span>]);
ip<span style="color:#000;font-weight:bold">::</span>tcp<span style="color:#000;font-weight:bold">::</span>socket sock2(service_[<span style="color:#099">1</span>]);
sock1.async_connect(ep, connect_handler);
sock2.async_connect(ep, connect_handler);
deadline_timer <span style="color:#900;font-weight:bold">t</span>(service_[<span style="color:#099">0</span>], boost<span style="color:#000;font-weight:bold">::</span>posix_time<span style="color:#000;font-weight:bold">::</span>seconds(<span style="color:#099">5</span>));
t.async_wait(timeout_handler);
<span style="color:#000;font-weight:bold">for</span> (<span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;</span> <span style="color:#099">2</span>; <span style="color:#000;font-weight:bold">++</span>i)
    boost<span style="color:#000;font-weight:bold">::</span><span style="color:#000;font-weight:bold">thread</span>(boost<span style="color:#000;font-weight:bold">::</span>bind(run_service, i));
<span style="color:#458;font-weight:bold">void</span> <span style="color:#900;font-weight:bold">run_service</span>(<span style="color:#458;font-weight:bold">int</span> idx) {
    service_[idx].run();
}
</code></pre></div></li>
</ul>
<p>首先，需要注意在一个线程里面不能有多个io_service实例。以下代码毫无意义：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000;font-weight:bold">for</span> ( <span style="color:#458;font-weight:bold">int</span> i <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>; i <span style="color:#000;font-weight:bold">&lt;</span> <span style="color:#099">2</span>; <span style="color:#000;font-weight:bold">++</span>i)
    service_[i].run();
</code></pre></div>
<p>以下是从前面例子中你应该学到的：</p>
<ul>
<li>第一种情况对最基本的程序有用。如果多个处理函数需要同时调用，将遇到瓶颈，因为它们以顺序方式被调用。如果一个处理函数花太长时间结束，所有后续处理函数都将等待。</li>
<li>第二种情况适用于大多数程序。如果多个处理函数被同时调用，它们会在自己的线程被调用。唯一的瓶颈是如果所有处理线程都在忙碌，而新的处理函数被调用。</li>
<li>第三种情况最复杂最灵活。你应该在第二种情况不够的时候使用它。你可以认为每一个处理线程（运行io_service::run()的线程）有自己的select/epoll循环。</li>
</ul>
<p>最后记住如果没有更多的操作需要处理，run()将会终止。如果想要run()继续运行，你必须把更多工作给它。一种方法是在处理函数中开始另一个异步操作。另一种方法是模拟一些工作给它：</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000;font-weight:bold">typedef</span> boost<span style="color:#000;font-weight:bold">::</span>shared_ptr<span style="color:#000;font-weight:bold">&lt;</span>io_service<span style="color:#000;font-weight:bold">::</span>work<span style="color:#000;font-weight:bold">&gt;</span> work_ptr;
work_ptr <span style="color:#900;font-weight:bold">dummy_work</span>(<span style="color:#000;font-weight:bold">new</span> io_service<span style="color:#000;font-weight:bold">::</span>work(service_));
</code></pre></div>
<p>上述代码将使得service_.run()不会停止除非你使用service_.stop()或dummy_work.reset(0)销毁dummy_work。</p>

        </div>

        
<div class="post-archive">
    <ul class="post-copyright">
        <li><strong>原文作者：</strong><a rel="author" href="https://gitop.cc">招财猫</a></li>
        <li style="word-break:break-all"><strong>原文链接：</strong><a href="https://gitop.cc/posts/Asio-Network-Programming-1/">https://gitop.cc/posts/Asio-Network-Programming-1/</a></li>
        <li><strong>版权声明：</strong>本作品采用<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li>
    </ul>
</div>
<br/>



        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/posts/cpp-primer-16/">第16章 模板和泛型编程</a></li>
        
        <li><a href="/posts/cpp-primer-15/">第15章 面向对象编程</a></li>
        
        <li><a href="/posts/cpp-primer-14/">第14章 重载操作和转换</a></li>
        
        <li><a href="/posts/Core-Python-3/">Python核心编程 第3章</a></li>
        
        <li><a href="/posts/Core-Python-2/">Python核心编程 第2章</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='https://gitop.cc/tags/C&#43;&#43;'>C&#43;&#43;</a></li>
                
            </ul>
            
        </div>
    </article>
    
    <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "yourdiscussshortname" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "your github repo"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
</div>

                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://gitop.cc/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://gitop.cc">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://gitop.cc/posts/scrapy-fundamental/" title="Scrapy爬虫基础">Scrapy爬虫基础</a>
    </li>
    
    <li>
        <a href="https://gitop.cc/posts/xpath/" title="XPath教程">XPath教程</a>
    </li>
    
    <li>
        <a href="https://gitop.cc/posts/refactoring-testing-debugging/" title="重构、测试和调试">重构、测试和调试</a>
    </li>
    
    <li>
        <a href="https://gitop.cc/posts/collection-api-enhancements/" title="Collection API增强">Collection API增强</a>
    </li>
    
    <li>
        <a href="https://gitop.cc/posts/parallel-data-processing-and-performance/" title="并行数据处理和性能">并行数据处理和性能</a>
    </li>
    
    <li>
        <a href="https://gitop.cc/posts/collecting-data-with-streams/" title="使用流收集数据">使用流收集数据</a>
    </li>
    
    <li>
        <a href="https://gitop.cc/posts/working-with-streams/" title="使用流">使用流</a>
    </li>
    
    <li>
        <a href="https://gitop.cc/posts/introducing-streams/" title="流介绍">流介绍</a>
    </li>
    
    <li>
        <a href="https://gitop.cc/posts/lambda-expressions/" title="Lambda表达式">Lambda表达式</a>
    </li>
    
    <li>
        <a href="https://gitop.cc/posts/git-multi-sshkey/" title="Git配置多个SSH-Key">Git配置多个SSH-Key</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
    <li><a href="https://gitop.cc/categories/Crawler/">Crawler (1)</a></li>
    
    <li><a href="https://gitop.cc/categories/Database/">Database (12)</a></li>
    
    <li><a href="https://gitop.cc/categories/GUI/">GUI (5)</a></li>
    
    <li><a href="https://gitop.cc/categories/Gist/">Gist (1)</a></li>
    
    <li><a href="https://gitop.cc/categories/Language/">Language (23)</a></li>
    
    <li><a href="https://gitop.cc/categories/Linux/">Linux (3)</a></li>
    
    <li><a href="https://gitop.cc/categories/Network/">Network (4)</a></li>
    
    <li><a href="https://gitop.cc/categories/Tool/">Tool (4)</a></li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="https://gitop.cc/tags/C/">C</a>
    
    <a href="https://gitop.cc/tags/C&#43;&#43;/">C&#43;&#43;</a>
    
    <a href="https://gitop.cc/tags/CentOS/">CentOS</a>
    
    <a href="https://gitop.cc/tags/Docker/">Docker</a>
    
    <a href="https://gitop.cc/tags/Git/">Git</a>
    
    <a href="https://gitop.cc/tags/Greenplum/">Greenplum</a>
    
    <a href="https://gitop.cc/tags/Idea/">Idea</a>
    
    <a href="https://gitop.cc/tags/Java/">Java</a>
    
    <a href="https://gitop.cc/tags/Javascript/">Javascript</a>
    
    <a href="https://gitop.cc/tags/Markdown/">Markdown</a>
    
    <a href="https://gitop.cc/tags/MySQL/">MySQL</a>
    
    <a href="https://gitop.cc/tags/PostgreSQL/">PostgreSQL</a>
    
    <a href="https://gitop.cc/tags/ProjectEuler/">ProjectEuler</a>
    
    <a href="https://gitop.cc/tags/Python/">Python</a>
    
    <a href="https://gitop.cc/tags/Scrapy/">Scrapy</a>
    
    <a href="https://gitop.cc/tags/Ubuntu/">Ubuntu</a>
    
    <a href="https://gitop.cc/tags/XPath/">XPath</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://gitop.cc/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
    <footer id="footer">
    <div class="container">
        &copy; 2020 <a href="https://gitop.cc">招财猫的博客 By 招财猫</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/flysnow-org/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>


<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




</body>

</html>