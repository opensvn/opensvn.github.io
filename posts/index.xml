<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on 静心</title>
		<link>https://gitop.cc/posts/</link>
		<description>Recent content in Posts on 静心</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Mon, 04 Nov 2019 17:49:51 +0800</lastBuildDate>
		<atom:link href="https://gitop.cc/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Scrapy爬虫基础</title>
			<link>https://gitop.cc/posts/scrapy-fundamental/</link>
			<pubDate>Mon, 04 Nov 2019 17:49:51 +0800</pubDate>
			
			<guid>https://gitop.cc/posts/scrapy-fundamental/</guid>
			<description>安装Scrapy 推荐virtualenv安装，步骤如下： 如果没有virtualenv，先安装virtualenv sudo pip3 install virtualenv 创建一个virtua</description>
			<content type="html"><![CDATA[

<h2 id="安装scrapy">安装Scrapy</h2>

<p>推荐virtualenv安装，步骤如下：</p>

<ol>
<li><p>如果没有virtualenv，先安装virtualenv</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo pip3 install virtualenv</code></pre></div></li>

<li><p>创建一个virtualenv环境</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">virtualenv --no-site-packages scrapy</code></pre></div></li>

<li><p>进入目录，激活virtualenv环境</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">source</span> bin/activate</code></pre></div></li>

<li><p>安装Scrapy</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">pip install Scrapy</code></pre></div></li>
</ol>

<h2 id="爬虫基本流程">爬虫基本流程</h2>

<p><img src="/static/images/2019/11/04/ur2im.png" alt="ur2im" /></p>

<h3 id="url">URL</h3>

<p>一切都从一个URL开始。您需要从您想要抓取的站点上获取一些示例url。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">scrapy shell -s <span class="nv">USER_AGENT</span><span class="o">=</span><span class="s2">&#34;Mozilla/5.0&#34;</span> http://www.gumtree.com/p/studios-bedsits-rent</code></pre></div>
<p>要在使用scrapy shell时调试问题，请添加<code>--pdb</code>参数，以便在出现异常时启用交互式调试。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">scrapy shell --pdb https://gumtree.com</code></pre></div>
<h3 id="请求和响应">请求和响应</h3>

<p>Scrapy shell为我们做了一些工作，我们给它提供了一个URL，它执行了默认的GET请求并获得了返回码200的响应。这意味着该页面上的信息已经加载并可以使用。如果尝试打印response.body的前50个字符，则会得到以下内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">response</span><span class="o">.</span><span class="n">body</span><span class="p">[:</span><span class="mi">50</span><span class="p">]</span>
<span class="s1">&#39;&lt;!DOCTYPE html&gt;</span><span class="se">\n</span><span class="s1">&lt;html&gt;</span><span class="se">\n</span><span class="s1">&lt;head&gt;</span><span class="se">\n</span><span class="s1">&lt;meta charset=&#34;UTF-8&#34;&#39;</span></code></pre></div>
<h3 id="物品">物品</h3>

<p>下一步是尝试将响应中的数据提取到物品的字段中。因为这个页面的格式是HTML，所以我们使用XPath表达式来实现。</p>

<table>
<thead>
<tr>
<th>主要字段</th>
<th>XPath表达式</th>
</tr>
</thead>

<tbody>
<tr>
<td>title</td>
<td>//*[@itemprop=&ldquo;name&rdquo;][1]/text()</td>
</tr>

<tr>
<td>price</td>
<td>//*[@itemprop=&ldquo;price&rdquo;][1]/text()</td>
</tr>

<tr>
<td>description</td>
<td>//*[@itemprop=&ldquo;description&rdquo;][1]/text()</td>
</tr>

<tr>
<td>address</td>
<td>//*[@itemtype=&ldquo;<a href="http://schema.org/Place&quot;][1]/text(">http://schema.org/Place&quot;][1]/text(</a>)</td>
</tr>

<tr>
<td>image_urls</td>
<td>//*[@itemprop=&ldquo;image&rdquo;][1]/@src</td>
</tr>
</tbody>
</table>

<h2 id="一个scrapy项目">一个Scrapy项目</h2>

<p>首先创建一个名为&rdquo;properties&rdquo;的工程：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ scrapy startproject properties</code></pre></div>
<h3 id="定义物品">定义物品</h3>

<p>让我们使用文件编辑器打开items.py。其中已经有一些模板代码，但是我们将针对我们的用例修改它。我们将重新定义PropertiesItem类，以添加我们在前一个表中总结的字段。</p>

<p>我们还会添加一些辅助字段后面会用到。需要注意的一件重要的事情是，我们声明一个字段并不意味着我们要在每个爬行器上填充它，或者甚至一起使用它。您可以随意添加任何您认为合适的字段—您可以在以后修改它们。</p>

<table>
<thead>
<tr>
<th>计算字段</th>
<th>Python表达式</th>
</tr>
</thead>

<tbody>
<tr>
<td>images</td>
<td>图像管道将根据image_urls自动填充这个。</td>
</tr>

<tr>
<td>location</td>
<td>我们的地理编码管道将在稍后填充此内容。</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th>辅助字段</th>
<th>Python表达式</th>
</tr>
</thead>

<tbody>
<tr>
<td>url</td>
<td>response.url</td>
</tr>

<tr>
<td>project</td>
<td>self.settings.get(&lsquo;BOT_NAME&rsquo;)</td>
</tr>

<tr>
<td>spider</td>
<td>self.name</td>
</tr>

<tr>
<td>server</td>
<td>socket.gethostname()</td>
</tr>

<tr>
<td>date</td>
<td>datetime.datetime.now()</td>
</tr>
</tbody>
</table>

<p>定义完这些字段，我们将items.py修改如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">scrapy.item</span> <span class="kn">import</span> <span class="n">Item</span><span class="p">,</span> <span class="n">Field</span>


<span class="k">class</span> <span class="nc">PropertiesItem</span><span class="p">(</span><span class="n">Item</span><span class="p">):</span>
    <span class="c1"># Primary fields</span>
    <span class="n">title</span> <span class="o">=</span> <span class="n">Field</span><span class="p">()</span>
    <span class="n">price</span> <span class="o">=</span> <span class="n">Field</span><span class="p">()</span>
    <span class="n">description</span> <span class="o">=</span> <span class="n">Field</span><span class="p">()</span>
    <span class="n">address</span> <span class="o">=</span> <span class="n">Field</span><span class="p">()</span>
    <span class="n">image_urls</span> <span class="o">=</span> <span class="n">Field</span><span class="p">()</span>

    <span class="c1"># Calculated fields</span>
    <span class="n">images</span> <span class="o">=</span> <span class="n">Field</span><span class="p">()</span>
    <span class="n">location</span> <span class="o">=</span> <span class="n">Field</span><span class="p">()</span>

    <span class="c1"># Housekeeping fields</span>
    <span class="n">url</span> <span class="o">=</span> <span class="n">Field</span><span class="p">()</span>
    <span class="n">project</span> <span class="o">=</span> <span class="n">Field</span><span class="p">()</span>
    <span class="n">spider</span> <span class="o">=</span> <span class="n">Field</span><span class="p">()</span>
    <span class="n">server</span> <span class="o">=</span> <span class="n">Field</span><span class="p">()</span>
    <span class="n">date</span> <span class="o">=</span> <span class="n">Field</span><span class="p">()</span></code></pre></div>
<h3 id="编写爬虫">编写爬虫</h3>

<p>一个爬虫的代码实现了整个$UR^2IM$过程。使用如下命令生成爬虫：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ scrapy genspider basic web
Created spider <span class="s1">&#39;basic&#39;</span> using template <span class="s1">&#39;basic&#39;</span> in module:
properties.spiders.basic</code></pre></div>
<p>使用如下命令查看爬虫模板列表：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">scrapy genspider -l </code></pre></div>
<p>basic.py内容如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">scrapy</span>


<span class="k">class</span> <span class="nc">BasicSpider</span><span class="p">(</span><span class="n">scrapy</span><span class="o">.</span><span class="n">Spider</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&#34;basic&#34;</span>
    <span class="n">allowed_domains</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;web&#34;</span><span class="p">]</span>
    <span class="n">start_urls</span> <span class="o">=</span> <span class="p">(</span>
    	<span class="s1">&#39;http://www.web/&#39;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">response</span><span class="p">):</span>
    	<span class="k">pass</span></code></pre></div>
<p>开始编码修改一下爬虫：</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">scrapy</span>


<span class="k">class</span> <span class="nc">BasicSpider</span><span class="p">(</span><span class="n">scrapy</span><span class="o">.</span><span class="n">Spider</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&#34;basic&#34;</span>
    <span class="n">allowed_domains</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;web&#34;</span><span class="p">]</span>
    <span class="n">start_urls</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;http://web:9312/properties/property_000000.html&#39;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">response</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&#34;title: </span><span class="si">%s</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="n">response</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span>
            <span class="s1">&#39;//*[@itemprop=&#34;name&#34;][1]/text()&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">extract</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&#34;price: </span><span class="si">%s</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="n">response</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span>
            <span class="s1">&#39;//*[@itemprop=&#34;price&#34;][1]/text()&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">re</span><span class="p">(</span><span class="s1">&#39;[.0-9]+&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&#34;description: </span><span class="si">%s</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="n">response</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span>
            <span class="s1">&#39;//*[@itemprop=&#34;description&#34;][1]/text()&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">extract</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&#34;address: </span><span class="si">%s</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="n">response</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span>
            <span class="s1">&#39;//*[@itemtype=&#34;http://schema.org/&#39;</span>
            <span class="s1">&#39;Place&#34;][1]/text()&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">extract</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&#34;image_urls: </span><span class="si">%s</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="n">response</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span>
            <span class="s1">&#39;//*[@itemprop=&#34;image&#34;][1]/@src&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">extract</span><span class="p">())</span></code></pre></div>
<p>使用如下命令运行爬虫：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ scrapy crawl basic</code></pre></div>
<h3 id="填充物品">填充物品</h3>

<p>首先我们需要导入PropertiesItem类。</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">scrapy</span>
<span class="kn">from</span> <span class="nn">properties.items</span> <span class="kn">import</span> <span class="n">PropertiesItem</span>


<span class="k">class</span> <span class="nc">BasicSpider</span><span class="p">(</span><span class="n">scrapy</span><span class="o">.</span><span class="n">Spider</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&#34;basic&#34;</span>
    <span class="n">allowed_domains</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;web&#34;</span><span class="p">]</span>
    <span class="n">start_urls</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;http://web:9312/properties/property_000000.html&#39;</span><span class="p">,</span>
    <span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">response</span><span class="p">):</span>
        <span class="n">item</span> <span class="o">=</span> <span class="n">PropertiesItem</span><span class="p">()</span>
        <span class="n">item</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span>
            <span class="s1">&#39;//*[@itemprop=&#34;name&#34;][1]/text()&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">extract</span><span class="p">()</span>
        <span class="n">item</span><span class="p">[</span><span class="s1">&#39;price&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span>
            <span class="s1">&#39;//*[@itemprop=&#34;price&#34;][1]/text()&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">re</span><span class="p">(</span><span class="s1">&#39;[.0-9]+&#39;</span><span class="p">)</span>
        <span class="n">item</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span>
            <span class="s1">&#39;//*[@itemprop=&#34;description&#34;][1]/text()&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">extract</span><span class="p">()</span>
        <span class="n">item</span><span class="p">[</span><span class="s1">&#39;address&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span>
            <span class="s1">&#39;//*[@itemtype=&#34;http://schema.org/&#39;</span>
            <span class="s1">&#39;Place&#34;][1]/text()&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">extract</span><span class="p">()</span>
        <span class="n">item</span><span class="p">[</span><span class="s1">&#39;image_urls&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span>
            <span class="s1">&#39;//*[@itemprop=&#34;image&#34;][1]/@src&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">extract</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">item</span></code></pre></div>
<h3 id="保存到文件">保存到文件</h3>

<p>以下命令可以将爬虫爬取到的数据保存到文件：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ scrapy crawl basic -o items.json
$ scrapy crawl basic -o items.jl
$ scrapy crawl basic -o items.csv
$ scrapy crawl basic -o items.xml
$ scrapy crawl basic -o <span class="s2">&#34;ftp://user:pass@ftp.scrapybook.com/items.json &#34;</span>
$ scrapy crawl basic -o <span class="s2">&#34;s3://aws_key:aws_secret@scrapybook/items.json&#34;</span></code></pre></div>
<h3 id="清理">清理</h3>

<p>我们首先使用一个很好的实用工具类ItemLoader来替换所有那些看起来很混乱的extract()和xpath()操作。通过使用它，我们的parse()方法改变如下:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">response</span><span class="p">):</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">ItemLoader</span><span class="p">(</span><span class="n">item</span><span class="o">=</span><span class="n">PropertiesItem</span><span class="p">(),</span> <span class="n">response</span><span class="o">=</span><span class="n">response</span><span class="p">)</span>

    <span class="n">l</span><span class="o">.</span><span class="n">add_xpath</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="s1">&#39;//*[@itemprop=&#34;name&#34;][1]/text()&#39;</span><span class="p">)</span>
    <span class="n">l</span><span class="o">.</span><span class="n">add_xpath</span><span class="p">(</span><span class="s1">&#39;price&#39;</span><span class="p">,</span> <span class="s1">&#39;.//*[@itemprop=&#34;price&#34;]&#39;</span>
    <span class="s1">&#39;[1]/text()&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">=</span><span class="s1">&#39;[,.0-9]+&#39;</span><span class="p">)</span>
    <span class="n">l</span><span class="o">.</span><span class="n">add_xpath</span><span class="p">(</span><span class="s1">&#39;description&#39;</span><span class="p">,</span> <span class="s1">&#39;//*[@itemprop=&#34;description&#34;]&#39;</span>
    <span class="s1">&#39;[1]/text()&#39;</span><span class="p">)</span>
    <span class="n">l</span><span class="o">.</span><span class="n">add_xpath</span><span class="p">(</span><span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;//*[@itemtype=&#39;</span>
    <span class="s1">&#39;&#34;http://schema.org/Place&#34;][1]/text()&#39;</span><span class="p">)</span>
    <span class="n">l</span><span class="o">.</span><span class="n">add_xpath</span><span class="p">(</span><span class="s1">&#39;image_urls&#39;</span><span class="p">,</span> <span class="s1">&#39;//*[@itemprop=&#34;image&#34;][1]/@src&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">l</span><span class="o">.</span><span class="n">load_item</span><span class="p">()</span></code></pre></div>
<p>itemloader提供了许多有趣的方式来组合数据、格式化数据和清理数据。其中MapCompose可以用来组合任意一个或多个Python函数来实现复杂的功能。比如：</p>

<table>
<thead>
<tr>
<th>处理器</th>
<th>功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>Join()</td>
<td>将多个结果合并成一个</td>
</tr>

<tr>
<td>MapCompose(unicode.strip)</td>
<td>删除开头和结尾的空白字符</td>
</tr>

<tr>
<td>MapCompose(unicode.strip, unicode.title)</td>
<td>删除开头和结尾的空白字符，并返回标题结果</td>
</tr>

<tr>
<td>MapCompose(float)</td>
<td>转换为数字</td>
</tr>

<tr>
<td>MapCompose(lambda i: i.replace(&lsquo;,&rsquo;, &ldquo;), float)</td>
<td>忽略&rsquo;,&lsquo;字符，并转换为数字</td>
</tr>

<tr>
<td>MapCompose(lambda i: urlparse.urljoin(response.url, i))</td>
<td>将相对路径URL转为绝对路径URL</td>
</tr>
</tbody>
</table>

<p>使用MapCompose修改过的爬虫如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">response</span><span class="p">):</span>
    <span class="n">l</span><span class="o">.</span><span class="n">add_xpath</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="s1">&#39;//*[@itemprop=&#34;name&#34;][1]/text()&#39;</span><span class="p">,</span>
                <span class="n">MapCompose</span><span class="p">(</span><span class="nb">unicode</span><span class="o">.</span><span class="n">strip</span><span class="p">,</span> <span class="nb">unicode</span><span class="o">.</span><span class="n">title</span><span class="p">))</span>
    <span class="n">l</span><span class="o">.</span><span class="n">add_xpath</span><span class="p">(</span><span class="s1">&#39;price&#39;</span><span class="p">,</span> <span class="s1">&#39;.//*[@itemprop=&#34;price&#34;][1]/text()&#39;</span><span class="p">,</span>
                <span class="n">MapCompose</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="nb">float</span><span class="p">),</span>
                <span class="n">re</span><span class="o">=</span><span class="s1">&#39;[,.0-9]+&#39;</span><span class="p">)</span>
    <span class="n">l</span><span class="o">.</span><span class="n">add_xpath</span><span class="p">(</span><span class="s1">&#39;description&#39;</span><span class="p">,</span> <span class="s1">&#39;//*[@itemprop=&#34;description&#34;][1]/text()&#39;</span><span class="p">,</span>
                <span class="n">MapCompose</span><span class="p">(</span><span class="nb">unicode</span><span class="o">.</span><span class="n">strip</span><span class="p">),</span> <span class="n">Join</span><span class="p">())</span>
    <span class="n">l</span><span class="o">.</span><span class="n">add_xpath</span><span class="p">(</span><span class="s1">&#39;address&#39;</span><span class="p">,</span>
                <span class="s1">&#39;//*[@itemtype=&#34;http://schema.org/Place&#34;][1]/text()&#39;</span><span class="p">,</span>
                <span class="n">MapCompose</span><span class="p">(</span><span class="nb">unicode</span><span class="o">.</span><span class="n">strip</span><span class="p">))</span>
    <span class="n">l</span><span class="o">.</span><span class="n">add_xpath</span><span class="p">(</span><span class="s1">&#39;image_urls&#39;</span><span class="p">,</span> <span class="s1">&#39;//*[@itemprop=&#34;image&#34;][1]/@src&#39;</span><span class="p">,</span>
                <span class="n">MapCompose</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">urlparse</span><span class="o">.</span><span class="n">urljoin</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">url</span><span class="p">,</span> <span class="n">i</span><span class="p">)))</span></code></pre></div>
<h3 id="创建合约">创建合约</h3>

<p>合约有点像spider的单元测试。它们能让你很快知道是否发生了什么坏了。合约包含在注释中，就在函数名(docstring)后面，并且以@开头。看下面一个例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">response</span><span class="p">):</span>
    <span class="s2">&#34;&#34;&#34; This function parses a property page.
</span><span class="s2">
</span><span class="s2">    @url http://web:9312/properties/property_000000.html
</span><span class="s2">    @returns items 1
</span><span class="s2">    @scrapes title price description address image_urls
</span><span class="s2">    @scrapes url project spider server date
</span><span class="s2">    &#34;&#34;&#34;</span></code></pre></div>
<p>使用名<code>scrapy check</code>检查合约是否满足：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ scrapy check basic</code></pre></div>
<h2 id="提取更多url">提取更多URL</h2>

<p>到目前为止，我们只是爬取一个URL链接。很多网站是有很多分页的。因此一个典型的爬虫在两个方向爬取：</p>

<ul>
<li>水平方向——从一个分页到另一个分页</li>
<li>垂直方向——从一个分页到列表页面</li>
</ul>

<p>将parse函数修改为：</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">response</span><span class="p">):</span>
    <span class="c1"># Get the next index URLs and yield Requests</span>
    <span class="n">next_selector</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span><span class="s1">&#39;//*[contains(@class, &#34;next&#34;)]//@href&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">next_selector</span><span class="o">.</span><span class="n">extract</span><span class="p">():</span>
        <span class="k">yield</span> <span class="n">Request</span><span class="p">(</span><span class="n">urlparse</span><span class="o">.</span><span class="n">urljoin</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">url</span><span class="p">,</span> <span class="n">url</span><span class="p">))</span>
    <span class="c1"># Get item URLs and yield Requests</span>
    <span class="n">item_selector</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="n">xpath</span><span class="p">(</span><span class="s1">&#39;//*[@itemprop=&#34;url&#34;]/@href&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">item_selector</span><span class="o">.</span><span class="n">extract</span><span class="p">():</span>
        <span class="k">yield</span> <span class="n">Request</span><span class="p">(</span><span class="n">urlparse</span><span class="o">.</span><span class="n">urljoin</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">url</span><span class="p">,</span> <span class="n">url</span><span class="p">),</span>
                      <span class="n">callback</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parse_item</span><span class="p">)</span></code></pre></div>
<h3 id="两个方向爬取使用crawlspider">两个方向爬取使用CrawlSpider</h3>

<p>前面的代码太麻烦了，Scrapy使用CrawlSpider可以简单的实现同样的工作。首先使用crawl模板创建爬虫：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ scrapy genspider -t crawl easy web</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">EasySpider</span><span class="p">(</span><span class="n">CrawlSpider</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;easy&#39;</span>
    <span class="n">allowed_domains</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;web&#34;</span><span class="p">]</span>

    <span class="c1"># Start on the first index page</span>
    <span class="n">start_urls</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;http://web:9312/properties/index_00000.html&#39;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Rules for horizontal and vertical crawling</span>
    <span class="n">rules</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">Rule</span><span class="p">(</span><span class="n">LinkExtractor</span><span class="p">(</span><span class="n">restrict_xpaths</span><span class="o">=</span><span class="s1">&#39;//*[contains(@class,&#34;next&#34;)]&#39;</span><span class="p">)),</span>
        <span class="n">Rule</span><span class="p">(</span><span class="n">LinkExtractor</span><span class="p">(</span><span class="n">restrict_xpaths</span><span class="o">=</span><span class="s1">&#39;//*[@itemprop=&#34;url&#34;]&#39;</span><span class="p">),</span>
             <span class="n">callback</span><span class="o">=</span><span class="s1">&#39;parse_item&#39;</span><span class="p">)</span>
    <span class="p">)</span></code></pre></div>]]></content>
		</item>
		
		<item>
			<title>XPath教程</title>
			<link>https://gitop.cc/posts/xpath/</link>
			<pubDate>Sat, 02 Nov 2019 13:49:25 +0800</pubDate>
			
			<guid>https://gitop.cc/posts/xpath/</guid>
			<description>XPath是什么？ XPath代表XML路径语言 XPath使用“类似路径”的语法来标识和导航XML文档中的节点 XPath包含200多个内置函数</description>
			<content type="html"><![CDATA[

<h2 id="xpath是什么">XPath是什么？</h2>

<ul>
<li>XPath代表XML路径语言</li>
<li>XPath使用“类似路径”的语法来标识和导航XML文档中的节点</li>
<li>XPath包含200多个内置函数</li>
<li>XPath是XSLT标准中的一个主要元素</li>
<li>XPath是W3C的推荐</li>
</ul>

<h3 id="xpath路径表达式">XPath路径表达式</h3>

<p>XPath使用路径表达式来选择XML文档中的节点或节点集。这些路径表达式非常类似于传统计算机文件系统中使用的路径表达式。</p>

<h3 id="xpath标准函数">XPath标准函数</h3>

<p>XPath包含200多个内置函数。有用于字符串值，数字值，布尔值，日期和时间比较，节点操作，序列操作等的功能。今天，XPath表达式也可以用于JavaScript，Java，XML Schema，PHP，Python，C和C ++，以及许多其他语言。</p>

<h2 id="xpath节点">XPath节点</h2>

<h3 id="xpath术语">XPath术语</h3>

<h4 id="节点">节点</h4>

<p>在XPath中，有七种节点：元素，属性，文本，名称空间，处理指令，注释和文档节点。XML文档被视为节点树。树的最顶端的元素叫做根元素。请看下面的XML文档：</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="cp">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>

<span class="nt">&lt;bookstore&gt;</span>
    <span class="nt">&lt;book&gt;</span>
        <span class="nt">&lt;title</span> <span class="na">lang=</span><span class="s">&#34;en&#34;</span><span class="nt">&gt;</span>Harry Potter<span class="nt">&lt;/title&gt;</span>
        <span class="nt">&lt;author&gt;</span>J K. Rowling<span class="nt">&lt;/author&gt;</span>
        <span class="nt">&lt;year&gt;</span>2005<span class="nt">&lt;/year&gt;</span>
        <span class="nt">&lt;price&gt;</span>29.99<span class="nt">&lt;/price&gt;</span>
    <span class="nt">&lt;/book&gt;</span>
<span class="nt">&lt;/bookstore&gt;</span></code></pre></div>
<p>上面的XML文档中的节点示例：</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;bookstore&gt;</span>  (根节点)
<span class="nt">&lt;author&gt;</span>J K. Rowling<span class="nt">&lt;/author&gt;</span>  (元素节点)
lang=&#34;en&#34; (属性节点)</code></pre></div>
<h4 id="原子值">原子值</h4>

<p>原子值是没有子节点或父节点的节点。原子值的例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml">J K. Rowling
&#34;en&#34;</code></pre></div>
<h4 id="项目">项目</h4>

<p>项目是原子值或节点。</p>

<h3 id="节点关系">节点关系</h3>

<h4 id="父节点">父节点</h4>

<p>每个元素和属性都有一个父节点。在上面的例子中，book元素是title，author，year和price的父节点。</p>

<h4 id="子节点">子节点</h4>

<p>元素节点可以有零个、一个或多个子节点。在上面的例子中，title，author，year和price都是book元素的子节点。</p>

<h4 id="兄弟节点">兄弟节点</h4>

<p>具有相同父节点的节点。 在上面的例子中，title，author，year和price都是兄弟节点。</p>

<h4 id="祖先节点">祖先节点</h4>

<p>节点的父节点、父节点的父节点等。在上面的例子中，book元素和bookstore元素是title的祖先节点。</p>

<h4 id="后代节点">后代节点</h4>

<p>节点的子节点、子节点的子节点等。在上面的例子中，book，title，author，year和price都是bookstore元素的后代节点。</p>

<h2 id="xpath语法">XPath语法</h2>

<h3 id="xml示例文档">XML示例文档</h3>

<p>在以下的例子中，我们将使用下面的XML文档。</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="cp">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
<span class="nt">&lt;bookstore&gt;</span>
    <span class="nt">&lt;book&gt;</span>
        <span class="nt">&lt;title</span> <span class="na">lang=</span><span class="s">&#34;en&#34;</span><span class="nt">&gt;</span>Harry Potter<span class="nt">&lt;/title&gt;</span>
        <span class="nt">&lt;price&gt;</span>29.99<span class="nt">&lt;/price&gt;</span>
    <span class="nt">&lt;/book&gt;</span>
    <span class="nt">&lt;book&gt;</span>
        <span class="nt">&lt;title</span> <span class="na">lang=</span><span class="s">&#34;en&#34;</span><span class="nt">&gt;</span>Learning XML<span class="nt">&lt;/title&gt;</span>
        <span class="nt">&lt;price&gt;</span>39.95<span class="nt">&lt;/price&gt;</span>
    <span class="nt">&lt;/book&gt;</span>
<span class="nt">&lt;/bookstore&gt;</span></code></pre></div>
<h3 id="选择节点">选择节点</h3>

<p>XPath使用路径表达式来选择XML文档中的节点。节点是按照路径或步骤选择的。下面列出了最有用的路径表达式：</p>

<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>nodename</td>
<td>选择所有名字为“nodename”的节点</td>
</tr>

<tr>
<td>/</td>
<td>选择根节点开始的某个节点</td>
</tr>

<tr>
<td>//</td>
<td>选择任意位置的某个节点</td>
</tr>

<tr>
<td>.</td>
<td>选择当前节点</td>
</tr>

<tr>
<td>..</td>
<td>选择当前节点的父节点</td>
</tr>

<tr>
<td>@</td>
<td>选择某个属性</td>
</tr>
</tbody>
</table>

<p>在下表中，我们列出了一些路径表达式和表达式的结果：</p>

<table>
<thead>
<tr>
<th>路径表达式</th>
<th>结果</th>
</tr>
</thead>

<tbody>
<tr>
<td>bookstore</td>
<td>选择所有名字为&rdquo;bookstore&rdquo;的节点</td>
</tr>

<tr>
<td>/bookstore</td>
<td>选择根节点bookstore，这是绝对路径写法</td>
</tr>

<tr>
<td>bookstore/book</td>
<td>选择所有属于bookstore子节点的book元素，这是相对路径的写法</td>
</tr>

<tr>
<td>//book</td>
<td>选择所有book元素，不管它们在文档中的位置</td>
</tr>

<tr>
<td>bookstore//book</td>
<td>选择所有属于bookstore元素后代的book元素，不管它们位于bookstore之下的什么位置</td>
</tr>

<tr>
<td>//@lang</td>
<td>选择所有名为lang的属性</td>
</tr>
</tbody>
</table>

<h3 id="谓词">谓词</h3>

<p>谓词用于查找特定节点或包含特定值的节点。谓词总是嵌入在方括号中。在下表中，我们列出了一些带有谓词的路径表达式以及表达式的结果：</p>

<table>
<thead>
<tr>
<th>路径表达式</th>
<th>结果</th>
</tr>
</thead>

<tbody>
<tr>
<td>/bookstore/book[1]</td>
<td>选择bookstore的第一个book子元素</td>
</tr>

<tr>
<td>/bookstore/book[last()]</td>
<td>选择bookstore的最后一个book子元素</td>
</tr>

<tr>
<td>/bookstore/book[last()-1]</td>
<td>选择bookstore的倒数第二个book子元素</td>
</tr>

<tr>
<td>/bookstore/book[position()&lt;3]</td>
<td>选择bookstore的前二个book子元素</td>
</tr>

<tr>
<td>//title[@lang]</td>
<td>选择所有具有lang属性的title节点</td>
</tr>

<tr>
<td>//title[@lang=&lsquo;en&rsquo;]</td>
<td>选择所有lang属性值为&rdquo;en&rdquo;的title节点</td>
</tr>

<tr>
<td>/bookstore/book[price]</td>
<td>选择bookstore的所有book子元素，且book元素必须带有price子元素</td>
</tr>

<tr>
<td>/bookstore/book[price&gt;35.00]</td>
<td>选择bookstore的所有book子元素，且book元素的price子元素值必须大于35</td>
</tr>

<tr>
<td>/bookstore/book[price&gt;35.00]/title</td>
<td>选择所有上例中的title元素</td>
</tr>

<tr>
<td>/bookstore/book/price[.&gt;35.00]</td>
<td>选择所有大于35的&rdquo;/bookstore/book&rdquo;的price子元素</td>
</tr>
</tbody>
</table>

<h3 id="选择未知节点">选择未知节点</h3>

<p>XPath通配符可用于选择未知的XML节点。</p>

<table>
<thead>
<tr>
<th>通配符</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>*</td>
<td>匹配任何元素节点</td>
</tr>

<tr>
<td>@*</td>
<td>匹配任何属性节点</td>
</tr>

<tr>
<td>node()</td>
<td>匹配任何类型的节点</td>
</tr>
</tbody>
</table>

<p>在下表中，我们列出了一些路径表达式和表达式的结果：</p>

<table>
<thead>
<tr>
<th>路径表达式</th>
<th>结果</th>
</tr>
</thead>

<tbody>
<tr>
<td>//*</td>
<td>选择所有元素节点</td>
</tr>

<tr>
<td>/*/*</td>
<td>选择所有第二层的元素节点</td>
</tr>

<tr>
<td>/bookstore/*</td>
<td>选择bookstore的所有元素子节点</td>
</tr>

<tr>
<td>//title[@*]</td>
<td>选择所有带有属性的title元素</td>
</tr>
</tbody>
</table>

<h3 id="选择多个路径">选择多个路径</h3>

<p>通过在XPath表达式中使用|操作符，你可以选择多个路径。在下表中，我们列出了一些路径表达式和表达式的结果：</p>

<table>
<thead>
<tr>
<th>路径表达式</th>
<th>结果</th>
</tr>
</thead>

<tbody>
<tr>
<td>//book/title | //book/price</td>
<td>选择所有book元素的所有title子元素和所有price子元素</td>
</tr>

<tr>
<td>//title | //price</td>
<td>选择所有title元素和所有price元素</td>
</tr>
</tbody>
</table>

<h2 id="xpath轴">XPath轴</h2>

<p>轴表示与当前节点的关系，用于定位树中相对于当前节点的节点。</p>

<table>
<thead>
<tr>
<th>轴名字</th>
<th>结果</th>
</tr>
</thead>

<tbody>
<tr>
<td>ancestor</td>
<td>选择当前节点的所有祖先节点</td>
</tr>

<tr>
<td>ancestor-or-self</td>
<td>选择当前节点的所有祖先节点或自己</td>
</tr>

<tr>
<td>attribute</td>
<td>选择当前节点的所有属性</td>
</tr>

<tr>
<td>child</td>
<td>选择当前节点的所有子节点</td>
</tr>

<tr>
<td>descendant</td>
<td>选择当前节点的所有后代节点</td>
</tr>

<tr>
<td>descendant-or-self</td>
<td>选择当前节点的所有后代节点或自己</td>
</tr>

<tr>
<td>following</td>
<td>选择当前节点的结束标记之后的文档中的所有内容</td>
</tr>

<tr>
<td>following-sibling</td>
<td>选择当前节点之后的所有兄弟节点</td>
</tr>

<tr>
<td>namespace</td>
<td>选择当前节点的所有名称空间节点</td>
</tr>

<tr>
<td>parent</td>
<td>选择当前节点的父节点</td>
</tr>

<tr>
<td>preceding</td>
<td>选择在当前节点之前的所有节点，除了祖先节点、属性节点和名称空间节点</td>
</tr>

<tr>
<td>preceding-sibling</td>
<td>选择当前节点之前的所有兄弟节点</td>
</tr>

<tr>
<td>self</td>
<td>选择当前节点</td>
</tr>
</tbody>
</table>

<h3 id="位置路径表达式">位置路径表达式</h3>

<p>位置路径可以是绝对路径或相对路径。绝对位置路径以<code>/</code>开头，而相对位置路径则不是。这两种情况下，位置路径都包含一个或多个步骤，每个步骤之间都用斜杠分隔：</p>

<pre><code>/step/step/...
step/step/...
</code></pre>

<p>每个步骤都根据当前节点集中的节点进行计算。 一个步骤包括：</p>

<ul>
<li>轴（定义所选节点和当前节点之间的树关系）</li>
<li>节点测试（标识轴内的节点）</li>
<li>零个或多个谓词（进一步优化所选节点集）</li>
</ul>

<p>步骤的语法是：</p>

<pre><code>axisname::nodetest[predicate]
</code></pre>

<h3 id="例子">例子</h3>

<table>
<thead>
<tr>
<th>例子</th>
<th>结果</th>
</tr>
</thead>

<tbody>
<tr>
<td>child::book</td>
<td>选择所有是当前节点子节点的book节点</td>
</tr>

<tr>
<td>attribute::lang</td>
<td>选择当前节点的lang属性</td>
</tr>

<tr>
<td>child::*</td>
<td>选择当前节点的所有元素子节点</td>
</tr>

<tr>
<td>attribute::*</td>
<td>选择当前节点的所有属性</td>
</tr>

<tr>
<td>child::text()</td>
<td>选择所有是当前节点子节点的text类型节点</td>
</tr>

<tr>
<td>child::node()</td>
<td>选择当前节点的所有子节点</td>
</tr>

<tr>
<td>descendant::book</td>
<td>选择当前节点的所有book后代节点</td>
</tr>

<tr>
<td>ancestor::book</td>
<td>选择当前节点的所有book祖先节点</td>
</tr>

<tr>
<td>ancestor-or-self::book</td>
<td>选择当前节点的所有book祖先节点或者自己是book节点</td>
</tr>

<tr>
<td>child::*/child::price</td>
<td>选择当前节点的所有price孙子节点</td>
</tr>
</tbody>
</table>

<h2 id="xpath运算符">XPath运算符</h2>

<p>XPath表达式返回节点集，字符串，布尔值或数字。 以下是可在XPath表达式中使用的运算符的列表：</p>

<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>

<tbody>
<tr>
<td>|</td>
<td>计算两个节点集</td>
<td>//book | //cd</td>
</tr>

<tr>
<td>+</td>
<td>加法</td>
<td>6 + 4</td>
</tr>

<tr>
<td>-</td>
<td>减法</td>
<td>6 - 4</td>
</tr>

<tr>
<td>*</td>
<td>乘法</td>
<td>6 * 4</td>
</tr>

<tr>
<td>div</td>
<td>除法</td>
<td>8 div 4</td>
</tr>

<tr>
<td>=</td>
<td>相等</td>
<td>price=9.80</td>
</tr>

<tr>
<td>!=</td>
<td>不等</td>
<td>price!=9.80</td>
</tr>

<tr>
<td>&lt;</td>
<td></td>
<td>price&lt;9.80</td>
</tr>

<tr>
<td>&lt;=</td>
<td>小于或等于</td>
<td>price&lt;=9.80</td>
</tr>

<tr>
<td>&gt;</td>
<td>大于</td>
<td>price&gt;9.80</td>
</tr>

<tr>
<td>&gt;=</td>
<td>大于或等于</td>
<td>price&gt;=9.80</td>
</tr>

<tr>
<td>or</td>
<td>逻辑或</td>
<td>price=9.80 or price=9.70</td>
</tr>

<tr>
<td>and</td>
<td>逻辑与</td>
<td>price&gt;9.00 and price&lt;9.90</td>
</tr>

<tr>
<td>mod</td>
<td>取模</td>
<td>5 mod 2</td>
</tr>
</tbody>
</table>
]]></content>
		</item>
		
		<item>
			<title>重构、测试和调试</title>
			<link>https://gitop.cc/posts/refactoring-testing-debugging/</link>
			<pubDate>Wed, 24 Jul 2019 20:30:19 +0800</pubDate>
			
			<guid>https://gitop.cc/posts/refactoring-testing-debugging/</guid>
			<description>重构以提高可读性和灵活性 提高代码的可读性 我们介绍三个简单的重构，使用lambda、方法引用和流，将它们应用到代码中，以提高代码的可读性： 将匿</description>
			<content type="html"><![CDATA[

<h2 id="重构以提高可读性和灵活性">重构以提高可读性和灵活性</h2>

<h3 id="提高代码的可读性">提高代码的可读性</h3>

<p>我们介绍三个简单的重构，使用lambda、方法引用和流，将它们应用到代码中，以提高代码的可读性：</p>

<ul>
<li>将匿名类重构为lambda表达式</li>
<li>将lambda表达式重构为方法引用</li>
<li>将命令式数据处理重构为流处理</li>
</ul>

<h3 id="从匿名类到lambda表达式">从匿名类到lambda表达式</h3>

<p>下面是使用匿名类创建一个<code>Runnable</code>对象和对应的lambda表达式：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 使用匿名类
</span><span class="c1"></span><span class="err">Runnable r1 </span><span class="o">=</span> <span class="k">new</span> <span class="n">Runnable</span><span class="p">()</span> <span class="p">{</span>
    <span class="err">public void </span><span class="n">run</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Hello&#34;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// 使用lambda
</span><span class="c1"></span><span class="err">Runnable r2 </span><span class="o">=</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Hello&#34;</span><span class="p">);</span></code></pre></div>
<p>匿名类和lambda表达式有如下区别：</p>

<ul>
<li>this和super的含义不一样：在匿名类里面，this指的是匿名类本身，但在lambda里面，this指向包含lambda表达式的类。</li>

<li><p>匿名类允许隐藏它外围作用域中的变量，lambda表达式不行。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">int a </span><span class="o">=</span> <span class="n">10</span><span class="p">;</span>
<span class="err">Runnable r1 </span><span class="o">=</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="p">{</span>
<span class="err">int a </span><span class="o">=</span> <span class="n">2</span><span class="p">;</span> <span class="c1">// Compile error
</span><span class="c1"></span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="p">};</span>

<span class="err">Runnable r2 </span><span class="o">=</span> <span class="k">new</span> <span class="n">Runnable</span><span class="p">()</span> <span class="p">{</span>
<span class="err">public void </span><span class="n">run</span><span class="p">()</span> <span class="p">{</span>
    <span class="err">int a </span><span class="o">=</span> <span class="n">2</span><span class="p">;</span> <span class="c1">// Everything is fine!
</span><span class="c1"></span>    <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">};</span></code></pre></div></li>

<li><p>将匿名类转换为lambda表达式会使代码在重载上下文中具有歧义。考虑下面的例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">interface Task </span><span class="p">{</span>
<span class="err">public void </span><span class="n">execute</span><span class="p">();</span>
<span class="p">}</span>

<span class="err">public static void doSomething</span><span class="p">(</span><span class="err">Runnable r</span><span class="p">)</span> <span class="p">{</span>
<span class="n">r</span><span class="p">.</span><span class="na">run</span><span class="p">();</span>
<span class="p">}</span>

<span class="err">public static void doSomething</span><span class="p">(</span><span class="err">Task a</span><span class="p">)</span> <span class="p">{</span>
<span class="n">r</span><span class="p">.</span><span class="na">execute</span><span class="p">();</span>
<span class="p">}</span></code></pre></div></li>
</ul>

<p>这里使用匿名类没有问题，但是使用lambda表达式会有歧义，因为<code>Runnable</code>和<code>Task</code>都是合法目标类型：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">doSomething</span><span class="p">(()</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Danger danger!!&#34;</span><span class="p">));</span> <span class="o">//</span> <span class="n">歧义</span></code></pre></div>
<p>你可以提供显式转换解决歧义：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">doSomething</span><span class="p">((</span><span class="n">Task</span><span class="p">)()</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Danger danger!!&#34;</span><span class="p">));</span></code></pre></div>
<h3 id="从lambda表达式到方法引用">从lambda表达式到方法引用</h3>

<p>Lambda表达式对于少量代码非常有用，但是方法引用更能清楚地说明代码的意图。比如下面这个例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">CaloricLevel</span><span class="p">,</span> <span class="err">List&lt;Dish&gt;&gt; dishesByCaloricLevel </span><span class="o">=</span>
    <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span><span class="n">groupingBy</span><span class="p">(</span><span class="n">dish</span> <span class="o">-&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dish</span><span class="p">.</span><span class="na">getCalories</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">400</span><span class="p">)</span> <span class="k">return</span> <span class="n">CaloricLevel</span><span class="p">.</span><span class="na">DIET</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dish</span><span class="p">.</span><span class="na">getCalories</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">700</span><span class="p">)</span> <span class="k">return</span> <span class="n">CaloricLevel</span><span class="p">.</span><span class="na">NORMAL</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">return</span> <span class="n">CaloricLevel</span><span class="p">.</span><span class="na">FAT</span><span class="p">;</span>
    <span class="p">}));</span></code></pre></div>
<p>你可以将lambda表达式提取到一个单独的方法中，并将其作为参数传递给groupingBy。代码变得更加简洁，其意图也更加明确：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">CaloricLevel</span><span class="p">,</span> <span class="err">List&lt;Dish&gt;&gt; dishesByCaloricLevel </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span><span class="n">groupingBy</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getCaloricLevel</span><span class="p">));</span></code></pre></div>
<p>此外，尽可能使用辅助静态方法，比如comparing和maxBy。这些方法是为了方法引用而设计的：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// lambda表达式
</span><span class="c1"></span><span class="n">inventory</span><span class="p">.</span><span class="na">sort</span><span class="p">((</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a1</span><span class="p">.</span><span class="na">getWeight</span><span class="p">().</span><span class="na">compareTo</span><span class="p">(</span><span class="n">a2</span><span class="p">.</span><span class="na">getWeight</span><span class="p">()));</span>
<span class="c1">// 方法引用
</span><span class="c1"></span><span class="n">inventory</span><span class="p">.</span><span class="na">sort</span><span class="p">(</span><span class="n">comparing</span><span class="p">(</span><span class="n">Apple</span><span class="o">::</span><span class="n">getWeight</span><span class="p">));</span></code></pre></div>
<p>此外，对于许多常见的约简操作（如sum、maximum），有一些内置的辅助方法可以与方法引用相结合。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">int totalCalories </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">map</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getCalories</span><span class="p">).</span><span class="na">reduce</span><span class="p">(</span><span class="n">0</span><span class="p">,</span> <span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">c1</span> <span class="o">+</span> <span class="n">c2</span><span class="p">);</span>
<span class="err">int totalCalories </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span><span class="n">summingInt</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getCalories</span><span class="p">));</span></code></pre></div>
<h3 id="从命令式数据处理到流处理">从命令式数据处理到流处理</h3>

<p>理想情况下，你应该将使用迭代器处理集合的典型数据处理模式的所有代码转换为Streams API。因为Streams API更清楚地表达了数据处理的意图，并能在幕后进行优化，利用短路和惰性求值以及多核架构。</p>

<p>下面的命令式代码表达了两个混杂在一起的模式（过滤和提取），迫使程序员在弄清楚代码功能之前必须弄清楚整个实现。此外，并行执行的代码很难编写。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">List&lt;String&gt; dishNames </span><span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="err">Dish dish </span><span class="o">:</span> <span class="n">menu</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dish</span><span class="p">.</span><span class="na">getCalories</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">300</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dishNames</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">dish</span><span class="p">.</span><span class="na">getName</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>另一种方法使用Streams API，读起来就像问题陈述，并且可以很容易地并行化:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">menu</span><span class="p">.</span><span class="na">parallelStream</span><span class="p">().</span><span class="na">filter</span><span class="p">(</span><span class="n">d</span> <span class="o">-&gt;</span> <span class="n">d</span><span class="p">.</span><span class="na">getCalories</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">300</span><span class="p">)</span>
<span class="p">.</span><span class="na">map</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getName</span><span class="p">).</span><span class="na">collect</span><span class="p">(</span><span class="n">toList</span><span class="p">());</span></code></pre></div>
<h3 id="改进代码的灵活性">改进代码的灵活性</h3>

<h4 id="采用函数接口">采用函数接口</h4>

<p>首先，没有函数接口就不能使用lambda表达式，因此你应该开始在代码库中引入它们。我们讨论两个可以重构以利用lambda表达式的常见代码模式：条件延迟执行和Execute around。</p>

<h4 id="条件延迟执行">条件延迟执行</h4>

<p>控制流语句在业务逻辑代码中混合出现是很常见的。典型的场景包括安全检查和日志记录：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">if</span> <span class="p">(</span><span class="n">logger</span><span class="p">.</span><span class="na">isLoggable</span><span class="p">(</span><span class="n">Log</span><span class="p">.</span><span class="na">FINER</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">logger</span><span class="p">.</span><span class="na">finer</span><span class="p">(</span><span class="s">&#34;Problem: &#34;</span> <span class="o">+</span> <span class="n">generateDiagnostic</span><span class="p">());</span>
<span class="p">}</span></code></pre></div>
<p>有几个问题：</p>

<ul>
<li><p>isLoggable方法将logger的状态暴露给用户代码</p></li>

<li><p>为什么每次在记录消息之前都必须查询logger对象的状态？它会打乱你的代码</p></li>
</ul>

<p>更好的方法是使用log方法在内部检查logger对象是否设置为正确的级别，然后记录消息：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">logger</span><span class="p">.</span><span class="na">log</span><span class="p">(</span><span class="n">Level</span><span class="p">.</span><span class="na">FINER</span><span class="p">,</span> <span class="s">&#34;Problem: &#34;</span> <span class="o">+</span> <span class="n">generateDiagnostic</span><span class="p">());</span></code></pre></div>
<p>这种方法更好，代码不会被if检查搞得乱七八糟，而且logger的状态不再暴露。但是这段代码仍然存在一个问题：日志消息总是被计算，即使logger没有启用。</p>

<p>Lambda表达式可以提供帮助。你需要的是一种延迟消息构造的方法，以便只在给定的条件下生成消息。可以使用如下log方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public void </span><span class="n">log</span><span class="p">(</span><span class="err">Level level</span><span class="p">,</span> <span class="err">Supplier&lt;String&gt; msgSupplier</span><span class="p">)</span></code></pre></div>
<p>现在可以这样调用：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">logger</span><span class="p">.</span><span class="na">log</span><span class="p">(</span><span class="n">Level</span><span class="p">.</span><span class="na">FINER</span><span class="p">,</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="s">&#34;Problem: &#34;</span> <span class="o">+</span> <span class="n">generateDiagnostic</span><span class="p">());</span></code></pre></div>
<p>只有在日志级别正确的情况下，log方法才会执行lambda表达式。</p>

<h4 id="execute-around">Execute around</h4>

<p>如果不同代码使用相同的准备和清理阶段，则通常可以将其放入lambda。好处是可以重用准备和清理阶段的逻辑，从而减少代码重复。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">String oneLine </span><span class="o">=</span> <span class="n">processFile</span><span class="p">((</span><span class="err">BufferedReader b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">.</span><span class="na">readLine</span><span class="p">());</span>
<span class="err">String twoLines </span><span class="o">=</span> <span class="n">processFile</span><span class="p">((</span><span class="err">BufferedReader b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">.</span><span class="na">readLine</span><span class="p">()</span> <span class="o">+</span> <span class="n">b</span><span class="p">.</span><span class="na">readLine</span><span class="p">());</span>

<span class="err">public static String processFile</span><span class="p">(</span><span class="err">BufferedReaderProcessor p</span><span class="p">)</span> <span class="err">throws IOException </span><span class="p">{</span>
    <span class="k">try</span><span class="p">(</span><span class="err">BufferedReader br </span><span class="o">=</span> <span class="k">new</span> <span class="n">BufferedReader</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">FileReader</span><span class="p">(</span><span class="s">&#34;ModernJavaInAction/chap9/data.txt&#34;</span><span class="p">)))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">.</span><span class="na">process</span><span class="p">(</span><span class="n">br</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="err">public interface </span><span class="n">BufferedReaderProcessor</span> <span class="p">{</span>
    <span class="err">String process</span><span class="p">(</span><span class="err">BufferedReader b</span><span class="p">)</span> <span class="err">throws IOException</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>
<h2 id="使用lambda重构设计模式">使用lambda重构设计模式</h2>

<h3 id="策略模式">策略模式</h3>

<p>策略模式是一种常见的设计模式，用于表示一系列算法，并让你在运行时从中进行选择。如下图：</p>

<p><img src="/static/images/2019/07/24/strategy.png" alt="strategy.png" /></p>

<p>策略模式包含3个部分：</p>

<ul>
<li>一个代表某种算法的接口</li>
<li>一个或多个接口的实现用于表示多个算法</li>
<li>一个或多个使用策略对象的用户</li>
</ul>

<p>假设您想验证文本输入对不同的条件是否正确格式化。首先定义一个接口来验证文本：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public interface </span><span class="n">ValidationStrategy</span> <span class="p">{</span>
	<span class="err">boolean execute</span><span class="p">(</span><span class="err">String s</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>接下来定义接口的2个实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public class IsAllLowerCase implements </span><span class="n">ValidationStrategy</span> <span class="p">{</span>
    <span class="err">public boolean </span><span class="n">execute</span><span class="p">(</span><span class="err">String s</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="na">matches</span><span class="p">(</span><span class="s">&#34;[a-z]+&#34;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="err">public class IsNumeric implements </span><span class="n">ValidationStrategy</span> <span class="p">{</span>
    <span class="err">public boolean </span><span class="n">execute</span><span class="p">(</span><span class="err">String s</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="na">matches</span><span class="p">(</span><span class="s">&#34;\\d+&#34;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>然后你可以使用这些不同的验证策略：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public class </span><span class="n">Validator</span> <span class="p">{</span>
    <span class="err">private final ValidationStrategy strategy</span><span class="p">;</span>

    <span class="err">public Validator</span><span class="p">(</span><span class="err">ValidationStrategy v</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="na">strategy</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="err">public boolean </span><span class="n">validate</span><span class="p">(</span><span class="err">String s</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">strategy</span><span class="p">.</span><span class="na">execute</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="err">Validator numericValidator </span><span class="o">=</span> <span class="k">new</span> <span class="n">Validator</span><span class="p">(</span><span class="k">new</span> <span class="n">IsNumeric</span><span class="p">());</span>
<span class="err">boolean b1 </span><span class="o">=</span> <span class="n">numericValidator</span><span class="p">.</span><span class="na">validate</span><span class="p">(</span><span class="s">&#34;aaaa&#34;</span><span class="p">);</span>
<span class="err">Validator lowerCaseValidator </span><span class="o">=</span> <span class="k">new</span> <span class="n">Validator</span><span class="p">(</span><span class="k">new</span> <span class="n">IsAllLowerCase</span><span class="p">());</span>
<span class="err">boolean b2 </span><span class="o">=</span> <span class="n">lowerCaseValidator</span><span class="p">.</span><span class="na">validate</span><span class="p">(</span><span class="s">&#34;bbbb&#34;</span><span class="p">);</span></code></pre></div>
<h4 id="使用lambda表达式">使用lambda表达式</h4>

<p>ValidationStrategy是一个函数接口，因此可以直接传递更简洁的lambda表达式，来实现不同的策略：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">Validator numericValidator </span><span class="o">=</span> <span class="k">new</span> <span class="n">Validator</span><span class="p">((</span><span class="err">String s</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="p">.</span><span class="na">matches</span><span class="p">(</span><span class="s">&#34;[a-z]+&#34;</span><span class="p">));</span>
<span class="err">boolean b1 </span><span class="o">=</span> <span class="n">numericValidator</span><span class="p">.</span><span class="na">validate</span><span class="p">(</span><span class="s">&#34;aaaa&#34;</span><span class="p">);</span>
<span class="err">Validator lowerCaseValidator </span><span class="o">=</span> <span class="k">new</span> <span class="n">Validator</span><span class="p">((</span><span class="err">String s</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="p">.</span><span class="na">matches</span><span class="p">(</span><span class="s">&#34;\\d+&#34;</span><span class="p">));</span>
<span class="err">boolean b2 </span><span class="o">=</span> <span class="n">lowerCaseValidator</span><span class="p">.</span><span class="na">validate</span><span class="p">(</span><span class="s">&#34;bbbb&#34;</span><span class="p">);</span></code></pre></div>
<h3 id="模板方法模式">模板方法模式</h3>

<p>模板方法模式是一种常见的模式，当你需要表示算法的大纲并具有更改其中某些部分的额外灵活性时。下面是一个模板方法模式的例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">abstract class </span><span class="n">OnlineBanking</span> <span class="p">{</span>
    <span class="err">public void </span><span class="n">processCustomer</span><span class="p">(</span><span class="err">int id</span><span class="p">)</span> <span class="p">{</span>
        <span class="err">Customer c </span><span class="o">=</span> <span class="n">Database</span><span class="p">.</span><span class="na">getCustomerWithId</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
        <span class="n">makeCustomerHappy</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="err">abstract void </span><span class="n">makeCustomerHappy</span><span class="p">(</span><span class="err">Customer c</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<h4 id="使用lambda表达式-1">使用lambda表达式</h4>

<p>你可以使用lambda表达式解决相同的问题，需要更改的部分可以使用lambda表达式：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public void </span><span class="n">processCustomer</span><span class="p">(</span><span class="err">int id</span><span class="p">,</span> <span class="err">Consumer&lt;Customer&gt; makeCustomerHappy</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">Customer c </span><span class="o">=</span> <span class="n">Database</span><span class="p">.</span><span class="na">getCustomerWithId</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
    <span class="n">makeCustomerHappy</span><span class="p">.</span><span class="na">accept</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>现在你可以通过lambda表达式插入不同的行为，而不用继承<code>OnlineBanking</code>类：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">new</span> <span class="n">OnlineBankingLambda</span><span class="p">().</span><span class="na">processCustomer</span><span class="p">(</span><span class="n">1337</span><span class="p">,</span> <span class="p">(</span><span class="err">Customer c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Hello &#34;</span> <span class="o">+</span> <span class="n">c</span><span class="p">.</span><span class="na">getName</span><span class="p">());</span></code></pre></div>
<h3 id="观察者模式">观察者模式</h3>

<p>观察者模式是一种常见的设计模式，当主体需要在发生某些事件时自动通知其他观察者。假设你要设计一个Twitter通知系统，几家报社订阅了一个新闻，并希望能收到特定新闻通知。</p>

<p>首先定义观察者接口：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">interface Observer </span><span class="p">{</span>
    <span class="err">void notify</span><span class="p">(</span><span class="err">String tweet</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>接下来定义不同的报社实现观察者接口：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">class NYTimes implements Observer </span><span class="p">{</span>
    <span class="err">public void </span><span class="n">notify</span><span class="p">(</span><span class="err">String tweet</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tweet</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">tweet</span><span class="p">.</span><span class="na">contains</span><span class="p">(</span><span class="s">&#34;money&#34;</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Breaking news in NY! &#34;</span> <span class="o">+</span> <span class="n">tweet</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="err">class Guardian implements Observer </span><span class="p">{</span>
    <span class="err">public void </span><span class="n">notify</span><span class="p">(</span><span class="err">String tweet</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tweet</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">tweet</span><span class="p">.</span><span class="na">contains</span><span class="p">(</span><span class="s">&#34;queen&#34;</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Yet more news from London... &#34;</span> <span class="o">+</span> <span class="n">tweet</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="err">class LeMonde implements Observer </span><span class="p">{</span>
    <span class="err">public void </span><span class="n">notify</span><span class="p">(</span><span class="err">String tweet</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tweet</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">tweet</span><span class="p">.</span><span class="na">contains</span><span class="p">(</span><span class="s">&#34;wine&#34;</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Today cheese, wine and news! &#34;</span> <span class="o">+</span> <span class="n">tweet</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>定义主体接口：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">interface Subject </span><span class="p">{</span>
    <span class="err">void registerObserver</span><span class="p">(</span><span class="err">Observer o</span><span class="p">);</span>
    <span class="err">void notifyObservers</span><span class="p">(</span><span class="err">String tweet</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>主体使用<code>registerObserver</code>方法注册观察者，使用<code>notifyObservers</code>方法通知观察者，接下来实现订阅类：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">class Feed implements Subject </span><span class="p">{</span>
    <span class="err">private final List&lt;Observer&gt; observers </span><span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>

    <span class="err">public void </span><span class="n">registerObserver</span><span class="p">(</span><span class="err">Observer o</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="na">observers</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="err">public void </span><span class="n">notifyObservers</span><span class="p">(</span><span class="err">String tweet</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">observers</span><span class="p">.</span><span class="na">forEach</span><span class="p">(</span><span class="n">o</span> <span class="o">-&gt;</span> <span class="n">o</span><span class="p">.</span><span class="na">notify</span><span class="p">(</span><span class="n">tweet</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h4 id="使用lambda表达式-2">使用lambda表达式</h4>

<p>观察者接口可以使用lambda表达式替换：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">f</span><span class="p">.</span><span class="na">registerObserver</span><span class="p">((</span><span class="err">String tweet</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tweet</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">tweet</span><span class="p">.</span><span class="na">contains</span><span class="p">(</span><span class="s">&#34;money&#34;</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Breaking news in NY! &#34;</span> <span class="o">+</span> <span class="n">tweet</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="n">f</span><span class="p">.</span><span class="na">registerObserver</span><span class="p">((</span><span class="err">String tweet</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tweet</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">tweet</span><span class="p">.</span><span class="na">contains</span><span class="p">(</span><span class="s">&#34;queen&#34;</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Yet more news from London... &#34;</span> <span class="o">+</span> <span class="n">tweet</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span></code></pre></div>
<h3 id="职责链模式">职责链模式</h3>

<p>责任链模式是创建处理对象链的设计模式。一个处理对象可以做一些工作并将结果传递给另一个对象，另一个对象也做一些工作并将结果传递给下一个处理对象，以此类推。</p>

<p>通常该模式是通过定义一个抽象类来实现的。这个类表示一个处理对象，并定义一个字段来跟踪后继对象。当它完成它的工作时，处理对象将它的工作移交给它的后继对象。如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public abstract class ProcessingObject</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="err">protected ProcessingObject</span><span class="o">&lt;</span><span class="err">T&gt; successor</span><span class="p">;</span>

    <span class="err">public void </span><span class="n">setSuccessor</span><span class="p">(</span><span class="err">ProcessingObject&lt;T&gt; successor</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="na">successor</span> <span class="o">=</span> <span class="n">successor</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="err">public T </span><span class="n">handle</span><span class="p">(</span><span class="err">T input</span><span class="p">)</span> <span class="p">{</span>
        <span class="err">T r </span><span class="o">=</span> <span class="n">handleWork</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">successor</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">successor</span><span class="p">.</span><span class="na">handle</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="err">abstract protected T handleWork</span><span class="p">(</span><span class="err">T input</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>下面是使用此模式的例子，你可以创建两个处理对象来执行一些文本处理：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public class HeaderTextProcessing extends </span><span class="n">ProcessingObject</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="err">public String </span><span class="n">handleWork</span><span class="p">(</span><span class="err">String text</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&#34;From Raoul, Mario and Alan: &#34;</span> <span class="o">+</span> <span class="n">text</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="err">public class SpellCheckerProcessing extends </span><span class="n">ProcessingObject</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="err">public String </span><span class="n">handleWork</span><span class="p">(</span><span class="err">String text</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">text</span><span class="p">.</span><span class="na">replaceAll</span><span class="p">(</span><span class="s">&#34;labda&#34;</span><span class="p">,</span> <span class="s">&#34;lambda&#34;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>现在你可以连接两个处理对象来创建一个操作链：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">ProcessingObject&lt;String&gt; p1 </span><span class="o">=</span> <span class="k">new</span> <span class="n">HeaderTextProcessing</span><span class="p">();</span>
<span class="err">ProcessingObject&lt;String&gt; p2 </span><span class="o">=</span> <span class="k">new</span> <span class="n">SpellCheckerProcessing</span><span class="p">();</span>
<span class="n">p1</span><span class="p">.</span><span class="na">setSuccessor</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span>
<span class="err">String result </span><span class="o">=</span> <span class="n">p1</span><span class="p">.</span><span class="na">handle</span><span class="p">(</span><span class="s">&#34;Aren&#39;t lambdas really sexy?!!&#34;</span><span class="p">);</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">result</span><span class="p">);</span></code></pre></div>
<h4 id="使用lambda表达式-3">使用lambda表达式</h4>

<p>这个模式看起来像组合函数，可以将处理对象表示为<code>Function&lt;String、String&gt;</code>或<code>UnaryOperator&lt;String&gt;</code>的实例。要将它们链接起来，可以使用andThen方法组合这些函数:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">UnaryOperator&lt;String&gt; headerProcessing </span><span class="o">=</span> <span class="p">(</span><span class="err">String text</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s">&#34;From Raoul, Mario and Alan: &#34;</span> <span class="o">+</span> <span class="n">text</span><span class="p">;</span>
<span class="err">UnaryOperator&lt;String&gt; spellCheckerProcessing </span><span class="o">=</span> <span class="p">(</span><span class="err">String text</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">text</span><span class="p">.</span><span class="na">replaceAll</span><span class="p">(</span><span class="s">&#34;labda&#34;</span><span class="p">,</span> <span class="s">&#34;lambda&#34;</span><span class="p">);</span>
<span class="n">Function</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="err">String&gt; pipeline </span><span class="o">=</span> <span class="n">headerProcessing</span><span class="p">.</span><span class="na">andThen</span><span class="p">(</span><span class="n">spellCheckerProcessing</span><span class="p">);</span>
<span class="err">String result </span><span class="o">=</span> <span class="n">pipeline</span><span class="p">.</span><span class="na">apply</span><span class="p">(</span><span class="s">&#34;Aren&#39;t lambdas really sexy?!!&#34;</span><span class="p">);</span></code></pre></div>
<h3 id="工厂模式">工厂模式</h3>

<p>工厂设计模式允许你创建对象，而无需暴露实例化逻辑：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public class </span><span class="n">ProductFactory</span> <span class="p">{</span>
    <span class="err">public static Product createProduct</span><span class="p">(</span><span class="err">String name</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="s">&#34;loan&#34;</span><span class="o">:</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Loan</span><span class="p">();</span>
            <span class="k">case</span> <span class="s">&#34;stock&#34;</span><span class="o">:</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Stock</span><span class="p">();</span>
            <span class="k">case</span> <span class="s">&#34;bond&#34;</span><span class="o">:</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Bond</span><span class="p">();</span>
            <span class="k">default</span><span class="o">:</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="p">(</span><span class="s">&#34;No such product &#34;</span> <span class="o">+</span> <span class="n">name</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h4 id="使用lambda表达式-4">使用lambda表达式</h4>

<p>我们可以像使用方法引用一样使用构造器引用，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">Supplier&lt;Product&gt; loanSupplier </span><span class="o">=</span> <span class="n">Loan</span><span class="o">::</span><span class="k">new</span><span class="p">;</span>
<span class="err">Loan loan </span><span class="o">=</span> <span class="n">loanSupplier</span><span class="p">.</span><span class="na">get</span><span class="p">();</span></code></pre></div>
<p>使用这个方法可以将前面的工厂模式重写为：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">final static </span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="err">Supplier&lt;Product&gt;&gt; map </span><span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;</span><span class="p">();</span>
<span class="kd">static</span> <span class="p">{</span>
    <span class="n">map</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;loan&#34;</span><span class="p">,</span> <span class="n">Loan</span><span class="o">::</span><span class="k">new</span><span class="p">);</span>
    <span class="n">map</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;stock&#34;</span><span class="p">,</span> <span class="n">Stock</span><span class="o">::</span><span class="k">new</span><span class="p">);</span>
    <span class="n">map</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;bond&#34;</span><span class="p">,</span> <span class="n">Bond</span><span class="o">::</span><span class="k">new</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>像工厂模式一样，你可以使用这个Map来初始化不同的产品：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public static Product createProduct</span><span class="p">(</span><span class="err">String name</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">Supplier&lt;Product&gt; p </span><span class="o">=</span> <span class="n">map</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="n">p</span><span class="p">.</span><span class="na">get</span><span class="p">();</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="p">(</span><span class="s">&#34;No such product &#34;</span> <span class="o">+</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<h2 id="测试lambda">测试lambda</h2>

<h3 id="测试可见lambda的行为">测试可见lambda的行为</h3>

<p>lambda表达式生成函数接口的实例，因此你可以测试该实例的行为：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public final static Comparator</span><span class="o">&lt;</span><span class="err">Point&gt; compareByXAndThenY </span><span class="o">=</span>
    <span class="n">comparing</span><span class="p">(</span><span class="n">Point</span><span class="o">::</span><span class="n">getX</span><span class="p">).</span><span class="na">thenComparing</span><span class="p">(</span><span class="n">Point</span><span class="o">::</span><span class="n">getY</span><span class="p">);</span>

<span class="nd">@Test</span>
<span class="err">public void </span><span class="n">testComparingTwoPoints</span><span class="p">()</span> <span class="err">throws Exception </span><span class="p">{</span>
    <span class="err">Point p1 </span><span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="p">(</span><span class="n">10</span><span class="p">,</span> <span class="n">15</span><span class="p">);</span>
    <span class="err">Point p2 </span><span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="p">(</span><span class="n">10</span><span class="p">,</span> <span class="n">20</span><span class="p">);</span>
    <span class="err">int result </span><span class="o">=</span> <span class="n">Point</span><span class="p">.</span><span class="na">compareByXAndThenY</span><span class="p">.</span><span class="na">compare</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span>
    <span class="n">assertTrue</span><span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="n">0</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<h3 id="关注使用lambda的方法的行为">关注使用lambda的方法的行为</h3>

<p>我们认为应该测试使用lambda表达式的方法的行为</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Test</span>
<span class="err">public void </span><span class="n">testMoveAllPointsRightBy</span><span class="p">()</span> <span class="err">throws Exception </span><span class="p">{</span>
    <span class="err">List&lt;Point&gt; points </span><span class="o">=</span>
        <span class="n">Arrays</span><span class="p">.</span><span class="na">asList</span><span class="p">(</span><span class="k">new</span> <span class="n">Point</span><span class="p">(</span><span class="n">5</span><span class="p">,</span> <span class="n">5</span><span class="p">),</span> <span class="k">new</span> <span class="n">Point</span><span class="p">(</span><span class="n">10</span><span class="p">,</span> <span class="n">5</span><span class="p">));</span>
    <span class="err">List&lt;Point&gt; expectedPoints </span><span class="o">=</span>
        <span class="n">Arrays</span><span class="p">.</span><span class="na">asList</span><span class="p">(</span><span class="k">new</span> <span class="n">Point</span><span class="p">(</span><span class="n">15</span><span class="p">,</span> <span class="n">5</span><span class="p">),</span> <span class="k">new</span> <span class="n">Point</span><span class="p">(</span><span class="n">20</span><span class="p">,</span> <span class="n">5</span><span class="p">));</span>
    <span class="err">List&lt;Point&gt; newPoints </span><span class="o">=</span> <span class="n">Point</span><span class="p">.</span><span class="na">moveAllPointsRightBy</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">10</span><span class="p">);</span>
    <span class="n">assertEquals</span><span class="p">(</span><span class="n">expectedPoints</span><span class="p">,</span> <span class="n">newPoints</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<h3 id="将复杂的lambda放到单独的方法中">将复杂的lambda放到单独的方法中</h3>

<p>也许你会遇到一个非常复杂的lambda表达式，包含很多逻辑。如何测试这个lambda表达式？一种策略是将lambda表达式转换为方法引用。然后可以像测试任何常规方法一样测试新方法的行为。</p>

<h3 id="测试高阶函数">测试高阶函数</h3>

<p>高阶函数比较难测试，可以用不同的lambda测试它的行为：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Test</span>
<span class="err">public void </span><span class="n">testFilter</span><span class="p">()</span> <span class="err">throws Exception </span><span class="p">{</span>
    <span class="err">List&lt;Integer&gt; numbers </span><span class="o">=</span> <span class="n">Arrays</span><span class="p">.</span><span class="na">asList</span><span class="p">(</span><span class="n">1</span><span class="p">,</span> <span class="n">2</span><span class="p">,</span> <span class="n">3</span><span class="p">,</span> <span class="n">4</span><span class="p">);</span>
    <span class="err">List&lt;Integer&gt; even </span><span class="o">=</span> <span class="n">filter</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">%</span> <span class="n">2</span> <span class="o">==</span> <span class="n">0</span><span class="p">);</span>
    <span class="err">List&lt;Integer&gt; smallerThanThree </span><span class="o">=</span> <span class="n">filter</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">3</span><span class="p">);</span>
    <span class="n">assertEquals</span><span class="p">(</span><span class="n">Arrays</span><span class="p">.</span><span class="na">asList</span><span class="p">(</span><span class="n">2</span><span class="p">,</span> <span class="n">4</span><span class="p">),</span> <span class="n">even</span><span class="p">);</span>
    <span class="n">assertEquals</span><span class="p">(</span><span class="n">Arrays</span><span class="p">.</span><span class="na">asList</span><span class="p">(</span><span class="n">1</span><span class="p">,</span> <span class="n">2</span><span class="p">),</span> <span class="n">smallerThanThree</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<h2 id="调试">调试</h2>

<h3 id="记录日志信息">记录日志信息</h3>

<p><code>peek</code>的目的是在使用流的每个元素时对其执行一个操作。它不像<code>forEach</code>那样消耗整个流，而是将其操作的元素转发给管道中的下一个操作。在下面的代码中，<code>peek</code>在流管道中的每个操作之前和之后打印中间值：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">List&lt;Integer&gt; result </span><span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="na">stream</span><span class="p">()</span>
    <span class="p">.</span><span class="na">peek</span><span class="p">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;from stream: &#34;</span> <span class="o">+</span> <span class="n">x</span><span class="p">))</span>
    <span class="p">.</span><span class="na">map</span><span class="p">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">17</span><span class="p">)</span>
    <span class="p">.</span><span class="na">peek</span><span class="p">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;after map: &#34;</span> <span class="o">+</span> <span class="n">x</span><span class="p">))</span>
    <span class="p">.</span><span class="na">filter</span><span class="p">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">%</span> <span class="n">2</span> <span class="o">==</span> <span class="n">0</span><span class="p">)</span>
    <span class="p">.</span><span class="na">peek</span><span class="p">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;after filter: &#34;</span> <span class="o">+</span> <span class="n">x</span><span class="p">))</span>
    <span class="p">.</span><span class="na">limit</span><span class="p">(</span><span class="n">3</span><span class="p">)</span>
    <span class="p">.</span><span class="na">peek</span><span class="p">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;after limit: &#34;</span> <span class="o">+</span> <span class="n">x</span><span class="p">))</span>
    <span class="p">.</span><span class="na">collect</span><span class="p">(</span><span class="n">toList</span><span class="p">());</span></code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Collection API增强</title>
			<link>https://gitop.cc/posts/collection-api-enhancements/</link>
			<pubDate>Wed, 24 Jul 2019 14:22:44 +0800</pubDate>
			
			<guid>https://gitop.cc/posts/collection-api-enhancements/</guid>
			<description>Collection工厂 Java 9引入了一些创建小型集合对象的方法，比如Arrays.asList()： List&amp;lt;String&amp;gt; friends = Arrays.asList(&amp;#34;Raphael&amp;#34;, &amp;#34;Olivia&amp;#34;, &amp;#34;Thibaut&amp;#34;); Arrays.asList()</description>
			<content type="html"><![CDATA[

<h2 id="collection工厂">Collection工厂</h2>

<p>Java 9引入了一些创建小型集合对象的方法，比如<code>Arrays.asList()</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">List&lt;String&gt; friends </span><span class="o">=</span> <span class="n">Arrays</span><span class="p">.</span><span class="na">asList</span><span class="p">(</span><span class="s">&#34;Raphael&#34;</span><span class="p">,</span> <span class="s">&#34;Olivia&#34;</span><span class="p">,</span> <span class="s">&#34;Thibaut&#34;</span><span class="p">);</span></code></pre></div>
<p><code>Arrays.asList()</code>返回一个固定大小的列表，可以对其进行更新，但不能添加或删除元素，否则抛出UnsupportedModificationException异常。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">List&lt;String&gt; friends </span><span class="o">=</span> <span class="n">Arrays</span><span class="p">.</span><span class="na">asList</span><span class="p">(</span><span class="s">&#34;Raphael&#34;</span><span class="p">,</span> <span class="s">&#34;Olivia&#34;</span><span class="p">);</span>
<span class="n">friends</span><span class="p">.</span><span class="na">set</span><span class="p">(</span><span class="n">0</span><span class="p">,</span> <span class="s">&#34;Richard&#34;</span><span class="p">);</span>
<span class="n">friends</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="s">&#34;Thibaut&#34;</span><span class="p">);</span> <span class="o">//</span> <span class="err">throws an </span><span class="n">UnsupportedOperationException</span></code></pre></div>
<p>没有<code>Arrays.asSet()</code>方法，但是可以使用一个小技巧，比如接受列表参数的HashSet构造函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">Set&lt;String&gt; friends </span><span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">Arrays</span><span class="p">.</span><span class="na">asList</span><span class="p">(</span><span class="s">&#34;Raphael&#34;</span><span class="p">,</span> <span class="s">&#34;Olivia&#34;</span><span class="p">,</span> <span class="s">&#34;Thibaut&#34;</span><span class="p">));</span></code></pre></div>
<p>或者可以使用Streams API：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">Set&lt;String&gt; friends </span><span class="o">=</span> <span class="n">Stream</span><span class="p">.</span><span class="na">of</span><span class="p">(</span><span class="s">&#34;Raphael&#34;</span><span class="p">,</span> <span class="s">&#34;Olivia&#34;</span><span class="p">,</span> <span class="s">&#34;Thibaut&#34;</span><span class="p">).</span><span class="na">collect</span><span class="p">(</span><span class="n">Collectors</span><span class="p">.</span><span class="na">toSet</span><span class="p">());</span></code></pre></div>
<p>然而，这两种解决方案都远远不够优雅，而且涉及不必要的对象分配。注意结果是一个可变Set。Java 9添加了工厂方法，让你可以更简单地创建小的List、Set或Map。</p>

<h3 id="list工厂">List工厂</h3>

<p>你可以调用<code>List.of</code>工厂方法创建一个List：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">List&lt;String&gt; friends </span><span class="o">=</span> <span class="n">List</span><span class="p">.</span><span class="na">of</span><span class="p">(</span><span class="s">&#34;Raphael&#34;</span><span class="p">,</span> <span class="s">&#34;Olivia&#34;</span><span class="p">,</span> <span class="s">&#34;Thibaut&#34;</span><span class="p">);</span></code></pre></div>
<p><code>List.of</code>生成的列表是不可更改的，不能添加或删除元素，也不能修改元素。为了防止意外错误并使用更紧凑的内部表示，元素不许为空。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">List&lt;String&gt; friends </span><span class="o">=</span> <span class="n">List</span><span class="p">.</span><span class="na">of</span><span class="p">(</span><span class="s">&#34;Raphael&#34;</span><span class="p">,</span> <span class="s">&#34;Olivia&#34;</span><span class="p">,</span> <span class="s">&#34;Thibaut&#34;</span><span class="p">);</span>
<span class="n">friends</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="s">&#34;Chih-Chun&#34;</span><span class="p">);</span> <span class="o">//</span> <span class="err">throws an </span><span class="n">UnsupportedOperationException</span></code></pre></div>
<h3 id="set工厂">Set工厂</h3>

<p>和<code>List.of</code>一样，可以使用<code>Set.of</code>从一组元素创建不可变Set：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">Set&lt;String&gt; friends </span><span class="o">=</span> <span class="n">Set</span><span class="p">.</span><span class="na">of</span><span class="p">(</span><span class="s">&#34;Raphael&#34;</span><span class="p">,</span> <span class="s">&#34;Olivia&#34;</span><span class="p">,</span> <span class="s">&#34;Thibaut&#34;</span><span class="p">);</span></code></pre></div>
<p>如果用重复元素来创建Set，将抛出IllegalArgumentException异常：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">Set&lt;String&gt; friends </span><span class="o">=</span> <span class="n">Set</span><span class="p">.</span><span class="na">of</span><span class="p">(</span><span class="s">&#34;Raphael&#34;</span><span class="p">,</span> <span class="s">&#34;Olivia&#34;</span><span class="p">,</span> <span class="s">&#34;Olivia&#34;</span><span class="p">);</span> <span class="o">//</span> <span class="n">java</span><span class="p">.</span><span class="na">lang</span><span class="p">.</span><span class="na">IllegalArgumentException</span><span class="o">:</span> <span class="err">duplicate element</span><span class="o">:</span> <span class="n">Olivia</span></code></pre></div>
<h3 id="map工厂">Map工厂</h3>

<p>在Java 9中初始化不可变Map有2中方法。第一种是使用<code>Map.of</code>，其参数在键值之间交替：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="err">Integer&gt; ageOfFriends </span><span class="o">=</span> <span class="n">Map</span><span class="p">.</span><span class="na">of</span><span class="p">(</span><span class="s">&#34;Raphael&#34;</span><span class="p">,</span> <span class="n">30</span><span class="p">,</span> <span class="s">&#34;Olivia&#34;</span><span class="p">,</span> <span class="n">25</span><span class="p">,</span> <span class="s">&#34;Thibaut&#34;</span><span class="p">,</span> <span class="n">26</span><span class="p">);</span></code></pre></div>
<p>第二种方法是使用<code>Map.ofEntries</code>，其参数为一组<code>Map.Entry&lt;K, V&gt;</code>对象。该方法需要额外的对象分配来封装键和值：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">import static </span><span class="n">java</span><span class="p">.</span><span class="na">util</span><span class="p">.</span><span class="na">Map</span><span class="p">.</span><span class="na">entry</span><span class="p">;</span>
<span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="err">Integer&gt; ageOfFriends </span><span class="o">=</span> <span class="n">Map</span><span class="p">.</span><span class="na">ofEntries</span><span class="p">(</span><span class="n">entry</span><span class="p">(</span><span class="s">&#34;Raphael&#34;</span><span class="p">,</span> <span class="n">30</span><span class="p">),</span> <span class="n">entry</span><span class="p">(</span><span class="s">&#34;Olivia&#34;</span><span class="p">,</span> <span class="n">25</span><span class="p">),</span> <span class="n">entry</span><span class="p">(</span><span class="s">&#34;Thibaut&#34;</span><span class="p">,</span> <span class="n">26</span><span class="p">));</span></code></pre></div>
<p>其中<code>Map.entry</code>是创建<code>Map.Entry</code>对象的工程方法。</p>

<h2 id="使用list和set">使用List和Set</h2>

<p>Java 8引入了一些方法到List和Set接口中：</p>

<ul>
<li>removeIf：删除匹配谓词的元素，在所有实现了List或Set接口的类中可用。</li>
<li>replaceAll：List上可用，使用一个UnaryOperator替换元素。</li>
<li>sort：List上可用，就地排序List。</li>
</ul>

<h3 id="removeif">removeIf</h3>

<p>考虑下面这个buggy例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">for</span> <span class="p">(</span><span class="err">Transaction transaction </span><span class="o">:</span> <span class="n">transactions</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Character</span><span class="p">.</span><span class="na">isDigit</span><span class="p">(</span><span class="n">transaction</span><span class="p">.</span><span class="na">getReferenceCode</span><span class="p">().</span><span class="na">charAt</span><span class="p">(</span><span class="n">0</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">transactions</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="n">transaction</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>遍历删除符合条件的元素是个很常见的用法，然而使用for循环很容易出错。<code>removeIf</code>不仅简单而且使你远离bug：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">transactions</span><span class="p">.</span><span class="na">removeIf</span><span class="p">(</span><span class="n">transaction</span> <span class="o">-&gt;</span> <span class="n">Character</span><span class="p">.</span><span class="na">isDigit</span><span class="p">(</span><span class="n">transaction</span><span class="p">.</span><span class="na">getReferenceCode</span><span class="p">().</span><span class="na">charAt</span><span class="p">(</span><span class="n">0</span><span class="p">)));</span></code></pre></div>
<h3 id="replaceall">replaceAll</h3>

<p><code>replaceAll</code>方法允许你用一个新的元素替换列表中的每个元素。使用Streams接口，可以如下处理：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">referenceCodes</span><span class="p">.</span><span class="na">stream</span><span class="p">()</span>
<span class="p">.</span><span class="na">map</span><span class="p">(</span><span class="n">code</span> <span class="o">-&gt;</span> <span class="n">Character</span><span class="p">.</span><span class="na">toUpperCase</span><span class="p">(</span><span class="n">code</span><span class="p">.</span><span class="na">charAt</span><span class="p">(</span><span class="n">0</span><span class="p">))</span> <span class="o">+</span> <span class="n">code</span><span class="p">.</span><span class="na">substring</span><span class="p">(</span><span class="n">1</span><span class="p">))</span>
<span class="p">.</span><span class="na">collect</span><span class="p">(</span><span class="n">Collectors</span><span class="p">.</span><span class="na">toList</span><span class="p">());</span></code></pre></div>
<p>这个代码返回一个新的List，如果你想要修改原有List，可以使用ListIterator，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">for</span> <span class="p">(</span><span class="err">ListIterator&lt;String&gt; iterator </span><span class="o">=</span> <span class="n">referenceCodes</span><span class="p">.</span><span class="na">listIterator</span><span class="p">();</span> <span class="n">iterator</span><span class="p">.</span><span class="na">hasNext</span><span class="p">();</span> <span class="p">)</span> <span class="p">{</span>
    <span class="err">String code </span><span class="o">=</span> <span class="n">iterator</span><span class="p">.</span><span class="na">next</span><span class="p">();</span>
    <span class="n">iterator</span><span class="p">.</span><span class="na">set</span><span class="p">(</span><span class="n">Character</span><span class="p">.</span><span class="na">toUpperCase</span><span class="p">(</span><span class="n">code</span><span class="p">.</span><span class="na">charAt</span><span class="p">(</span><span class="n">0</span><span class="p">))</span> <span class="o">+</span> <span class="n">code</span><span class="p">.</span><span class="na">substring</span><span class="p">(</span><span class="n">1</span><span class="p">));</span>
<span class="p">}</span></code></pre></div>
<p>这段代码相当冗长，而且将迭代器对象与集合对象结合使用很容易出错，因为混合了对集合的迭代和修改。在Java 8中，可以简单的使用<code>replaceAll</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">referenceCodes</span><span class="p">.</span><span class="na">replaceAll</span><span class="p">(</span><span class="n">code</span> <span class="o">-&gt;</span> <span class="n">Character</span><span class="p">.</span><span class="na">toUpperCase</span><span class="p">(</span><span class="n">code</span><span class="p">.</span><span class="na">charAt</span><span class="p">(</span><span class="n">0</span><span class="p">))</span> <span class="o">+</span> <span class="n">code</span><span class="p">.</span><span class="na">substring</span><span class="p">(</span><span class="n">1</span><span class="p">));</span></code></pre></div>
<h2 id="使用map">使用Map</h2>

<h3 id="foreach">forEach</h3>

<p>遍历Map通常不太方便，你需要使用<code>Map.Entry&lt;K, V&gt;</code>的迭代器：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">for</span> <span class="p">(</span><span class="n">Map</span><span class="p">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="err">Integer&gt; entry </span><span class="o">:</span> <span class="n">ageOfFriends</span><span class="p">.</span><span class="na">entrySet</span><span class="p">())</span> <span class="p">{</span>
    <span class="err">String friend </span><span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="na">getKey</span><span class="p">();</span>
    <span class="err">Integer age </span><span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="na">getValue</span><span class="p">();</span>
    <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">friend</span> <span class="o">+</span> <span class="s">&#34; is &#34;</span> <span class="o">+</span> <span class="n">age</span> <span class="o">+</span> <span class="s">&#34; years old&#34;</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>从Java 8开始，Map接口支持<code>forEach</code>方法，接受一个<code>BiConsumer&lt;K, V&gt;</code>参数：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">ageOfFriends</span><span class="p">.</span><span class="na">forEach</span><span class="p">((</span><span class="n">friend</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">friend</span> <span class="o">+</span> <span class="s">&#34; is &#34;</span> <span class="o">+</span>
<span class="n">age</span> <span class="o">+</span> <span class="s">&#34; years old&#34;</span><span class="p">));</span></code></pre></div>
<h3 id="sorting">Sorting</h3>

<p>有两个新方法允许按键或值对Map进行排序：</p>

<ul>
<li>Entry.comparingByValue</li>

<li><p>Entry.comparingByKey</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="err">String&gt; favouriteMovies </span><span class="o">=</span> <span class="n">Map</span><span class="p">.</span><span class="na">ofEntries</span><span class="p">(</span><span class="n">entry</span><span class="p">(</span><span class="s">&#34;Raphael&#34;</span><span class="p">,</span> <span class="s">&#34;Star Wars&#34;</span><span class="p">),</span>
<span class="n">entry</span><span class="p">(</span><span class="s">&#34;Cristina&#34;</span><span class="p">,</span> <span class="s">&#34;Matrix&#34;</span><span class="p">),</span> <span class="n">entry</span><span class="p">(</span><span class="s">&#34;Olivia&#34;</span><span class="p">,</span> <span class="s">&#34;James Bond&#34;</span><span class="p">));</span>
<span class="n">favouriteMovies</span><span class="p">.</span><span class="na">entrySet</span><span class="p">().</span><span class="na">stream</span><span class="p">().</span><span class="na">sorted</span><span class="p">(</span><span class="n">Entry</span><span class="p">.</span><span class="na">comparingByKey</span><span class="p">())</span>
<span class="p">.</span><span class="na">forEachOrdered</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="p">);</span></code></pre></div></li>
</ul>

<h3 id="getordefault">getOrDefault</h3>

<p>当查找的键不存在时，你将得到一个null值。Map支持<code>getOrDefault</code>方法，接受键和默认值作为参数：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="err">String&gt; favouriteMovies </span><span class="o">=</span> <span class="n">Map</span><span class="p">.</span><span class="na">ofEntries</span><span class="p">(</span><span class="n">entry</span><span class="p">(</span><span class="s">&#34;Raphael&#34;</span><span class="p">,</span> <span class="s">&#34;Star Wars&#34;</span><span class="p">),</span>
    <span class="n">entry</span><span class="p">(</span><span class="s">&#34;Olivia&#34;</span><span class="p">,</span> <span class="s">&#34;James Bond&#34;</span><span class="p">));</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">favouriteMovies</span><span class="p">.</span><span class="na">getOrDefault</span><span class="p">(</span><span class="s">&#34;Olivia&#34;</span><span class="p">,</span> <span class="s">&#34;Matrix&#34;</span><span class="p">));</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">favouriteMovies</span><span class="p">.</span><span class="na">getOrDefault</span><span class="p">(</span><span class="s">&#34;Thibaut&#34;</span><span class="p">,</span> <span class="s">&#34;Matrix&#34;</span><span class="p">));</span></code></pre></div>
<p>注意，如果键关联的值是null，getOrDefault仍然返回null，而且作为默认值的表达式总是被求值。</p>

<h3 id="计算模式">计算模式</h3>

<p>有时候你想要有条件地执行操作并存储其结果：</p>

<ul>
<li>computeIfAbsent：如果指定的key在Map中没有值，计算新值并添加到Map中</li>
<li>computeIfPresent：如果指定的key存在，计算新值并添加到Map中</li>
<li>compute：计算指定key的值并添加到Map中</li>
</ul>

<p><code>computeIfAbsent</code>的一个用途是缓存信息。假设你需要计算一个每一行的SHA-256，如果已经处理就不需要再次计算。假设信息使用Map缓存，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="err">byte[]&gt; dataToHash </span><span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;</span><span class="p">();</span>
<span class="err">MessageDigest messageDigest </span><span class="o">=</span> <span class="n">MessageDigest</span><span class="p">.</span><span class="na">getInstance</span><span class="p">(</span><span class="s">&#34;SHA-256&#34;</span><span class="p">);</span></code></pre></div>
<p>然后你可以遍历数据并缓存结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">lines</span><span class="p">.</span><span class="na">forEach</span><span class="p">(</span><span class="n">line</span> <span class="o">-&gt;</span> <span class="n">dataToHash</span><span class="p">.</span><span class="na">computeIfAbsent</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="k">this</span><span class="o">::</span><span class="n">calculateDigest</span><span class="p">));</span>
<span class="err">private byte</span><span class="p">[]</span> <span class="n">calculateDigest</span><span class="p">(</span><span class="err">String key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">messageDigest</span><span class="p">.</span><span class="na">digest</span><span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="na">getBytes</span><span class="p">(</span><span class="n">StandardCharsets</span><span class="p">.</span><span class="na">UTF_8</span><span class="p">));</span>
<span class="p">}</span></code></pre></div>
<p>注意，如果生成值的函数返回null，则从Map删除当前键值对。</p>

<h3 id="删除模式">删除模式</h3>

<p>从Java 8开始，Map的<code>remove</code>方法的一个重载版本，当key关联到指定的value才删除记录：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">favouriteMovies</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span></code></pre></div>
<h3 id="替换模式">替换模式</h3>

<p>有2个新方法可以替换Map中的记录：</p>

<ul>
<li>replaceAll：用<code>BiFunction</code>返回的结果替换每个记录的值</li>

<li><p>Replace：如果key存在则替换其值。另一个重载版本替换指定值。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="err">String&gt; favouriteMovies </span><span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;</span><span class="p">();</span>
<span class="n">favouriteMovies</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;Raphael&#34;</span><span class="p">,</span> <span class="s">&#34;Star Wars&#34;</span><span class="p">);</span>
<span class="n">favouriteMovies</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;Olivia&#34;</span><span class="p">,</span> <span class="s">&#34;james bond&#34;</span><span class="p">);</span>
<span class="n">favouriteMovies</span><span class="p">.</span><span class="na">replaceAll</span><span class="p">((</span><span class="n">friend</span><span class="p">,</span> <span class="n">movie</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">movie</span><span class="p">.</span><span class="na">toUpperCase</span><span class="p">());</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">favouriteMovies</span><span class="p">);</span></code></pre></div></li>
</ul>

<h3 id="合并">合并</h3>

<p><code>putAll</code>方法可以将2个Map合并：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="err">String&gt; family </span><span class="o">=</span> <span class="n">Map</span><span class="p">.</span><span class="na">ofEntries</span><span class="p">(</span><span class="n">entry</span><span class="p">(</span><span class="s">&#34;Teo&#34;</span><span class="p">,</span> <span class="s">&#34;Star Wars&#34;</span><span class="p">),</span> <span class="n">entry</span><span class="p">(</span><span class="s">&#34;Cristina&#34;</span><span class="p">,</span> <span class="s">&#34;James Bond&#34;</span><span class="p">));</span>
<span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="err">String&gt; friends </span><span class="o">=</span> <span class="n">Map</span><span class="p">.</span><span class="na">ofEntries</span><span class="p">(</span><span class="n">entry</span><span class="p">(</span><span class="s">&#34;Raphael&#34;</span><span class="p">,</span> <span class="s">&#34;Star Wars&#34;</span><span class="p">));</span>
<span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="err">String&gt; everyone </span><span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">family</span><span class="p">);</span>
<span class="n">everyone</span><span class="p">.</span><span class="na">putAll</span><span class="p">(</span><span class="n">friends</span><span class="p">);</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">everyone</span><span class="p">);</span></code></pre></div>
<p>如果需要更灵活地合并值，可以使用<code>merge</code>方法。该方法使用<code>BiFunction</code>合并具有重复键的值。假设Cristina同时出现在family和friends的Map中，但与之相关的电影却各不相同：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="err">String&gt; family </span><span class="o">=</span> <span class="n">Map</span><span class="p">.</span><span class="na">ofEntries</span><span class="p">(</span><span class="n">entry</span><span class="p">(</span><span class="s">&#34;Teo&#34;</span><span class="p">,</span> <span class="s">&#34;Star Wars&#34;</span><span class="p">),</span> <span class="n">entry</span><span class="p">(</span><span class="s">&#34;Cristina&#34;</span><span class="p">,</span> <span class="s">&#34;James Bond&#34;</span><span class="p">));</span>
<span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="err">String&gt; friends </span><span class="o">=</span> <span class="n">Map</span><span class="p">.</span><span class="na">ofEntries</span><span class="p">(</span><span class="n">entry</span><span class="p">(</span><span class="s">&#34;Raphael&#34;</span><span class="p">,</span> <span class="s">&#34;Star Wars&#34;</span><span class="p">),</span> <span class="n">entry</span><span class="p">(</span><span class="s">&#34;Cristina&#34;</span><span class="p">,</span> <span class="s">&#34;Matrix&#34;</span><span class="p">));</span></code></pre></div>
<p>使用<code>merge</code>方法可以如下处理键冲突：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="err">String&gt; everyone </span><span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">family</span><span class="p">);</span>
<span class="n">friends</span><span class="p">.</span><span class="na">forEach</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">everyone</span><span class="p">.</span><span class="na">merge</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="n">movie1</span><span class="p">,</span> <span class="n">movie2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">movie1</span> <span class="o">+</span> <span class="s">&#34; &amp; &#34;</span> <span class="o">+</span> <span class="n">movie2</span><span class="p">));</span>
<span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">everyone</span><span class="p">);</span></code></pre></div>
<p><code>merge</code>方法有一种相当复杂的方法来处理null：</p>

<ul>
<li>如果指定的键不存在或关联的值是null，merge将其与指定的非null值关联</li>
<li>否则，使用指定的重映射函数的结果替换当前值。如果重映射函数返回null，则删除当前记录</li>
</ul>

<p>也可以用<code>merge</code>实现初始化检查。假设你有一个记录电影观看次数的Map，在增加次数前需要检查电影是否在Map中：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="err">Long&gt; moviesToCount </span><span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;</span><span class="p">();</span>
<span class="err">String movieName </span><span class="o">=</span> <span class="s">&#34;JamesBond&#34;</span><span class="p">;</span>
<span class="err">long count </span><span class="o">=</span> <span class="n">moviesToCount</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">movieName</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">moviesToCount</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">movieName</span><span class="p">,</span> <span class="n">1</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">moviesToCount</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">moviename</span><span class="p">,</span> <span class="n">count</span> <span class="o">+</span> <span class="n">1</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>上面的代码可以被重写为：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">moviesToCount</span><span class="p">.</span><span class="na">merge</span><span class="p">(</span><span class="n">movieName</span><span class="p">,</span> <span class="n">1L</span><span class="p">,</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">count</span> <span class="o">+</span> <span class="n">1L</span><span class="p">);</span></code></pre></div>
<h2 id="改善的concurrenthashmap">改善的ConcurrentHashMap</h2>

<p>ConcurrentHashMap允许并发添加和更新操作，只锁定内部某些数据结构。</p>

<h3 id="reduce和search">Reduce和Search</h3>

<p>ConcurrentHashMap支持三种新的操作：</p>

<ul>
<li>forEach：对每个(key, value)执行指定的操作</li>
<li>reduce：使用指定的归纳函数将所有记录合并为一个结果</li>
<li>search：对每个(key, value)应用一个函数，直到该函数产生一个非空结果</li>
</ul>

<p>每个操作支持4种形式：</p>

<ul>
<li>操作键值：forEach，reduce，search</li>
<li>操作键：forEachKey，reduceKeys，searchKeys</li>
<li>操作值：forEachValue，reduceValues，searchValues</li>
<li>操作Map.Entry对象：forEachEntry，reduceEntries，searchEntries</li>
</ul>

<p>注意，这些操作不会锁定ConcurrentHashMap的状态。提供给这些操作的函数不应该依赖于任何顺序，也不应该依赖于计算过程中可能发生变化的任何其他对象或值。</p>

<p>此外，你需要为这些操作指定并行阈值。如果Map大小小于给定阈值，则按顺序执行操作。阈值1代表使用公共线程池实现最大的并行度，阈值为Long.MAX_VALUE表示在单个线程上运行该操作。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">ConcurrentHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="err">Long&gt; map </span><span class="o">=</span> <span class="k">new</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;&gt;</span><span class="p">();</span>
<span class="err">long parallelismThreshold </span><span class="o">=</span> <span class="n">1</span><span class="p">;</span>
<span class="err">Optional&lt;Integer&gt; maxValue </span><span class="o">=</span>
    <span class="n">Optional</span><span class="p">.</span><span class="na">ofNullable</span><span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="na">reduceValues</span><span class="p">(</span><span class="n">parallelismThreshold</span><span class="p">,</span> <span class="n">Long</span><span class="o">::</span><span class="n">max</span><span class="p">));</span></code></pre></div>
<p>每个reduce操作的原始类型版本更高效，比如reduceValuesToInt, reduceKeysToLong等等。</p>

<h3 id="计数">计数</h3>

<p><code>mappingCount</code>方法返回ConcurrentHashMap类的记录数，类型为long。你应该在新代码中使用<code>mappingCount</code>替换返回类型为int的<code>size</code>方法。</p>

<h3 id="set视图">Set视图</h3>

<p>ConcurrentHashMap类提供一个新方法<code>keySet</code>返回一个Set视图，Map的修改会反映在Set视图中，反之亦然。你可以使用静态方法<code>newKeySet</code>创建一个ConcurrentHashMap的Set视图。</p>
]]></content>
		</item>
		
		<item>
			<title>并行数据处理和性能</title>
			<link>https://gitop.cc/posts/parallel-data-processing-and-performance/</link>
			<pubDate>Tue, 23 Jul 2019 20:00:47 +0800</pubDate>
			
			<guid>https://gitop.cc/posts/parallel-data-processing-and-performance/</guid>
			<description>并行流 通过调用parallelStream方法，可以将集合转换为并行流。并行流是将元素分割成多个块的流，使用不同的线程处理每个块。因此，你可</description>
			<content type="html"><![CDATA[

<h2 id="并行流">并行流</h2>

<p>通过调用<code>parallelStream</code>方法，可以将集合转换为并行流。并行流是将元素分割成多个块的流，使用不同的线程处理每个块。因此，你可以自动划分指定操作的工作负载在多核处理器的所有核心上，并使它们一样忙。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public long </span><span class="n">sequentialSum</span><span class="p">(</span><span class="err">long n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Stream</span><span class="p">.</span><span class="na">iterate</span><span class="p">(</span><span class="n">1L</span><span class="p">,</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="p">).</span><span class="na">limit</span><span class="p">(</span><span class="n">n</span><span class="p">).</span><span class="na">reduce</span><span class="p">(</span><span class="n">0L</span><span class="p">,</span> <span class="n">Long</span><span class="o">::</span><span class="n">sum</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<h3 id="将顺序流转为并行流">将顺序流转为并行流</h3>

<p>调用<code>parallel</code>方法可以将顺序流转为并行流：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public long </span><span class="n">parallelSum</span><span class="p">(</span><span class="err">long n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Stream</span><span class="p">.</span><span class="na">iterate</span><span class="p">(</span><span class="n">1L</span><span class="p">,</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="p">).</span><span class="na">limit</span><span class="p">(</span><span class="n">n</span><span class="p">).</span><span class="na">parallel</span><span class="p">().</span><span class="na">reduce</span><span class="p">(</span><span class="n">0L</span><span class="p">,</span> <span class="n">Long</span><span class="o">::</span><span class="n">sum</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>实际上，在顺序流上并行<code>parallel</code>方法并没有对流进行任何转换。在内部设置一个布尔值，标志<code>parallel</code>后面所有的操作需要并行处理。你也许会认为通过<code>sequential</code>方法和<code>parallel</code>方法可以更精细的控制流操作，比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">stream</span><span class="p">.</span><span class="na">parallel</span><span class="p">().</span><span class="na">filter</span><span class="p">(...).</span><span class="na">sequential</span><span class="p">().</span><span class="na">map</span><span class="p">(...).</span><span class="na">parallel</span><span class="p">().</span><span class="na">reduce</span><span class="p">();</span></code></pre></div>
<p>但是<code>parallel</code>或<code>sequential</code>的最后一次调用获胜并影响整个流管道。</p>

<blockquote>
<p>配置并行流使用的线程池</p>

<p>并行流在内部使用默认的ForkJoinPool。默认情况下，它的线程数与处理器的数量相同，由Runtime.getRuntime().availableprocessors()返回。</p>

<p>但是你可以修改系统属性java.util.concurrent.ForkJoinPool.common.parallelism修改线程池大小，比如：System.setProperty(&ldquo;java.util.concurrent.ForkJoinPool.common.parallelism&rdquo;, &ldquo;12&rdquo;);</p>

<p>这是一个全局设置，因此它将影响代码中的所有并行流。不推荐修改这个值。</p>
</blockquote>

<h3 id="测量流处理性能">测量流处理性能</h3>

<p>如果使用Maven作为构建工具，那么要在项目中使用JMH，需要向pom.xml文件添加几个依赖项：</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;dependency&gt;</span>
  <span class="nt">&lt;groupId&gt;</span>org.openjdk.jmh<span class="nt">&lt;/groupId&gt;</span>
  <span class="nt">&lt;artifactId&gt;</span>jmh-core<span class="nt">&lt;/artifactId&gt;</span>
  <span class="nt">&lt;version&gt;</span>1.17.4<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
  <span class="nt">&lt;groupId&gt;</span>org.openjdk.jmh<span class="nt">&lt;/groupId&gt;</span>
  <span class="nt">&lt;artifactId&gt;</span>jmh-generator-annprocess<span class="nt">&lt;/artifactId&gt;</span>
  <span class="nt">&lt;version&gt;</span>1.17.4<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>

<span class="nt">&lt;build&gt;</span>
  <span class="nt">&lt;plugins&gt;</span>
    <span class="nt">&lt;plugin&gt;</span>
      <span class="nt">&lt;groupId&gt;</span>org.apache.maven.plugins<span class="nt">&lt;/groupId&gt;</span>
      <span class="nt">&lt;artifactId&gt;</span>maven-shade-plugin<span class="nt">&lt;/artifactId&gt;</span>
      <span class="nt">&lt;executions&gt;</span>
        <span class="nt">&lt;execution&gt;</span>
          <span class="nt">&lt;phase&gt;</span>package<span class="nt">&lt;/phase&gt;</span>
          <span class="nt">&lt;goals&gt;&lt;goal&gt;</span>shade<span class="nt">&lt;/goal&gt;&lt;/goals&gt;</span>
          <span class="nt">&lt;configuration&gt;</span>
            <span class="nt">&lt;finalName&gt;</span>benchmarks<span class="nt">&lt;/finalName&gt;</span>
            <span class="nt">&lt;transformers&gt;</span>
              <span class="nt">&lt;transformer</span> <span class="na">implementation=</span><span class="s">&#34;org.apache.maven.plugins.shade.
</span><span class="s">resource.ManifestResourceTransformer&#34;</span><span class="nt">&gt;</span>
                <span class="nt">&lt;mainClass&gt;</span>org.openjdk.jmh.Main<span class="nt">&lt;/mainClass&gt;</span>
              <span class="nt">&lt;/transformer&gt;</span>
            <span class="nt">&lt;/transformers&gt;</span>
          <span class="nt">&lt;/configuration&gt;</span>
        <span class="nt">&lt;/execution&gt;</span>
      <span class="nt">&lt;/executions&gt;</span>
    <span class="nt">&lt;/plugin&gt;</span>
  <span class="nt">&lt;/plugins&gt;</span>
<span class="nt">&lt;/build&gt;</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@BenchmarkMode</span><span class="p">(</span><span class="n">Mode</span><span class="p">.</span><span class="na">AverageTime</span><span class="p">)</span>
<span class="nd">@OutputTimeUnit</span><span class="p">(</span><span class="n">TimeUnit</span><span class="p">.</span><span class="na">MILLISECONDS</span><span class="p">)</span>
<span class="nd">@Fork</span><span class="p">(</span><span class="n">2</span><span class="p">,</span> <span class="n">jvmArgs</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;-Xms4G&#34;</span><span class="p">,</span> <span class="s">&#34;-Xmx4G&#34;</span><span class="p">})</span>
<span class="err">public class </span><span class="n">ParallelStreamBenchmark</span> <span class="p">{</span>
    <span class="err">private static final long </span><span class="n">N</span> <span class="o">=</span> <span class="n">10_000_000L</span><span class="p">;</span>

    <span class="nd">@Benchmark</span>
    <span class="err">public long </span><span class="n">sequentialSum</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Stream</span><span class="p">.</span><span class="na">iterate</span><span class="p">(</span><span class="n">1L</span><span class="p">,</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="p">).</span><span class="na">limit</span><span class="p">(</span><span class="n">N</span><span class="p">).</span><span class="na">reduce</span><span class="p">(</span><span class="n">0L</span><span class="p">,</span> <span class="n">Long</span><span class="o">::</span><span class="n">sum</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">@Benchmark</span>
    <span class="err">public long </span><span class="n">iterativeSum</span><span class="p">()</span> <span class="p">{</span>
        <span class="err">long result </span><span class="o">=</span> <span class="n">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="err">long i </span><span class="o">=</span> <span class="n">1L</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">@TearDown</span><span class="p">(</span><span class="n">Level</span><span class="p">.</span><span class="na">Invocation</span><span class="p">)</span>
    <span class="err">public void </span><span class="n">tearDown</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">System</span><span class="p">.</span><span class="na">gc</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>这说明了并行编程是多么棘手，有时甚至违反直觉。当被误用时，可能会降低程序的整体性能，因此必须了解调用并行方法的背后发生了什么。</p>

<h4 id="使用更专业的方法">使用更专业的方法</h4>

<p><code>LongStream.rangeClosed</code>相比<code>iterate</code>有2个好处：</p>

<ul>
<li>LongStream.rangeClosed直接处理原始类型long，因此没有装箱和拆箱开销。</li>

<li><p>LongStream.rangeClosed产生一个范围的数字，可以很容易地划分为独立的块。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Benchmark</span>
<span class="err">public long </span><span class="n">rangedSum</span><span class="p">()</span> <span class="p">{</span>
<span class="k">return</span> <span class="n">LongStream</span><span class="p">.</span><span class="na">rangeClosed</span><span class="p">(</span><span class="n">1</span><span class="p">,</span> <span class="n">N</span><span class="p">).</span><span class="na">reduce</span><span class="p">(</span><span class="n">0L</span><span class="p">,</span> <span class="n">Long</span><span class="o">::</span><span class="n">sum</span><span class="p">);</span>
<span class="p">}</span>

<span class="nd">@Benchmark</span>
<span class="err">public long </span><span class="n">parallelRangedSum</span><span class="p">()</span> <span class="p">{</span>
<span class="k">return</span> <span class="n">LongStream</span><span class="p">.</span><span class="na">rangeClosed</span><span class="p">(</span><span class="n">1</span><span class="p">,</span> <span class="n">N</span><span class="p">).</span><span class="na">parallel</span><span class="p">().</span><span class="na">reduce</span><span class="p">(</span><span class="n">0L</span><span class="p">,</span> <span class="n">Long</span><span class="o">::</span><span class="n">sum</span><span class="p">);</span>
<span class="p">}</span></code></pre></div></li>
</ul>

<h3 id="正确使用并行流">正确使用并行流</h3>

<p>误用并行流产生错误的主要原因是使用了改变某些共享状态的算法。下面是一种方法通过修改共享累加器来求前n个自然数之和：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public long </span><span class="n">sideEffectSum</span><span class="p">(</span><span class="err">long n</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">Accumulator accumulator </span><span class="o">=</span> <span class="k">new</span> <span class="n">Accumulator</span><span class="p">();</span>
    <span class="n">LongStream</span><span class="p">.</span><span class="na">rangeClosed</span><span class="p">(</span><span class="n">1</span><span class="p">,</span> <span class="n">n</span><span class="p">).</span><span class="na">forEach</span><span class="p">(</span><span class="n">accumulator</span><span class="o">::</span><span class="n">add</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">accumulator</span><span class="p">.</span><span class="na">total</span><span class="p">;</span>
<span class="p">}</span>

<span class="err">public class </span><span class="n">Accumulator</span> <span class="p">{</span>
    <span class="err">public long </span><span class="n">total</span> <span class="o">=</span> <span class="n">0</span><span class="p">;</span>
    <span class="err">public void </span><span class="n">add</span><span class="p">(</span><span class="err">long value</span><span class="p">)</span> <span class="p">{</span> <span class="n">total</span> <span class="o">+=</span> <span class="n">value</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>请记住，避免共享可变状态可以确保并行流产生正确的结果。</p>

<h3 id="有效地使用并行流">有效地使用并行流</h3>

<p>以下是使用并行流的一些建议：</p>

<ul>
<li>并行流并不总是比相应的顺序流快，因此在选择顺序流和并行流时，最重要的建议是使用适当的基准测试它们的性能。</li>
<li>自动装箱和拆箱操作会极大地影响性能。可能使用IntStream、LongStream和DoubleStream。</li>
<li>有些操作在并行流上的性能比在顺序流上差。特别是依赖于元素顺序的limit和findFirst之类的操作在并行流中非常昂贵。</li>
<li>考虑流管道操作的总成本，成本越高，使用并行流性能越好。</li>
<li>对于少量数据，选择并行流不是个好决定。并行处理只有几个元素的优势不足以补偿并行化过程带来的额外成本。</li>
<li>考虑流下面的数据结构是否容易分解。比如ArrayList比LinkedList更容易分割。原始类型流的<code>range</code>方法能快速分解。你也可以实现自己的<code>Spliterator</code>来完全控制分解过程。</li>
<li>流的特征以及管道的中间操作如何修改它们，会改变分解过程的性能。比如一个固定大小的流可以分成多个相等的部分，然后可以更有效地并行处理每个部分，但是<code>filter</code>操作会丢弃不可预知的元素数量，从而使流本身的大小未知。</li>
<li>考虑终端操作的合并步骤是否昂贵。</li>
</ul>

<p>下表从可分解性的角度总结了某些集合的并行友好性。</p>

<table>
<thead>
<tr>
<th>数据源</th>
<th>可分解性</th>
</tr>
</thead>

<tbody>
<tr>
<td>ArrayList</td>
<td>极好</td>
</tr>

<tr>
<td>LinkedList</td>
<td>差</td>
</tr>

<tr>
<td>IntStream.range</td>
<td>极好</td>
</tr>

<tr>
<td>Stream.iterate</td>
<td>差</td>
</tr>

<tr>
<td>HashSet</td>
<td>好</td>
</tr>

<tr>
<td>TreeSet</td>
<td>好</td>
</tr>
</tbody>
</table>

<h2 id="fork-join框架">fork/join框架</h2>

<p>fork/join框架的设计目的是递归地将一个可并行化的任务分解为更小的任务，然后将每个子任务的结果组合起来，以生成总体结果。它是ExecutorService接口的实现，该接口将这些子任务分发给线程池（称为ForkJoinPool）中的工作线程。</p>

<h3 id="使用recursivetask">使用RecursiveTask</h3>

<p>想要提交任务到线程池，你需要创建一个<code>RecursiveTask&lt;R&gt;</code>子类，其中R是并行任务产生的结果类型。如果任务不返回任何结果，则需要创建<code>RecursiveAction</code>的子类。要定义<code>RecursiveTask</code>，只需要实现它的一个抽象方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">protected abstract R compute</span><span class="p">();</span></code></pre></div>
<p>该方法定义了将任务分解为子任务的逻辑，以及生成单个子任务结果的算法。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public class ForkJoinSumCalculator extends </span><span class="n">java</span><span class="p">.</span><span class="na">util</span><span class="p">.</span><span class="na">concurrent</span><span class="p">.</span><span class="na">RecursiveTask</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="err">private final long[] numbers</span><span class="p">;</span>
    <span class="err">private final int start</span><span class="p">;</span>
    <span class="err">private final int end</span><span class="p">;</span>
    <span class="err">public static final long </span><span class="n">THRESHOLD</span> <span class="o">=</span> <span class="n">10_000</span><span class="p">;</span>

    <span class="err">public ForkJoinSumCalculator</span><span class="p">(</span><span class="err">long[] numbers</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="n">0</span><span class="p">,</span> <span class="n">numbers</span><span class="p">.</span><span class="na">length</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="err">private ForkJoinSumCalculator</span><span class="p">(</span><span class="err">long[] numbers</span><span class="p">,</span> <span class="err">int start</span><span class="p">,</span> <span class="err">int end</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="na">numbers</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="na">start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="na">end</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">@Override</span>
    <span class="err">protected Long </span><span class="n">compute</span><span class="p">()</span> <span class="p">{</span>
        <span class="err">int length </span><span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&lt;=</span> <span class="n">THRESHOLD</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">computeSequentially</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="err">ForkJoinSumCalculator leftTask </span><span class="o">=</span>
            <span class="k">new</span> <span class="n">ForkJoinSumCalculator</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">length</span> <span class="o">/</span> <span class="n">2</span><span class="p">);</span>
        <span class="n">leftTask</span><span class="p">.</span><span class="na">fork</span><span class="p">();</span>
        <span class="err">ForkJoinSumCalculator rightTask </span><span class="o">=</span>
            <span class="k">new</span> <span class="n">ForkJoinSumCalculator</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">length</span> <span class="o">/</span> <span class="n">2</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
        <span class="err">Long rightResult </span><span class="o">=</span> <span class="n">rightTask</span><span class="p">.</span><span class="na">compute</span><span class="p">();</span>
        <span class="err">Long leftResult </span><span class="o">=</span> <span class="n">leftTask</span><span class="p">.</span><span class="na">join</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">leftResult</span> <span class="o">+</span> <span class="n">rightResult</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="err">private long </span><span class="n">computeSequentially</span><span class="p">()</span> <span class="p">{</span>
        <span class="err">long sum </span><span class="o">=</span> <span class="n">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="err">int i </span><span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="err">public static long forkJoinSum</span><span class="p">(</span><span class="err">long n</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">long[] numbers </span><span class="o">=</span> <span class="n">LongStream</span><span class="p">.</span><span class="na">rangeClosed</span><span class="p">(</span><span class="n">1</span><span class="p">,</span> <span class="n">n</span><span class="p">).</span><span class="na">toArray</span><span class="p">();</span>
    <span class="err">ForkJoinTask&lt;Long&gt; task </span><span class="o">=</span> <span class="k">new</span> <span class="n">ForkJoinSumCalculator</span><span class="p">(</span><span class="n">numbers</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">ForkJoinPool</span><span class="p">().</span><span class="na">invoke</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<h3 id="使用fork-join框架的最佳实践">使用fork/join框架的最佳实践</h3>

<p>尽管fork/join框架相对容易使用，但它也很容易被误用。下面是一些有效使用它的最佳实践：</p>

<ul>
<li>在任务上调用<code>join</code>方法会阻塞调用者，直到该任务生成的结果就绪为止。因此必须在启动两个子任务的计算之后调用它。</li>
<li>不应该在<code>RecursiveTask</code>中调用<code>ForkJoinPool</code>的<code>invoke</code>方法。只有顺序代码才应该使用<code>invoke</code>开始并行计算。</li>
<li>在子任务上调用fork方法实际上是将任务放入ForkJoinPool。在其中一个子任务上直接调用compute可以重用一个的线程，避免在池中不必要地分配另一个任务而造成的开销。</li>
<li>调试使用fort/join框架的并行计算比较棘手，因为在不同的线程执行计算。</li>
<li>和使用并行流一样，不能想当然地认为在多核处理器上使用fork/join框架进行计算比顺序处理会更快。一个任务应该可以分解为几个独立的子任务，以便能够获得相应的性能提升。这些子任务的执行时间应该比创建一个新任务时间要长。</li>
</ul>

<h3 id="工作窃取">工作窃取</h3>

<p>ForkJoinPool中每个线程都持有一个双链表，包含分配给它的任务。每完成一个任务，线程从队列头部取出另一个任务并开始执行。但是由于一些原因，一个线程可能比其他线程更快地完成分配给它的所有任务，这意味着当其他线程仍然非常忙时，它的队列将变为空。在这种情况下，该线程会随机选择另一个线程的工作队列，并从队列尾部“窃取”任务。这个过程一直进行直到所有任务都完成。这就是为什么有许多较小的任务，而不是只有几个较大的任务，可以帮助更好地平衡工作线程之间的工作负载。</p>

<h2 id="spliterator">Spliterator</h2>

<p>Spliterator是Java 8新增的一个接口。Collection接口提供了一个默认方法spliterator()，返回一个spliterator对象。Spliterator接口定义了几个方法，如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public interface </span><span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="err">boolean tryAdvance</span><span class="p">(</span><span class="n">Consumer</span><span class="o">&lt;?</span> <span class="err">super T</span><span class="o">&gt;</span> <span class="n">action</span><span class="p">);</span>
    <span class="err">Spliterator&lt;T&gt; trySplit</span><span class="p">();</span>
    <span class="err">long estimateSize</span><span class="p">();</span>
    <span class="err">int characteristics</span><span class="p">();</span>
<span class="p">}</span></code></pre></div>
<p><code>tryAdvance</code>方法与普通迭代器类似，用于顺序遍历Spliterator的元素，如果还有其他元素要遍历，则返回true。</p>

<p><code>trySplit</code>方法用于将其部分元素分割到第二个Spliterator，从而允许并行处理这两个Spliterator。</p>

<p><code>estimateSize</code>方法估计剩余要遍历的元素的数量。</p>

<h3 id="分裂过程">分裂过程</h3>

<p>将一个流分成多个部分是一个递归过程。首先，在第一个Spliterator上调用trySplit并生成第二个Spliterator。然后在这两个spliterator上再次调用trySplit，得到四个Spliterator。不断调用方法trySplit，直到返回null，说明正在处理的数据是不可再分割的。当所有Spliterators调用trySplit返回null时，分裂过程终止。分裂过程会受到Spliterator本身的特性的影响，它们由<code>characteristics</code>方法声明的。</p>

<h4 id="spliterator特征">Spliterator特征</h4>

<p><code>characteristics</code>方法返回一个int，包含一组Spliterator的特征。可以使用这些特性更好地控制和优化Spliterator使用。</p>

<table>
<thead>
<tr>
<th>特征</th>
<th>意义</th>
</tr>
</thead>

<tbody>
<tr>
<td>ORDERED</td>
<td>元素有顺序，因此Spliterator在遍历和分区时保持这个顺序</td>
</tr>

<tr>
<td>DISTINCT</td>
<td>所有元素唯一</td>
</tr>

<tr>
<td>SORTED</td>
<td>遍历的元素遵循预定义的排序顺序</td>
</tr>

<tr>
<td>SIZED</td>
<td>遍历的元素大小已知</td>
</tr>

<tr>
<td>NON_NULL</td>
<td>元素非空</td>
</tr>

<tr>
<td>IMMUTABLE</td>
<td>数据源不能修改</td>
</tr>

<tr>
<td>CONCURRENT</td>
<td>可并行</td>
</tr>

<tr>
<td>SUBSIZED</td>
<td>所有的Spliterator大小已知</td>
</tr>
</tbody>
</table>

<h3 id="实现自己的spliterator">实现自己的Spliterator</h3>

<p>我们将开发一个简单的方法来计算字符串中的单词数量。其迭代版如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public int </span><span class="n">countWordsIteratively</span><span class="p">(</span><span class="err">String s</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">int counter </span><span class="o">=</span> <span class="n">0</span><span class="p">;</span>
    <span class="err">boolean lastSpace </span><span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="err">char c </span><span class="o">:</span> <span class="n">s</span><span class="p">.</span><span class="na">toCharArray</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Character</span><span class="p">.</span><span class="na">isWhitespace</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">lastSpace</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">lastSpace</span><span class="p">)</span> <span class="n">counter</span><span class="o">++</span><span class="p">;</span>
            <span class="n">lastSpace</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">counter</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>
<h4 id="函数风格重写单词计数器">函数风格重写单词计数器</h4>

<p>首先，需要将字符串转换为流</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">Stream&lt;Character&gt; stream </span><span class="o">=</span> <span class="n">IntStream</span><span class="p">.</span><span class="na">range</span><span class="p">(</span><span class="n">0</span><span class="p">,</span> <span class="n">SENTENCE</span><span class="p">.</span><span class="na">length</span><span class="p">()).</span><span class="na">mapToObj</span><span class="p">(</span><span class="n">SENTENCE</span><span class="o">::</span><span class="n">charAt</span><span class="p">);</span></code></pre></div>
<p>定义一个类WordCounter用于携带2个状态，一个是目前为止找到的单词数量，一个是最后字符是否为空格。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">class WordCounter </span><span class="p">{</span>
    <span class="err">private final int counter</span><span class="p">;</span>
    <span class="err">private final boolean lastSpace</span><span class="p">;</span>

    <span class="err">public WordCounter</span><span class="p">(</span><span class="err">int counter</span><span class="p">,</span> <span class="err">boolean lastSpace</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="na">counter</span> <span class="o">=</span> <span class="n">counter</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="na">lastSpace</span> <span class="o">=</span> <span class="n">lastSpace</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="err">public WordCounter </span><span class="n">accumulate</span><span class="p">(</span><span class="err">Character c</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Character</span><span class="p">.</span><span class="na">isWhitespace</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">lastSpace</span> <span class="o">?</span> <span class="k">this</span> <span class="o">:</span> <span class="k">new</span> <span class="n">WordCounter</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">lastSpace</span> <span class="o">?</span> <span class="k">new</span> <span class="n">WordCounter</span><span class="p">(</span><span class="n">counter</span> <span class="o">+</span> <span class="n">1</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span> <span class="o">:</span> <span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="err">public WordCounter </span><span class="n">combine</span><span class="p">(</span><span class="err">WordCounter wordCounter</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">WordCounter</span><span class="p">(</span><span class="n">counter</span> <span class="o">+</span> <span class="n">wordCounter</span><span class="p">.</span><span class="na">counter</span><span class="p">,</span>
            <span class="n">wordCounter</span><span class="p">.</span><span class="na">lastSpace</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="err">public int </span><span class="n">getCounter</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">counter</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>如下所示计算流中的单词数：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">private int </span><span class="n">countWords</span><span class="p">(</span><span class="err">Stream&lt;Character&gt; stream</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">WordCounter wordCounter </span><span class="o">=</span> <span class="n">stream</span><span class="p">.</span><span class="na">reduce</span><span class="p">(</span><span class="k">new</span> <span class="n">WordCounter</span><span class="p">(</span><span class="n">0</span><span class="p">,</span> <span class="kc">true</span><span class="p">),</span>
        <span class="n">WordCounter</span><span class="o">::</span><span class="n">accumulate</span><span class="p">,</span>
        <span class="n">WordCounter</span><span class="o">::</span><span class="n">combine</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">wordCounter</span><span class="p">.</span><span class="na">getCounter</span><span class="p">();</span>
<span class="p">}</span></code></pre></div>
<h4 id="使单词计数器并行工作">使单词计数器并行工作</h4>

<p>解决方案需确保字符串不是在随机位置拆分，而只在单词末尾拆分。所以需要实现一个字符Spliterator，只在两个单词之间分割字符串，然后从中创建并行流。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">class WordCounterSpliterator implements Spliterator</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="err">private final String string</span><span class="p">;</span>
    <span class="err">private int </span><span class="n">currentChar</span> <span class="o">=</span> <span class="n">0</span><span class="p">;</span>

    <span class="err">public WordCounterSpliterator</span><span class="p">(</span><span class="err">String string</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="na">string</span> <span class="o">=</span> <span class="n">string</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">@Override</span>
    <span class="err">public boolean </span><span class="n">tryAdvance</span><span class="p">(</span><span class="n">Consumer</span><span class="o">&lt;?</span> <span class="err">super Character</span><span class="o">&gt;</span> <span class="n">action</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">action</span><span class="p">.</span><span class="na">accept</span><span class="p">(</span><span class="n">string</span><span class="p">.</span><span class="na">charAt</span><span class="p">(</span><span class="n">currentChar</span><span class="o">++</span><span class="p">));</span>
        <span class="k">return</span> <span class="n">currentChar</span> <span class="o">&lt;</span> <span class="n">string</span><span class="p">.</span><span class="na">length</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="nd">@Override</span>
    <span class="err">public Spliterator</span><span class="o">&lt;</span><span class="err">Character&gt; trySplit</span><span class="p">()</span> <span class="p">{</span>
        <span class="err">int currentSize </span><span class="o">=</span> <span class="n">string</span><span class="p">.</span><span class="na">length</span><span class="p">()</span> <span class="o">-</span> <span class="n">currentChar</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">currentSize</span> <span class="o">&lt;</span> <span class="n">10</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="err">int splitPos </span><span class="o">=</span> <span class="n">currentSize</span> <span class="o">/</span> <span class="n">2</span> <span class="o">+</span> <span class="n">currentChar</span><span class="p">;</span>
             <span class="n">splitPos</span> <span class="o">&lt;</span> <span class="n">string</span><span class="p">.</span><span class="na">length</span><span class="p">();</span> <span class="n">splitPos</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">Character</span><span class="p">.</span><span class="na">isWhitespace</span><span class="p">(</span><span class="n">string</span><span class="p">.</span><span class="na">charAt</span><span class="p">(</span><span class="n">splitPos</span><span class="p">)))</span> <span class="p">{</span>
                <span class="err">Spliterator&lt;Character&gt; spliterator </span><span class="o">=</span>
                    <span class="k">new</span> <span class="n">WordCounterSpliterator</span><span class="p">(</span><span class="n">string</span><span class="p">.</span><span class="na">substring</span><span class="p">(</span><span class="n">currentChar</span><span class="p">,</span>
                        <span class="n">splitPos</span><span class="p">));</span>
                <span class="n">currentChar</span> <span class="o">=</span> <span class="n">splitPos</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">spliterator</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">@Override</span>
    <span class="err">public long </span><span class="n">estimateSize</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">string</span><span class="p">.</span><span class="na">length</span><span class="p">()</span> <span class="o">-</span> <span class="n">currentChar</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">@Override</span>
    <span class="err">public int </span><span class="n">characteristics</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">ORDERED</span> <span class="o">+</span> <span class="n">SIZED</span> <span class="o">+</span> <span class="n">SUBSIZED</span> <span class="o">+</span> <span class="n">NON_NULL</span> <span class="o">+</span> <span class="n">IMMUTABLE</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h4 id="使单词计数器spliterator工作">使单词计数器Spliterator工作</h4>

<p>现在可以使用这个并行流，如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">Spliterator&lt;Character&gt; spliterator </span><span class="o">=</span> <span class="k">new</span> <span class="n">WordCounterSpliterator</span><span class="p">(</span><span class="n">SENTENCE</span><span class="p">);</span>
<span class="err">Stream&lt;Character&gt; stream </span><span class="o">=</span> <span class="n">StreamSupport</span><span class="p">.</span><span class="na">stream</span><span class="p">(</span><span class="n">spliterator</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span></code></pre></div>
<p>Spliterator的最后一个显著特性是，可以绑定要在第一次遍历、第一次拆分或第一次查询时(而不是在创建时)遍历的元素的数据源，称为后期绑定Spliterator。</p>
]]></content>
		</item>
		
		<item>
			<title>使用流收集数据</title>
			<link>https://gitop.cc/posts/collecting-data-with-streams/</link>
			<pubDate>Tue, 23 Jul 2019 13:04:54 +0800</pubDate>
			
			<guid>https://gitop.cc/posts/collecting-data-with-streams/</guid>
			<description>假设有一个事务列表，你希望根据货币对它们进行分组。在Java 8之前，即使是这样一个简单的例子也很难实现，如下所示： Map&amp;lt;Currency, List&amp;lt;Transaction&amp;gt;&amp;gt; transactionsByCurrencies = new HashMap&amp;lt;&amp;gt;(); for (Transaction transaction : transactions) { Currency</description>
			<content type="html"><![CDATA[

<p>假设有一个事务列表，你希望根据货币对它们进行分组。在Java 8之前，即使是这样一个简单的例子也很难实现，如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">Currency</span><span class="p">,</span> <span class="err">List&lt;Transaction&gt;&gt; transactionsByCurrencies </span><span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="err">Transaction transaction </span><span class="o">:</span> <span class="n">transactions</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">Currency currency </span><span class="o">=</span> <span class="n">transaction</span><span class="p">.</span><span class="na">getCurrency</span><span class="p">();</span>
	<span class="err">List&lt;Transaction&gt; transactionsForCurrency </span><span class="o">=</span> <span class="n">transactionsByCurrencies</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">currency</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transactionsForCurrency</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transactionsForCurrency</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>
		<span class="n">transactionsByCurrencies</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">currency</span><span class="p">,</span> <span class="n">transactionsForCurrency</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">transactionsForCurrency</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">transaction</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>在Java 8之后，仅用一条语句就可以获得完全相同的结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">Currency</span><span class="p">,</span> <span class="err">List&lt;Transaction&gt;&gt; transactionsByCurrencies </span><span class="o">=</span> <span class="n">transactions</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span><span class="n">groupingBy</span><span class="p">(</span><span class="n">Transaction</span><span class="o">::</span><span class="n">getCurrency</span><span class="p">));</span></code></pre></div>
<p>Collector接口提供了三个主要功能：</p>

<ul>
<li>将流中的元素汇总为一个值</li>

<li><p>将元素进行分组</p></li>

<li><p>将元素进行分区</p></li>
</ul>

<h2 id="归纳总结">归纳总结</h2>

<p>Collector接口（collect方法的参数）通常用于需要将流的元素重新组织到集合中的情况。但更一般的情况是，Collector接口可以用于将流中的所有元素组合成一个结果时。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">long howManyDishes </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span><span class="n">Collectors</span><span class="p">.</span><span class="na">counting</span><span class="p">());</span></code></pre></div>
<p>也可以写成</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">long howManyDishes </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">count</span><span class="p">();</span></code></pre></div>
<h3 id="查找最大和最小值">查找最大和最小值</h3>

<p>你可以使用<code>Collectors.maxBy</code> 和<code>Collectors.minBy</code> 计算流中的最大值和最小值。它们的参数是<code>Comparator</code></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">Comparator&lt;Dish&gt; dishCaloriesComparator </span><span class="o">=</span> <span class="n">Comparator</span><span class="p">.</span><span class="na">comparingInt</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getCalories</span><span class="p">);</span>
<span class="err">Optional&lt;Dish&gt; mostCalorieDish </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span><span class="n">maxBy</span><span class="p">(</span><span class="n">dishCaloriesComparator</span><span class="p">));</span></code></pre></div>
<h3 id="总结">总结</h3>

<p>Collectors类提供了用于求和的特定工厂方法<code>Collectors.summingInt</code>，其参数是<code>ToIntFunction</code>，并返回一个Collector。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">int totalCalories </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span><span class="n">summingInt</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getCalories</span><span class="p">));</span></code></pre></div>
<p><code>Collectors.summingLong</code> 和<code>Collectors.summingDouble</code> 方法类似用于计算long和double。<code>Collectors.averagingInt</code> ，<code>averagingLong</code> 和<code>averagingDouble</code> 用于计算一组值的平均值。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">double avgCalories </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span><span class="n">averagingInt</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getCalories</span><span class="p">));</span></code></pre></div>
<p>有时候你想要获取更多统计信息，可以使用<code>Collectors.summarizingInt</code>。这个Collector将所有信息收集到<code>IntSummaryStatistics</code>类里面。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">IntSummaryStatistics menuStatistics </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span><span class="n">summarizingInt</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getCalories</span><span class="p">));</span>
<span class="o">//</span> <span class="n">IntSummaryStatistics</span><span class="p">{</span><span class="n">count</span><span class="o">=</span><span class="n">9</span><span class="p">,</span> <span class="n">sum</span><span class="o">=</span><span class="n">4300</span><span class="p">,</span> <span class="n">min</span><span class="o">=</span><span class="n">120</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="n">477</span><span class="p">.</span><span class="na">777778</span><span class="p">,</span> <span class="n">max</span><span class="o">=</span><span class="n">800</span><span class="p">}</span></code></pre></div>
<p>同样相应地有<code>summarizingLong</code>和<code>summarizingDouble</code>以及对应的类<code>LongSummaryStatistics</code>和<code>DoubleSummaryStatistics</code></p>

<h3 id="连接字符串">连接字符串</h3>

<p><code>Collectors.joining</code>将流中所有对象连接成一个字符串，调用每个对象的<code>toString</code>方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">String shortMenu </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">map</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getName</span><span class="p">).</span><span class="na">collect</span><span class="p">(</span><span class="n">joining</span><span class="p">());</span></code></pre></div>
<p><code>Collectors.joining</code>的重载版本接受一个字符串用于间隔元素：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">String shortMenu </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">map</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getName</span><span class="p">).</span><span class="na">collect</span><span class="p">(</span><span class="n">joining</span><span class="p">(</span><span class="s">&#34;,&#34;</span><span class="p">));</span></code></pre></div>
<h3 id="通用归纳总结">通用归纳总结</h3>

<p>到目前为止，我们讨论的所有Collector实际上都是<code>Collectors.reducing</code>方法的简便版。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">int totalCalories </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span><span class="n">reducing</span><span class="p">(</span><span class="n">0</span><span class="p">,</span> <span class="n">Dish</span><span class="o">::</span><span class="n">getCalories</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">));</span>
<span class="err">Optional&lt;Dish&gt; mostCalorieDish </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span><span class="n">reducing</span><span class="p">((</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">d1</span><span class="p">.</span><span class="na">getCalories</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">d2</span><span class="p">.</span><span class="na">getCalories</span><span class="p">()</span> <span class="o">?</span> <span class="n">d1</span> <span class="o">:</span> <span class="n">d2</span><span class="p">));</span></code></pre></div>
<p>比如前面用到的<code>counting</code>定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public static </span><span class="o">&lt;</span><span class="err">T&gt; Collector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="o">?</span><span class="p">,</span> <span class="err">Long&gt; counting</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">reducing</span><span class="p">(</span><span class="n">0L</span><span class="p">,</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="n">1L</span><span class="p">,</span> <span class="n">Long</span><span class="o">::</span><span class="n">sum</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>达到同样的效果，可以有多种方法，比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">int totalCalories </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">map</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getCalories</span><span class="p">).</span><span class="na">reduce</span><span class="p">(</span><span class="n">Integer</span><span class="o">::</span><span class="n">sum</span><span class="p">).</span><span class="na">get</span><span class="p">();</span>
<span class="err">int totalCalories </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">mapToInt</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getCalories</span><span class="p">).</span><span class="na">sum</span><span class="p">();</span></code></pre></div>
<h2 id="分组">分组</h2>

<p>数据库的一个常见操作是根据一个或多个属性将数据分组。Java 8中使用<code>groupingBy</code>达到相同的效果：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">Dish</span><span class="p">.</span><span class="na">Type</span><span class="p">,</span> <span class="err">List&lt;Dish&gt;&gt; dishesByType </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span><span class="n">groupingBy</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getType</span><span class="p">));</span></code></pre></div>
<p>但是并不总是可以将方法引用用作分类函数，因为你可能希望使用比简单属性访问器更复杂的方法进行分类。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public enum </span><span class="n">CaloricLevel</span> <span class="p">{</span><span class="n">DIET</span><span class="p">,</span> <span class="n">NORMAL</span><span class="p">,</span> <span class="n">FAT</span><span class="p">}</span>
<span class="n">Map</span><span class="o">&lt;</span><span class="n">CaloricLevel</span><span class="p">,</span> <span class="err">List&lt;Dish&gt;&gt; dishesByCaloricLevel </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span>
    <span class="n">groupingBy</span><span class="p">(</span><span class="n">dish</span> <span class="o">-&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dish</span><span class="p">.</span><span class="na">getCalories</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">400</span><span class="p">)</span> <span class="k">return</span> <span class="n">CaloricLevel</span><span class="p">.</span><span class="na">DIET</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dish</span><span class="p">.</span><span class="na">getCalories</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">700</span><span class="p">)</span> <span class="k">return</span> <span class="n">CaloricLevel</span><span class="p">.</span><span class="na">NORMAL</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">return</span> <span class="n">CaloricLevel</span><span class="p">.</span><span class="na">FAT</span><span class="p">;</span>
    <span class="p">}));</span></code></pre></div>
<h3 id="操作分组元素">操作分组元素</h3>

<p>假设你要按类型分组菜肴并在每个分组过滤热量大于500的菜肴，你可能会这样做：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">Dish</span><span class="p">.</span><span class="na">Type</span><span class="p">,</span> <span class="err">List&lt;Dish&gt;&gt; caloricDishesByType </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">filter</span><span class="p">(</span><span class="n">dish</span> <span class="o">-&gt;</span> <span class="n">dish</span><span class="p">.</span><span class="na">getCalories</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">500</span><span class="p">).</span><span class="na">collect</span><span class="p">(</span><span class="n">groupingBy</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getType</span><span class="p">));</span></code></pre></div>
<p>打印<code>caloricDishesByType</code>得到：</p>

<pre><code>{OTHER=[french fries, pizza], MEAT=[pork, beef]}
</code></pre>

<p>可以看到这个方法有一个问题，<code>FISH</code>分组不见了。为了解决这个问题，<code>Collectors.groupingBy</code>提供了一个重载的方法接受另一个Collector参数。如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">Dish</span><span class="p">.</span><span class="na">Type</span><span class="p">,</span> <span class="err">List&lt;Dish&gt;&gt; caloricDishesByType </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span><span class="n">groupingBy</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getType</span><span class="p">,</span> <span class="n">filtering</span><span class="p">(</span><span class="n">dish</span> <span class="o">-&gt;</span> <span class="n">dish</span><span class="p">.</span><span class="na">getCalories</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">500</span><span class="p">,</span> <span class="n">toList</span><span class="p">())));</span></code></pre></div>
<p><code>filtering</code>接受一个谓词过滤每个分组的元素，另外一个Collector用于重新分组过滤后的元素。</p>

<pre><code>{OTHER=[french fries, pizza], MEAT=[pork, beef], FISH=[]}
</code></pre>

<p>另一种常见的操作分组元素的方法是通过映射函数转换它们。<code>Collectors.mapping</code>接受一个Function和另一个Collector用于收集分组中被映射的元素：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">Dish</span><span class="p">.</span><span class="na">Type</span><span class="p">,</span> <span class="err">List&lt;String&gt;&gt; dishNamesByType </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span><span class="n">groupingBy</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getType</span><span class="p">,</span> <span class="n">mapping</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getName</span><span class="p">,</span> <span class="n">toList</span><span class="p">())));</span></code></pre></div>
<p><code>groupingBy</code>还可以和<code>flatMapping</code>结合使用。假设我们有如下数据：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="err">List&lt;String&gt;&gt; dishTags </span><span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;</span><span class="p">();</span>
<span class="n">dishTags</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;pork&#34;</span><span class="p">,</span> <span class="n">asList</span><span class="p">(</span><span class="s">&#34;greasy&#34;</span><span class="p">,</span> <span class="s">&#34;salty&#34;</span><span class="p">));</span>
<span class="n">dishTags</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;beef&#34;</span><span class="p">,</span> <span class="n">asList</span><span class="p">(</span><span class="s">&#34;salty&#34;</span><span class="p">,</span> <span class="s">&#34;roasted&#34;</span><span class="p">));</span>
<span class="n">dishTags</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;chicken&#34;</span><span class="p">,</span> <span class="n">asList</span><span class="p">(</span><span class="s">&#34;fried&#34;</span><span class="p">,</span> <span class="s">&#34;crisp&#34;</span><span class="p">));</span>
<span class="n">dishTags</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;french fries&#34;</span><span class="p">,</span> <span class="n">asList</span><span class="p">(</span><span class="s">&#34;greasy&#34;</span><span class="p">,</span> <span class="s">&#34;fried&#34;</span><span class="p">));</span>
<span class="n">dishTags</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;rice&#34;</span><span class="p">,</span> <span class="n">asList</span><span class="p">(</span><span class="s">&#34;light&#34;</span><span class="p">,</span> <span class="s">&#34;natural&#34;</span><span class="p">));</span>
<span class="n">dishTags</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;season fruit&#34;</span><span class="p">,</span> <span class="n">asList</span><span class="p">(</span><span class="s">&#34;fresh&#34;</span><span class="p">,</span> <span class="s">&#34;natural&#34;</span><span class="p">));</span>
<span class="n">dishTags</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;pizza&#34;</span><span class="p">,</span> <span class="n">asList</span><span class="p">(</span><span class="s">&#34;tasty&#34;</span><span class="p">,</span> <span class="s">&#34;salty&#34;</span><span class="p">));</span>
<span class="n">dishTags</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;prawns&#34;</span><span class="p">,</span> <span class="n">asList</span><span class="p">(</span><span class="s">&#34;tasty&#34;</span><span class="p">,</span> <span class="s">&#34;roasted&#34;</span><span class="p">));</span>
<span class="n">dishTags</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&#34;salmon&#34;</span><span class="p">,</span> <span class="n">asList</span><span class="p">(</span><span class="s">&#34;delicious&#34;</span><span class="p">,</span> <span class="s">&#34;fresh&#34;</span><span class="p">));</span></code></pre></div>
<p>假如我们想要获取各类菜肴的标签，如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">Dish</span><span class="p">.</span><span class="na">Type</span><span class="p">,</span> <span class="err">Set&lt;String&gt;&gt; dishNamesByType </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span><span class="n">groupingBy</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getType</span><span class="p">,</span> <span class="n">flatMapping</span><span class="p">(</span><span class="n">dish</span> <span class="o">-&gt;</span> <span class="n">dishTags</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">dish</span><span class="p">.</span><span class="na">getName</span><span class="p">()).</span><span class="na">stream</span><span class="p">(),</span> <span class="n">toSet</span><span class="p">())));</span></code></pre></div>
<h3 id="多级分组">多级分组</h3>

<p>带两个参数的<code>Collectors.groupingBy</code>可以用来执行两级分组，如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">Dish</span><span class="p">.</span><span class="na">Type</span><span class="p">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">CaloricLevel</span><span class="p">,</span> <span class="err">List&lt;Dish&gt;&gt;&gt; dishesByTypeCaloricLevel </span><span class="o">=</span>
    <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span>
        <span class="n">groupingBy</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getType</span><span class="p">,</span>
            <span class="n">groupingBy</span><span class="p">(</span><span class="n">dish</span> <span class="o">-&gt;</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">dish</span><span class="p">.</span><span class="na">getCalories</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">400</span><span class="p">)</span> <span class="k">return</span> <span class="n">CaloricLevel</span><span class="p">.</span><span class="na">DIET</span><span class="p">;</span>
                <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dish</span><span class="p">.</span><span class="na">getCalories</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">700</span><span class="p">)</span> <span class="k">return</span> <span class="n">CaloricLevel</span><span class="p">.</span><span class="na">NORMAL</span><span class="p">;</span>
                <span class="k">else</span> <span class="k">return</span> <span class="n">CaloricLevel</span><span class="p">.</span><span class="na">FAT</span><span class="p">;</span>
            <span class="p">})</span>
        <span class="p">)</span>
    <span class="p">);</span></code></pre></div>
<p>多级分组操作可以扩展到任意层级，一个N级分组结果是一个N级Map。</p>

<h3 id="在子分组中收集数据">在子分组中收集数据</h3>

<p><code>groupingBy</code>的第二个参数可以是任意类型的Collector。比如<code>counting</code>用于计算每个分组的数量：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">Dish</span><span class="p">.</span><span class="na">Type</span><span class="p">,</span> <span class="err">Long&gt; typesCount </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span><span class="n">groupingBy</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getType</span><span class="p">,</span> <span class="n">counting</span><span class="p">()));</span></code></pre></div>
<p>而且单个参数的<code>groupingBy(f)</code>实际上等价于<code>groupingBy(f, toList())</code>。再举一个例子，获取各类菜肴热量最高的菜：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">Dish</span><span class="p">.</span><span class="na">Type</span><span class="p">,</span> <span class="err">Optional&lt;Dish&gt;&gt; mostCaloricByType </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span><span class="n">groupingBy</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getType</span><span class="p">,</span> <span class="n">maxBy</span><span class="p">(</span><span class="n">comparingInt</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getCalories</span><span class="p">))));</span></code></pre></div>
<h4 id="将收集器结果调整为不同的类型">将收集器结果调整为不同的类型</h4>

<p>要使收集器返回的结果调整为不同的类型，可以使用Collectors.collectingAndThen factory`返回的Collector，如下面所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">Dish</span><span class="p">.</span><span class="na">Type</span><span class="p">,</span> <span class="err">Dish&gt; mostCaloricByType </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span><span class="n">groupingBy</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getType</span><span class="p">,</span>
	<span class="n">collectingAndThen</span><span class="p">(</span><span class="n">maxBy</span><span class="p">(</span><span class="n">comparingInt</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getCalories</span><span class="p">)),</span> <span class="n">Optional</span><span class="o">::</span><span class="n">get</span><span class="p">)));</span></code></pre></div>
<h4 id="与groupingby一起使用的其他收集器示例">与groupingBy一起使用的其他收集器示例</h4>

<p>更一般地，传递给<code>groupingBy</code>方法第二个参数的收集器将用于对流中分类为同一组的所有元素执行进一步的归纳操作。比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">Dish</span><span class="p">.</span><span class="na">Type</span><span class="p">,</span> <span class="err">Integer&gt; totalCaloriesByType </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span><span class="n">groupingBy</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getType</span><span class="p">,</span> <span class="n">summingInt</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getCalories</span><span class="p">)));</span></code></pre></div>
<p>另外一个收集器是由<code>mapping</code>方法生成的。此方法接受两个参数：一个函数转换流中的元素，另一个收集器收集转换后的对象。如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">Dish</span><span class="p">.</span><span class="na">Type</span><span class="p">,</span> <span class="err">Set&lt;CaloricLevel&gt;&gt; caloricLevelsByType </span><span class="o">=</span>
    <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span>
        <span class="n">groupingBy</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getType</span><span class="p">,</span> <span class="n">mapping</span><span class="p">(</span><span class="n">dish</span> <span class="o">-&gt;</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">dish</span><span class="p">.</span><span class="na">getCalories</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">400</span><span class="p">)</span> <span class="k">return</span> <span class="n">CaloricLevel</span><span class="p">.</span><span class="na">DIET</span><span class="p">;</span>
                <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dish</span><span class="p">.</span><span class="na">getCalories</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">700</span><span class="p">)</span> <span class="k">return</span> <span class="n">CaloricLevel</span><span class="p">.</span><span class="na">NORMAL</span><span class="p">;</span>
                <span class="k">else</span> <span class="k">return</span> <span class="n">CaloricLevel</span><span class="p">.</span><span class="na">FAT</span><span class="p">;</span>
            <span class="p">},</span> <span class="n">toSet</span><span class="p">())));</span></code></pre></div>
<p>在上例中，我们不知道<code>toSet</code>会返回什么类型的Set。如果你想要返回指定的集合，可以是用<code>toCollection</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">Dish</span><span class="p">.</span><span class="na">Type</span><span class="p">,</span> <span class="err">Set&lt;CaloricLevel&gt;&gt; caloricLevelsByType </span><span class="o">=</span>
    <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span>
        <span class="n">groupingBy</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getType</span><span class="p">,</span> <span class="n">mapping</span><span class="p">(</span><span class="n">dish</span> <span class="o">-&gt;</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">dish</span><span class="p">.</span><span class="na">getCalories</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">400</span><span class="p">)</span> <span class="k">return</span> <span class="n">CaloricLevel</span><span class="p">.</span><span class="na">DIET</span><span class="p">;</span>
                <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dish</span><span class="p">.</span><span class="na">getCalories</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">700</span><span class="p">)</span> <span class="k">return</span> <span class="n">CaloricLevel</span><span class="p">.</span><span class="na">NORMAL</span><span class="p">;</span>
                <span class="k">else</span> <span class="k">return</span> <span class="n">CaloricLevel</span><span class="p">.</span><span class="na">FAT</span><span class="p">;</span>
            <span class="p">},</span> <span class="n">toCollection</span><span class="p">(</span><span class="n">HashSet</span><span class="o">::</span><span class="k">new</span><span class="p">))));</span></code></pre></div>
<h2 id="分区">分区</h2>

<p>分区是分组的一种特殊情况：使用一个称为分区函数的谓词作为分类函数。分区函数返回布尔值这一事实意味着生成的分组映射将使用布尔值作为键类型，因此最多可以有两个不同的组——一个为true，一个为false。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="p">,</span> <span class="err">List&lt;Dish&gt;&gt; partitionedMenu </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span><span class="n">partitioningBy</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">isVegetarian</span><span class="p">));</span></code></pre></div>
<h3 id="advantages-of-partitioning">Advantages of partitioning</h3>

<p>和分组一样，<code>partitioningBy</code>方法也有一个重载版本，可以向其传递第二个收集器，如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="p">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Dish</span><span class="p">.</span><span class="na">Type</span><span class="p">,</span> <span class="err">List&lt;Dish&gt;&gt;&gt; vegetarianDishesByType </span><span class="o">=</span>
    <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span>
        <span class="n">partitioningBy</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">isVegetarian</span><span class="p">,</span> <span class="n">groupingBy</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getType</span><span class="p">)));</span>

<span class="n">Map</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="p">,</span> <span class="err">Dish&gt; mostCaloricPartitionedByVegetarian </span><span class="o">=</span>
    <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span>
        <span class="n">partitioningBy</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">isVegetarian</span><span class="p">,</span>
            <span class="n">collectingAndThen</span><span class="p">(</span><span class="n">maxBy</span><span class="p">(</span><span class="n">comparingInt</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getCalories</span><span class="p">)),</span>
                <span class="n">Optional</span><span class="o">::</span><span class="n">get</span><span class="p">)));</span></code></pre></div>
<h3 id="将数字划分为素数和非素数">将数字划分为素数和非素数</h3>

<p>假设你想编写一个方法，接受一个整数n作为参数，并将前n个自然数划分为素数和非素数。但首先，你需要一个谓词判断一个整数是否是质数：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public boolean </span><span class="n">isPrime</span><span class="p">(</span><span class="err">int candidate</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">IntStream</span><span class="p">.</span><span class="na">range</span><span class="p">(</span><span class="n">2</span><span class="p">,</span> <span class="n">candidate</span><span class="p">).</span><span class="na">noneMatch</span><span class="p">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">candidate</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="n">0</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>下面是一个小小的优化：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public boolean </span><span class="n">isPrime</span><span class="p">(</span><span class="err">int candidate</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">int candidateRoot </span><span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">Math</span><span class="p">.</span><span class="na">sqrt</span><span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="n">candidate</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">IntStream</span><span class="p">.</span><span class="na">rangeClosed</span><span class="p">(</span><span class="n">2</span><span class="p">,</span> <span class="n">candidateRoot</span><span class="p">).</span><span class="na">noneMatch</span><span class="p">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">candidate</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="n">0</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>现在就可以划分前n个整数是否是质数了：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public Map</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="p">,</span> <span class="err">List&lt;Integer&gt;&gt; partitionPrimes</span><span class="p">(</span><span class="err">int n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">IntStream</span><span class="p">.</span><span class="na">rangeClosed</span><span class="p">(</span><span class="n">2</span><span class="p">,</span> <span class="n">n</span><span class="p">).</span><span class="na">boxed</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span><span class="n">partitioningBy</span><span class="p">(</span><span class="n">candidate</span> <span class="o">-&gt;</span> <span class="n">isPrime</span><span class="p">(</span><span class="n">candidate</span><span class="p">)));</span>
<span class="p">}</span></code></pre></div>
<p>下表是<code>Collectors</code>类中主要的静态工厂方法：</p>

<table>
<thead>
<tr>
<th>工厂方法</th>
<th>返回类型</th>
<th>用途</th>
</tr>
</thead>

<tbody>
<tr>
<td>toList</td>
<td>List&lt;T&gt;</td>
<td>将流中的元素放入List</td>
</tr>

<tr>
<td>toSet</td>
<td>Set&lt;T&gt;</td>
<td>将流中的元素放入Set，去除重复元素</td>
</tr>

<tr>
<td>toCollection</td>
<td>Collection&lt;T&gt;</td>
<td>将流中的元素放入指定的集合</td>
</tr>

<tr>
<td>counting</td>
<td>Long</td>
<td>统计流中元素个数</td>
</tr>

<tr>
<td>summingInt</td>
<td>Integer</td>
<td>对流中元素的整形属性求和</td>
</tr>

<tr>
<td>averagingInt</td>
<td>Double</td>
<td>计算流中元素的整形属性的平均值</td>
</tr>

<tr>
<td>summarizingInt</td>
<td>IntSummaryStatistics</td>
<td>收集流中元素的整形属性的统计数据</td>
</tr>

<tr>
<td>joining</td>
<td>String</td>
<td>连接流中元素调用toString方法产生的字符串</td>
</tr>

<tr>
<td>maxBy</td>
<td>Optional&lt;T&gt;</td>
<td>根据指定的Comparator返回流中最大的元素或Optional.empty()</td>
</tr>

<tr>
<td>minBy</td>
<td>Optional&lt;T&gt;</td>
<td>根据指定的Comparator返回流中最小的元素或Optional.empty()</td>
</tr>

<tr>
<td>reducing</td>
<td>归纳操作产生的类型</td>
<td>使用BinaryOperator依次将流中元素合并为一个值</td>
</tr>

<tr>
<td>collectingAndThen</td>
<td>转换函数返回的类型</td>
<td>包装另一个收集器并对其结果应用转换函数</td>
</tr>

<tr>
<td>groupingBy</td>
<td>Map&lt;K, List&lt;T&gt;&gt;</td>
<td>基于流中元素的属性作为键值分组元素</td>
</tr>

<tr>
<td>partitioningBy</td>
<td>Map&lt;Boolean, List&lt;T&gt;&gt;</td>
<td>基于谓词对流中的元素分区</td>
</tr>
</tbody>
</table>

<h2 id="collector接口">Collector接口</h2>

<p>Collector接口声明的方法如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public interface </span><span class="n">Collector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="err">Supplier&lt;A&gt; supplier</span><span class="p">();</span>
    <span class="n">BiConsumer</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="err">T&gt; accumulator</span><span class="p">();</span>
    <span class="n">Function</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="err">R&gt; finisher</span><span class="p">();</span>
    <span class="err">BinaryOperator&lt;A&gt; combiner</span><span class="p">();</span>
    <span class="err">Set&lt;Characteristics&gt; characteristics</span><span class="p">();</span>
<span class="p">}</span></code></pre></div>
<p>其中：</p>

<ul>
<li>T是要被收集的流中元素的类型</li>
<li>A是累加器的类型，在收集过程中，收集部分结果的对象。</li>
<li>R是结果类型</li>
</ul>

<p>比如你可以实现一个类<code>ToListCollector&lt;T&gt;</code> 将<code>Stream&lt;T&gt;</code>中所有的元素收集到<code>List&lt;T&gt;</code>中</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public class ToListCollector&lt;T&gt; implements </span><span class="n">Collector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span></code></pre></div>
<h3 id="理解collector接口声明的方法">理解Collector接口声明的方法</h3>

<h4 id="supplier方法">supplier方法</h4>

<p><code>supplier</code>方法必须返回一个空的累加器，比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public Supplier</span><span class="o">&lt;</span><span class="err">List&lt;T&gt;&gt; supplier</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span></code></pre></div>
<p>也可以使用构造器引用：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public Supplier</span><span class="o">&lt;</span><span class="err">List&lt;T&gt;&gt; supplier</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">ArrayList</span><span class="o">::</span><span class="k">new</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>
<h4 id="accumulator方法">accumulator方法</h4>

<p><code>accumulator</code>方法返回一个执行归纳操作的函数。这个函数带2个参数，一个是累加器，一个是流中第n个元素，并返回void，因为累加器被就地修改。比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public BiConsumer</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="err">T&gt; accumulator</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">list</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>也可以使用方法引用：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public BiConsumer</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="err">T&gt; accumulator</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">List</span><span class="o">::</span><span class="n">add</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>
<h4 id="finisher方法">finisher方法</h4>

<p><code>finisher</code>方法返回一个在累加过程最后调用的函数，用于将累加器对象转换为最终结果，比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public Function</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="err">List&lt;T&gt;&gt; finisher</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">Function</span><span class="p">.</span><span class="na">identity</span><span class="p">();</span>
<span class="p">}</span></code></pre></div>
<p>下图为<code>collect</code>方法处理过程</p>

<p><img src="/static/images/2019/07/23/collect.png" alt="collect.png" /></p>

<h4 id="combiner方法">combiner方法</h4>

<p><code>combiner</code>方法返回一个方法用于并行处理时将流中不同的子部分元素合并起来，比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public BinaryOperator</span><span class="o">&lt;</span><span class="err">List&lt;T&gt;&gt; combiner</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">{</span>
        <span class="n">list1</span><span class="p">.</span><span class="na">addAll</span><span class="p">(</span><span class="n">list2</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">list1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h4 id="characteristics方法">characteristics方法</h4>

<p><code>characteristics</code>方法返回<code>Characteristics</code>集合，定义了收集器的行为。特别是提示是否可以并行处理以及哪些优化可行。<code>Characteristics</code>是一个枚举：</p>

<ul>
<li>UNORDERED：归纳的结果不受遍历和累加流中元素的顺序的影响</li>
<li>CONCURRENT：累加方法可以被多个线程并发调用，收集器可以在流上执行并行归纳。</li>
<li>IDENTITY_FINISH：<code>finisher</code>方法返回的结果是累加器本身，这意味着累加器A到结果R的类型转换不需要检查。</li>
</ul>

<h4 id="collect方法重载版本">collect方法重载版本</h4>

<p>对于<code>IDENTITY_FINISH</code>类型的收集操作，可以不需要实现<code>Collector</code>接口就能自定义收集操作。<code>collect</code>方法有一个重载版本接受3个参数——<code>supplier</code>，<code>accumulator</code>，<code>combiner</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">List&lt;Dish&gt; dishes </span><span class="o">=</span> <span class="n">menuStream</span><span class="p">.</span><span class="na">collect</span><span class="p">(</span><span class="n">ArrayList</span><span class="o">::</span><span class="k">new</span><span class="p">,</span> <span class="n">List</span><span class="o">::</span><span class="n">add</span><span class="p">,</span> <span class="n">List</span><span class="o">::</span><span class="n">addAll</span><span class="p">);</span></code></pre></div>
<h2 id="开发自己的收集器">开发自己的收集器</h2>

<h3 id="只除质数">只除质数</h3>

<p>判断一个数是否是质数，只需将这个数除以比它小的质数即可，不用每一个数都去测试</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public static boolean isPrime</span><span class="p">(</span><span class="err">List&lt;Integer&gt; primes</span><span class="p">,</span> <span class="err">int candidate</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">primes</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">noneMatch</span><span class="p">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">candidate</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="n">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="err">public static boolean isPrime</span><span class="p">(</span><span class="err">List&lt;Integer&gt; primes</span><span class="p">,</span> <span class="err">int candidate</span><span class="p">){</span>
    <span class="err">int candidateRoot </span><span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">Math</span><span class="p">.</span><span class="na">sqrt</span><span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="n">candidate</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">primes</span><span class="p">.</span><span class="na">stream</span><span class="p">()</span>
        <span class="p">.</span><span class="na">takeWhile</span><span class="p">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">candidateRoot</span><span class="p">)</span>
        <span class="p">.</span><span class="na">noneMatch</span><span class="p">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">candidate</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="n">0</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<h4 id="定义收集器类">定义收集器类</h4>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public class PrimeNumbersCollector implements </span><span class="n">Collector</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;&gt;</span></code></pre></div>
<h4 id="实现归纳过程">实现归纳过程</h4>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public Supplier</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="p">,</span> <span class="err">List&lt;Integer&gt;&gt;&gt; supplier</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span><span class="p">()</span> <span class="p">{{</span>
        <span class="n">put</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="p">());</span>
        <span class="n">put</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="p">}};</span>
<span class="p">}</span>

<span class="err">public BiConsumer</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="err">Integer&gt; accumulator</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="p">,</span> <span class="err">List&lt;Integer&gt;&gt; acc</span><span class="p">,</span> <span class="err">Integer candidate</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">{</span>
        <span class="n">acc</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">isPrime</span><span class="p">(</span><span class="n">acc</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="kc">true</span><span class="p">),</span> <span class="n">candidate</span><span class="p">))</span>
            <span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">candidate</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span></code></pre></div>
<h4 id="尽可能并行收集">尽可能并行收集</h4>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public BinaryOperator</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="p">,</span> <span class="err">List&lt;Integer&gt;&gt;&gt; combiner</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="p">,</span> <span class="err">List&lt;Integer&gt;&gt; map1</span><span class="p">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="p">,</span> <span class="err">List&lt;Integer&gt;&gt; map2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">{</span>
        <span class="n">map1</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="kc">true</span><span class="p">).</span><span class="na">addAll</span><span class="p">(</span><span class="n">map2</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="kc">true</span><span class="p">));</span>
        <span class="n">map1</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="kc">false</span><span class="p">).</span><span class="na">addAll</span><span class="p">(</span><span class="n">map2</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="kc">false</span><span class="p">));</span>
        <span class="k">return</span> <span class="n">map1</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span></code></pre></div>
<h4 id="最后两个方法">最后两个方法</h4>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public Function</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="p">,</span> <span class="err">List&lt;Integer&gt;&gt;&gt; finisher</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Function</span><span class="p">.</span><span class="na">identity</span><span class="p">();</span>
<span class="p">}</span>

<span class="err">public Set</span><span class="o">&lt;</span><span class="err">Characteristics&gt; characteristics</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Collections</span><span class="p">.</span><span class="na">unmodifiableSet</span><span class="p">(</span><span class="n">EnumSet</span><span class="p">.</span><span class="na">of</span><span class="p">(</span><span class="n">IDENTITY_FINISH</span><span class="p">));</span>
<span class="p">}</span></code></pre></div>
<p>现在可以使用这个自定义的收集器分区质数：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public Map</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="p">,</span> <span class="err">List&lt;Integer&gt;&gt; partitionPrimesWithCustomCollector</span><span class="p">(</span><span class="err">int n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">IntStream</span><span class="p">.</span><span class="na">rangeClosed</span><span class="p">(</span><span class="n">2</span><span class="p">,</span> <span class="n">n</span><span class="p">).</span><span class="na">boxed</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span><span class="k">new</span> <span class="n">PrimeNumbersCollector</span><span class="p">());</span>
<span class="p">}</span></code></pre></div>
<p>也可以使用<code>collect</code>接受3个参数的重载版本，但是这样可读性变差了，而且代码也不能复用了。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public Map</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="p">,</span> <span class="err">List&lt;Integer&gt;&gt; partitionPrimesWithCustomCollector </span><span class="p">(</span><span class="err">int n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">IntStream</span><span class="p">.</span><span class="na">rangeClosed</span><span class="p">(</span><span class="n">2</span><span class="p">,</span> <span class="n">n</span><span class="p">).</span><span class="na">boxed</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span>
        <span class="p">()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span><span class="p">()</span> <span class="p">{{</span>
            <span class="n">put</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="p">());</span>
            <span class="n">put</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="p">());</span>
        <span class="p">}},</span>
        <span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="n">candidate</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">{</span>
            <span class="n">acc</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">isPrime</span><span class="p">(</span><span class="n">acc</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="kc">true</span><span class="p">),</span> <span class="n">candidate</span><span class="p">))</span>
                <span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">candidate</span><span class="p">);</span>
        <span class="p">},</span>
        <span class="p">(</span><span class="n">map1</span><span class="p">,</span> <span class="n">map2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">{</span>
            <span class="n">map1</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="kc">true</span><span class="p">).</span><span class="na">addAll</span><span class="p">(</span><span class="n">map2</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="kc">true</span><span class="p">));</span>
            <span class="n">map1</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="kc">false</span><span class="p">).</span><span class="na">addAll</span><span class="p">(</span><span class="n">map2</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="kc">false</span><span class="p">));</span>
        <span class="p">});</span>
<span class="p">}</span></code></pre></div>]]></content>
		</item>
		
		<item>
			<title>使用流</title>
			<link>https://gitop.cc/posts/working-with-streams/</link>
			<pubDate>Thu, 11 Jul 2019 08:39:11 +0800</pubDate>
			
			<guid>https://gitop.cc/posts/working-with-streams/</guid>
			<description>过滤 使用谓词过滤 filter方法接受一个谓词函数为参数，并返回包含所有匹配谓词的元素的流。如下例： List&amp;lt;Dish&amp;gt; vegetarianMenu = menu.stream().filter(Dish::isVegetarian).collect(toList()); 如下图所示： 过滤唯一元素 disti</description>
			<content type="html"><![CDATA[

<h2 id="过滤">过滤</h2>

<h3 id="使用谓词过滤">使用谓词过滤</h3>

<p><code>filter</code>方法接受一个谓词函数为参数，并返回包含所有匹配谓词的元素的流。如下例：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">List&lt;Dish&gt; vegetarianMenu </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">filter</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">isVegetarian</span><span class="p">).</span><span class="na">collect</span><span class="p">(</span><span class="n">toList</span><span class="p">());</span></code></pre></div>
<p>如下图所示：</p>

<p><img src="/static/images/2019/07/11/filter.png" alt="filter.png" /></p>

<h3 id="过滤唯一元素">过滤唯一元素</h3>

<p><code>distinct</code>方法返回包含唯一元素的流。如下例：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">List&lt;Integer&gt; numbers </span><span class="o">=</span> <span class="n">Arrays</span><span class="p">.</span><span class="na">asList</span><span class="p">(</span><span class="n">1</span><span class="p">,</span> <span class="n">2</span><span class="p">,</span> <span class="n">1</span><span class="p">,</span> <span class="n">3</span><span class="p">,</span> <span class="n">3</span><span class="p">,</span> <span class="n">2</span><span class="p">,</span> <span class="n">4</span><span class="p">);</span>
<span class="n">numbers</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">filter</span><span class="p">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">%</span> <span class="n">2</span> <span class="o">==</span> <span class="n">0</span><span class="p">).</span><span class="na">distinct</span><span class="p">().</span><span class="na">forEach</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="p">);</span></code></pre></div>
<p>如下图所示：</p>

<p><img src="/static/images/2019/07/11/distinct.png" alt="distinct.png" /></p>

<h2 id="切分流">切分流</h2>

<p>Java 9添加了两个新方法<code>takeWhile</code>和<code>dropWhile</code>，可以有效地选择流中的元素。</p>

<h3 id="takewhile">takeWhile</h3>

<p><code>takeWhile</code>方法使用谓词切分流，即使是无限流。一旦发现一个元素不满足条件，<code>takeWhile</code>会立刻停止。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">List&lt;Dish&gt; slicedMenu1 </span><span class="o">=</span> <span class="n">specialMenu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">takeWhile</span><span class="p">(</span><span class="n">dish</span> <span class="o">-&gt;</span> <span class="n">dish</span><span class="p">.</span><span class="na">getCalories</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">320</span><span class="p">).</span><span class="na">collect</span><span class="p">(</span><span class="n">toList</span><span class="p">());</span></code></pre></div>
<h3 id="dropwhile">dropWhile</h3>

<p><code>dropWhile</code>和<code>takeWhile</code>正好相反。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">List&lt;Dish&gt; slicedMenu2 </span><span class="o">=</span> <span class="n">specialMenu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">dropWhile</span><span class="p">(</span><span class="n">dish</span> <span class="o">-&gt;</span> <span class="n">dish</span><span class="p">.</span><span class="na">getCalories</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">320</span><span class="p">).</span><span class="na">collect</span><span class="p">(</span><span class="n">toList</span><span class="p">());</span></code></pre></div>
<h3 id="截断流">截断流</h3>

<p><code>limit(n)</code>方法返回一个不大于指定长度的流</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">List&lt;Dish&gt; dishes </span><span class="o">=</span> <span class="n">specialMenu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">filter</span><span class="p">(</span><span class="n">dish</span> <span class="o">-&gt;</span> <span class="n">dish</span><span class="p">.</span><span class="na">getCalories</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">300</span><span class="p">).</span><span class="na">limit</span><span class="p">(</span><span class="n">3</span><span class="p">).</span><span class="na">collect</span><span class="p">(</span><span class="n">toList</span><span class="p">());</span></code></pre></div>
<h3 id="跳过元素">跳过元素</h3>

<p><code>skip(n)</code>方法返回一个丢弃前n个元素的流，如果流中的元素小于n，则返回一个空流</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">List&lt;Dish&gt; dishes </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">filter</span><span class="p">(</span><span class="n">d</span> <span class="o">-&gt;</span> <span class="n">d</span><span class="p">.</span><span class="na">getCalories</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">300</span><span class="p">).</span><span class="na">skip</span><span class="p">(</span><span class="n">2</span><span class="p">).</span><span class="na">collect</span><span class="p">(</span><span class="n">toList</span><span class="p">());</span></code></pre></div>
<h2 id="映射">映射</h2>

<h3 id="map">map</h3>

<p><code>map</code>方法接受一个<code>Function&lt;T, R&gt;</code>为参数，将其应用于每一个元素，并映射为一个新的元素</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">List&lt;Integer&gt; dishNameLengths </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">map</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getName</span><span class="p">).</span><span class="na">map</span><span class="p">(</span><span class="n">String</span><span class="o">::</span><span class="n">length</span><span class="p">).</span><span class="na">collect</span><span class="p">(</span><span class="n">toList</span><span class="p">());</span></code></pre></div>
<h3 id="flatmap">flatMap</h3>

<p>如何返回一组单词中所有唯一的字符呢？比如[&ldquo;Hello&rdquo;, &ldquo;World&rdquo;]，你想要返回[&ldquo;H&rdquo;, &ldquo;e&rdquo;, &ldquo;l&rdquo;, &ldquo;o&rdquo;, &ldquo;W&rdquo;, &ldquo;r&rdquo;, &ldquo;d&rdquo;] 。第一次尝试如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">words</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">map</span><span class="p">(</span><span class="n">word</span> <span class="o">-&gt;</span> <span class="n">word</span><span class="p">.</span><span class="na">split</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)).</span><span class="na">distinct</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span><span class="n">toList</span><span class="p">());</span></code></pre></div>
<p><code>map</code>返回的流为<code>Stream&lt;String[]&gt;</code>，而你想要的流是<code>Stream&lt;String&gt;</code>，这样不对。</p>

<p>如下图所示：</p>

<p><img src="/static/images/2019/07/11/first-try.png" alt="first-try.png" /></p>

<h4 id="尝试使用map和arrays-stream">尝试使用map和Arrays.stream</h4>

<p>首先你需要一个字符串流而不是数组流。<code>Arrays.stream</code>方法接受一个数组并产生一个包含数组元素的流：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">String[] arrayOfWords </span><span class="o">=</span> <span class="p">{</span><span class="s">&#34;Goodbye&#34;</span><span class="p">,</span> <span class="s">&#34;World&#34;</span><span class="p">};</span>
<span class="err">Stream&lt;String&gt; streamOfwords </span><span class="o">=</span> <span class="n">Arrays</span><span class="p">.</span><span class="na">stream</span><span class="p">(</span><span class="n">arrayOfWords</span><span class="p">);</span></code></pre></div>
<p>第二次尝试：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">words</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">map</span><span class="p">(</span><span class="n">word</span> <span class="o">-&gt;</span> <span class="n">word</span><span class="p">.</span><span class="na">split</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)).</span><span class="na">map</span><span class="p">(</span><span class="n">Arrays</span><span class="o">::</span><span class="n">stream</span><span class="p">).</span><span class="na">distinct</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span><span class="n">toList</span><span class="p">());</span></code></pre></div>
<p>这个方法依然不行，因为<code>map(Arrays::stream)</code>返回一组流，准确的说是<code>List&lt;Stream&lt;String&gt;&gt;</code>。</p>

<h4 id="使用flatmap">使用flatMap</h4>

<p>可以使用<code>flatMap</code>解决这个问题：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">List&lt;String&gt; uniqueCharacters </span><span class="o">=</span> <span class="n">words</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">map</span><span class="p">(</span><span class="n">word</span> <span class="o">-&gt;</span> <span class="n">word</span><span class="p">.</span><span class="na">split</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)).</span><span class="na">flatMap</span><span class="p">(</span><span class="n">Arrays</span><span class="o">::</span><span class="n">stream</span><span class="p">).</span><span class="na">distinct</span><span class="p">().</span><span class="na">collect</span><span class="p">(</span><span class="n">toList</span><span class="p">());</span></code></pre></div>
<p><code>flatMap</code>将<code>map(Arrays::stream)</code>产生的一组流合并为一个流。</p>

<p>如下图所示：</p>

<p><img src="/static/images/2019/07/11/flatmap.png" alt="flatmap.png" /></p>

<h2 id="查找和匹配">查找和匹配</h2>

<h3 id="匹配至少一个元素">匹配至少一个元素</h3>

<p><code>anyMatch</code>用于查找至少一个匹配给定谓词，返回boolean</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="k">if</span> <span class="p">(</span><span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">anyMatch</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">isVegetarian</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;The menu is (somewhat) vegetarian friendly!!&#34;</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<h3 id="匹配所有元素">匹配所有元素</h3>

<p><code>allMatch</code>检查是否所有元素匹配给定谓词，返回boolean</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">boolean isHealthy </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">allMatch</span><span class="p">(</span><span class="n">dish</span> <span class="o">-&gt;</span> <span class="n">dish</span><span class="p">.</span><span class="na">getCalories</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">1000</span><span class="p">);</span></code></pre></div>
<h4 id="不匹配任何元素">不匹配任何元素</h4>

<p><code>noneMatch</code>所有元素都不满足给定谓词，返回boolean</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">boolean isHealthy </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">noneMatch</span><span class="p">(</span><span class="n">d</span> <span class="o">-&gt;</span> <span class="n">d</span><span class="p">.</span><span class="na">getCalories</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">1000</span><span class="p">);</span></code></pre></div>
<p><code>anyMatch</code>，<code>allMatch</code>和<code>noneMatch</code>都具有短路求值的特性。</p>

<h3 id="查找一个元素">查找一个元素</h3>

<p><code>findAny</code>返回流中任意一个元素。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">Optional&lt;Dish&gt; dish </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">filter</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">isVegetarian</span><span class="p">).</span><span class="na">findAny</span><span class="p">();</span></code></pre></div>
<h3 id="查找第一个元素">查找第一个元素</h3>

<p><code>findFirst</code>和<code>findAny</code>类似，<code>findFirst</code>查找第一个元素</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">List&lt;Integer&gt; someNumbers </span><span class="o">=</span> <span class="n">Arrays</span><span class="p">.</span><span class="na">asList</span><span class="p">(</span><span class="n">1</span><span class="p">,</span> <span class="n">2</span><span class="p">,</span> <span class="n">3</span><span class="p">,</span> <span class="n">4</span><span class="p">,</span> <span class="n">5</span><span class="p">);</span>
<span class="err">Optional&lt;Integer&gt; firstSquareDivisibleByThree </span><span class="o">=</span> <span class="n">someNumbers</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">map</span><span class="p">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="p">).</span><span class="na">filter</span><span class="p">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">%</span> <span class="n">3</span> <span class="o">==</span> <span class="n">0</span><span class="p">).</span><span class="na">findFirst</span><span class="p">();</span></code></pre></div>
<blockquote>
<p>findFirst在并行处理的时候有更多的限制，如果你不介意返回哪个元素，并行处理的时候选择findAny</p>
</blockquote>

<h2 id="归纳">归纳</h2>

<h3 id="计算元素的和">计算元素的和</h3>

<p>使用<code>reduce</code>计算流中所有元素的和：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">int sum </span><span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">reduce</span><span class="p">(</span><span class="n">0</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">);</span></code></pre></div>
<p><code>reduce</code>接受2个参数：</p>

<ul>
<li>一个初始值</li>
<li>一个<code>BinaryOperator&lt;T&gt;</code>计算2个元素的值并产生一个新值</li>
</ul>

<p>你可以使用方法引用使得代码更简明：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">int sum </span><span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">reduce</span><span class="p">(</span><span class="n">0</span><span class="p">,</span> <span class="n">Integer</span><span class="o">::</span><span class="n">sum</span><span class="p">);</span></code></pre></div>
<p>如下图所示：</p>

<p><img src="/static/images/2019/07/11/reduce.png" alt="reduce.png" /></p>

<h4 id="没有初始值">没有初始值</h4>

<p>还有一个不带初始值的<code>reduce</code>重载版本，它返回一个<code>Optional</code>对象</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">Optional&lt;Integer&gt; sum </span><span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">reduce</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">));</span></code></pre></div>
<h3 id="查找最大和最小元素">查找最大和最小元素</h3>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">Optional&lt;Integer&gt; max </span><span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">reduce</span><span class="p">(</span><span class="n">Integer</span><span class="o">::</span><span class="n">max</span><span class="p">);</span>
<span class="err">Optional&lt;Integer&gt; min </span><span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">reduce</span><span class="p">(</span><span class="n">Integer</span><span class="o">::</span><span class="n">min</span><span class="p">);</span></code></pre></div>
<p>流API总结表：</p>

<table>
<thead>
<tr>
<th>操作</th>
<th>类型</th>
<th>返回类型</th>
<th>参数(类型/函数接口)</th>
<th>函数描述符</th>
</tr>
</thead>

<tbody>
<tr>
<td>filter</td>
<td>中间操作</td>
<td>Stream&lt;T&gt;</td>
<td>Predicate&lt;T&gt;</td>
<td>T -&gt; boolean</td>
</tr>

<tr>
<td>distinct</td>
<td>中间操作(有状态-无上界)</td>
<td>Stream&lt;T&gt;</td>
<td></td>
<td></td>
</tr>

<tr>
<td>takeWhile</td>
<td>中间操作</td>
<td>Stream&lt;T&gt;</td>
<td>Predicate&lt;T&gt;</td>
<td>T -&gt; boolean</td>
</tr>

<tr>
<td>dropWhile</td>
<td>中间操作</td>
<td>Stream&lt;T&gt;</td>
<td>Predicate&lt;T&gt;</td>
<td>T -&gt; boolean</td>
</tr>

<tr>
<td>skip</td>
<td>中间操作(有状态-有上界)</td>
<td>Stream&lt;T&gt;</td>
<td>long</td>
<td></td>
</tr>

<tr>
<td>limit</td>
<td>中间操作(有状态-有上界)</td>
<td>Stream&lt;T&gt;</td>
<td>long</td>
<td></td>
</tr>

<tr>
<td>map</td>
<td>中间操作</td>
<td>Stream&lt;R&gt;</td>
<td>Function&lt;T, R&gt;</td>
<td>T -&gt; R</td>
</tr>

<tr>
<td>flatMap</td>
<td>中间操作</td>
<td>Stream&lt;R&gt;</td>
<td>Function&lt;T, Stream&lt;R&gt;&gt;</td>
<td>T -&gt; Stream&lt;R&gt;</td>
</tr>

<tr>
<td>sorted</td>
<td>中间操作(有状态-无上界)</td>
<td>Stream&lt;T&gt;</td>
<td>Comparator&lt;T&gt;</td>
<td>(T, T) -&gt; int</td>
</tr>

<tr>
<td>anyMatch</td>
<td>结束操作</td>
<td>boolean</td>
<td>Predicate&lt;T&gt;</td>
<td>T -&gt; boolean</td>
</tr>

<tr>
<td>noneMatch</td>
<td>结束操作</td>
<td>boolean</td>
<td>Predicate&lt;T&gt;</td>
<td>T -&gt; boolean</td>
</tr>

<tr>
<td>allMatch</td>
<td>结束操作</td>
<td>boolean</td>
<td>Predicate&lt;T&gt;</td>
<td>T -&gt; boolean</td>
</tr>

<tr>
<td>findAny</td>
<td>结束操作</td>
<td>Optional&lt;T&gt;</td>
<td></td>
<td></td>
</tr>

<tr>
<td>findFirst</td>
<td>结束操作</td>
<td>Optional&lt;T&gt;</td>
<td></td>
<td></td>
</tr>

<tr>
<td>forEach</td>
<td>结束操作</td>
<td>void</td>
<td>Consumer&lt;T&gt;</td>
<td>T -&gt; void</td>
</tr>

<tr>
<td>collect</td>
<td>结束操作</td>
<td>R</td>
<td>Collector&lt;T, A, R&gt;</td>
<td></td>
</tr>

<tr>
<td>reduce</td>
<td>结束操作(有状态-有上界)</td>
<td>Optional&lt;T&gt;</td>
<td>BinaryOperator&lt;T&gt;</td>
<td>(T, T) -&gt; T</td>
</tr>

<tr>
<td>count</td>
<td>结束操作</td>
<td>long</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<h2 id="数字流">数字流</h2>

<h3 id="原始类型的专有流">原始类型的专有流</h3>

<p>Java8提供3种基础类型的特殊流：<code>IntStream</code>，<code>DoubleStream</code>和<code>LongStream</code>。这些流提供了很多方便用于数值计算的方法，比如<code>sum</code>，<code>max</code>，<code>min</code>，<code>average</code></p>

<h4 id="映射为数字流">映射为数字流</h4>

<p>将一个流转换为数字流的最常用的方法是使用<code>mapToInt</code>，<code>mapToDouble</code>和<code>mapToLong</code>方法</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">int calories </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">mapToInt</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getCalories</span><span class="p">).</span><span class="na">sum</span><span class="p">();</span></code></pre></div>
<h3 id="转换回对象流">转换回对象流</h3>

<p>使用<code>boxed</code>方法将数字流转换为对象流</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">IntStream intStream </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">mapToInt</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getCalories</span><span class="p">);</span>
<span class="err">Stream&lt;Integer&gt; stream </span><span class="o">=</span> <span class="n">intStream</span><span class="p">.</span><span class="na">boxed</span><span class="p">();</span></code></pre></div>
<h3 id="默认值">默认值</h3>

<p>数字流有3个特殊版本的<code>Optinal</code>类型：<code>OptionalInt</code> ，<code>OptionalDouble</code> 和<code>OptionalLong</code></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">OptionalInt maxCalories </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">().</span><span class="na">mapToInt</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getCalories</span><span class="p">).</span><span class="na">max</span><span class="p">();</span>
<span class="err">int max </span><span class="o">=</span> <span class="n">maxCalories</span><span class="p">.</span><span class="na">orElse</span><span class="p">(</span><span class="n">1</span><span class="p">);</span></code></pre></div>
<h3 id="数字范围">数字范围</h3>

<p><code>IntStream</code>和<code>LongStream</code>提供2个静态方法<code>range</code>和<code>rangeClosed</code>用于生成数字范围。<code>range</code>的范围是[start, end)，<code>rangeClosed</code>的范围是[start, end]。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">IntStream evenNumbers </span><span class="o">=</span> <span class="n">IntStream</span><span class="p">.</span><span class="na">rangeClosed</span><span class="p">(</span><span class="n">1</span><span class="p">,</span> <span class="n">100</span><span class="p">).</span><span class="na">filter</span><span class="p">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">%</span> <span class="n">2</span> <span class="o">==</span> <span class="n">0</span><span class="p">);</span></code></pre></div>
<h3 id="数字流实例">数字流实例</h3>

<p>查找毕氏三元数(勾股数)</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">Stream&lt;int[]&gt; pythagoreanTriples </span><span class="o">=</span> <span class="n">IntStream</span><span class="p">.</span><span class="na">rangeClosed</span><span class="p">(</span><span class="n">1</span><span class="p">,</span> <span class="n">100</span><span class="p">).</span><span class="na">boxed</span><span class="p">().</span><span class="na">flatMap</span><span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">IntStream</span><span class="p">.</span><span class="na">rangeClosed</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">100</span><span class="p">).</span><span class="na">filter</span><span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">Math</span><span class="p">.</span><span class="na">sqrt</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">b</span><span class="p">)</span> <span class="o">%</span> <span class="n">1</span> <span class="o">==</span> <span class="n">0</span><span class="p">).</span><span class="na">mapToObj</span><span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span>
<span class="k">new</span> <span class="kt">int</span><span class="p">[]{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">Math</span><span class="p">.</span><span class="na">sqrt</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">)}));</span>
<span class="n">pythagoreanTriples</span><span class="p">.</span><span class="na">limit</span><span class="p">(</span><span class="n">5</span><span class="p">).</span><span class="na">forEach</span><span class="p">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">0</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#34;, &#34;</span> <span class="o">+</span> <span class="n">t</span><span class="p">[</span><span class="n">1</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#34;, &#34;</span> <span class="o">+</span> <span class="n">t</span><span class="p">[</span><span class="n">2</span><span class="p">]));</span></code></pre></div>
<p>第二种方法</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">Stream&lt;double[]&gt; pythagoreanTriples2 </span><span class="o">=</span> <span class="n">IntStream</span><span class="p">.</span><span class="na">rangeClosed</span><span class="p">(</span><span class="n">1</span><span class="p">,</span> <span class="n">100</span><span class="p">).</span><span class="na">boxed</span><span class="p">().</span><span class="na">flatMap</span><span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span>
<span class="n">IntStream</span><span class="p">.</span><span class="na">rangeClosed</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">100</span><span class="p">).</span><span class="na">mapToObj</span><span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[]{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">Math</span><span class="p">.</span><span class="na">sqrt</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">b</span><span class="p">)}).</span><span class="na">filter</span><span class="p">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="p">[</span><span class="n">2</span><span class="p">]</span> <span class="o">%</span> <span class="n">1</span> <span class="o">==</span> <span class="n">0</span><span class="p">));</span></code></pre></div>
<h2 id="创建流">创建流</h2>

<h3 id="从一组值创建流">从一组值创建流</h3>

<p><code>Stream.of</code>接受任意个数参数并返回一个流</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">Stream&lt;String&gt; stream </span><span class="o">=</span> <span class="n">Stream</span><span class="p">.</span><span class="na">of</span><span class="p">(</span><span class="s">&#34;Modern &#34;</span><span class="p">,</span> <span class="s">&#34;Java &#34;</span><span class="p">,</span> <span class="s">&#34;In &#34;</span><span class="p">,</span> <span class="s">&#34;Action&#34;</span><span class="p">);</span>
<span class="n">stream</span><span class="p">.</span><span class="na">map</span><span class="p">(</span><span class="n">String</span><span class="o">::</span><span class="n">toUpperCase</span><span class="p">).</span><span class="na">forEach</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="p">);</span></code></pre></div>
<p><code>Stream.empty</code>返回一个空流</p>

<h3 id="从可空元素创建流">从可空元素创建流</h3>

<p><code>Stream.ofNullable</code>可以从可空对象创建流</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">String homeValue </span><span class="o">=</span> <span class="n">System</span><span class="p">.</span><span class="na">getProperty</span><span class="p">(</span><span class="s">&#34;home&#34;</span><span class="p">);</span>
<span class="err">Stream&lt;String&gt; homeValueStream </span><span class="o">=</span> <span class="n">homeValue</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">Stream</span><span class="p">.</span><span class="na">empty</span><span class="p">()</span> <span class="o">:</span> <span class="n">Stream</span><span class="p">.</span><span class="na">of</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="err">Stream&lt;String&gt; homeValueStream </span><span class="o">=</span> <span class="n">Stream</span><span class="p">.</span><span class="na">ofNullable</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="na">getProperty</span><span class="p">(</span><span class="s">&#34;home&#34;</span><span class="p">));</span></code></pre></div>
<h3 id="从数组创建流">从数组创建流</h3>

<p><code>Arrays.stream</code>可以从数组创建流</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">int[] numbers </span><span class="o">=</span> <span class="p">{</span><span class="n">2</span><span class="p">,</span> <span class="n">3</span><span class="p">,</span> <span class="n">5</span><span class="p">,</span> <span class="n">7</span><span class="p">,</span> <span class="n">11</span><span class="p">,</span> <span class="n">13</span><span class="p">};</span>
<span class="err">int sum </span><span class="o">=</span> <span class="n">Arrays</span><span class="p">.</span><span class="na">stream</span><span class="p">(</span><span class="n">numbers</span><span class="p">).</span><span class="na">sum</span><span class="p">();</span></code></pre></div>
<h3 id="从文件创建流">从文件创建流</h3>

<p>java的NIO提供了许多静态方法返回流，比如<code>Files.lines</code></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">long uniqueWords </span><span class="o">=</span> <span class="n">0</span><span class="p">;</span>
<span class="k">try</span> <span class="p">(</span><span class="err">Stream&lt;String&gt; lines </span><span class="o">=</span> <span class="n">Files</span><span class="p">.</span><span class="na">lines</span><span class="p">(</span><span class="n">Paths</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="s">&#34;data.txt&#34;</span><span class="p">),</span> <span class="n">Charset</span><span class="p">.</span><span class="na">defaultCharset</span><span class="p">()))</span> <span class="p">{</span>
    <span class="n">uniqueWords</span> <span class="o">=</span> <span class="n">lines</span><span class="p">.</span><span class="na">flatMap</span><span class="p">(</span><span class="n">line</span> <span class="o">-&gt;</span> <span class="n">Arrays</span><span class="p">.</span><span class="na">stream</span><span class="p">(</span><span class="n">line</span><span class="p">.</span><span class="na">split</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">))).</span><span class="na">distinct</span><span class="p">().</span><span class="na">count</span><span class="p">();</span>
<span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="err">IOException e</span><span class="p">){</span>
<span class="p">}</span></code></pre></div>
<h3 id="从函数创建流">从函数创建流</h3>

<p><code>Stream.iterate</code>和<code>Stream.generate</code>可以让你创建一个无限流，通常需要结合<code>limit</code>使用</p>

<h4 id="iterate">iterate</h4>

<p><code>iterate</code>接受2个参数：</p>

<ul>
<li>初始值</li>

<li><p><code>UnaryOperator&lt;T&gt;</code>用于迭代产生新值</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Stream</span><span class="p">.</span><span class="na">iterate</span><span class="p">(</span><span class="n">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">+</span> <span class="n">2</span><span class="p">).</span><span class="na">limit</span><span class="p">(</span><span class="n">10</span><span class="p">).</span><span class="na">forEach</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="p">);</span></code></pre></div></li>
</ul>

<p>在Java9中，<code>iterate</code>被增强了，支持谓词。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">IntStream</span><span class="p">.</span><span class="na">iterate</span><span class="p">(</span><span class="n">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">100</span><span class="p">,</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">+</span> <span class="n">4</span><span class="p">).</span><span class="na">forEach</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="p">);</span></code></pre></div>
<p>相当于</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">IntStream</span><span class="p">.</span><span class="na">iterate</span><span class="p">(</span><span class="n">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">+</span> <span class="n">4</span><span class="p">).</span><span class="na">takeWhile</span><span class="p">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">100</span><span class="p">).</span><span class="na">forEach</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="p">);</span></code></pre></div>
<h4 id="generate">generate</h4>

<p><code>generate</code>接受一个<code>Supplier&lt;T&gt;</code>参数来产生新值</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Stream</span><span class="p">.</span><span class="na">generate</span><span class="p">(</span><span class="n">Math</span><span class="o">::</span><span class="n">random</span><span class="p">).</span><span class="na">limit</span><span class="p">(</span><span class="n">5</span><span class="p">).</span><span class="na">forEach</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="p">);</span></code></pre></div>
<p>使用<code>generate</code>生成前20个Fibonacci序列数字：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">IntSupplier fib </span><span class="o">=</span> <span class="k">new</span> <span class="n">IntSupplier</span><span class="p">()</span> <span class="p">{</span>
    <span class="err">private int </span><span class="n">previous</span> <span class="o">=</span> <span class="n">0</span><span class="p">;</span>
    <span class="err">private int </span><span class="n">current</span> <span class="o">=</span> <span class="n">1</span><span class="p">;</span>
    <span class="err">public int </span><span class="n">getAsInt</span><span class="p">(){</span>
        <span class="err">int oldPrevious </span><span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="na">previous</span><span class="p">;</span>
        <span class="err">int nextValue </span><span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="na">previous</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="na">current</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="na">previous</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="na">current</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="na">current</span> <span class="o">=</span> <span class="n">nextValue</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">oldPrevious</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="n">IntStream</span><span class="p">.</span><span class="na">generate</span><span class="p">(</span><span class="n">fib</span><span class="p">).</span><span class="na">limit</span><span class="p">(</span><span class="n">20</span><span class="p">).</span><span class="na">forEach</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="p">);</span></code></pre></div>]]></content>
		</item>
		
		<item>
			<title>流介绍</title>
			<link>https://gitop.cc/posts/introducing-streams/</link>
			<pubDate>Wed, 10 Jul 2019 17:22:30 +0800</pubDate>
			
			<guid>https://gitop.cc/posts/introducing-streams/</guid>
			<description>流是什么 流是对Java API的更新，允许你以声明式的方式操作数据集合。首先看一个例子，假设你想获得所有热量低于400卡的菜肴的名字，并按热量</description>
			<content type="html"><![CDATA[

<h2 id="流是什么">流是什么</h2>

<p>流是对Java API的更新，允许你以声明式的方式操作数据集合。首先看一个例子，假设你想获得所有热量低于400卡的菜肴的名字，并按热量排序。在Java 8之前，你可以这样做：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">List&lt;Dish&gt; lowCaloricDishes </span><span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="err">Dish dish </span><span class="o">:</span> <span class="n">menu</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dish</span><span class="p">.</span><span class="na">getCalories</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">400</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">lowCaloricDishes</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">dish</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">Collections</span><span class="p">.</span><span class="na">sort</span><span class="p">(</span><span class="n">lowCaloricDishes</span><span class="p">,</span> <span class="k">new</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Dish</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">{</span>
    <span class="err">public int </span><span class="n">compare</span><span class="p">(</span><span class="err">Dish dish1</span><span class="p">,</span> <span class="err">Dish dish2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Integer</span><span class="p">.</span><span class="na">compare</span><span class="p">(</span><span class="n">dish1</span><span class="p">.</span><span class="na">getCalories</span><span class="p">(),</span> <span class="n">dish2</span><span class="p">.</span><span class="na">getCalories</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="err">List&lt;String&gt; lowCaloricDishesName </span><span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="err">Dish dish </span><span class="o">:</span> <span class="n">lowCaloricDishes</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lowCaloricDishesName</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">dish</span><span class="p">.</span><span class="na">getName</span><span class="p">());</span>
<span class="p">}</span></code></pre></div>
<p>在Java 8之后，你只需这样做：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">import static </span><span class="n">java</span><span class="p">.</span><span class="na">util</span><span class="p">.</span><span class="na">Comparator</span><span class="p">.</span><span class="na">comparing</span><span class="p">;</span>
<span class="err">import static </span><span class="n">java</span><span class="p">.</span><span class="na">util</span><span class="p">.</span><span class="na">stream</span><span class="p">.</span><span class="na">Collectors</span><span class="p">.</span><span class="na">toList</span><span class="p">;</span>
<span class="err">List&lt;String&gt; lowCaloricDishesName </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">stream</span><span class="p">()</span>
    <span class="p">.</span><span class="na">filter</span><span class="p">(</span><span class="n">d</span> <span class="o">-&gt;</span> <span class="n">d</span><span class="p">.</span><span class="na">getCalories</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">400</span><span class="p">)</span>
    <span class="p">.</span><span class="na">sorted</span><span class="p">(</span><span class="n">comparing</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getCalories</span><span class="p">))</span>
    <span class="p">.</span><span class="na">map</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getName</span><span class="p">)</span>
    <span class="p">.</span><span class="na">collect</span><span class="p">(</span><span class="n">toList</span><span class="p">());</span></code></pre></div>
<p>要利用多核体系结构并行执行此代码，只需将<code>stream()</code>更改为<code>parallelStream()</code></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">List&lt;String&gt; lowCaloricDishesName </span><span class="o">=</span> <span class="n">menu</span><span class="p">.</span><span class="na">parallelStream</span><span class="p">()</span>
    <span class="p">.</span><span class="na">filter</span><span class="p">(</span><span class="n">d</span> <span class="o">-&gt;</span> <span class="n">d</span><span class="p">.</span><span class="na">getCalories</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">400</span><span class="p">)</span>
    <span class="p">.</span><span class="na">sorted</span><span class="p">(</span><span class="n">comparing</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getCalories</span><span class="p">))</span>
    <span class="p">.</span><span class="na">map</span><span class="p">(</span><span class="n">Dish</span><span class="o">::</span><span class="n">getName</span><span class="p">)</span>
    <span class="p">.</span><span class="na">collect</span><span class="p">(</span><span class="n">toList</span><span class="p">());</span></code></pre></div>
<p>总之，Java 8中的流API允许你编写这样的代码</p>

<ul>
<li>声明式：更简洁，可读性更强</li>
<li>可组合：更灵活</li>
<li>可并行：更好的性能</li>
</ul>

<h2 id="开始使用流">开始使用流</h2>

<p>首先，流到底是什么？一个简短的定义是，来自某个数据源的支持数据处理操作的元素序列。</p>

<ul>
<li>元素序列：与集合类似，流提供了访问特定类型元素集的接口。集合是关于数据的，流是关于计算的。</li>
<li>数据源：流从数据源（如集合、数组或I/O资源）消费。从集合生成的流保留了集合中元素的顺序。</li>
<li>数据处理操作：流支持类似数据库的操作，以及函数式编程语言的常见操作来操作数据。比如filter，map，reduce，find， match， sort等。流操作可以顺序执行，也可以并行执行。</li>
</ul>

<p>此外，流操作还有两个重要特征：</p>

<ul>
<li>流管道：许多流操作返回流本身，允许将操作链接起来形成一个更大的流管道。这样可以支持某些优化，比如惰性求值和短路求值。在数据源上的流管道操作可以看作类似数据库的查询。</li>
<li>内部迭代：与集合相反，流操作在内部进行迭代。</li>
</ul>

<h2 id="流与集合">流与集合</h2>

<h3 id="只遍历一次">只遍历一次</h3>

<p>与迭代器类似，流只能遍历一次，遍历之后流就被消耗殆尽了。你可以从初始数据源获得一个新的流来再次遍历它。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">List&lt;String&gt; title </span><span class="o">=</span> <span class="n">Arrays</span><span class="p">.</span><span class="na">asList</span><span class="p">(</span><span class="s">&#34;Modern&#34;</span><span class="p">,</span> <span class="s">&#34;Java&#34;</span><span class="p">,</span> <span class="s">&#34;In&#34;</span><span class="p">,</span> <span class="s">&#34;Action&#34;</span><span class="p">);</span>
<span class="err">Stream&lt;String&gt; s </span><span class="o">=</span> <span class="n">title</span><span class="p">.</span><span class="na">stream</span><span class="p">();</span>
<span class="n">s</span><span class="p">.</span><span class="na">forEach</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="p">);</span>
<span class="n">s</span><span class="p">.</span><span class="na">forEach</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="p">);</span> <span class="o">//</span> <span class="n">java</span><span class="p">.</span><span class="na">lang</span><span class="p">.</span><span class="na">IllegalStateException</span></code></pre></div>
<h3 id="外部迭代与内部迭代">外部迭代与内部迭代</h3>

<p>集合需要用户进行迭代，比如使用foreach，这称为外部迭代。与之相反，流使用内部迭代，即为你执行迭代，并负责将流产生的值存储在某个地方，你只需提供一个函数说明要做什么。</p>

<h2 id="流操作">流操作</h2>

<p>可以连接的流操作称为中间操作，关闭流的操作称为结束操作。</p>

<h3 id="中间操作">中间操作</h3>

<p>中间操作（如filter或sorted）返回另一个流，这允许将操作连接起来形成查询。重要的是，在调用结束操作之前，中间操作不会执行任何处理，它们是惰性求值的。这是因为中间操作通常可以被结束操作合并一次处理。</p>

<h3 id="结束操作">结束操作</h3>

<p>结束操作从流管道产生一个非流值结果。</p>

<h3 id="使用流">使用流</h3>

<p>总而言之，使用流通常包括三个部分：</p>

<ul>
<li>执行查询的数据源，比如集合</li>
<li>形成流管道的一系列中间操作</li>
<li>执行流管道并产生结果的结束操作</li>
</ul>

<p>下表总结了一些常见流操作。</p>

<table>
<thead>
<tr>
<th>操作</th>
<th>类型</th>
<th>返回类型</th>
<th>参数</th>
<th>函数描述符</th>
</tr>
</thead>

<tbody>
<tr>
<td>filter</td>
<td>中间操作</td>
<td>Stream&lt;T&gt;</td>
<td>Predicate&lt;T&gt;</td>
<td>T -&gt; boolean</td>
</tr>

<tr>
<td>map</td>
<td>中间操作</td>
<td>Stream&lt;R&gt;</td>
<td>Function&lt;T, R&gt;</td>
<td>T -&gt; R</td>
</tr>

<tr>
<td>limit</td>
<td>中间操作</td>
<td>Stream&lt;T&gt;</td>
<td></td>
<td></td>
</tr>

<tr>
<td>sorted</td>
<td>中间操作</td>
<td>Stream&lt;T&gt;</td>
<td>Comparator&lt;T&gt;</td>
<td>(T, T) -&gt; int</td>
</tr>

<tr>
<td>distinct</td>
<td>中间操作</td>
<td>Stream&lt;T&gt;</td>
<td></td>
<td></td>
</tr>

<tr>
<td>forEach</td>
<td>结束操作</td>
<td>void</td>
<td>Consumer&lt;T&gt;</td>
<td>T -&gt; void</td>
</tr>

<tr>
<td>count</td>
<td>结束操作</td>
<td>long</td>
<td></td>
<td></td>
</tr>

<tr>
<td>collect</td>
<td>结束操作</td>
<td>R</td>
<td>Collector&lt;T, A, R&gt;</td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
		</item>
		
		<item>
			<title>Lambda表达式</title>
			<link>https://gitop.cc/posts/lambda-expressions/</link>
			<pubDate>Wed, 10 Jul 2019 08:48:55 +0800</pubDate>
			
			<guid>https://gitop.cc/posts/lambda-expressions/</guid>
			<description>Lambda概述 lambda表达式没有名称，但是它有参数列表，函数体和返回类型，还可能包含一个异常列表。 匿名，lambda表达式不像方法一样</description>
			<content type="html"><![CDATA[

<h2 id="lambda概述">Lambda概述</h2>

<p>lambda表达式没有名称，但是它有参数列表，函数体和返回类型，还可能包含一个异常列表。</p>

<ul>
<li>匿名，lambda表达式不像方法一样有一个显式的名字</li>
<li>函数，lambda表达式不像方法一样关联到一个特定的类</li>
<li>传递，lambda表达式可以像函数参数一样传递，或者保存到变量里面</li>
<li>简洁，不需要像匿名类一样写很多样板代码</li>
</ul>

<p>lambda基本语法有2种</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="p">(</span><span class="n">parameters</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">expression</span></code></pre></div>
<p>和</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="p">(</span><span class="n">parameters</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">statements</span><span class="p">;</span> <span class="p">}</span></code></pre></div>
<table>
<thead>
<tr>
<th>用例</th>
<th>lambda示例</th>
</tr>
</thead>

<tbody>
<tr>
<td>布尔表达式</td>
<td>(List&lt;String&gt; list) -&gt; list.isEmpty()</td>
</tr>

<tr>
<td>创建对象</td>
<td>() -&gt; new Apple(10)</td>
</tr>

<tr>
<td>消费对象</td>
<td>(Apple a) -&gt; { System.out.println(a.getWeight()); }</td>
</tr>

<tr>
<td>从对象中提取属性</td>
<td>(String s) -&gt; s.length()</td>
</tr>

<tr>
<td>合并两个值</td>
<td>(int a, int b) -&gt; a * b</td>
</tr>

<tr>
<td>比较两个对象</td>
<td>(Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight())</td>
</tr>
</tbody>
</table>

<h2 id="哪里可以使用lambda">哪里可以使用lambda</h2>

<p>你可以在函数接口上下文中使用lambda表达式</p>

<h3 id="函数接口">函数接口</h3>

<p>简单地说，函数接口就是只有一个抽象方法的接口，比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public interface </span><span class="n">Predicate</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="err">boolean test </span><span class="p">(</span><span class="err">T t</span><span class="p">);</span>
<span class="p">}</span>

<span class="err">public interface </span><span class="n">Comparator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="err">int compare</span><span class="p">(</span><span class="err">T o1</span><span class="p">,</span> <span class="err">T o2</span><span class="p">);</span>
<span class="p">}</span>

<span class="err">public interface </span><span class="n">Runnable</span> <span class="p">{</span>
    <span class="err">void run</span><span class="p">();</span>
<span class="p">}</span>

<span class="err">public interface ActionListener extends </span><span class="n">EventListener</span> <span class="p">{</span>
    <span class="err">void actionPerformed</span><span class="p">(</span><span class="err">ActionEvent e</span><span class="p">);</span>
<span class="p">}</span>

<span class="err">public interface </span><span class="n">Callable</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="err">V call</span><span class="p">()</span> <span class="err">throws Exception</span><span class="p">;</span>
<span class="p">}</span>

<span class="err">public interface </span><span class="n">PrivilegedAction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="err">T run</span><span class="p">();</span>
<span class="p">}</span></code></pre></div>
<blockquote>
<p>注意，接口现在可以有默认方法。如果一个接口有许多默认方法，只要它只有一个抽象方法，那么它仍然是一个函数接口。</p>
</blockquote>

<p>lambda表达式可以为函数接口的抽象方法提供实现，并将整个表达式看做函数接口的一个实例。</p>

<h3 id="函数描述符">函数描述符</h3>

<p>函数接口的抽象方法的签名描述了lambda表达式的签名，我们称这个抽象方法为函数描述符。我们使用一个特殊的标记来描述函数描述符，比如() -&gt; void表示参数为空并返回void的函数。</p>

<p>只要lambda表达式具有与函数接口的抽象方法相同的签名，就可以将lambda表达式赋值给变量或传递给参数为函数接口的方法。</p>

<blockquote>
<p>下面这个lambda表达式合法：() -&gt; System.out.println(&ldquo;This is awesome&rdquo;);
<code>System.out.println</code>不是一个表达式，为什么不需要用花括号括起来？ 原来，在Java语言规范中定义了一个用于void方法调用的特殊规则，void方法调用不需要使用花括号。</p>

<p>@FunctionalInterface用于指示一个接口是函数接口。如果使用@FunctionalInterface定义一个不是函数接口的接口，编译器会返回一个警告。@FunctionalInterface不是强制性的，但是使用它定义函数接口是个好习惯。</p>
</blockquote>

<h2 id="使用函数接口">使用函数接口</h2>

<h3 id="predicate-t">Predicate&lt;T&gt;</h3>

<p><code>java.util.function.Predicate&lt;T&gt;</code>定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@FunctionalInterface</span>
<span class="err">public interface </span><span class="n">Predicate</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="err">boolean test</span><span class="p">(</span><span class="err">T t</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<h3 id="consumer-t">Consumer&lt;T&gt;</h3>

<p><code>java.util.function.Consumer&lt;T&gt;</code>定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@FunctionalInterface</span>
<span class="err">public interface </span><span class="n">Consumer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="err">void accept</span><span class="p">(</span><span class="err">T t</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<h3 id="function-t-r">Function&lt;T, R&gt;</h3>

<p><code>java.util.function.Function&lt;T, R&gt;</code>定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="nd">@FunctionalInterface</span>
<span class="err">public interface </span><span class="n">Function</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="err">R apply</span><span class="p">(</span><span class="err">T t</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>Java 8同样添加了特殊版的函数接口以避免基础类型的autoboxing：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public interface </span><span class="n">IntPredicate</span> <span class="p">{</span>
    <span class="err">boolean test</span><span class="p">(</span><span class="err">int t</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>
<p>常用函数接口表</p>

<table>
<thead>
<tr>
<th>函数接口</th>
<th>函数描述符</th>
<th>特殊版本函数接口</th>
</tr>
</thead>

<tbody>
<tr>
<td>Predicate&lt;T&gt;</td>
<td>T -&gt; boolean</td>
<td>IntPredicate<br/>LongPredicate<br/>DoublePredicate</td>
</tr>

<tr>
<td>Consumer&lt;T&gt;</td>
<td>T -&gt; void</td>
<td>IntConsumer<br/>LongConsumer<br/>DoubleConsumer</td>
</tr>

<tr>
<td>Function&lt;T, R&gt;</td>
<td>T -&gt; R</td>
<td>IntFunction&lt;R&gt;<br/>IntToDoubleFunction<br/>IntToLongFunction<br/>LongFunction&lt;R&gt;<br/>LongToDoubleFunction<br/>LongToIntFunction<br/>DoubleFunction&lt;R&gt;<br/>DoubleToIntFunction<br/>DoubleToLongFunction<br/>ToIntFunction&lt;T&gt;<br/>ToDoubleFunction&lt;T&gt;<br/>ToLongFunction&lt;T&gt;</td>
</tr>

<tr>
<td>Supplier&lt;T&gt;</td>
<td>() -&gt; T</td>
<td>BooleanSupplier<br/>IntSupplier<br/>LongSupplier<br/>DoubleSupplier</td>
</tr>

<tr>
<td>UnaryOperator&lt;T&gt;</td>
<td>T -&gt; T</td>
<td>IntUnaryOperator<br/>LongUnaryOperator<br/>DoubleUnaryOperator</td>
</tr>

<tr>
<td>BinaryOperator&lt;T&gt;</td>
<td>(T, T) -&gt; T</td>
<td>IntBinaryOperator<br/>LongBinaryOperator<br/>DoubleBinaryOperator</td>
</tr>

<tr>
<td>BiPredicate&lt;T, U&gt;</td>
<td>(T, U) -&gt; boolean</td>
<td></td>
</tr>

<tr>
<td>BiConsumer&lt;T, U&gt;</td>
<td>(T, U) -&gt; void</td>
<td>ObjIntConsumer&lt;T&gt;<br/>ObjLongConsumer&lt;T&gt;<br/>ObjDoubleConsumer&lt;T&gt;</td>
</tr>

<tr>
<td>BiFunction&lt;T, U, R&gt;</td>
<td>(T, U) -&gt; R</td>
<td>ToIntBiFunction&lt;T, U&gt;<br/>ToLongBiFunction&lt;T, U&gt;<br/>ToDoubleBiFunction&lt;T, U&gt;</td>
</tr>
</tbody>
</table>

<blockquote>
<p>注意这些函数接口都不允许抛出checked异常。如果你需要lambda表达式抛出异常，你可以定义自己的函数接口声明checked异常，或者在lambda表达式函数体中catch异常。</p>
</blockquote>

<h2 id="类型检查-类型推断与限制">类型检查，类型推断与限制</h2>

<h3 id="类型检查">类型检查</h3>

<p>lambda表达式的类型是从使用lambda表达式的上下文中推导出来的。lambda表达式上下文中期待的类型称为目标类型。</p>

<h3 id="同样的lambda不同的函数接口">同样的lambda不同的函数接口</h3>

<p>由于目标类型的原因，如果不同的函数接口具有兼容的抽象方法签名，相同的lambda表达式可以关联到它们。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">Comparator&lt;Apple&gt; c1 </span><span class="o">=</span> <span class="p">(</span><span class="err">Apple a1</span><span class="p">,</span> <span class="err">Apple a2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a1</span><span class="p">.</span><span class="na">getWeight</span><span class="p">().</span><span class="na">compareTo</span><span class="p">(</span><span class="n">a2</span><span class="p">.</span><span class="na">getWeight</span><span class="p">());</span>
<span class="n">ToIntBiFunction</span><span class="o">&lt;</span><span class="n">Apple</span><span class="p">,</span> <span class="err">Apple&gt; c2 </span><span class="o">=</span> <span class="p">(</span><span class="err">Apple a1</span><span class="p">,</span> <span class="err">Apple a2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a1</span><span class="p">.</span><span class="na">getWeight</span><span class="p">().</span><span class="na">compareTo</span><span class="p">(</span><span class="n">a2</span><span class="p">.</span><span class="na">getWeight</span><span class="p">());</span>
<span class="n">BiFunction</span><span class="o">&lt;</span><span class="n">Apple</span><span class="p">,</span> <span class="n">Apple</span><span class="p">,</span> <span class="err">Integer&gt; c3 </span><span class="o">=</span> <span class="p">(</span><span class="err">Apple a1</span><span class="p">,</span> <span class="err">Apple a2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a1</span><span class="p">.</span><span class="na">getWeight</span><span class="p">().</span><span class="na">compareTo</span><span class="p">(</span><span class="n">a2</span><span class="p">.</span><span class="na">getWeight</span><span class="p">());</span></code></pre></div>
<blockquote>
<p>特殊的void兼容规则</p>

<p>如果lambda函数体是一个表达式语句，则它和返回void的函数描述符兼容。比如：</p>

<p>// Predicate has a boolean return</p>

<p>Predicate&lt;String&gt; p = (String s) -&gt; list.add(s);</p>

<p>// Consumer has a void return</p>

<p>Consumer&lt;String&gt; b = (String s) -&gt; list.add(s);</p>
</blockquote>

<h3 id="类型推断">类型推断</h3>

<p>Java编译器可以推断出lambda表达式关联的函数接口，意味着它也能够推导出相应的抽象函数的签名。好处是Java编译器知道lambda表达式的参数类型，因此lambda表达式可以忽略掉参数类型：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">List&lt;Apple&gt; greenApples </span><span class="o">=</span> <span class="n">filter</span><span class="p">(</span><span class="n">inventory</span><span class="p">,</span> <span class="n">apple</span> <span class="o">-&gt;</span> <span class="n">GREEN</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">apple</span><span class="p">.</span><span class="na">getColor</span><span class="p">()));</span>
<span class="err">Comparator&lt;Apple&gt; c </span><span class="o">=</span> <span class="p">(</span><span class="err">Apple a1</span><span class="p">,</span> <span class="err">Apple a2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a1</span><span class="p">.</span><span class="na">getWeight</span><span class="p">().</span><span class="na">compareTo</span><span class="p">(</span><span class="n">a2</span><span class="p">.</span><span class="na">getWeight</span><span class="p">());</span>
<span class="err">Comparator&lt;Apple&gt; c </span><span class="o">=</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a1</span><span class="p">.</span><span class="na">getWeight</span><span class="p">().</span><span class="na">compareTo</span><span class="p">(</span><span class="n">a2</span><span class="p">.</span><span class="na">getWeight</span><span class="p">());</span></code></pre></div>
<h3 id="使用局部变量">使用局部变量</h3>

<p>lambda表达式允许使用自由变量（不是参数且定义在外部作用域），就像匿名类一样。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">int portNumber </span><span class="o">=</span> <span class="n">1337</span><span class="p">;</span>
<span class="err">Runnable r </span><span class="o">=</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">portNumber</span><span class="p">);</span></code></pre></div>
<p>Lambda可以不受限制地捕获实例变量和静态变量。但是当捕获局部变量时，必须显式地声明它们为final或有效的final。Lambda表达式可以捕获只分赋值一次的局部变量。下面的代码将编译不了：</p>

<pre><code>int portNumber = 1337;
Runnable r = () -&gt; System.out.println(portNumber);
portNumber = 31337;
</code></pre>

<h4 id="局部变量的限制">局部变量的限制</h4>

<p>实例变量和局部变量在实现方式上有一个关键区别。实例变量存储在堆上，而局部变量存储在堆栈上。如果lambda可以直接访问局部变量，并且lambda在线程中使用，那么使用lambda的线程可以在分配变量的线程释放变量之后尝试访问该变量。因此Java将对自由变量的访问实现为对它的副本的访问，而不是对原始变量的访问。</p>

<h2 id="方法引用">方法引用</h2>

<p>方法引用可以看作是只调用特定方法的lambda表达式的简写，可以将方法引用看作lambda的语法糖。</p>

<table>
<thead>
<tr>
<th>Lambda</th>
<th>等价方法引用</th>
</tr>
</thead>

<tbody>
<tr>
<td>(Apple apple) -&gt; apple.getWeight()</td>
<td>Apple::getWeight</td>
</tr>

<tr>
<td>() -&gt; Thread.currentThread().dumpStack()</td>
<td>Thread.currentThread()::dumpStack</td>
</tr>

<tr>
<td>(str, i) -&gt; str.substring(i)</td>
<td>String::substring</td>
</tr>

<tr>
<td>(String s) -&gt; System.out.println(s)</td>
<td>System.out::println</td>
</tr>

<tr>
<td>(String s) -&gt; this.isValidName(s)</td>
<td>this::isValidName</td>
</tr>
</tbody>
</table>

<h4 id="构造方法引用">构造方法引用</h4>

<p>如下图：</p>

<p><img src="/static/images/2019/07/10/method-reference.png" alt="method-reference.png" /></p>

<h3 id="构造函数引用">构造函数引用</h3>

<p>使用类名和关键字new创建构造函数引用：<code>ClassName::new</code>，类似静态方法引用。比如，如果有不带参数的构造函数</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">Supplier&lt;Apple&gt; c1 </span><span class="o">=</span> <span class="n">Apple</span><span class="o">::</span><span class="k">new</span><span class="p">;</span>
<span class="err">Apple a1 </span><span class="o">=</span> <span class="n">c1</span><span class="p">.</span><span class="na">get</span><span class="p">();</span></code></pre></div>
<p>等价于</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">Supplier&lt;Apple&gt; c1 </span><span class="o">=</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">Apple</span><span class="p">();</span>
<span class="err">Apple a1 </span><span class="o">=</span> <span class="n">c1</span><span class="p">.</span><span class="na">get</span><span class="p">();</span></code></pre></div>
<p>如果有带一个参数的构造函数，则满足Function函数接口：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Function</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="err">Apple&gt; c2 </span><span class="o">=</span> <span class="n">Apple</span><span class="o">::</span><span class="k">new</span><span class="p">;</span>
<span class="err">Apple a2 </span><span class="o">=</span> <span class="n">c2</span><span class="p">.</span><span class="na">apply</span><span class="p">(</span><span class="n">110</span><span class="p">);</span></code></pre></div>
<p>如果有带亮个参数的构造函数，则满足BiFunction函数接口：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">BiFunction</span><span class="o">&lt;</span><span class="n">Color</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="err">Apple&gt; c3 </span><span class="o">=</span> <span class="n">Apple</span><span class="o">::</span><span class="k">new</span><span class="p">;</span>
<span class="err">Apple a3 </span><span class="o">=</span> <span class="n">c3</span><span class="p">.</span><span class="na">apply</span><span class="p">(</span><span class="n">GREEN</span><span class="p">,</span> <span class="n">110</span><span class="p">);</span></code></pre></div>
<h2 id="组合lambda表达式的有用方法">组合lambda表达式的有用方法</h2>

<h3 id="组合comparators">组合Comparators</h3>

<p>静态方法<code>Comparator.comparing</code>返回一个基于函数的Comparator，该函数提取一个关键字进行比较，如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">Comparator&lt;Apple&gt; c </span><span class="o">=</span> <span class="n">Comparator</span><span class="p">.</span><span class="na">comparing</span><span class="p">(</span><span class="n">Apple</span><span class="o">::</span><span class="n">getWeight</span><span class="p">);</span></code></pre></div>
<h4 id="反向比较">反向比较</h4>

<p><code>reversed</code>方法反转指定Comparator的顺序：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">inventory</span><span class="p">.</span><span class="na">sort</span><span class="p">(</span><span class="n">comparing</span><span class="p">(</span><span class="n">Apple</span><span class="o">::</span><span class="n">getWeight</span><span class="p">).</span><span class="na">reversed</span><span class="p">());</span></code></pre></div>
<h4 id="链接comparators">链接Comparators</h4>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">inventory</span><span class="p">.</span><span class="na">sort</span><span class="p">(</span><span class="n">comparing</span><span class="p">(</span><span class="n">Apple</span><span class="o">::</span><span class="n">getWeight</span><span class="p">).</span><span class="na">reversed</span><span class="p">().</span><span class="na">thenComparing</span><span class="p">(</span><span class="n">Apple</span><span class="o">::</span><span class="n">getCountry</span><span class="p">));</span></code></pre></div>
<h3 id="组合predicates">组合Predicates</h3>

<p>谓词接口包含三个方法，可以重用现有的谓词来创建更复杂的谓词：<code>negate</code>、<code>and</code>和<code>or</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="err">Predicate&lt;Apple&gt; notRedApple </span><span class="o">=</span> <span class="n">redApple</span><span class="p">.</span><span class="na">negate</span><span class="p">();</span>
<span class="err">Predicate&lt;Apple&gt; redAndHeavyApple </span><span class="o">=</span> <span class="n">redApple</span><span class="p">.</span><span class="na">and</span><span class="p">(</span><span class="n">apple</span> <span class="o">-&gt;</span> <span class="n">apple</span><span class="p">.</span><span class="na">getWeight</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">150</span><span class="p">);</span>
<span class="err">Predicate&lt;Apple&gt; redAndHeavyAppleOrGreen </span><span class="o">=</span> <span class="n">redApple</span><span class="p">.</span><span class="na">and</span><span class="p">(</span><span class="n">apple</span> <span class="o">-&gt;</span> <span class="n">apple</span><span class="p">.</span><span class="na">getWeight</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">150</span><span class="p">).</span><span class="na">or</span><span class="p">(</span><span class="n">apple</span> <span class="o">-&gt;</span> <span class="n">GREEN</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="na">getColor</span><span class="p">()));</span></code></pre></div>
<p>注意方法的优先级是从左到右。</p>

<h3 id="组合functions">组合Functions</h3>

<p>Function接口提供2个方法用于组合lambda表达式：<code>andThen</code>和<code>compose</code>。</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Function</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="err">Integer&gt; f </span><span class="o">=</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">1</span><span class="p">;</span>
<span class="n">Function</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="err">Integer&gt; g </span><span class="o">=</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">2</span><span class="p">;</span>
<span class="n">Function</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="err">Integer&gt; h </span><span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="na">andThen</span><span class="p">(</span><span class="n">g</span><span class="p">);</span> <span class="c1">// In mathematics you’d write g(f(x))
</span><span class="c1"></span><span class="n">Function</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="err">Integer&gt; j </span><span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="na">compose</span><span class="p">(</span><span class="n">g</span><span class="p">);</span> <span class="c1">// In mathematics you’d write f(g(x))
</span><span class="c1"></span><span class="err">int result1 </span><span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="na">apply</span><span class="p">(</span><span class="n">1</span><span class="p">);</span>
<span class="err">int result2 </span><span class="o">=</span> <span class="n">j</span><span class="p">.</span><span class="na">apply</span><span class="p">(</span><span class="n">1</span><span class="p">);</span></code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Git配置多个SSH-Key</title>
			<link>https://gitop.cc/posts/git-multi-sshkey/</link>
			<pubDate>Mon, 08 Jul 2019 16:59:22 +0800</pubDate>
			
			<guid>https://gitop.cc/posts/git-multi-sshkey/</guid>
			<description>转自这里 背景 当有多个git账号时，比如： 一个gitee，用于公司内部的工作开发； 一个github，用于自己进行一些开发活动； 解决方法 1.生成</description>
			<content type="html"><![CDATA[

<p>转自<a href="https://gitee.com/help/articles/4229">这里</a></p>

<h3 id="背景">背景</h3>

<p>当有多个git账号时，比如：</p>

<ul>
<li>一个gitee，用于公司内部的工作开发；</li>
<li>一个github，用于自己进行一些开发活动；</li>
</ul>

<h3 id="解决方法">解决方法</h3>

<p>1.生成一个公司用的SSH-Key</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ ssh-keygen -t rsa -C <span class="s1">&#39;xxxxx@company.com&#39;</span> -f ~/.ssh/gitee_id_rsa</code></pre></div>
<p>2.生成一个github用的SSH-Key</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ ssh-keygen -t rsa -C <span class="s1">&#39;xxxxx@qq.com&#39;</span> -f ~/.ssh/github_id_rsa</code></pre></div>
<p>3.在 ~/.ssh 目录下新建一个config文件，添加如下内容（其中Host和HostName填写git服务器的域名，IdentityFile指定私钥的路径）</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># gitee</span>
Host gitee.com
HostName gitee.com
PreferredAuthentications publickey
IdentityFile ~/.ssh/gitee_id_rsa
<span class="c1"># github</span>
Host github.com
HostName github.com
PreferredAuthentications publickey
IdentityFile ~/.ssh/github_id_rsa</code></pre></div>
<p>4.用ssh命令分别测试</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ ssh -T git@gitee.com
$ ssh -T git@github.com</code></pre></div>
<p>这里以gitee为例，成功的话会返回下图内容</p>

<p><img src="/static/images/2019/07/08/ssh-test-success.png" alt="ssh-test-success.png" /></p>
]]></content>
		</item>
		
		<item>
			<title>Greenplum TPC-H测试</title>
			<link>https://gitop.cc/posts/tpch-test/</link>
			<pubDate>Sun, 14 Apr 2019 15:40:23 +0800</pubDate>
			
			<guid>https://gitop.cc/posts/tpch-test/</guid>
			<description>首先从官网下载TPC-H_Tools_v2.18.0.zip，解压 $ unzip TPC-H_Tools_v2.18.0.zip 进入dbgen目录，拷贝Makefile $ cd tpc/2.18.0_rc2/dbgen $ cp makefile.suite Makefile 修改Makef</description>
			<content type="html"><![CDATA[<p>首先从<a href="http://www.tpc.org">官网</a>下载TPC-H_Tools_v2.18.0.zip，解压</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ unzip TPC-H_Tools_v2.18.0.zip</code></pre></div>

<p>进入<code>dbgen</code>目录，拷贝Makefile</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> tpc/2.18.0_rc2/dbgen
$ cp makefile.suite Makefile</code></pre></div>

<p>修改Makefile，主要修改如下</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">CC</span>      <span class="o">=</span> gcc
<span class="nv">DATABASE</span> <span class="o">=</span> ORACLE
<span class="nv">MACHINE</span> <span class="o">=</span> LINUX
<span class="nv">WORKLOAD</span> <span class="o">=</span> TPCH</code></pre></div>

<p>编译<code>dbgen</code></p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ make</code></pre></div>

<p><code>./dbgen -h</code>可以查看<code>dbgen</code>的用法</p>

<p>使用<code>dbgen</code>产生一些测试数据，<code>-s</code>表示scale(单位GB)</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ ./dbgen -s <span class="m">50</span> -f
$ ll -h *.tbl</code></pre></div>

<p>将测试数据转换为PostgreSQL能够识别的格式，并删除末尾的分隔符<code>|</code></p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="k">for</span> i in <span class="sb">`</span>ls *.tbl<span class="sb">`</span><span class="p">;</span> <span class="k">do</span> sed <span class="s1">&#39;s/|$//&#39;</span> <span class="nv">$i</span> &gt; <span class="si">${</span><span class="nv">i</span><span class="p">/tbl/csv</span><span class="si">}</span><span class="p">;</span> <span class="k">done</span>
$ ll -h *.csv</code></pre></div>

<p>创建软链接<code>/tmp/dss-data</code>指向包含csv文件的目录</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ ln -s <span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span> /tmp/dss-data</code></pre></div>

<p>下载pg_tpch</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ git clone https://github.com/digoal/pg_tpch.git</code></pre></div>

<p>将pg_tpch的文件逗拷贝到dbgen目录下面</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ cp -r ~/pg_tpch/* ~/tpc/2.18.0_rc2/dbgen</code></pre></div>

<p>创建一个<code>queries</code>目录，用于存放转换后的TPC-H测试SQL</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> ~/tpc/2.18.0_rc2/dbgen
$ mkdir -p dss/queries</code></pre></div>

<p>生成测试SQL，<code>SF</code>用于dbgen指定scale值</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nv">SF</span><span class="o">=</span><span class="m">50</span>
$ <span class="k">for</span> q in <span class="sb">`</span>seq <span class="m">1</span> <span class="m">22</span><span class="sb">`</span>
<span class="k">do</span>
    <span class="nv">DSS_QUERY</span><span class="o">=</span>dss/templates ./qgen -s <span class="nv">$SF</span> <span class="nv">$q</span> &gt; dss/queries/<span class="nv">$q</span>.sql
    sed <span class="s1">&#39;s/^select/explain select/&#39;</span> dss/queries/<span class="nv">$q</span>.sql &gt; dss/queries/<span class="nv">$q</span>.explain.sql
<span class="k">done</span></code></pre></div>

<p>设置gpdb几个参数</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ gpconfig -c enable_nestloop -v off
$ gpconfig -c work_mem -v 256MB
$ gpstop -u</code></pre></div>

<p>开始测试，结果输出到results目录</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ ./tpch.sh ./results tpch-db gpadmin</code></pre></div>

<p>结束后，可以使用以下方法生成CSV报告</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ php process.php ./results output.csv</code></pre></div>
]]></content>
		</item>
		
		<item>
			<title>gpdb官方安装包自定义安装路径的方法</title>
			<link>https://gitop.cc/posts/custom_gpdb_installation/</link>
			<pubDate>Thu, 11 Apr 2019 16:38:13 +0800</pubDate>
			
			<guid>https://gitop.cc/posts/custom_gpdb_installation/</guid>
			<description>下载安装包并解压，得到一个bin文件，从bin文件提取rpm文件 # 前960行为安装脚本 [root@hadoop2 ~]# tail -n +961 greenplum-db-5.16.0-rhel7-x86_64.bin &amp;gt; gpdb.tar.gz 如果集群没有gpadmin用户，可以利</description>
			<content type="html"><![CDATA[<p>下载安装包并解压，得到一个bin文件，从bin文件提取rpm文件</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># 前960行为安装脚本</span>
<span class="o">[</span>root@hadoop2 ~<span class="o">]</span><span class="c1"># tail -n +961 greenplum-db-5.16.0-rhel7-x86_64.bin &gt; gpdb.tar.gz</span></code></pre></div>

<p>如果集群没有gpadmin用户，可以利用<code>gpssh</code>批量创建gpadmin用户。首先以root用户登陆master节点，解压gpdb.tar.gz：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>root@hadoop2 ~<span class="o">]</span><span class="c1"># mkdir gpdb-5.16.0</span>
<span class="o">[</span>root@hadoop2 ~<span class="o">]</span><span class="c1"># tar zxf gpdb.tar.gz -C gpdb-5.16.0</span></code></pre></div>

<p>修改<code>gpdb-5.16.0/greenplum_path.sh</code>文件：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">GPHOME</span><span class="o">=</span>~/gpdb-5.16.0</code></pre></div>

<p>使gpdb环境变量生效：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>root@hadoop2 ~<span class="o">]</span><span class="c1"># source gpdb-5.16.0/greenplum_path.sh</span>
<span class="o">[</span>root@hadoop2 ~<span class="o">]</span><span class="c1"># which gpssh</span>
/root/gpdb-5.16.0/bin/gpssh</code></pre></div>

<p>创建hosts文件，包含集群所有节点的主机名，主机名需要添加到<code>/etc/hosts</code>文件中：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>root@hadoop2 ~<span class="o">]</span><span class="c1"># cat /etc/hosts</span>
<span class="m">127</span>.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6

<span class="m">192</span>.168.203.12 hadoop2.lw hadoop2
<span class="m">192</span>.168.203.13 hadoop3.lw hadoop3
<span class="m">192</span>.168.203.14 hadoop4.lw hadoop4
<span class="o">[</span>root@hadoop2 ~<span class="o">]</span><span class="c1"># cat hosts</span>
hadoop2
hadoop3
hadoop4</code></pre></div>

<p>交换各节点之间的ssh key：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>root@hadoop2 ~<span class="o">]</span><span class="c1"># gpssh-exkeys -f hosts</span>
<span class="o">[</span>STEP <span class="m">1</span> of <span class="m">5</span><span class="o">]</span> create <span class="nb">local</span> ID and authorize on <span class="nb">local</span> host
<span class="o">[</span>STEP <span class="m">2</span> of <span class="m">5</span><span class="o">]</span> keyscan all hosts and update known_hosts file
<span class="o">[</span>STEP <span class="m">3</span> of <span class="m">5</span><span class="o">]</span> authorize current user on remote hosts
  ... send to hadoop3
  *** Enter password <span class="k">for</span> hadoop3:
  ... send to hadoop4
<span class="o">[</span>STEP <span class="m">4</span> of <span class="m">5</span><span class="o">]</span> determine common authentication file content
<span class="o">[</span>STEP <span class="m">5</span> of <span class="m">5</span><span class="o">]</span> copy authentication files to all remote hosts
  ... finished key exchange with hadoop3
  ... finished key exchange with hadoop4
<span class="o">[</span>INFO<span class="o">]</span> completed successfully</code></pre></div>

<p>现在可以开始批量创建gpadmin用户了：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>root@hadoop2 ~<span class="o">]</span><span class="c1"># gpssh -f hosts</span>
<span class="o">=</span>&gt; groupadd -g <span class="m">530</span> gpadmin
<span class="o">[</span>hadoop2<span class="o">]</span>
<span class="o">[</span>hadoop4<span class="o">]</span>
<span class="o">[</span>hadoop3<span class="o">]</span>
<span class="o">=</span>&gt; useradd -g <span class="m">530</span> -u <span class="m">530</span> -m -d /home/gpadmin -s /bin/bash gpadmin
<span class="o">[</span>hadoop2<span class="o">]</span>
<span class="o">[</span>hadoop4<span class="o">]</span>
<span class="o">[</span>hadoop3<span class="o">]</span>
<span class="o">=</span>&gt; <span class="nb">echo</span> gpadmin:gpadmin <span class="p">|</span> chpasswd
<span class="o">[</span>hadoop2<span class="o">]</span>
<span class="o">[</span>hadoop4<span class="o">]</span>
<span class="o">[</span>hadoop3<span class="o">]</span></code></pre></div>

<p>修改每个节点上的文件打开数量限制，这里只展示一个节点，其他节点类似操作。因为之前有交换过key，所以可以无需密码直接通过<code>ssh hostname</code>连接到其他节点修改配置，这个步骤也可以用<code>gpssh</code>处理，但是稳妥起见，还是手动修改每个节点吧。</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>root@hadoop2 ~<span class="o">]</span><span class="c1"># vi /etc/security/limits.conf</span>
<span class="c1"># End of file</span>
* soft nofile <span class="m">65536</span>
* hard nofile <span class="m">65536</span>
* soft nproc <span class="m">131072</span>
* hard nproc <span class="m">131072</span></code></pre></div>

<p>将数据库安装目录移动到<code>/home/gpadmin</code>：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>root@hadoop2 ~<span class="o">]</span><span class="c1"># mv gpdb-5.16.0 /home/gpadmin</span>
<span class="o">[</span>root@hadoop2 ~<span class="o">]</span><span class="c1"># chown -R gpadmin:gpadmin /home/gpadmin/gpdb-5.16.0</span>
<span class="o">[</span>root@hadoop2 ~<span class="o">]</span><span class="c1"># mv hosts /home/gpadmin</span>
<span class="o">[</span>root@hadoop2 ~<span class="o">]</span><span class="c1"># chown gpadmin:gpadmin /home/gpadmin/hosts</span></code></pre></div>

<p>接下来切换到gpadmin用户下安装gpdb：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>root@hadoop2 ~<span class="o">]</span><span class="c1"># su - gpadmin</span></code></pre></div>

<p>修改<code>.bash_profile</code>，添加如下内容：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">GREENPLUM_PATH</span><span class="o">=</span>~/gpdb-5.16.0/greenplum_path.sh
<span class="nb">source</span> <span class="nv">$GREENPLUM_PATH</span>
<span class="c1">#DATA_DIR目录用于存放master数据，如果你想把数据放到别的地方，不要忘了修改这个路径</span>
<span class="nv">DATA_DIR</span><span class="o">=</span>~/data/master/gpseg-1/
<span class="nb">export</span> <span class="nv">MASTER_DATA_DIRECTORY</span><span class="o">=</span><span class="nv">$DATA_DIR</span>
<span class="nb">export</span> <span class="nv">PGPORT</span><span class="o">=</span><span class="m">5432</span>
<span class="nb">export</span> <span class="nv">PGDATABASE</span><span class="o">=</span>postgres</code></pre></div>

<p>使<code>.bash_profile</code>生效：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>gpadmin@hadoop2 ~<span class="o">]</span>$ <span class="nb">source</span> .bash_profile
<span class="o">[</span>gpadmin@hadoop2 ~<span class="o">]</span>$ which gpssh
~/gpdb-5.16.0/bin/gpssh</code></pre></div>

<p>因为现在处于<code>gpadmin</code>用户下，需要再次交换一下各节点之间的ssh key：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>gpadmin@hadoop2 ~<span class="o">]</span>$ gpssh-exkeys -f hosts
<span class="o">[</span>STEP <span class="m">1</span> of <span class="m">5</span><span class="o">]</span> create <span class="nb">local</span> ID and authorize on <span class="nb">local</span> host
<span class="o">[</span>STEP <span class="m">2</span> of <span class="m">5</span><span class="o">]</span> keyscan all hosts and update known_hosts file
<span class="o">[</span>STEP <span class="m">3</span> of <span class="m">5</span><span class="o">]</span> authorize current user on remote hosts
  ... send to hadoop3
  *** Enter password <span class="k">for</span> hadoop3:
  ... send to hadoop4
<span class="o">[</span>STEP <span class="m">4</span> of <span class="m">5</span><span class="o">]</span> determine common authentication file content
<span class="o">[</span>STEP <span class="m">5</span> of <span class="m">5</span><span class="o">]</span> copy authentication files to all remote hosts
  ... finished key exchange with hadoop3
  ... finished key exchange with hadoop4
<span class="o">[</span>INFO<span class="o">]</span> completed successfully</code></pre></div>

<p>创建segs文件，该文件包含所有子节点的主机名，不包括主节点的主机名：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>gpadmin@hadoop2 ~<span class="o">]</span>$ cat segs
hadoop3
hadoop4</code></pre></div>

<p>将数据库安装目录分发到各个子节点：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>gpadmin@hadoop2 ~<span class="o">]</span>$ gpseginstall -f segs
<span class="m">2019041152027100</span> gpseginstallgpadmin-<span class="o">[</span>INFO<span class="o">]</span>:-Installation Info:
link_name None
binary_path /home/gpadmin/gpdb-5.16.0
binary_dir_location /home/gpadmin
binary_dir_name gpdb-5.16.0
<span class="m">2019041152027100</span> gpseginstallgpadmin-<span class="o">[</span>INFO<span class="o">]</span>:-check cluster password access
<span class="m">2019041152027100</span> gpseginstallgpadmin-<span class="o">[</span>INFO<span class="o">]</span>:-de-duplicate hostnames
<span class="m">2019041152027100</span> gpseginstallgpadmin-<span class="o">[</span>INFO<span class="o">]</span>:-master hostname: hadoop2
<span class="m">2019041152027100</span> gpseginstallgpadmin-<span class="o">[</span>INFO<span class="o">]</span>:-rm -f /home/gpadmin/gpdb-5.16.0.tar<span class="p">;</span> rm -f /home/gpadmin/gpdb-5.16.0.tar.gz
...
<span class="m">2019041154027100</span> gpseginstallgpadmin-<span class="o">[</span>INFO<span class="o">]</span>:-SUCCESS -- Requested commands completed</code></pre></div>

<p>批量创建存放数据的目录：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>gpadmin@hadoop2 ~<span class="o">]</span>$ gpssh -f <span class="nv">hosts</span>
<span class="o">=</span>&gt; mkdir data
<span class="o">[</span>hadoop2<span class="o">]</span>
<span class="o">[</span>hadoop4<span class="o">]</span>
<span class="o">[</span>hadoop3<span class="o">]</span>
<span class="o">=</span>&gt; <span class="nb">cd</span> data
<span class="o">[</span>hadoop2<span class="o">]</span>
<span class="o">[</span>hadoop4<span class="o">]</span>
<span class="o">[</span>hadoop3<span class="o">]</span>
<span class="o">=</span>&gt; mkdir p1 p2 m1 m2 master
<span class="o">[</span>hadoop2<span class="o">]</span>
<span class="o">[</span>hadoop4<span class="o">]</span>
<span class="o">[</span>hadoop3<span class="o">]</span></code></pre></div>

<p>从数据库安装目录中拷贝一个初始化数据库的配置文件模板：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">cp gpdb-5.16.0/docs/cli_help/gpconfigs/gpinitsystem_config .</code></pre></div>

<p>修改初始化数据库的配置文件，主要修改以下选项：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">PORT_BASE</span><span class="o">=</span><span class="m">40000</span> <span class="c1">#这个端口不要设置太小了，可能会端口冲突</span>
<span class="nb">declare</span> -a <span class="nv">DATA_DIRECTORY</span><span class="o">=(</span>/home/gpadmin/data/p1 /home/gpadmin/data/p2<span class="o">)</span>
<span class="nv">MASTER_HOSTNAME</span><span class="o">=</span>hadoop2
<span class="nv">MASTER_DIRECTORY</span><span class="o">=</span>/home/gpadmin/data/master
<span class="nb">declare</span> -a <span class="nv">MIRROR_DATA_DIRECTORY</span><span class="o">=(</span>/home/gpadmin/data/m1 /home/gpadmin/data/m2<span class="o">)</span></code></pre></div>

<p>最后初始化数据库：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">gpinitsystem -c gpinitsystem_config -h hosts</code></pre></div>

<p>修改数据库用户gpadmin密码：</p>

<div class="highlight"><pre class="chroma"><code class="language-plsql" data-lang="plsql">postgres=# ALTER USER gpadmin PASSWORD &#39;gpadmin&#39;;</code></pre></div>

<p>修改master数据目录中的配置文件<code>pg_hba.conf</code>，在最后添加以下内容：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">host    all     all     <span class="m">192</span>.168.0.0/16  md5</code></pre></div>

<p>重新加载配置文件：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">gpstop -ua</code></pre></div>

<p>至此，gpdb数据库可以接受内网的访问了。</p>
]]></content>
		</item>
		
		<item>
			<title>psql使用介绍</title>
			<link>https://gitop.cc/posts/psql_intro/</link>
			<pubDate>Sat, 19 Jan 2019 19:13:20 +0800</pubDate>
			
			<guid>https://gitop.cc/posts/psql_intro/</guid>
			<description>psql介绍 psql是PostgreSQL中的一个命令行交互式客户端工具，类似Oracle中的命令行工具sqlplus，但它使用起来远比sq</description>
			<content type="html"><![CDATA[

<h2 id="psql介绍">psql介绍</h2>

<p><code>psql</code>是PostgreSQL中的一个命令行交互式客户端工具，类似Oracle中的命令行工具<code>sqlplus</code>，但它使用起来远比<code>sqlplus</code>方便。</p>

<p>在<code>postgres</code>用户下可以直接输入<code>psql</code>进入到数据库：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ psql
psql <span class="o">(</span><span class="m">10</span>.5 <span class="o">(</span>Debian <span class="m">10</span>.5-1.pgdg90+1<span class="o">))</span>
Type <span class="s2">&#34;help&#34;</span> <span class="k">for</span> help.

<span class="nv">postgres</span><span class="o">=</span>#</code></pre></div>

<blockquote>
<p>为什么不需要输入用户名和密码呢?因为在安装PostgreSQL数据库时，会创建一个数据库超级用户，这个用户与初始化数据库的操作系统用户。用这个用户登录数据库执行的是操作系统认证，所以不需要用户名和密码。</p>
</blockquote>

<p>PostgreSQL安装好后，默认会有一个叫<code>postgres</code>的数据库，还有两个模板数据库<code>template1</code>和<code>template0</code>。当用户创建数据库时，默认是从模板数据库<code>template1</code>克隆出来的。通常可以定制<code>template1</code>数据库中的内容，如往<code>template1</code>中添加一些表和函数，这样后续创建的数据库就会继承这些表和函数。而<code>template0</code>是一个最简化的模板库，创建数据库时，如果明确指定从此数据库中继承，将创建出一个最简化的数据库。</p>

<h2 id="常用斜杠命令">常用斜杠命令</h2>

<h3 id="l-命令"><code>\l</code>命令</h3>

<p><code>\l</code>命令查看数据库，相当于<code>psql -l</code></p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># \l</span>
                                 List of databases
   Name    <span class="p">|</span>  Owner   <span class="p">|</span> Encoding <span class="p">|</span>  Collate   <span class="p">|</span>   Ctype    <span class="p">|</span>   Access privileges
-----------<span class="p">|</span>----------<span class="p">|</span>----------<span class="p">|</span>------------<span class="p">|</span>------------<span class="p">|</span>-----------------------
 postgres  <span class="p">|</span> postgres <span class="p">|</span> UTF8     <span class="p">|</span> en_US.utf8 <span class="p">|</span> en_US.utf8 <span class="p">|</span>
 template0 <span class="p">|</span> postgres <span class="p">|</span> UTF8     <span class="p">|</span> en_US.utf8 <span class="p">|</span> en_US.utf8 <span class="p">|</span> <span class="o">=</span>c/postgres          +
           <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>            <span class="p">|</span>            <span class="p">|</span> <span class="nv">postgres</span><span class="o">=</span>CTc/postgres
 template1 <span class="p">|</span> postgres <span class="p">|</span> UTF8     <span class="p">|</span> en_US.utf8 <span class="p">|</span> en_US.utf8 <span class="p">|</span> <span class="o">=</span>c/postgres          +
           <span class="p">|</span>          <span class="p">|</span>          <span class="p">|</span>            <span class="p">|</span>            <span class="p">|</span> <span class="nv">postgres</span><span class="o">=</span>CTc/postgres</code></pre></div>

<h3 id="c命令">\c命令</h3>

<p><code>\c</code>命令用于连接指定数据库，语法如下：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="se">\c</span><span class="o">[</span>onnect<span class="o">]</span> <span class="o">{[</span>DBNAME<span class="p">|</span>- USER<span class="p">|</span>- HOST<span class="p">|</span>- PORT<span class="p">|</span>-<span class="o">]</span> <span class="p">|</span> conninfo<span class="o">}</span></code></pre></div>

<p>相当于<code>psql -h hostname -p port [db_name][username]</code>，比如：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ psql -h localhost -p <span class="m">5432</span> postgres postgres
psql <span class="o">(</span><span class="m">10</span>.5 <span class="o">(</span>Debian <span class="m">10</span>.5-1.pgdg90+1<span class="o">))</span>
Type <span class="s2">&#34;help&#34;</span> <span class="k">for</span> help.

<span class="nv">postgres</span><span class="o">=</span><span class="c1"># \c template1;</span>
You are now connected to database <span class="s2">&#34;template1&#34;</span> as user <span class="s2">&#34;postgres&#34;</span>.
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># \c postgres gpadmin 192.168.205.135 5432</span>
Password <span class="k">for</span> user gpadmin:
psql <span class="o">(</span><span class="m">10</span>.5 <span class="o">(</span>Debian <span class="m">10</span>.5-1.pgdg90+1<span class="o">)</span>, server <span class="m">8</span>.3.23<span class="o">)</span>
You are now connected to database <span class="s2">&#34;postgres&#34;</span> as user <span class="s2">&#34;gpadmin&#34;</span> on host <span class="s2">&#34;192.168.205.135&#34;</span> at port <span class="s2">&#34;5432&#34;</span>.</code></pre></div>

<p>也可以将这些连接参数设置为环境变量：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">export</span> <span class="nv">PGDATABASE</span><span class="o">=</span>postgres
<span class="nb">export</span> <span class="nv">PGHOST</span><span class="o">=</span><span class="m">192</span>.168.56.11
<span class="nb">export</span> <span class="nv">PGPORT</span><span class="o">=</span><span class="m">5432</span>
<span class="nb">export</span> <span class="nv">PGUSER</span><span class="o">=</span>postgres</code></pre></div>

<h3 id="d命令">\d命令</h3>

<p><code>\d</code>命令格式如下</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="se">\d</span> <span class="o">[</span>pattern<span class="o">]</span>
<span class="se">\d</span> <span class="o">[</span>pattern<span class="o">]</span>+</code></pre></div>

<p>该命令将显示每个匹配关系（表、视图、索引、序列）的信息。</p>

<ol>
<li><p>如果<code>\d</code>命令什么都不带，将列出当前数据库中的所有表</p></li>

<li><p><code>\d</code>后面跟一个对象名，显示这个对象的结构定义</p></li>

<li><p><code>\d</code>后面也可以跟通配符如<code>*</code>或<code>?</code></p></li>

<li><p><code>d+</code>命令显示比<code>\d</code>命令更详细的信息</p></li>

<li><p>匹配不同对象类型的<code>\d</code>命令</p>

<ul>
<li><p><code>\dt</code>命令只显示匹配的表</p></li>

<li><p><code>\di</code>命令只显示索引</p></li>

<li><p><code>\ds</code>命令只显示序列</p></li>

<li><p><code>\dv</code>命令只显示视图</p></li>

<li><p><code>\df</code>命令只显示函数</p></li>
</ul></li>

<li><p><code>\dn</code>命令列出所有的schema</p></li>

<li><p><code>\db</code>命令显示所有的表空间</p></li>

<li><p><code>\du</code>或<code>\dg</code>命令列出数据库中的所有角色或用户</p></li>

<li><p><code>\dp</code>或<code>\z</code>命令显示表的权限分配情况</p></li>
</ol>

<h3 id="timing命令">\timing命令</h3>

<p><code>\timing</code>命令显示SQL执行耗时</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># \timing</span>
Timing is on.</code></pre></div>

<h3 id="encoding命令">\encoding命令</h3>

<p><code>\encoding</code>命令设置客户端字符编码，比如utf8，gbk等。</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># \encoding utf8;</span></code></pre></div>

<h3 id="pset命令">\pset命令</h3>

<p><code>\pset</code>命令设置输出的格式，具体如下：</p>

<ul>
<li><code>\pset border 0</code>：表示输出内容无边框</li>
<li><code>\pset border 1</code>：表示边框只在内部</li>
<li><code>\pset border 2</code>：表示内外都有边框</li>
</ul>

<h3 id="x命令">\x命令</h3>

<p><code>\x</code>命令单行展示表中每行的每列数据，等价于<code>psql -x</code></p>

<h3 id="i命令">\i命令</h3>

<p><code>\i sql_file</code>执行存储在文件中sql语句，等价于<code>psql -f sql_file</code></p>

<h3 id="echo命令">\echo命令</h3>

<p><code>\echo</code>命令输出一行信息，常用于SQL脚本文件中输出提示信息。</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># \echo hello world</span>
hello world</code></pre></div>

<h3 id="set命令">\set命令</h3>

<p><code>\set [NAME [VALUE]]</code>命令设置内部变量，如果没有指定变量名称，则显示所有变量的值。</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># \set</span>
<span class="nv">AUTOCOMMIT</span> <span class="o">=</span> <span class="s1">&#39;off&#39;</span>
<span class="nv">COMP_KEYWORD_CASE</span> <span class="o">=</span> <span class="s1">&#39;preserve-upper&#39;</span>
<span class="nv">DBNAME</span> <span class="o">=</span> <span class="s1">&#39;postgres&#39;</span>
<span class="nv">ECHO</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
<span class="nv">ECHO_HIDDEN</span> <span class="o">=</span> <span class="s1">&#39;off&#39;</span>
<span class="nv">ENCODING</span> <span class="o">=</span> <span class="s1">&#39;SQL_ASCII&#39;</span>
<span class="nv">FETCH_COUNT</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span>
<span class="nv">HISTCONTROL</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
<span class="nv">HISTSIZE</span> <span class="o">=</span> <span class="s1">&#39;500&#39;</span>
<span class="nv">HOST</span> <span class="o">=</span> <span class="s1">&#39;/var/run/postgresql&#39;</span>
<span class="nv">IGNOREEOF</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span>
<span class="nv">LASTOID</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span>
<span class="nv">ON_ERROR_ROLLBACK</span> <span class="o">=</span> <span class="s1">&#39;off&#39;</span>
<span class="nv">ON_ERROR_STOP</span> <span class="o">=</span> <span class="s1">&#39;off&#39;</span>
<span class="nv">PORT</span> <span class="o">=</span> <span class="s1">&#39;5432&#39;</span>
<span class="nv">PROMPT1</span> <span class="o">=</span> <span class="s1">&#39;%/%R%# &#39;</span>
<span class="nv">PROMPT2</span> <span class="o">=</span> <span class="s1">&#39;%/%R%# &#39;</span>
<span class="nv">PROMPT3</span> <span class="o">=</span> <span class="s1">&#39;&gt;&gt; &#39;</span>
<span class="nv">QUIET</span> <span class="o">=</span> <span class="s1">&#39;off&#39;</span>
<span class="nv">SERVER_VERSION_NAME</span> <span class="o">=</span> <span class="s1">&#39;10.5 (Debian 10.5-1.pgdg90+1)&#39;</span>
<span class="nv">SERVER_VERSION_NUM</span> <span class="o">=</span> <span class="s1">&#39;100005&#39;</span>
<span class="nv">SHOW_CONTEXT</span> <span class="o">=</span> <span class="s1">&#39;errors&#39;</span>
<span class="nv">SINGLELINE</span> <span class="o">=</span> <span class="s1">&#39;off&#39;</span>
<span class="nv">SINGLESTEP</span> <span class="o">=</span> <span class="s1">&#39;off&#39;</span>
<span class="nv">USER</span> <span class="o">=</span> <span class="s1">&#39;postgres&#39;</span>
<span class="nv">VERBOSITY</span> <span class="o">=</span> <span class="s1">&#39;default&#39;</span>
<span class="nv">VERSION</span> <span class="o">=</span> <span class="s1">&#39;PostgreSQL 10.5 (Debian 10.5-1.pgdg90+1) on x86_64-pc-linux-gnu, compiled by gcc (Debian 6.3.0-18+deb9u1) 6.3.0 20170516, 64-bit&#39;</span>
<span class="nv">VERSION_NAME</span> <span class="o">=</span> <span class="s1">&#39;10.5 (Debian 10.5-1.pgdg90+1)&#39;</span>
<span class="nv">VERSION_NUM</span> <span class="o">=</span> <span class="s1">&#39;100005&#39;</span></code></pre></div>

<h3 id="h命令">\h命令</h3>

<p><code>\h</code>命令查看SQL命令的语法，<code>*</code>查看所有命令的语法：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">template1</span><span class="o">=</span><span class="c1"># \h drop table</span>
Command:     DROP TABLE
Description: remove a table
Syntax:
DROP TABLE <span class="o">[</span> IF EXISTS <span class="o">]</span> name <span class="o">[</span>, ...<span class="o">]</span> <span class="o">[</span> CASCADE <span class="p">|</span> RESTRICT <span class="o">]</span></code></pre></div>

<h3 id="命令">\?命令</h3>

<p><code>\?</code>帮助命令</p>

<h2 id="一些使用技巧">一些使用技巧</h2>

<h3 id="历史命令与补全的功能">历史命令与补全的功能</h3>

<p>可以使用上下键选择之前使用过的命令或SQL语句，<code>ctrl+r</code>快捷键可以搜索历史命令。连续按两次tab键表示把命令补全或给出提示输入。</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># \d然后连续按2次tab</span>
<span class="se">\d</span>     <span class="se">\d</span>E    <span class="se">\d</span>Ft   <span class="se">\d</span>Rs   <span class="se">\d</span>b    <span class="se">\d</span>es   <span class="se">\d</span>f    <span class="se">\d</span>m    <span class="se">\d</span>rds  <span class="se">\d</span>v
<span class="se">\d</span>A    <span class="se">\d</span>F    <span class="se">\d</span>L    <span class="se">\d</span>S    <span class="se">\d</span>c    <span class="se">\d</span>et   <span class="se">\d</span>g    <span class="se">\d</span>n    <span class="se">\d</span>s    <span class="se">\d</span>x
<span class="se">\d</span>C    <span class="se">\d</span>Fd   <span class="se">\d</span>O    <span class="se">\d</span>T    <span class="se">\d</span>d    <span class="se">\d</span>eu   <span class="se">\d</span>i    <span class="se">\d</span>o    <span class="se">\d</span>t    <span class="se">\d</span>y
<span class="se">\d</span>D    <span class="se">\d</span>Fp   <span class="se">\d</span>Rp   <span class="se">\d</span>a    <span class="se">\d</span>dp   <span class="se">\d</span>ew   <span class="se">\d</span>l    <span class="se">\d</span>p    <span class="se">\d</span>u</code></pre></div>

<h3 id="自动提交的技巧">自动提交的技巧</h3>

<p>在psql中事务是自动提交的。比如执行完一条<code>delete</code>或<code>update</code>语句后，事务就自动提交了。如果不想自动提交，有两种方法：</p>

<ol>
<li>运行<code>begin</code>命令，然后执行DML语句，最后再执行<code>commit</code>或<code>rollback</code>语句。</li>
<li>使用<code>\set AUTOCOMMIT off</code>命令关闭自动提交，注意<code>AUTOCOMMIT</code>是大写的。</li>
</ol>

<h3 id="显示psql命令实际执行的sql语句">显示psql命令实际执行的SQL语句</h3>

<p>变量<code>ECHO_HIDDEN</code>控制斜杠命令是否显示执行的SQL语句，<code>\set ECHO_HIDDEN on</code>显示执行的SQL语句，相当于<code>psql -E</code>。</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># \set ECHO_HIDDEN on</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># \d</span>
********* QUERY **********
SELECT n.nspname as <span class="s2">&#34;Schema&#34;</span>,
  c.relname as <span class="s2">&#34;Name&#34;</span>,
  CASE c.relkind WHEN <span class="s1">&#39;r&#39;</span> THEN <span class="s1">&#39;table&#39;</span> WHEN <span class="s1">&#39;v&#39;</span> THEN <span class="s1">&#39;view&#39;</span> WHEN <span class="s1">&#39;m&#39;</span> THEN <span class="s1">&#39;materialized view&#39;</span> WHEN <span class="s1">&#39;i&#39;</span> THEN <span class="s1">&#39;index&#39;</span> WHEN <span class="s1">&#39;S&#39;</span> THEN <span class="s1">&#39;sequence&#39;</span> WHEN <span class="s1">&#39;s&#39;</span> THEN <span class="s1">&#39;special&#39;</span> WHEN <span class="s1">&#39;f&#39;</span> THEN <span class="s1">&#39;foreign table&#39;</span> WHEN <span class="s1">&#39;p&#39;</span> THEN <span class="s1">&#39;table&#39;</span> END as <span class="s2">&#34;Type&#34;</span>,
  pg_catalog.pg_get_userbyid<span class="o">(</span>c.relowner<span class="o">)</span> as <span class="s2">&#34;Owner&#34;</span>
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid <span class="o">=</span> c.relnamespace
WHERE c.relkind IN <span class="o">(</span><span class="s1">&#39;r&#39;</span>,<span class="s1">&#39;p&#39;</span>,<span class="s1">&#39;v&#39;</span>,<span class="s1">&#39;m&#39;</span>,<span class="s1">&#39;S&#39;</span>,<span class="s1">&#39;f&#39;</span>,<span class="s1">&#39;&#39;</span><span class="o">)</span>
      AND n.nspname &lt;&gt; <span class="s1">&#39;pg_catalog&#39;</span>
      AND n.nspname &lt;&gt; <span class="s1">&#39;information_schema&#39;</span>
      AND n.nspname !~ <span class="s1">&#39;^pg_toast&#39;</span>
  AND pg_catalog.pg_table_is_visible<span class="o">(</span>c.oid<span class="o">)</span>
ORDER BY <span class="m">1</span>,2<span class="p">;</span>
**************************

            List of relations
 Schema <span class="p">|</span>    Name     <span class="p">|</span> Type  <span class="p">|</span>  Owner
--------<span class="p">|</span>-------------<span class="p">|</span>-------<span class="p">|</span>----------
 public <span class="p">|</span> bit_test    <span class="p">|</span> table <span class="p">|</span> postgres
 public <span class="p">|</span> class       <span class="p">|</span> table <span class="p">|</span> postgres
 public <span class="p">|</span> date_test   <span class="p">|</span> table <span class="p">|</span> postgres
 public <span class="p">|</span> duty        <span class="p">|</span> table <span class="p">|</span> postgres
 public <span class="p">|</span> score       <span class="p">|</span> table <span class="p">|</span> postgres
 public <span class="p">|</span> student     <span class="p">|</span> table <span class="p">|</span> postgres
 public <span class="p">|</span> student_bak <span class="p">|</span> table <span class="p">|</span> postgres
<span class="o">(</span><span class="m">7</span> rows<span class="o">)</span></code></pre></div>
]]></content>
		</item>
		
		<item>
			<title>SQL入门</title>
			<link>https://gitop.cc/posts/sql_intro/</link>
			<pubDate>Sat, 19 Jan 2019 19:13:04 +0800</pubDate>
			
			<guid>https://gitop.cc/posts/sql_intro/</guid>
			<description>SQL语句分类 DQL(Data Query Language)：数据查询语言，基本就是select语句，用于数据查询。 DML(Data Manipulation Language)：数据操纵语言，包含ins</description>
			<content type="html"><![CDATA[

<h2 id="sql语句分类">SQL语句分类</h2>

<ul>
<li>DQL(Data Query Language)：数据查询语言，基本就是<code>select</code>语句，用于数据查询。</li>
<li>DML(Data Manipulation Language)：数据操纵语言，包含<code>insert</code>、<code>update</code>、<code>delete</code>三种语句。</li>
<li>DDL(Data Definition Language)：数据定义语言，主要用于创建、删除或修改表、索引等数据库对象。</li>
</ul>

<h2 id="创建表-create-table">创建表(create table)</h2>

<p>使用<code>\h create table</code>查看帮助</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># \h create table</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># create table score (</span>
postgres<span class="o">(</span><span class="c1"># student_name varchar(40),</span>
postgres<span class="o">(</span><span class="c1"># chinese_score int,</span>
postgres<span class="o">(</span><span class="c1"># math_score int,</span>
postgres<span class="o">(</span><span class="c1"># test_date date</span>
postgres<span class="o">(</span><span class="c1"># );</span>
CREATE TABLE
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># \d score</span>
                          Table <span class="s2">&#34;public.score&#34;</span>
    Column     <span class="p">|</span>         Type          <span class="p">|</span> Collation <span class="p">|</span> Nullable <span class="p">|</span> Default
---------------<span class="p">|</span>-----------------------<span class="p">|</span>-----------<span class="p">|</span>----------<span class="p">|</span>---------
 student_name  <span class="p">|</span> character varying<span class="o">(</span><span class="m">40</span><span class="o">)</span> <span class="p">|</span>           <span class="p">|</span>          <span class="p">|</span>
 chinese_score <span class="p">|</span> integer               <span class="p">|</span>           <span class="p">|</span>          <span class="p">|</span>
 math_score    <span class="p">|</span> integer               <span class="p">|</span>           <span class="p">|</span>          <span class="p">|</span>
 test_date     <span class="p">|</span> date                  <span class="p">|</span>           <span class="p">|</span>          <span class="p">|</span></code></pre></div>

<p>其中<code>int</code>是<code>integer</code>别名，<code>varchar(40)</code>是<code>character varying(40)</code>别名。在建表的时候，可以在列定义后面使用<code>primary key</code>来指定这一列为主键：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># create table student(no int primary key, name varchar(40), age int, class_no int);</span></code></pre></div>

<p>PostgreSQL会自动为主键创建索引<code>student_pkey</code>。</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># \di</span>
                 List of relations
 Schema <span class="p">|</span>     Name     <span class="p">|</span> Type  <span class="p">|</span>  Owner   <span class="p">|</span>  Table
--------<span class="p">|</span>--------------<span class="p">|</span>-------<span class="p">|</span>----------<span class="p">|</span>---------
 public <span class="p">|</span> student_pkey <span class="p">|</span> index <span class="p">|</span> postgres <span class="p">|</span> student</code></pre></div>

<h2 id="插入语句-insert">插入语句(insert)</h2>

<p>使用<code>\h insert</code>查看帮助</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># \h insert</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># insert into student values(1, &#39;lily&#39;, 14);</span>
INSERT <span class="m">0</span> <span class="m">1</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># insert into student(no, age, name) values(2, 13, &#39;lucy&#39;);</span>
INSERT <span class="m">0</span> <span class="m">1</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># insert into student(no, name) values(3, &#39;bob&#39;);</span>
INSERT <span class="m">0</span> <span class="m">1</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># insert into student values(4, &#39;kate&#39;, 12), (5, &#39;jobs&#39;, 15), (6, &#39;bill&#39;, 13);</span>
INSERT <span class="m">0</span> <span class="m">3</span></code></pre></div>

<h2 id="查询语句-select">查询语句(select)</h2>

<p>使用<code>\h select</code>查看帮助</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># \h select</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># select no, name, age from student;</span>
 no <span class="p">|</span> name <span class="p">|</span> age
----<span class="p">|</span>------<span class="p">|</span>-----
  <span class="m">1</span> <span class="p">|</span> lily <span class="p">|</span>  <span class="m">14</span>
  <span class="m">2</span> <span class="p">|</span> lucy <span class="p">|</span>  <span class="m">13</span>
  <span class="m">3</span> <span class="p">|</span> bob  <span class="p">|</span>
  <span class="m">4</span> <span class="p">|</span> kate <span class="p">|</span>  <span class="m">12</span>
  <span class="m">5</span> <span class="p">|</span> <span class="nb">jobs</span> <span class="p">|</span>  <span class="m">15</span>
  <span class="m">6</span> <span class="p">|</span> bill <span class="p">|</span>  <span class="m">13</span>
<span class="o">(</span><span class="m">6</span> rows<span class="o">)</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># select name, age+5 from student;</span>
 name <span class="p">|</span> ?column?
------<span class="p">|</span>----------
 lily <span class="p">|</span>       <span class="m">19</span>
 lucy <span class="p">|</span>       <span class="m">18</span>
 bob  <span class="p">|</span>
 kate <span class="p">|</span>       <span class="m">17</span>
 <span class="nb">jobs</span> <span class="p">|</span>       <span class="m">20</span>
 bill <span class="p">|</span>       <span class="m">18</span>
<span class="o">(</span><span class="m">6</span> rows<span class="o">)</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># select no, 3+5 from student;</span>
 no <span class="p">|</span> ?column?
----<span class="p">|</span>----------
  <span class="m">1</span> <span class="p">|</span>        <span class="m">8</span>
  <span class="m">2</span> <span class="p">|</span>        <span class="m">8</span>
  <span class="m">3</span> <span class="p">|</span>        <span class="m">8</span>
  <span class="m">4</span> <span class="p">|</span>        <span class="m">8</span>
  <span class="m">5</span> <span class="p">|</span>        <span class="m">8</span>
  <span class="m">6</span> <span class="p">|</span>        <span class="m">8</span>
<span class="o">(</span><span class="m">6</span> rows<span class="o">)</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># select 55+88;</span>
 ?column?
----------
      <span class="m">143</span>
<span class="o">(</span><span class="m">1</span> row<span class="o">)</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># select 10*2, 3*5+2;</span>
 ?column? <span class="p">|</span> ?column?
----------<span class="p">|</span>----------
       <span class="m">20</span> <span class="p">|</span>       <span class="m">17</span>
<span class="o">(</span><span class="m">1</span> row<span class="o">)</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># select * from student;</span>
 no <span class="p">|</span> name <span class="p">|</span> age <span class="p">|</span> class_no
----<span class="p">|</span>------<span class="p">|</span>-----<span class="p">|</span>----------
  <span class="m">1</span> <span class="p">|</span> lily <span class="p">|</span>  <span class="m">14</span> <span class="p">|</span>
  <span class="m">2</span> <span class="p">|</span> lucy <span class="p">|</span>  <span class="m">13</span> <span class="p">|</span>
  <span class="m">3</span> <span class="p">|</span> bob  <span class="p">|</span>     <span class="p">|</span>
  <span class="m">4</span> <span class="p">|</span> kate <span class="p">|</span>  <span class="m">12</span> <span class="p">|</span>
  <span class="m">5</span> <span class="p">|</span> <span class="nb">jobs</span> <span class="p">|</span>  <span class="m">15</span> <span class="p">|</span>
  <span class="m">6</span> <span class="p">|</span> bill <span class="p">|</span>  <span class="m">13</span> <span class="p">|</span>
<span class="o">(</span><span class="m">6</span> rows<span class="o">)</span></code></pre></div>

<h3 id="条件过滤-where">条件过滤(where)</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># select * from student where no = 3;</span>
 no <span class="p">|</span> name <span class="p">|</span> age <span class="p">|</span> class_no
----<span class="p">|</span>------<span class="p">|</span>-----<span class="p">|</span>----------
  <span class="m">3</span> <span class="p">|</span> bob  <span class="p">|</span>     <span class="p">|</span>
<span class="o">(</span><span class="m">1</span> row<span class="o">)</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># select * from student where age &gt; 13;</span>
 no <span class="p">|</span> name <span class="p">|</span> age <span class="p">|</span> class_no
----<span class="p">|</span>------<span class="p">|</span>-----<span class="p">|</span>----------
  <span class="m">1</span> <span class="p">|</span> lily <span class="p">|</span>  <span class="m">14</span> <span class="p">|</span>
  <span class="m">5</span> <span class="p">|</span> <span class="nb">jobs</span> <span class="p">|</span>  <span class="m">15</span> <span class="p">|</span>
<span class="o">(</span><span class="m">2</span> rows<span class="o">)</span></code></pre></div>

<h3 id="排序-order-by">排序(order by)</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># select * from student order by age;</span>
 no <span class="p">|</span> name <span class="p">|</span> age <span class="p">|</span> class_no
----<span class="p">|</span>------<span class="p">|</span>-----<span class="p">|</span>----------
  <span class="m">4</span> <span class="p">|</span> kate <span class="p">|</span>  <span class="m">12</span> <span class="p">|</span>
  <span class="m">2</span> <span class="p">|</span> lucy <span class="p">|</span>  <span class="m">13</span> <span class="p">|</span>
  <span class="m">6</span> <span class="p">|</span> bill <span class="p">|</span>  <span class="m">13</span> <span class="p">|</span>
  <span class="m">1</span> <span class="p">|</span> lily <span class="p">|</span>  <span class="m">14</span> <span class="p">|</span>
  <span class="m">5</span> <span class="p">|</span> <span class="nb">jobs</span> <span class="p">|</span>  <span class="m">15</span> <span class="p">|</span>
  <span class="m">3</span> <span class="p">|</span> bob  <span class="p">|</span>     <span class="p">|</span>
<span class="o">(</span><span class="m">6</span> rows<span class="o">)</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># select * from student where age &gt; 12 order by age;</span>
 no <span class="p">|</span> name <span class="p">|</span> age <span class="p">|</span> class_no
----<span class="p">|</span>------<span class="p">|</span>-----<span class="p">|</span>----------
  <span class="m">2</span> <span class="p">|</span> lucy <span class="p">|</span>  <span class="m">13</span> <span class="p">|</span>
  <span class="m">6</span> <span class="p">|</span> bill <span class="p">|</span>  <span class="m">13</span> <span class="p">|</span>
  <span class="m">1</span> <span class="p">|</span> lily <span class="p">|</span>  <span class="m">14</span> <span class="p">|</span>
  <span class="m">5</span> <span class="p">|</span> <span class="nb">jobs</span> <span class="p">|</span>  <span class="m">15</span> <span class="p">|</span>
<span class="o">(</span><span class="m">4</span> rows<span class="o">)</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># select * from student order by age, name;</span>
 no <span class="p">|</span> name <span class="p">|</span> age <span class="p">|</span> class_no
----<span class="p">|</span>------<span class="p">|</span>-----<span class="p">|</span>----------
  <span class="m">4</span> <span class="p">|</span> kate <span class="p">|</span>  <span class="m">12</span> <span class="p">|</span>
  <span class="m">6</span> <span class="p">|</span> bill <span class="p">|</span>  <span class="m">13</span> <span class="p">|</span>
  <span class="m">2</span> <span class="p">|</span> lucy <span class="p">|</span>  <span class="m">13</span> <span class="p">|</span>
  <span class="m">1</span> <span class="p">|</span> lily <span class="p">|</span>  <span class="m">14</span> <span class="p">|</span>
  <span class="m">5</span> <span class="p">|</span> <span class="nb">jobs</span> <span class="p">|</span>  <span class="m">15</span> <span class="p">|</span>
  <span class="m">3</span> <span class="p">|</span> bob  <span class="p">|</span>     <span class="p">|</span>
<span class="o">(</span><span class="m">6</span> rows<span class="o">)</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># select * from student order by age desc;</span>
 no <span class="p">|</span> name <span class="p">|</span> age <span class="p">|</span> class_no
----<span class="p">|</span>------<span class="p">|</span>-----<span class="p">|</span>----------
  <span class="m">3</span> <span class="p">|</span> bob  <span class="p">|</span>     <span class="p">|</span>
  <span class="m">5</span> <span class="p">|</span> <span class="nb">jobs</span> <span class="p">|</span>  <span class="m">15</span> <span class="p">|</span>
  <span class="m">1</span> <span class="p">|</span> lily <span class="p">|</span>  <span class="m">14</span> <span class="p">|</span>
  <span class="m">2</span> <span class="p">|</span> lucy <span class="p">|</span>  <span class="m">13</span> <span class="p">|</span>
  <span class="m">6</span> <span class="p">|</span> bill <span class="p">|</span>  <span class="m">13</span> <span class="p">|</span>
  <span class="m">4</span> <span class="p">|</span> kate <span class="p">|</span>  <span class="m">12</span> <span class="p">|</span>
<span class="o">(</span><span class="m">6</span> rows<span class="o">)</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># select * from student order by age desc, name;</span>
 no <span class="p">|</span> name <span class="p">|</span> age <span class="p">|</span> class_no
----<span class="p">|</span>------<span class="p">|</span>-----<span class="p">|</span>----------
  <span class="m">3</span> <span class="p">|</span> bob  <span class="p">|</span>     <span class="p">|</span>
  <span class="m">5</span> <span class="p">|</span> <span class="nb">jobs</span> <span class="p">|</span>  <span class="m">15</span> <span class="p">|</span>
  <span class="m">1</span> <span class="p">|</span> lily <span class="p">|</span>  <span class="m">14</span> <span class="p">|</span>
  <span class="m">6</span> <span class="p">|</span> bill <span class="p">|</span>  <span class="m">13</span> <span class="p">|</span>
  <span class="m">2</span> <span class="p">|</span> lucy <span class="p">|</span>  <span class="m">13</span> <span class="p">|</span>
  <span class="m">4</span> <span class="p">|</span> kate <span class="p">|</span>  <span class="m">12</span> <span class="p">|</span>
<span class="o">(</span><span class="m">6</span> rows<span class="o">)</span></code></pre></div>

<h3 id="分组查询-group-by">分组查询(group by)</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># select age, count(*) from student group by age;</span>
 age <span class="p">|</span> count
-----<span class="p">|</span>-------
     <span class="p">|</span>     <span class="m">1</span>
  <span class="m">15</span> <span class="p">|</span>     <span class="m">1</span>
  <span class="m">14</span> <span class="p">|</span>     <span class="m">1</span>
  <span class="m">13</span> <span class="p">|</span>     <span class="m">2</span>
  <span class="m">12</span> <span class="p">|</span>     <span class="m">1</span>
<span class="o">(</span><span class="m">5</span> rows<span class="o">)</span></code></pre></div>

<h3 id="表连接-join">表连接(join)</h3>

<p>表连接也称为多表关联查询。为了演示，现在创建一张班级表，并插入一些测试数据：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># create table class (no int primary key, name varchar(40));</span>
CREATE TABLE
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># insert into class values(1, &#39;grade 1&#39;);</span>
INSERT <span class="m">0</span> <span class="m">1</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># insert into class values(2, &#39;grade 2&#39;);</span>
INSERT <span class="m">0</span> <span class="m">1</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># insert into class values(3, &#39;grade 3&#39;);</span>
INSERT <span class="m">0</span> <span class="m">1</span></code></pre></div>

<p>修改<code>student</code>表<code>class_no</code>字段用于测试：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># update student set class_no = 1 where no &lt; 3;</span>
UPDATE <span class="m">2</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># update student set class_no = 2 where no &gt;=3 and no &lt; 5;</span>
UPDATE <span class="m">2</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># update student set class_no = 3 where no &gt;=5;</span>
UPDATE <span class="m">2</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># select * from student;</span>
 no <span class="p">|</span> name <span class="p">|</span> age <span class="p">|</span> class_no
----<span class="p">|</span>------<span class="p">|</span>-----<span class="p">|</span>----------
  <span class="m">1</span> <span class="p">|</span> lily <span class="p">|</span>  <span class="m">14</span> <span class="p">|</span>        <span class="m">1</span>
  <span class="m">2</span> <span class="p">|</span> lucy <span class="p">|</span>  <span class="m">13</span> <span class="p">|</span>        <span class="m">1</span>
  <span class="m">3</span> <span class="p">|</span> bob  <span class="p">|</span>     <span class="p">|</span>        <span class="m">2</span>
  <span class="m">4</span> <span class="p">|</span> kate <span class="p">|</span>  <span class="m">12</span> <span class="p">|</span>        <span class="m">2</span>
  <span class="m">5</span> <span class="p">|</span> <span class="nb">jobs</span> <span class="p">|</span>  <span class="m">15</span> <span class="p">|</span>        <span class="m">3</span>
  <span class="m">6</span> <span class="p">|</span> bill <span class="p">|</span>  <span class="m">13</span> <span class="p">|</span>        <span class="m">3</span>
<span class="o">(</span><span class="m">6</span> rows<span class="o">)</span></code></pre></div>

<p>若想查出每个学生与班级的关系，那么就需要关联查询两张表：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># select s.name, c.name from student s, class c where s.class_no = c.no;</span>
 name <span class="p">|</span>  name
------<span class="p">|</span>---------
 lily <span class="p">|</span> grade <span class="m">1</span>
 lucy <span class="p">|</span> grade <span class="m">1</span>
 bob  <span class="p">|</span> grade <span class="m">2</span>
 kate <span class="p">|</span> grade <span class="m">2</span>
 <span class="nb">jobs</span> <span class="p">|</span> grade <span class="m">3</span>
 bill <span class="p">|</span> grade <span class="m">3</span>
<span class="o">(</span><span class="m">6</span> rows<span class="o">)</span></code></pre></div>

<h2 id="更新语句-update">更新语句(update)</h2>

<p>使用<code>\h update</code>查看帮助</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># \h update</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># update student set age = 15;</span>
UPDATE <span class="m">6</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># select * from student;</span>
 no <span class="p">|</span> name <span class="p">|</span> age <span class="p">|</span> class_no
----<span class="p">|</span>------<span class="p">|</span>-----<span class="p">|</span>----------
  <span class="m">1</span> <span class="p">|</span> lily <span class="p">|</span>  <span class="m">15</span> <span class="p">|</span>        <span class="m">1</span>
  <span class="m">2</span> <span class="p">|</span> lucy <span class="p">|</span>  <span class="m">15</span> <span class="p">|</span>        <span class="m">1</span>
  <span class="m">3</span> <span class="p">|</span> bob  <span class="p">|</span>  <span class="m">15</span> <span class="p">|</span>        <span class="m">2</span>
  <span class="m">4</span> <span class="p">|</span> kate <span class="p">|</span>  <span class="m">15</span> <span class="p">|</span>        <span class="m">2</span>
  <span class="m">5</span> <span class="p">|</span> <span class="nb">jobs</span> <span class="p">|</span>  <span class="m">15</span> <span class="p">|</span>        <span class="m">3</span>
  <span class="m">6</span> <span class="p">|</span> bill <span class="p">|</span>  <span class="m">15</span> <span class="p">|</span>        <span class="m">3</span>
<span class="o">(</span><span class="m">6</span> rows<span class="o">)</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># update student set age = 14 where no = 3;</span>
UPDATE <span class="m">1</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># update student set age = 12, name = &#39;tom&#39; where no = 4;</span>
UPDATE <span class="m">1</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># select * from student;</span>
 no <span class="p">|</span> name <span class="p">|</span> age <span class="p">|</span> class_no
----<span class="p">|</span>------<span class="p">|</span>-----<span class="p">|</span>----------
  <span class="m">1</span> <span class="p">|</span> lily <span class="p">|</span>  <span class="m">15</span> <span class="p">|</span>        <span class="m">1</span>
  <span class="m">2</span> <span class="p">|</span> lucy <span class="p">|</span>  <span class="m">15</span> <span class="p">|</span>        <span class="m">1</span>
  <span class="m">5</span> <span class="p">|</span> <span class="nb">jobs</span> <span class="p">|</span>  <span class="m">15</span> <span class="p">|</span>        <span class="m">3</span>
  <span class="m">6</span> <span class="p">|</span> bill <span class="p">|</span>  <span class="m">15</span> <span class="p">|</span>        <span class="m">3</span>
  <span class="m">3</span> <span class="p">|</span> bob  <span class="p">|</span>  <span class="m">14</span> <span class="p">|</span>        <span class="m">2</span>
  <span class="m">4</span> <span class="p">|</span> tom  <span class="p">|</span>  <span class="m">12</span> <span class="p">|</span>        <span class="m">2</span>
<span class="o">(</span><span class="m">6</span> rows<span class="o">)</span></code></pre></div>

<h2 id="删除语句-delete">删除语句(delete)</h2>

<p>使用<code>\h delete</code>查看帮助</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># \h delete</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># delete from student where no = 3;</span>
DELETE <span class="m">1</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># select * from student;</span>
 no <span class="p">|</span> name <span class="p">|</span> age <span class="p">|</span> class_no
----<span class="p">|</span>------<span class="p">|</span>-----<span class="p">|</span>----------
  <span class="m">1</span> <span class="p">|</span> lily <span class="p">|</span>  <span class="m">15</span> <span class="p">|</span>        <span class="m">1</span>
  <span class="m">2</span> <span class="p">|</span> lucy <span class="p">|</span>  <span class="m">15</span> <span class="p">|</span>        <span class="m">1</span>
  <span class="m">5</span> <span class="p">|</span> <span class="nb">jobs</span> <span class="p">|</span>  <span class="m">15</span> <span class="p">|</span>        <span class="m">3</span>
  <span class="m">6</span> <span class="p">|</span> bill <span class="p">|</span>  <span class="m">15</span> <span class="p">|</span>        <span class="m">3</span>
  <span class="m">4</span> <span class="p">|</span> tom  <span class="p">|</span>  <span class="m">12</span> <span class="p">|</span>        <span class="m">2</span>
<span class="o">(</span><span class="m">5</span> rows<span class="o">)</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># delete from student;</span>
DELETE <span class="m">5</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># select * from student;</span>
 no <span class="p">|</span> name <span class="p">|</span> age <span class="p">|</span> class_no
----<span class="p">|</span>------<span class="p">|</span>-----<span class="p">|</span>----------
<span class="o">(</span><span class="m">0</span> rows<span class="o">)</span></code></pre></div>

<h2 id="删除表">删除表</h2>

<p>使用<code>\h drop table</code>查看帮助</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># \h drop table</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># drop table student;</span>
DROP TABLE</code></pre></div>

<h2 id="其他sql语句">其他SQL语句</h2>

<h3 id="insert-into-select语句">insert into &hellip; select语句</h3>

<p>使用<code>INSERT INTO… SELECT</code>语句可以把数据从一张表插入到另一张表中，这个语句属
于DML语句。创建一张学生表的备份表：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># create table student_bak(no int primary key, name varchar(40), age int, class_no int);</span>
CREATE TABLE
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># insert into student_bak select * from student;</span>
INSERT <span class="m">0</span> <span class="m">6</span>
<span class="nv">postgres</span><span class="o">=</span><span class="c1"># select * from student_bak;</span>
 no <span class="p">|</span> name <span class="p">|</span> age <span class="p">|</span> class_no
----<span class="p">|</span>------<span class="p">|</span>-----<span class="p">|</span>----------
  <span class="m">5</span> <span class="p">|</span> <span class="nb">jobs</span> <span class="p">|</span>  <span class="m">15</span> <span class="p">|</span>        <span class="m">3</span>
  <span class="m">6</span> <span class="p">|</span> bill <span class="p">|</span>  <span class="m">13</span> <span class="p">|</span>        <span class="m">3</span>
  <span class="m">3</span> <span class="p">|</span> bob  <span class="p">|</span>     <span class="p">|</span>        <span class="m">2</span>
  <span class="m">4</span> <span class="p">|</span> kate <span class="p">|</span>  <span class="m">12</span> <span class="p">|</span>        <span class="m">2</span>
  <span class="m">1</span> <span class="p">|</span> lily <span class="p">|</span>  <span class="m">14</span> <span class="p">|</span>        <span class="m">1</span>
  <span class="m">2</span> <span class="p">|</span> lucy <span class="p">|</span>  <span class="m">13</span> <span class="p">|</span>        <span class="m">1</span>
<span class="o">(</span><span class="m">6</span> rows<span class="o">)</span></code></pre></div>

<h3 id="union语句">union语句</h3>

<p>可以将从两张表查询出来的数据整合在一个结果集下：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># select * from student where no = 1 union select * from student_bak where no = 2;</span>
 no <span class="p">|</span> name <span class="p">|</span> age <span class="p">|</span> class_no
----<span class="p">|</span>------<span class="p">|</span>-----<span class="p">|</span>----------
  <span class="m">1</span> <span class="p">|</span> lily <span class="p">|</span>  <span class="m">14</span> <span class="p">|</span>        <span class="m">1</span>
  <span class="m">2</span> <span class="p">|</span> lucy <span class="p">|</span>  <span class="m">13</span> <span class="p">|</span>        <span class="m">1</span>
<span class="o">(</span><span class="m">2</span> rows<span class="o">)</span></code></pre></div>

<p>语法比较简单，把两个SQL语句用<code>union</code>关键字连接起来就可以了。注意<code>union</code>会把结果集中相同的两条记录合并成一条。如果不想合并，请使用<code>union all</code>：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># select * from student where no = 1 union all select * from student_bak where no = 1;</span>
 no <span class="p">|</span> name <span class="p">|</span> age <span class="p">|</span> class_no
----<span class="p">|</span>------<span class="p">|</span>-----<span class="p">|</span>----------
  <span class="m">1</span> <span class="p">|</span> lily <span class="p">|</span>  <span class="m">14</span> <span class="p">|</span>        <span class="m">1</span>
  <span class="m">1</span> <span class="p">|</span> lily <span class="p">|</span>  <span class="m">14</span> <span class="p">|</span>        <span class="m">1</span>
<span class="o">(</span><span class="m">2</span> rows<span class="o">)</span></code></pre></div>

<h3 id="truncate-table语句">truncate table语句</h3>

<p><code>truncate table</code>语句用于清空表，与不带<code>where</code>子句的<code>delete</code>一样清空表数据，但两者在实现原理上是不一样的。<code>truncate table</code>是DDL语句，相当于用重新定义一个新表的方法
把原先表的内容直接丢弃了，所以 <code>truncate table</code>执行起来很快。而<code>delete</code>是DML
语句，它一条一条地删除数据。如果删除很多行数据，就会比较慢。</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># truncate table student_bak;</span>
TRUNCATE TABLE</code></pre></div>
]]></content>
		</item>
		
		<item>
			<title>Docker安装gpdb测试数据库</title>
			<link>https://gitop.cc/posts/docker_install_gpdb_dev_env/</link>
			<pubDate>Thu, 17 Jan 2019 15:02:33 +0800</pubDate>
			
			<guid>https://gitop.cc/posts/docker_install_gpdb_dev_env/</guid>
			<description>下载gpdb-dev镜像 pivotaldata/gpdb-dev:centos7是官方的开发镜像，里面已经装好了一些依赖，所以使用起来会方便</description>
			<content type="html"><![CDATA[<p><strong>下载gpdb-dev镜像</strong></p>

<p><code>pivotaldata/gpdb-dev:centos7</code>是官方的开发镜像，里面已经装好了一些依赖，所以使用起来会方便一点。</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">docker pull pivotaldata/gpdb-dev:centos7</code></pre></div>

<p><strong>下载gpdb源码到指定目录</strong></p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">git clone https://github.com/greenplum-db/gpdb.git ~/github</code></pre></div>

<p><strong>创建目录用于容器数据库</strong></p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo mkdir -p /var/lib/centos-gpdb-dev-data
sudo chown xiaoyu:xiaoyu /var/lib/centos-gpdb-dev-data</code></pre></div>

<p><strong>运行容器</strong></p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">docker run -it --name centos-gpdb-dev -v ~/github/gpdb:/home/gpadmin/gpdb_src -v /var/lib/centos-gpdb-dev-data:/home/gpadmin/data -p <span class="m">15432</span>:15432 pivotaldata/gpdb-dev:centos7</code></pre></div>

<p><strong>安装依赖</strong></p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">/home/gpadmin/gpdb_src/README.CentOS.bash</code></pre></div>

<p><strong>添加动态库搜索路径，并使之生效</strong></p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">echo</span> /usr/local/lib &gt;&gt; /etc/ld.so.conf
<span class="nb">echo</span> /usr/local/lib64 &gt;&gt; /etc/ld.so.conf
ldconfig</code></pre></div>

<p><strong>设置启动sshd</strong></p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">echo</span> /usr/sbin/sshd &gt;&gt; ~/.bashrc
/usr/sbin/sshd <span class="c1"># 第一次手动启动</span></code></pre></div>

<p><strong>切换到gpadmin用户，并进入源码目录</strong></p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">su - gpadmin
mkdir gpdb <span class="c1"># 创建gpdb目录作为gpdb安装目录</span>
<span class="nb">cd</span> /home/gpadmin/gpdb_src</code></pre></div>

<p><strong>编译gp-xerces</strong></p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">git clone https://github.com/greenplum-db/gp-xerces.git
<span class="nb">cd</span> gp-xerces
./configure <span class="o">&amp;&amp;</span> make -j4
sudo make install
<span class="nb">cd</span> ..</code></pre></div>

<p><strong>安装conan</strong></p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo pip install --upgrade pip
sudo pip install -I conan <span class="c1"># -I忽略已安装的包</span></code></pre></div>

<p><strong>编译ORCA</strong></p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">cd</span> depends
./configure <span class="o">&amp;&amp;</span> make -j4 orca
sudo make install_local
sudo ldconfig
<span class="nb">cd</span> ..</code></pre></div>

<p><strong>编译gpdb</strong></p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">./configure --enable-debug --with-perl --with-python --with-libxml --with-gssapi --prefix<span class="o">=</span>/home/gpadmin/gpdb
make -j4 <span class="o">&amp;&amp;</span> make -j4 install</code></pre></div>

<p><strong>使greenplum环境变量生效</strong></p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">echo</span> <span class="nb">source</span> /home/gpadmin/gpdb/greenplum_path.sh &gt;&gt; ~/.bashrc
<span class="nb">source</span> ~/.bashrc</code></pre></div>

<p><strong>创建测试数据库</strong></p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">export</span> <span class="nv">MASTER_DATADIR</span><span class="o">=</span>~/data <span class="c1"># 脚本demo_cluster.sh中用到</span>
make create-demo-cluster
<span class="nb">echo</span> <span class="nb">source</span> /home/gpadmin/gpdb_src/gpAux/gpdemo/gpdemo-env.sh &gt;&gt; ~/.bashrc
<span class="nb">source</span> ~/.bashrc</code></pre></div>

<p><strong>修改数据库用户名密码</strong></p>

<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">ALTER</span> <span class="k">USER</span> <span class="n">gpadmin</span> <span class="n">PASSWORD</span> <span class="s1">&#39;gpadmin&#39;</span><span class="p">;</span></code></pre></div>

<p><strong>修改master数据目录的配置文件pg_hba.conf，在最后添加以下内容</strong></p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">host    all     all     <span class="m">192</span>.168.0.0/16  md5</code></pre></div>

<p><strong>修改master数据目录的配置文件postgresql.conf，找到listen_addresses，去掉前面的#，让gpdb重新加载配置文件</strong></p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">gpstop -ua</code></pre></div>

<p><strong>至此，gpdb测试数据库可以接受内网的访问。</strong></p>
]]></content>
		</item>
		
		<item>
			<title>数组</title>
			<link>https://gitop.cc/posts/arrays/</link>
			<pubDate>Mon, 12 Nov 2018 19:37:34 +0800</pubDate>
			
			<guid>https://gitop.cc/posts/arrays/</guid>
			<description>创建数组 创建数组的最简单方法是使用数组字面值： var empty = []; // An array with no elements var primes = [2, 3, 5, 7, 11]; // An array with 5 numeric elements var misc = [1.1, true, &amp;#34;a&amp;#34;,]; // 3 elements of various types + trailing comma 数组字面值中的</description>
			<content type="html"><![CDATA[

<h3 id="创建数组">创建数组</h3>

<p>创建数组的最简单方法是使用数组字面值：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">empty</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// An array with no elements
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">primes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">];</span> <span class="c1">// An array with 5 numeric elements
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">misc</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.1</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="s2">&#34;a&#34;</span><span class="p">,];</span> <span class="c1">// 3 elements of various types + trailing comma
</span></code></pre></div>

<p>数组字面值中的元素可以是任意的表达式。如果数组中有省略的元素，其值为<code>undefined</code>：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,,</span><span class="mi">3</span><span class="p">];</span> <span class="c1">// An array with 3 elements, the middle one undefined.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">undefs</span> <span class="o">=</span> <span class="p">[,,];</span> <span class="c1">// An array with 2 elements, both undefined.
</span></code></pre></div>

<p>另一种方式是使用<code>Array</code>构造函数：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">();</span> <span class="c1">// equivalent to []
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// length 10, but has no values
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&#34;testing, testing&#34;</span><span class="p">);</span> <span class="c1">// arguments become array&#39;s elements
</span></code></pre></div>

<h3 id="读写数组元素">读写数组元素</h3>

<p>使用<code>[]</code>运算符访问数组的元素。所有索引都是属性名，但只有0到2^32-1之间的整数属性名才是索引。所有数组都是对象，你可以在数组上创建任何名称的属性。如果你使用的是索引，那么数组会自动更新<code>length</code>属性。</p>

<p>负数或浮点数可以用于数组索引。它们被转换为一个字符串，并被用作属性名，它被视为常规对象属性，而不是数组索引。</p>

<p>数组索引只是一种特殊类型的属性名，这意味着数组没有“越界”的概念：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">];</span> <span class="c1">// This array has elements at indexes 0 and 1
</span><span class="c1"></span><span class="nx">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="c1">// =&gt; undefined. No element at this index.
</span><span class="c1"></span><span class="nx">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1">// =&gt; undefined. No property with this name.
</span></code></pre></div>

<h3 id="稀疏数组">稀疏数组</h3>

<p>稀疏数组是没有连续索引的数组。稀疏数组的<code>length</code>属性的值大于元素的数量：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// No elements, but a.length is 5.
</span><span class="c1"></span><span class="nx">a</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// Create an array with no elements and length = 0.
</span><span class="c1"></span><span class="nx">a</span><span class="p">[</span><span class="mi">1000</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Assignment adds one element but sets length to 1001.
</span></code></pre></div>

<p>创建数组时忽略的元素和稀疏数组中不存在的元素是有区别的：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">a1</span> <span class="o">=</span> <span class="p">[,,,];</span> <span class="c1">// This array is [undefined, undefined, undefined]
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">a2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// This array has no values at all
</span><span class="c1"></span><span class="mi">0</span> <span class="k">in</span> <span class="nx">a1</span> <span class="c1">// =&gt; true: a1 has an element with index 0
</span><span class="c1"></span><span class="mi">0</span> <span class="k">in</span> <span class="nx">a2</span> <span class="c1">// =&gt; false: a2 has no element with index 0
</span></code></pre></div>

<h3 id="数组长度">数组长度</h3>

<p>数组的<code>length</code>属性使得数组不同于普通的JavaScript对象。对于密集的数组， <code>length</code>属性指定数组中元素的数量。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="p">[].</span><span class="nx">length</span> <span class="c1">// =&gt; 0: the array has no elements
</span><span class="c1"></span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">].</span><span class="nx">length</span> <span class="c1">// =&gt; 3: highest index is 2, length is 3
</span></code></pre></div>

<p>稀疏数组的<code>length</code> 属性大于元素的数量。也就是说，数组的索引永远小于数组<code>length</code>属性。为了维持这个不变量，数组有2个特殊行为：</p>

<ol>
<li>如果给大于<code>length</code>的索引<code>i</code>的元素赋值，则<code>length</code>被设为<code>i+1</code>。</li>
<li>如果将<code>length</code>属性设置为小于其当前值的非负整数<code>n</code>，那么任何索引大于或等于<code>n</code>的元素都被删除。</li>
</ol>

<p>将<code>length</code>属性设置为大于其当前的值，这样做实际上只是在数组末尾创建一个稀疏区域。在ES5中，可以使用<code>Object.defineProperty</code>将数组的<code>length</code>属性设置为只读：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">];</span> <span class="c1">// Start with a 3-element array.
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="s2">&#34;length&#34;</span><span class="p">,</span> <span class="p">{</span><span class="nx">writable</span><span class="o">:</span> <span class="kc">false</span><span class="p">});</span>  <span class="c1">// Make the length property readonly.
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// a is unchanged.
</span></code></pre></div>

<p>类似地，如果使数组元素不可配置，则不能删除它，即不能将<code>length</code>属性设置为小于不可配置元素的索引。</p>

<h3 id="添加和删除元素">添加和删除元素</h3>

<p>最简单的添加元素方法是赋值给新索引：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">a</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">// Start with an empty array.
</span><span class="c1"></span><span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&#34;zero&#34;</span><span class="p">;</span> <span class="c1">// And add elements to it.
</span><span class="c1"></span><span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&#34;one&#34;</span><span class="p">;</span>
</code></pre></div>

<p>还可以使用<code>push</code>方法向数组末尾添加一个或多个值：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">a</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// Start with an empty array
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&#34;zero&#34;</span><span class="p">)</span> <span class="c1">// Add a value at the end. a = [&#34;zero&#34;]
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="s2">&#34;one&#34;</span><span class="p">,</span> <span class="s2">&#34;two&#34;</span><span class="p">)</span> <span class="c1">// Add two more values. a = [&#34;zero&#34;, &#34;one&#34;, &#34;two&#34;]
</span></code></pre></div>

<p>可以使用<code>unshift</code>在数组开头插入元素，将现有的元素移到更高的索引。</p>

<p>使用<code>delete</code>删除数组元素：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">];</span>
<span class="k">delete</span> <span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// a now has no element at index 1
</span><span class="c1"></span><span class="mi">1</span> <span class="k">in</span> <span class="nx">a</span> <span class="c1">// =&gt; false: no array index 1 is defined
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// =&gt; 3: delete does not affect array length
</span></code></pre></div>

<p><code>delete</code>数组元素不会改变<code>length</code>属性，也不会将索引较高的元素向下移动，成为稀疏数组。也通过将<code>length</code>属性设置为新的长度来删除数组末尾的元素。</p>

<p><code>pop</code>方法将数组的<code>length</code>减1，并返回删除元素的值。</p>

<p><code>shift</code>方法从数组的开头删除一个元素，并将所有的元素索引前移一个位置。</p>

<p><code>splice</code>是用于插入、删除或替换数组元素的通用方法。它改变<code>length</code>属性，并根据需要将数组元素移到更高或更低的索引。</p>

<h3 id="遍历数组">遍历数组</h3>

<p>遍历数组元素最常见的方法是使用for循环：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">keys</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">o</span><span class="p">);</span> <span class="c1">// Get an array of property names for object o
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">values</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">// Store matching property values in this array
</span><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">keys</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// For each index in the array
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">key</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span> <span class="c1">// Get the key at that index
</span><span class="c1"></span>    <span class="nx">values</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">o</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="c1">// Store the value in the values array
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<p>for循环一个小小的优化，不用每次查询<code>length</code>：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">keys</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// loop body remains the same
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<p>循环中检查数组元素的几种情况：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span> <span class="c1">// Skip null, undefined, and nonexistent elements
</span><span class="c1"></span><span class="p">}</span>
<span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span> <span class="c1">// Skip undefined + nonexistent elements
</span><span class="c1"></span><span class="p">}</span>
<span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">i</span> <span class="k">in</span> <span class="nx">a</span><span class="p">))</span> <span class="k">continue</span> <span class="p">;</span> <span class="c1">// Skip nonexistent elements
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<p>for/in循环可以用于稀疏阵列。每次循环给循环变量分配一个可枚举的属性名（包括数组索引），不存在的索引将不会被遍历：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">index</span> <span class="k">in</span> <span class="nx">sparseArray</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">sparseArray</span><span class="p">[</span><span class="nx">index</span><span class="p">];</span>
    <span class="c1">// Now do something with index and value
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<p>for/in循环可以返回继承属性的名字，比如添加到<code>Array.prototype</code>的属性。因此在数组上使用for/in循环，应该过滤掉不需要的属性：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">a</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span> <span class="c1">// Skip inherited properties
</span><span class="c1"></span><span class="p">}</span>
<span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Skip i if it is not a non-negative integer
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nb">String</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nb">Number</span><span class="p">(</span><span class="nx">i</span><span class="p">))))</span> <span class="o">!==</span> <span class="nx">i</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>ES5定义了许多用于迭代数组元素的新方法，<code>forEach</code>方法是最通用的一个：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span> <span class="c1">// This is the array we want to iterate
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">sumOfSquares</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// We want to compute the sum of the squares of data
</span><span class="c1"></span><span class="nx">data</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Pass each element of data to this function
</span><span class="c1"></span>    <span class="nx">sumOfSquares</span> <span class="o">+=</span> <span class="nx">x</span><span class="o">*</span><span class="nx">x</span><span class="p">;</span> <span class="c1">// add up the squares
</span><span class="c1"></span><span class="p">});</span>
<span class="nx">sumOfSquares</span> <span class="c1">// =&gt;55 : 1+4+9+16+25
</span></code></pre></div>

<h3 id="多维数组">多维数组</h3>

<p>JavaScript不支持真正的多维数组，但可以用数组的数组模拟它们：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">// Create a multidimensional array
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">table</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// 10 rows of the table
</span><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">table</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
    <span class="nx">table</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// Each row has 10 columns
</span><span class="c1">// Initialize the array
</span><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">row</span> <span class="o">&lt;</span> <span class="nx">table</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">row</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="nx">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">col</span> <span class="o">&lt;</span> <span class="nx">table</span><span class="p">[</span><span class="nx">row</span><span class="p">].</span><span class="nx">length</span><span class="p">;</span> <span class="nx">col</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">table</span><span class="p">[</span><span class="nx">row</span><span class="p">][</span><span class="nx">col</span><span class="p">]</span> <span class="o">=</span> <span class="nx">row</span><span class="o">*</span><span class="nx">col</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">product</span> <span class="o">=</span> <span class="nx">table</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">7</span><span class="p">];</span> <span class="c1">// 35
</span></code></pre></div>

<h3 id="数组方法">数组方法</h3>

<p>ES3在<code>Array.prototype</code>上定义了许多有用函数。这意味着它们可以用作任何数组的方法。</p>

<h4 id="join">join</h4>

<p><code>join</code>方法将数组元素转换为字符串，并连接起来，返回字符串。可以指定一个可选的字符串来分隔元素，默认使用逗号：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span> <span class="c1">// Create a new array with these three elements
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">join</span><span class="p">();</span> <span class="c1">// =&gt; &#34;1,2,3&#34;
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s2">&#34; &#34;</span><span class="p">);</span> <span class="c1">// =&gt; &#34;1 2 3&#34;
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s2">&#34;&#34;</span><span class="p">);</span> <span class="c1">// =&gt; &#34;123&#34;
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// An array of length 10 with no elements
</span><span class="c1"></span><span class="nx">b</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span> <span class="c1">// =&gt; &#39;---------&#39;: a string of 9 hyphens
</span></code></pre></div>

<p><code>join</code>方法和<code>split</code>方法刚好相反。</p>

<h4 id="reverse">reverse</h4>

<p><code>reverse</code>方法原地反转数组的顺序，并返回已反转的数组。</p>

<h4 id="sort">sort</h4>

<p><code>sort</code>原地排序数组元素，并返回已排序的数组。在不带参数的情况下，<code>sort</code>按字母顺序对数组元素进行排序，如果需要的话，将数组元素临时转换为字符串来进行比较。如果数组包含<code>undefined</code>元素，它们被移到数组后面。</p>

<p>要将数组按其它顺序排序，必须传递一个比较函数作为<code>sort</code>的参数。这个函数决定它的两个参数中的哪个应该先出现在数组中：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">33</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1111</span><span class="p">,</span> <span class="mi">222</span><span class="p">];</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">sort</span><span class="p">();</span> <span class="c1">// Alphabetical order: 1111, 222, 33, 4
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">sort</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Numerical order: 4, 33, 222, 1111
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">a</span><span class="o">-</span><span class="nx">b</span><span class="p">;</span>
<span class="p">});</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">sort</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="nx">b</span><span class="o">-</span><span class="nx">a</span><span class="p">});</span> <span class="c1">// Reverse numerical order
</span><span class="c1"></span>
<span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ant&#39;</span><span class="p">,</span> <span class="s1">&#39;Bug&#39;</span><span class="p">,</span> <span class="s1">&#39;cat&#39;</span><span class="p">,</span> <span class="s1">&#39;Dog&#39;</span><span class="p">]</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">sort</span><span class="p">();</span> <span class="c1">// case-sensitive sort: [&#39;Bug&#39;,&#39;Dog&#39;,&#39;ant&#39;,cat&#39;]
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">sort</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Case-insensitive sort
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">();</span>
    <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">a</span> <span class="o">&lt;</span> <span class="nx">b</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">a</span> <span class="o">&gt;</span> <span class="nx">b</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">});</span> <span class="c1">// =&gt; [&#39;ant&#39;,&#39;Bug&#39;,&#39;cat&#39;,&#39;Dog&#39;]
</span></code></pre></div>

<h4 id="concat">concat</h4>

<p><code>concat</code>方法连接调用它的数组元素和它的参数，并返回一个新数组。如果参数是一个数组，那么连接的是数组元素，而不是数组本身，但是<code>concat</code>只处理最外层数组：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">];</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">// Returns [1,2,3,4,5]
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">concat</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]);</span> <span class="c1">// Returns [1,2,3,4,5]
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">concat</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span> <span class="c1">// Returns [1,2,3,4,5,6,7]
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]])</span> <span class="c1">// Returns [1,2,3,4,5,[6,7]]
</span></code></pre></div>

<h4 id="slice">slice</h4>

<p>语法如下：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nb">Array</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">end</span><span class="p">)</span> <span class="c1">// 返回包含[start, end)元素的数组
</span><span class="c1"></span><span class="nb">Array</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">start</span><span class="p">)</span> <span class="c1">// 等价于Array.slice(start, Array.length)
</span></code></pre></div>

<p>如果参数为负数，它表示是数组倒数第几个元素：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// Returns [1,2,3]
</span><span class="c1"></span>
<span class="nx">a</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// Returns [4,5]
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// Returns [2,3,4]
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// Returns [3]
</span></code></pre></div>

<h4 id="splice">splice</h4>

<p><code>splice</code>方法是用于插入或删除数组元素的通用方法，它会修改数组。<code>splice</code>第一个参数指定开始插入或删除的数组位置。第二个参数指定应该从数组中删除的元素个数。如果省略了第二个参数，那么从开始元素到数组末尾的所有数组元素都将被删除。<code>splice</code>返回删除元素的数组，如果没有删除元素，返回空数组：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">];</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// Returns [5,6,7,8]; a is [1,2,3,4]
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// Returns [2,3]; a is [1,4]
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// Returns [4]; a is [1]
</span></code></pre></div>

<p><code>splice</code>的前两个参数指定要删除的数组元素。它们后面可以跟任意数量的附加参数，这些参数指定要插入到数组中的元素，从第一个参数指定的位置开始：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">);</span> <span class="c1">// Returns []; a is [1,2,&#39;a&#39;,&#39;b&#39;,3,4,5]
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// Returns [&#39;a&#39;,&#39;b&#39;]; a is [1,2,[1,2],3,3,4,5]
</span></code></pre></div>

<h4 id="push和pop">push和pop</h4>

<p><code>push</code>和<code>pop</code>允许你以栈的方式处理数组。<code>push</code>将一个或多个新元素追加到数组的末尾，并返回数组的新长度。<code>pop</code>删除数组最后一个元素，递减数组长度，并返回删除的值。这两个方法直接修改数组。</p>

<h4 id="unshift和shift">unshift和shift</h4>

<p><code>unshift</code>在开头添加一个或多个元素，将现有的数组元素移动到更高的索引位置，并返回数组的新长度。<code>shift</code>删除并返回数组的第一个元素，将所有后续元素向下移动一个位置：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// a:[]
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">unshift</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// a:[1] Returns: 1
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">unshift</span><span class="p">(</span><span class="mi">22</span><span class="p">);</span> <span class="c1">// a:[22,1] Returns: 2
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span> <span class="c1">// a:[1] Returns: 22
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">unshift</span><span class="p">(</span><span class="mi">3</span><span class="p">,[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]);</span> <span class="c1">// a:[3,[4,5],1] Returns: 3
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span> <span class="c1">// a:[[4,5],1] Returns: 3
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span> <span class="c1">// a:[1] Returns: [4,5]
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span> <span class="c1">// a:[] Returns: 1
</span></code></pre></div>

<p>多个参数调用<code>unshift</code>时，一次性插入所有的参数。</p>

<h4 id="tostring和tolocalestring">toString和toLocaleString</h4>

<p>数组的<code>toString</code>方法将每个元素转换为一个字符串，并用逗号连接这些字符串：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">].</span><span class="nx">toString</span><span class="p">()</span> <span class="c1">// Yields &#39;1,2,3&#39;
</span><span class="c1"></span><span class="p">[</span><span class="s2">&#34;a&#34;</span><span class="p">,</span> <span class="s2">&#34;b&#34;</span><span class="p">,</span> <span class="s2">&#34;c&#34;</span><span class="p">].</span><span class="nx">toString</span><span class="p">()</span> <span class="c1">// Yields &#39;a,b,c&#39;
</span><span class="c1"></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">]].</span><span class="nx">toString</span><span class="p">()</span> <span class="c1">// Yields &#39;1,2,c&#39;
</span></code></pre></div>

<p>数组的<code>join</code>方法不带参数时返回的字符串和<code>toString</code>方法相同。</p>

<p><code>toLocaleString</code>是<code>toString</code>的本地化版本。它通过调用元素的<code>toLocaleString</code>方法将每个元素转换为字符串，然后使用本地化的分隔符字符串连接结果字符串。</p>

<h3 id="es5数组方法">ES5数组方法</h3>

<p>首先，大多数方法接受一个函数作为它的第一个参数，并为每个数组元素调用一次这个方法。如果是稀疏数组，不会为不存在的元素调用函数。大多数情况下，使用3个参数调用你提供的函数：数组元素的值，数组元素的索引和数组本身。通常你只需要第一个参数的值。</p>

<p>大多数接受函数作为第一个参数的ES5数组方法有一个可选的第二个参数。如果指定，则函数被作为第二个参数的方法调用。ES5数组方法不会修改调用它的数组。</p>

<h4 id="foreach">forEach</h4>

<p>语法如下：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">a</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">fn</span><span class="p">[,</span> <span class="nx">o</span><span class="p">])</span>
</code></pre></div>

<p><code>forEach</code>遍历数组，并为每个元素调用指定的函数。<code>forEach</code>使用3个参数调用函数：数组元素的值、数组元素的索引和数组本身：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span> <span class="c1">// An array to sum
</span><span class="c1">// Compute the sum of the array elements
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Start at 0
</span><span class="c1"></span><span class="nx">data</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span> <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">value</span><span class="p">;</span> <span class="p">});</span> <span class="c1">// Add each value to sum
</span><span class="c1"></span><span class="nx">sum</span> <span class="c1">// =&gt; 15
</span><span class="c1">// Now increment each array element
</span><span class="c1"></span><span class="nx">data</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span> <span class="p">{</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">});</span>
<span class="nx">data</span> <span class="c1">// =&gt; [2,3,4,5,6]
</span></code></pre></div>

<p><code>forEach</code>不能中止循环。如果需要提前终止，可以抛出异常：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">foreach</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">f</span><span class="p">,</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="nx">a</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span><span class="nx">t</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">e</span> <span class="o">===</span> <span class="nx">foreach</span><span class="p">.</span><span class="k">break</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">throw</span> <span class="nx">e</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">foreach</span><span class="p">.</span><span class="k">break</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&#34;StopIteration&#34;</span><span class="p">);</span>
</code></pre></div>

<h4 id="map">map</h4>

<p>语法如下：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">a</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span>
</code></pre></div>

<p>map方法将数组的每个元素传递给指定的函数，并返回一个包含该函数返回值的新数组：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="nx">b</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span><span class="o">*</span><span class="nx">x</span><span class="p">;</span> <span class="p">});</span> <span class="c1">// b is [1, 4, 9]
</span></code></pre></div>

<p>传递给<code>map</code>的方法应该返回一个值。如果数组是稀疏的，返回的数组也是稀疏的。</p>

<h4 id="filter">filter</h4>

<p>语法如下：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">a</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span>
</code></pre></div>

<p><code>filter</code>方法返回数组元素子集的数组。传递给<code>filter</code>的函数应该是谓词。如果谓词返回值为true，则该元素是返回数组的一个元素：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">];</span>
<span class="nx">smallvalues</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="p">});</span> <span class="c1">// [2, 1]
</span><span class="c1"></span><span class="nx">everyother</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">i</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">0</span> <span class="p">});</span> <span class="c1">// [5, 3, 1]
</span></code></pre></div>

<p><code>filter</code>忽略稀疏数组中不存在的元素，它的返回值不是稀疏数组：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">dense</span> <span class="o">=</span> <span class="nx">sparse</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span> <span class="p">});</span>
<span class="nx">a</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">&amp;&amp;</span> <span class="nx">x</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">;</span> <span class="p">});</span>
</code></pre></div>

<h4 id="every和some">every和some</h4>

<p>语法如下：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">a</span><span class="p">.</span><span class="nx">every</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">some</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span>
</code></pre></div>

<p><code>every</code>方法类似数学符号<code>∀</code>： 当且仅当谓词函数对数组所有元素返回true时，它才返回true。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">every</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="p">})</span> <span class="c1">// =&gt; true: all values &lt; 10.
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">every</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">0</span><span class="p">;</span> <span class="p">})</span> <span class="c1">// =&gt; false: not all values even.
</span></code></pre></div>

<p><code>some</code>方法类似数学符号<code>∃</code>：如果存在一个元素使谓词函数返回true，则返回true。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">some</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span><span class="o">%</span><span class="mi">2</span><span class="o">===</span><span class="mi">0</span><span class="p">;</span> <span class="p">})</span> <span class="c1">// =&gt; true a has some even numbers.
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">some</span><span class="p">(</span><span class="nb">isNaN</span><span class="p">)</span> <span class="c1">// =&gt; false: a has no non-numbers.
</span></code></pre></div>

<p><code>every</code>和<code>some</code>都是一旦能确定返回值时就停止迭代。根据数学惯例，当在空数组上调用时，<code>every</code>返回true，<code>some</code>返回false。</p>

<h4 id="reduce和reduceright">reduce和reduceRight</h4>

<p>语法如下：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">a</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="nx">fn</span><span class="p">[,</span> <span class="nx">initial</span><span class="p">])</span> <span class="c1">// initial为初始值
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">reduceRight</span><span class="p">(</span><span class="nx">fn</span><span class="p">[,</span> <span class="nx">initial</span><span class="p">])</span>
</code></pre></div>

<p><code>reduce</code>和<code>reduceRight</code> 方法使用指定函数计算数组元素：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="kd">var</span> <span class="nx">sum</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span><span class="o">+</span><span class="nx">y</span> <span class="p">},</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// Sum of values
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">product</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span><span class="o">*</span><span class="nx">y</span> <span class="p">},</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// Product of values
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">max</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="nx">x</span><span class="o">&gt;</span><span class="nx">y</span><span class="p">)</span><span class="o">?</span><span class="nx">x</span><span class="o">:</span><span class="nx">y</span><span class="p">;</span> <span class="p">});</span> <span class="c1">// Largest value
</span></code></pre></div>

<p>在<code>reduce</code>和<code>reduceRight</code>方法中，传递给<code>fn</code>的第一个参数是已经累计的结果，数组元素的值、数组元素的索引和数组本身紧跟第一个参数。第一次调用<code>fn</code>时，第一个参数为初始值。后续调用的第一个参数是前一个调用的返回值。</p>

<p>当没有初始值调用<code>reduce</code>时，初始值为数组的第一个元素。没有初始值时在空数组上调用reduce会导致TypeError。</p>

<p>以下2中情况，<code>reduce</code>不会调用<code>fn</code>，而是直接返回那个值：</p>

<ul>
<li>只有一个元素数组，没有初始值</li>
<li>空数组和初始值</li>
</ul>

<p><code>reduceRight</code>的工作原理与<code>reduce</code>类似，只是它从高到低处理数组：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="c1">// Compute 2^(3^4). Exponentiation has right-to-left precedence
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">big</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">reduceRight</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">accumulator</span><span class="p">,</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span><span class="nx">accumulator</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>

<p><code>reduce</code>和<code>reduceRight</code>不支持方法调用。如果想要调用方法，可以使用<code>Function.bind</code>。</p>

<p><code>reduce</code>和<code>reduceRight</code>不仅仅用于数学计算，考虑上一章的<code>union</code>函数：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">objects</span> <span class="o">=</span> <span class="p">[{</span><span class="nx">x</span><span class="o">:</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="nx">y</span><span class="o">:</span><span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="nx">z</span><span class="o">:</span><span class="mi">3</span><span class="p">}];</span>
<span class="kd">var</span> <span class="nx">merged</span> <span class="o">=</span> <span class="nx">objects</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="nx">union</span><span class="p">);</span> <span class="c1">// =&gt; {x:1, y:2, z:3}
</span></code></pre></div>

<p>当两个对象具有相同名称的属性时，union函数从第一个参数使用该属性的值。因此<code>reduce</code>和<code>reduceRight</code>可能会返回不同的结果：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">objects</span> <span class="o">=</span> <span class="p">[{</span><span class="nx">x</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span><span class="nx">a</span><span class="o">:</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="nx">y</span><span class="o">:</span><span class="mi">2</span><span class="p">,</span><span class="nx">a</span><span class="o">:</span><span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="nx">z</span><span class="o">:</span><span class="mi">3</span><span class="p">,</span><span class="nx">a</span><span class="o">:</span><span class="mi">3</span><span class="p">}];</span>
<span class="kd">var</span> <span class="nx">leftunion</span> <span class="o">=</span> <span class="nx">objects</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="nx">union</span><span class="p">);</span> <span class="c1">// {x:1, y:2, z:3, a:1}
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">rightunion</span> <span class="o">=</span> <span class="nx">objects</span><span class="p">.</span><span class="nx">reduceRight</span><span class="p">(</span><span class="nx">union</span><span class="p">);</span> <span class="c1">// {x:1, y:2, z:3, a:3}
</span></code></pre></div>

<h4 id="indexof和lastindexof">indexOf和lastIndexOf</h4>

<p>语法如下：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">a</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">value</span><span class="p">[,</span> <span class="nx">start</span><span class="p">])</span> <span class="c1">// 从头到尾搜索数组
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">lastIndexOf</span><span class="p">(</span><span class="nx">value</span><span class="p">[,</span> <span class="nx">start</span><span class="p">])</span> <span class="c1">// 与indexOf相反
</span></code></pre></div>

<p>返回找到的第一个元素的索引，如果没找到则返回-1：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// =&gt; 1: a[1] is 1
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">lastIndexOf</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// =&gt; 3: a[3] is 1
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// =&gt; -1: no element has value 3
</span></code></pre></div>

<p>第二可选参数指定搜索的起始位置，它可以是负值，像<code>splice</code>方法一样当作与数组末尾的偏移量：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">// Find all occurrences of a value x in an array a and return an array
</span><span class="c1">// of matching indexes
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">findall</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">results</span> <span class="o">=</span> <span class="p">[],</span> <span class="c1">// The array of indexes we&#39;ll return
</span><span class="c1"></span>        <span class="nx">len</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="c1">// The length of the array to be searched
</span><span class="c1"></span>        <span class="nx">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// The position to search from
</span><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="nx">pos</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// While more elements to search...
</span><span class="c1"></span>        <span class="nx">pos</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">pos</span><span class="p">);</span> <span class="c1">// Search
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">pos</span> <span class="o">===</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> <span class="c1">// If nothing found, we&#39;re done.
</span><span class="c1"></span>        <span class="nx">results</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">pos</span><span class="p">);</span> <span class="c1">// Otherwise, store index in array
</span><span class="c1"></span>        <span class="nx">pos</span> <span class="o">=</span> <span class="nx">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// And start next search at next element
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">results</span><span class="p">;</span> <span class="c1">// Return array of indexes
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<h4 id="数组类型">数组类型</h4>

<p>在ES5中，可以使用<code>Array.isArray</code>来判断一个对象是否是数组：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">([])</span> <span class="c1">// =&gt; true
</span><span class="c1"></span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">({})</span> <span class="c1">// =&gt; false
</span></code></pre></div>

<p>在ES5之前，区分数组和非数组对象是非常困难的。除了函数，<code>typeof</code>一个对象返回<code>object</code>。<code>instanceof</code>在简单的情况下工作：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="p">[]</span> <span class="k">instanceof</span> <span class="nb">Array</span> <span class="c1">// =&gt; true
</span><span class="c1"></span><span class="p">({})</span> <span class="k">instanceof</span> <span class="nb">Array</span> <span class="c1">// =&gt; false
</span></code></pre></div>

<p>解决方案是检查对象的<code>class</code>属性。对于数组，这个属性总是有值“Array”，因此我们可以这样在ES3中这样编写<code>isArray</code>函数：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">isArray</span> <span class="o">=</span> <span class="nb">Function</span><span class="p">.</span><span class="nx">isArray</span> <span class="o">||</span> <span class="kd">function</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">typeof</span> <span class="nx">o</span> <span class="o">===</span> <span class="s2">&#34;object&#34;</span> <span class="o">&amp;&amp;</span>
        <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="o">===</span> <span class="s2">&#34;[object Array]&#34;</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="类数组对象">类数组对象</h3>

<p>JavaScript数组有一些其他对象没有的特殊特性：</p>

<ul>
<li>当向数组添加新元素时，<code>length</code>属性将自动更新。</li>
<li>将<code>length</code>设置为较小的值会截断数组。</li>
<li>数组从<code>Array.prototype</code>继承了有用的方法。</li>
<li>数组具有类属性“Array“。</li>
</ul>

<p>事实证明，许多数组算法对类数组对象的工作效果与对数组的工作效果一样好。<code>arguments</code>对象是一个类数组对象，<code>document.getElementsByTagName</code>方法返回一个类数组对象。以下是一个测试像数组一样工作的对象：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">// Determine if o is an array-like object.
</span><span class="c1">// Strings and functions have numeric length properties, but are
</span><span class="c1">// excluded by the typeof test. In client-side JavaScript, DOM text
</span><span class="c1">// nodes have a numeric length property, and may need to be excluded
</span><span class="c1">// with an additional o.nodeType != 3 test.
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">isArrayLike</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">o</span> <span class="o">&amp;&amp;</span> <span class="c1">// o is not null, undefined, etc.
</span><span class="c1"></span>        <span class="k">typeof</span> <span class="nx">o</span> <span class="o">===</span> <span class="s2">&#34;object&#34;</span> <span class="o">&amp;&amp;</span> <span class="c1">// o is an object
</span><span class="c1"></span>        <span class="nb">isFinite</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="c1">// o.length is a finite number
</span><span class="c1"></span>        <span class="nx">o</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="c1">// o.length is non-negative
</span><span class="c1"></span>        <span class="nx">o</span><span class="p">.</span><span class="nx">length</span><span class="o">===</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="c1">// o.length is an integer
</span><span class="c1"></span>        <span class="nx">o</span><span class="p">.</span><span class="nx">length</span> <span class="o">&lt;</span> <span class="mi">4294967296</span><span class="p">)</span> <span class="c1">// o.length &lt; 2^32
</span><span class="c1"></span>        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// Then o is array-like
</span><span class="c1"></span>    <span class="k">else</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// Otherwise it is not
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<p>JavaScript数组方法被特意定义为通用的，以便数组和类数组对象都能正确工作。在ES5中，所有数组方法都是通用的。在ES3中，除了<code>toString</code>和<code>toLocaleString</code>之外的所有方法都是通用的。因为类数组对象不继承<code>Array.prototype</code>，你不能直接调用数组方法。但你可以使用<code>Function.call</code>函数间接调用它们：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&#34;0&#34;</span><span class="o">:</span><span class="s2">&#34;a&#34;</span><span class="p">,</span> <span class="s2">&#34;1&#34;</span><span class="o">:</span><span class="s2">&#34;b&#34;</span><span class="p">,</span> <span class="s2">&#34;2&#34;</span><span class="o">:</span><span class="s2">&#34;c&#34;</span><span class="p">,</span> <span class="nx">length</span><span class="o">:</span><span class="mi">3</span><span class="p">};</span> <span class="c1">// An array-like object
</span><span class="c1"></span><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">join</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="s2">&#34;+&#34;</span><span class="p">)</span> <span class="c1">// =&gt; &#34;a+b+c&#34;
</span><span class="c1"></span><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// =&gt; [&#34;a&#34;,&#34;b&#34;,&#34;c&#34;]: true array copy
</span><span class="c1"></span><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">map</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">();</span>
<span class="p">})</span> <span class="c1">// =&gt; [&#34;A&#34;,&#34;B&#34;,&#34;C&#34;]:
</span></code></pre></div>

<p>Firefox很早就在数组构造函数上定义了函数，上面的例子可以这样重写：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&#34;0&#34;</span><span class="o">:</span><span class="s2">&#34;a&#34;</span><span class="p">,</span> <span class="s2">&#34;1&#34;</span><span class="o">:</span><span class="s2">&#34;b&#34;</span><span class="p">,</span> <span class="s2">&#34;2&#34;</span><span class="o">:</span><span class="s2">&#34;c&#34;</span><span class="p">,</span> <span class="nx">length</span><span class="o">:</span><span class="mi">3</span><span class="p">};</span> <span class="c1">// An array-like object
</span><span class="c1"></span><span class="nb">Array</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="s2">&#34;+&#34;</span><span class="p">)</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">();</span> <span class="p">})</span>
</code></pre></div>

<p>这些数组方法的静态函数版本在处理类数组对象时非常有用，但是由于它们是非标准的，所以不能指望在所有浏览器中都定义它们。在使用之前，你可以这样确保所需的函数存在：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nb">Array</span><span class="p">.</span><span class="nx">join</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">join</span> <span class="o">||</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">sep</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">join</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">sep</span><span class="p">);</span>
<span class="p">};</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">slice</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">slice</span> <span class="o">||</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">from</span><span class="p">,</span><span class="nx">to</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">from</span><span class="p">,</span><span class="nx">to</span><span class="p">);</span>
<span class="p">};</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">map</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">map</span> <span class="o">||</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">thisArg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">map</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">thisArg</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="字符串作为类数组">字符串作为类数组</h3>

<p>在ES5（以及在ES5之前的许多浏览器实现）中，字符串表现得像只读数组。你可以使用<code>[]</code>，而不是<code>charAt</code>方法访问单个字符：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="nx">test</span><span class="p">;</span>
<span class="nx">s</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// =&gt; &#34;t&#34;
</span><span class="c1"></span><span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1">// =&gt; &#34;e&#34;
</span></code></pre></div>

<p>字符串表现得像数组也意味着，我们可以对它们使用通用数组方法：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">s</span> <span class="o">=</span> <span class="s2">&#34;JavaScript&#34;</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">join</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s2">&#34; &#34;</span><span class="p">)</span> <span class="c1">// =&gt; &#34;J a v a S c r i p t&#34;
</span><span class="c1"></span><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">filter</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="c1">// Filter the characters of the string
</span><span class="c1"></span>    <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/aeiou/</span><span class="p">);</span> <span class="c1">// Only match nonvowels
</span><span class="c1"></span>    <span class="p">}).</span><span class="nx">join</span><span class="p">(</span><span class="s2">&#34;&#34;</span><span class="p">)</span> <span class="c1">// =&gt; &#34;JvScrpt&#34;
</span></code></pre></div>

<p>字符串是不可变的值，所以当它们被当作数组时，它们是只读数组。数组方法如<code>push</code>、<code>sort</code>、<code>reverse</code>和<code>splice</code>，会原地修改数组，不能在字符串上工作。尝试使用数组方法修改字符串不会导致错误，只是默默地失败。</p>
]]></content>
		</item>
		
		<item>
			<title>对象</title>
			<link>https://gitop.cc/posts/objects/</link>
			<pubDate>Sat, 03 Nov 2018 21:39:25 +0800</pubDate>
			
			<guid>https://gitop.cc/posts/objects/</guid>
			<description>对象的属性也有属性： 可写属性指定属性的值是否可以设置。 枚举属性指定属性名是否能由for/in循环返回。 可配置属性指定属性是否可以删除和更改。</description>
			<content type="html"><![CDATA[

<p>对象的属性也有属性：</p>

<ul>
<li>可写属性指定属性的值是否可以设置。</li>
<li>枚举属性指定属性名是否能由for/in循环返回。</li>
<li>可配置属性指定属性是否可以删除和更改。</li>
</ul>

<p>在ES5之前，自己代码创建的对象中的所有属性都是可写的、可枚举的和可配置的。每个对象都有三个相关的对象属性：</p>

<ul>
<li>对象的prototype是对另一个对象的引用，从这个对象继承属性。</li>
<li>对象的class是区分对象类型的字符串。</li>
<li>对象的可扩展标志（ES5）指定是否可以向对象添加新的属性。</li>
</ul>

<p>我们使用以下术语来区分三大类JavaScript对象和两类属性：</p>

<ul>
<li>原生对象是由ECMAScript规范定义的对象。Array、function、Date和RegExp都是是原生对象。</li>
<li>宿主对象是由嵌入JavaScript解释器的宿主环境（如web浏览器）定义的对象。在客户端JavaScript中表示web页面结构的HTMLElement对象就是宿主对象。</li>
<li>用户定义对象是JavaScript代码执行时创建的任何对象。</li>
<li>自有属性是对象本身定义的属性。</li>
<li>继承属性是由原型对象定义的属性。</li>
</ul>

<h3 id="创建对象">创建对象</h3>

<h4 id="对象字面值">对象字面值</h4>

<p>对象字面值用逗号分隔的键值对。属性名是JavaScript标识符或字符串字面值（允许空字符串）。属性值是任何JavaScript表达式。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="o">:</span><span class="mi">2</span><span class="p">};</span>
</code></pre></div>

<p>在ES5中，保留字可以作为属性名使用，不需要用引号括起来。在ES3中保留字作为属性名必须用引号括起来。在ES5中，最后一个属性后面的逗号被忽略。在大多数ES3实现中，结尾逗号被忽略，但IE认为它们是错误的。</p>

<h4 id="用new创建对象">用new创建对象</h4>

<p>new操作符创建并初始化一个新对象。其后面必须有一个构造函数，用于初始化新创建的对象。JavaScript包含原生类型的内置构造函数。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span> <span class="c1">// Create an empty object: same as {}.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">();</span> <span class="c1">// Create an empty array: same as [].
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span> <span class="c1">// Create a Date object representing the current time
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">r</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">RegExp</span><span class="p">(</span><span class="s2">&#34;js&#34;</span><span class="p">);</span> <span class="c1">// Create a RegExp object for pattern matching.
</span></code></pre></div>

<h4 id="原型">原型</h4>

<p>每个JavaScript对象都有一个与之关联的原型对象。JavaScript对象从原型对象继承属性。</p>

<p>由对象字面值创建的所有对象都有相同的原型对象，这个原型对象是Object.prototype。使用new关键字和构造函数创建的对象的原型是构造函数的prototype属性。因此，new object()创建的对象继承自Object.prototype。new Array()创建的对象使用Array.prototype作为其原型，由new Date()创建的对象使用 Date.prototype作为原型。</p>

<p>Object.prototype是少有的没有原型的对象，它不继承任何属性。其他原型对象是有原型的普通对象。所有内置的构造函数（以及大多数用户定义的构造函数）都继承自Object.prototype。这一系列链接的原型对象被称为原型链。</p>

<h4 id="object-create">Object.create()</h4>

<p>ES5定义了一个方法Object.create()用于创建对象。第一个参数指定对象的原型。第二个参数可选，用于描述新对象的属性。Object.create()是一个静态函数，而不是方法：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o1</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span><span class="mi">2</span><span class="p">});</span> <span class="c1">// o1 inherits properties x and y.
</span></code></pre></div>

<p>您可以传递null来创建一个没有原型的新对象，该对象没有继承任何东西：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o2</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span> <span class="c1">// o2 inherits no props or methods.
</span></code></pre></div>

<p>如果您想创建一个普通的空对象（比如{}返回的对象或new object()），Object.prototype：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o3</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// o3 is like {} or new Object().
</span></code></pre></div>

<p>我们可以在ES3中用下面这个函数模拟它：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">// inherit() returns a newly created object that inherits properties from the
</span><span class="c1">// prototype object p. It uses the ECMAScript 5 function Object.create() if
</span><span class="c1">// it is defined, and otherwise falls back to an older technique.
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">inherit</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">p</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">TypeError</span><span class="p">();</span> <span class="c1">// p must be a non-null object
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">)</span> <span class="c1">// If Object.create() is defined...
</span><span class="c1"></span>        <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span> <span class="c1">// then just use it.
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">t</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">p</span><span class="p">;</span> <span class="c1">// Otherwise do some more type checking
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">t</span> <span class="o">!==</span> <span class="s2">&#34;object&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">t</span> <span class="o">!==</span> <span class="s2">&#34;function&#34;</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">TypeError</span><span class="p">();</span>
    <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{};</span> <span class="c1">// Define a dummy constructor function.
</span><span class="c1"></span>    <span class="nx">f</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">p</span><span class="p">;</span> <span class="c1">// Set its prototype property to p.
</span><span class="c1"></span>    <span class="k">return</span> <span class="k">new</span> <span class="nx">f</span><span class="p">();</span> <span class="c1">// Use f() to create an &#34;heir&#34; of p.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<p>inherit()函数的一种用法是当你想防止你无法控制的库函数无意修改对象时使用。不直接将对象传递给函数，而是传递一个继承对象。如果函数读取继承对象的属性，它将看到继承的值。如果它设置属性，这些属性只会影响继承对象，而不会影响原始对象：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span><span class="o">:</span> <span class="s2">&#34;don&#39;t change this value&#34;</span> <span class="p">};</span>
<span class="nx">library_function</span><span class="p">(</span><span class="nx">inherit</span><span class="p">(</span><span class="nx">o</span><span class="p">));</span> <span class="c1">// Guard against accidental modifications of o
</span></code></pre></div>

<h3 id="查询和设置属性">查询和设置属性</h3>

<p>使用.或[]获取属性。运算符左边是一个值为对象的表达式。如果使用点运算符，右边必须是一个表示属性名字的简单的标识符。如果使用方括号，方括号中的值必须是结果为字符串的表达式，该字符串包含所需的属性名：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">author</span> <span class="o">=</span> <span class="nx">book</span><span class="p">.</span><span class="nx">author</span><span class="p">;</span> <span class="c1">// Get the &#34;author&#34; property of the book.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">author</span><span class="p">.</span><span class="nx">surname</span> <span class="c1">// Get the &#34;surname&#34; property of the author.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">title</span> <span class="o">=</span> <span class="nx">book</span><span class="p">[</span><span class="s2">&#34;main title&#34;</span><span class="p">]</span> <span class="c1">// Get the &#34;main title&#34; property of the book.
</span></code></pre></div>

<p>要创建或设置属性，将.或[]表达式放在等号左边：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">book</span><span class="p">.</span><span class="nx">edition</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="c1">// Create an &#34;edition&#34; property of book.
</span><span class="c1"></span><span class="nx">book</span><span class="p">[</span><span class="s2">&#34;main title&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&#34;ECMAScript&#34;</span><span class="p">;</span> <span class="c1">// Set the &#34;main title&#34; property.
</span></code></pre></div>

<p>在ES3中，点操作符后面的标识符不能是保留字，ES5放宽了这个限制。</p>

<h4 id="继承">继承</h4>

<p>JavaScript对象有一组“自己的属性”，它们也从原型对象继承一组属性：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1">// o inherits object methods from Object.prototype
</span><span class="c1"></span><span class="nx">o</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// and has an own property x.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">inherit</span><span class="p">(</span><span class="nx">o</span><span class="p">);</span> <span class="c1">// p inherits properties from o and Object.prototype
</span><span class="c1"></span><span class="nx">p</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// and has an own property y.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">q</span> <span class="o">=</span> <span class="nx">inherit</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span> <span class="c1">// q inherits properties from p, o, and Object.prototype
</span><span class="c1"></span><span class="nx">q</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// and has an own property z.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span> <span class="c1">// toString is inherited from Object.prototype
</span><span class="c1"></span><span class="nx">q</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">q</span><span class="p">.</span><span class="nx">y</span> <span class="c1">// =&gt; 3: x and y are inherited from o and p
</span></code></pre></div>

<p>假设你给对象o的属性x赋值。如果o已经有了一个自己的属性x，那么赋值只会改变这个现有属性的值。否则赋值将在对象o上创建一个名为x的新属性。如果o之前继承了属性x，那么这个继承的属性现在被新创建的同名属性所隐藏。</p>

<p>属性赋值检查原型链以确定是否允许赋值。如果o继承一个名为x的只读属性，则不允许赋值。如果允许赋值，则总是在原对象中创建或设置一个属性，并且从不修改原型链。继承发生在查询属性时，而不是设置属性时，这是JavaScript的一个关键特性，因为它允许我们有选择地覆盖继承属性：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">unitcircle</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">r</span><span class="o">:</span><span class="mi">1</span> <span class="p">};</span> <span class="c1">// An object to inherit from
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">inherit</span><span class="p">(</span><span class="nx">unitcircle</span><span class="p">);</span> <span class="c1">// c inherits the property r
</span><span class="c1"></span><span class="nx">c</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// c defines two properties of its own
</span><span class="c1"></span><span class="nx">c</span><span class="p">.</span><span class="nx">r</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// c overrides its inherited property
</span><span class="c1"></span><span class="nx">unitcircle</span><span class="p">.</span><span class="nx">r</span><span class="p">;</span> <span class="c1">// =&gt; 1: the prototype object is not affected
</span></code></pre></div>

<p>如果o继承了一个带有setter方法的访问属性x，则调用该setter方法，而不是在o中创建新的属性x。但是setter方法是在对象o上调用的，因此如果setter方法定义了任何属性，都作用于o上，不会修改原型链。</p>

<h4 id="属性访问错误">属性访问错误</h4>

<p>查询不存在的属性不是错误。如果属性x不是o的自有属性或继承属性，则o.x值为undefined。null和undefined没有属性，查询或者设置它们的属性抛出TypeError。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">// A verbose and explicit technique
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">len</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">book</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">book</span><span class="p">.</span><span class="nx">subtitle</span><span class="p">)</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">book</span><span class="p">.</span><span class="nx">subtitle</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// A concise and idiomatic alternative to get subtitle length or undefined
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">book</span> <span class="o">&amp;&amp;</span> <span class="nx">book</span><span class="p">.</span><span class="nx">subtitle</span> <span class="o">&amp;&amp;</span> <span class="nx">book</span><span class="p">.</span><span class="nx">subtitle</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
</code></pre></div>

<p>设置属性不总是成功的：有些属性是只读的，不能设置，有些对象不允许添加新属性。这些操作通常是悄悄失败的：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">// The prototype properties of built-in constructors are read-only.
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Assignment fails silently; Object.prototype unchanged
</span></code></pre></div>

<p>在ES5严格模式下，任何设置属性失败都会抛出TypeError。设置对象o的属性p在以下情况失败：</p>

<ul>
<li>o有一个只读属性p，不能设置只读属性。</li>
<li>o有只读的继承属性p，不能使用同名的属性隐藏继承的只读属性。</li>
<li>o没有自有属性p，o也没有通过setter方法继承属性p，而且o的可扩展属性为false。</li>
</ul>

<h3 id="删除属性">删除属性</h3>

<p>delete从对象中删除属性，它的操作数是一个属性访问表达式。delete并不操作属性的值，而是操作属性本身：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">delete</span> <span class="nx">book</span><span class="p">.</span><span class="nx">author</span><span class="p">;</span> <span class="c1">// The book object now has no author property.
</span><span class="c1"></span><span class="k">delete</span> <span class="nx">book</span><span class="p">[</span><span class="s2">&#34;main title&#34;</span><span class="p">];</span> <span class="c1">// Now it doesn&#39;t have &#34;main title&#34;, either.
</span></code></pre></div>

<p>delete操作符只删除自己的属性，而不删除继承的属性。要删除继承的属性，必须从定义它的原型对象中删除它。这样做会影响从原型继承的每个对象。delete删除成功或删除没有效果时，返回true：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">o</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span><span class="mi">1</span><span class="p">};</span> <span class="c1">// o has own property x and inherits property toString
</span><span class="c1"></span><span class="k">delete</span> <span class="nx">o</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span> <span class="c1">// Delete x, and return true
</span><span class="c1"></span><span class="k">delete</span> <span class="nx">o</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span> <span class="c1">// Do nothing (x doesn&#39;t exist), and return true
</span><span class="c1"></span><span class="k">delete</span> <span class="nx">o</span><span class="p">.</span><span class="nx">toString</span><span class="p">;</span> <span class="c1">// Do nothing (toString isn&#39;t an own property), return true
</span><span class="c1"></span><span class="k">delete</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// Nonsense, but evaluates to true
</span></code></pre></div>

<p>delete不会删除不可配置的属性，但是它可以删除不可扩展对象的可配置属性。内置对象的某些属性是不可配置的，通过变量声明和函数声明创建的全局对象的属性也是不可配置的。在严格模式下，删除不可配置属性会导致TypeError。在非严格模式下，delete返回false：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">delete</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span> <span class="c1">// Can&#39;t delete; property is non-configurable
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// Declare a global variable
</span><span class="c1"></span><span class="k">delete</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span> <span class="c1">// Can&#39;t delete this property
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// Declare a global function
</span><span class="c1"></span><span class="k">delete</span> <span class="k">this</span><span class="p">.</span><span class="nx">f</span><span class="p">;</span> <span class="c1">// Can&#39;t delete this property either
</span></code></pre></div>

<p>在非严格模式下删除全局对象的可配置属性时，可以省略this：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// Create a configurable global property (no var)
</span><span class="c1"></span><span class="k">delete</span> <span class="nx">x</span><span class="p">;</span> <span class="c1">// And delete it
</span></code></pre></div>

<p>在严格模式下，如果delete的操作数是一个非限定的标识符，那么就会引发SyntaxError：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">delete</span> <span class="nx">x</span><span class="p">;</span> <span class="c1">// SyntaxError in strict mode
</span><span class="c1"></span><span class="k">delete</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span> <span class="c1">// This works
</span></code></pre></div>

<h3 id="测试属性">测试属性</h3>

<p>in操作符左边是一个属性名，右边是一个对象。如果对象这个名字的自有属性或继承的属性，则返回true：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span><span class="o">:</span> <span class="mi">1</span> <span class="p">}</span>
<span class="s2">&#34;x&#34;</span> <span class="k">in</span> <span class="nx">o</span><span class="p">;</span> <span class="c1">// true: o has an own property &#34;x&#34;
</span><span class="c1"></span><span class="s2">&#34;y&#34;</span> <span class="k">in</span> <span class="nx">o</span><span class="p">;</span> <span class="c1">// false: o doesn&#39;t have a property &#34;y&#34;
</span><span class="c1"></span><span class="s2">&#34;toString&#34;</span> <span class="k">in</span> <span class="nx">o</span><span class="p">;</span> <span class="c1">// true: o inherits a toString property
</span></code></pre></div>

<p>对象的hasOwnProperty()方法测试该对象是否具有具有给定名称的自己的属性。对于继承的属性，返回false：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript">
</code></pre></div>

<p>propertyIsEnumerable()只有当指定的属性是自己的属性且是可枚举的时，它才返回true：</p>

<p><div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="nx">inherit</span><span class="p">({</span><span class="nx">y</span><span class="o">:</span> <span class="mi">2</span><span class="p">});</span>
<span class="nx">o</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">o</span><span class="p">.</span><span class="nx">propertyIsEnumerable</span><span class="p">(</span><span class="s2">&#34;x&#34;</span><span class="p">);</span> <span class="c1">// true: o has an own enumerable property x
</span><span class="c1"></span><span class="nx">o</span><span class="p">.</span><span class="nx">propertyIsEnumerable</span><span class="p">(</span><span class="s2">&#34;y&#34;</span><span class="p">);</span> <span class="c1">// false: y is inherited, not own
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">propertyIsEnumerable</span><span class="p">(</span><span class="s2">&#34;toString&#34;</span><span class="p">);</span> <span class="c1">// false: not enumerable
</span></code></pre></div>
通常查询属性只需简单使用!==来确保它不是undefined：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span><span class="o">:</span> <span class="mi">1</span> <span class="p">}</span>
<span class="nx">o</span><span class="p">.</span><span class="nx">x</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span> <span class="c1">// true: o has a property x
</span><span class="c1"></span>
<span class="nx">o</span><span class="p">.</span><span class="nx">y</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span> <span class="c1">// false: o doesn&#39;t have a property y
</span><span class="c1"></span><span class="nx">o</span><span class="p">.</span><span class="nx">toString</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span> <span class="c1">// true: o inherits a toString property
</span></code></pre></div>

<p>有一件事是in操作符可以做的，而上面所示的简单属性访问技术做不到的。in可以区分不存在的属性和设置为undefined 的属性：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span><span class="o">:</span> <span class="kc">undefined</span> <span class="p">}</span> <span class="c1">// Property is explicitly set to undefined
</span><span class="c1"></span><span class="nx">o</span><span class="p">.</span><span class="nx">x</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="c1">// false: property exists but is undefined
</span><span class="c1"></span><span class="nx">o</span><span class="p">.</span><span class="nx">y</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="c1">// false: property doesn&#39;t even exist
</span><span class="c1"></span><span class="s2">&#34;x&#34;</span> <span class="k">in</span> <span class="nx">o</span> <span class="c1">// true: the property exists
</span><span class="c1"></span><span class="s2">&#34;y&#34;</span> <span class="k">in</span> <span class="nx">o</span> <span class="c1">// false: the property doesn&#39;t exists
</span><span class="c1"></span><span class="k">delete</span> <span class="nx">o</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span> <span class="c1">// Delete the property x
</span><span class="c1"></span><span class="s2">&#34;x&#34;</span> <span class="k">in</span> <span class="nx">o</span> <span class="c1">// false: it doesn&#39;t exist anymore
</span></code></pre></div>

<h3 id="枚举属性">枚举属性</h3>

<p>通常使用for/in循环来枚举属性。对象继承来的内置方法是不可枚举的，但是自己代码添加的属性是可枚举的：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span><span class="mi">2</span><span class="p">,</span> <span class="nx">z</span><span class="o">:</span><span class="mi">3</span><span class="p">};</span> <span class="c1">// Three enumerable own properties
</span><span class="c1"></span><span class="nx">o</span><span class="p">.</span><span class="nx">propertyIsEnumerable</span><span class="p">(</span><span class="s2">&#34;toString&#34;</span><span class="p">)</span> <span class="c1">// =&gt; false: not enumerable
</span><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="nx">p</span> <span class="k">in</span> <span class="nx">o</span><span class="p">)</span> <span class="c1">// Loop through the properties
</span><span class="c1"></span>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span> <span class="c1">// Prints x, y, and z, but not toString
</span></code></pre></div>

<p>一些库向会添加新方法或属性到Object.prototype，以便所有对象可以继承和使用用。在ES5之前，没有办法使这些属性不可枚举，因此for/in循环可以枚举它们。为了防止这种情况发生，您可能需要过滤for/in返回的属性：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">for</span><span class="p">(</span><span class="nx">p</span> <span class="k">in</span> <span class="nx">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">o</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">p</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span> <span class="c1">// Skip inherited properties
</span><span class="c1"></span><span class="p">}</span>

<span class="k">for</span><span class="p">(</span><span class="nx">p</span> <span class="k">in</span> <span class="nx">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">o</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="o">===</span> <span class="s2">&#34;function&#34;</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span> <span class="c1">// Skip methods
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<p>下面定义了几个实用函数：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="cm">/*
</span><span class="cm">* Copy the enumerable properties of p to o, and return o.
</span><span class="cm">* If o and p have a property by the same name, o&#39;s property is overwritten.
</span><span class="cm">* This function does not handle getters and setters or copy attributes.
</span><span class="cm">*/</span>
<span class="kd">function</span> <span class="nx">extend</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="nx">prop</span> <span class="k">in</span> <span class="nx">p</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// For all props in p.
</span><span class="c1"></span>        <span class="nx">o</span><span class="p">[</span><span class="nx">prop</span><span class="p">]</span> <span class="o">=</span> <span class="nx">p</span><span class="p">[</span><span class="nx">prop</span><span class="p">];</span> <span class="c1">// Add the property to o.
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">o</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
</span><span class="cm">* Copy the enumerable properties of p to o, and return o.
</span><span class="cm">* If o and p have a property by the same name, o&#39;s property is left alone.
</span><span class="cm">* This function does not handle getters and setters or copy attributes.
</span><span class="cm">*/</span>
<span class="kd">function</span> <span class="nx">merge</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="nx">prop</span> <span class="k">in</span> <span class="nx">p</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// For all props in p.
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">[</span><span class="nx">prop</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span> <span class="c1">// Except those already in o.
</span><span class="c1"></span>        <span class="nx">o</span><span class="p">[</span><span class="nx">prop</span><span class="p">]</span> <span class="o">=</span> <span class="nx">p</span><span class="p">[</span><span class="nx">prop</span><span class="p">];</span> <span class="c1">// Add the property to o.
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">o</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
</span><span class="cm">* Remove properties from o if there is not a property with the same name in p.
</span><span class="cm">* Return o.
</span><span class="cm">*/</span>
<span class="kd">function</span> <span class="nx">restrict</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="nx">prop</span> <span class="k">in</span> <span class="nx">o</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// For all props in o
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">prop</span> <span class="k">in</span> <span class="nx">p</span><span class="p">))</span> <span class="k">delete</span> <span class="nx">o</span><span class="p">[</span><span class="nx">prop</span><span class="p">];</span> <span class="c1">// Delete if not in p
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">o</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
</span><span class="cm">* For each property of p, delete the property with the same name from o.
</span><span class="cm">* Return o.
</span><span class="cm">*/</span>
<span class="kd">function</span> <span class="nx">subtract</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="nx">prop</span> <span class="k">in</span> <span class="nx">p</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// For all props in p
</span><span class="c1"></span>        <span class="k">delete</span> <span class="nx">o</span><span class="p">[</span><span class="nx">prop</span><span class="p">];</span> <span class="c1">// Delete from o (deleting a nonexistent prop is harmless)
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">o</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
</span><span class="cm">* Return a new object that holds the properties of both o and p.
</span><span class="cm">* If o and p have properties by the same name, the values from o are used.
</span><span class="cm">*/</span>
<span class="kd">function</span> <span class="nx">union</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">extend</span><span class="p">(</span><span class="nx">extend</span><span class="p">({},</span><span class="nx">o</span><span class="p">),</span> <span class="nx">p</span><span class="p">);</span> <span class="p">}</span>

<span class="cm">/*
</span><span class="cm">* Return a new object that holds only the properties of o that also appear
</span><span class="cm">* in p. This is something like the intersection of o and p, but the values of
</span><span class="cm">* the properties in p are discarded
</span><span class="cm">*/</span>
<span class="kd">function</span> <span class="nx">intersection</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">restrict</span><span class="p">(</span><span class="nx">extend</span><span class="p">({},</span> <span class="nx">o</span><span class="p">),</span> <span class="nx">p</span><span class="p">);</span> <span class="p">}</span>

<span class="cm">/*
</span><span class="cm">* Return an array that holds the names of the enumerable own properties of o.
</span><span class="cm">*/</span>
<span class="kd">function</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">o</span> <span class="o">!==</span> <span class="s2">&#34;object&#34;</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">TypeError</span><span class="p">();</span> <span class="c1">// Object argument required
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// The array we will return
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">prop</span> <span class="k">in</span> <span class="nx">o</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// For all enumerable properties
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">prop</span><span class="p">))</span> <span class="c1">// If it is an own property
</span><span class="c1"></span>            <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">prop</span><span class="p">);</span> <span class="c1">// add it to the array.
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span> <span class="c1">// Return the array.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<p>ES5定义了两个新函数来枚举属性名。第一个是Object.keys()，它返回一个对象的可枚举属性名数组。第二个是Object.getOwnPropertyNames()，它返回指定对象的所有自身属性名。</p>

<h3 id="属性getter和setter">属性getter和setter</h3>

<p>在ES5中，对象值可以被getter和setter方法替换。getter和setter定义的属性有时称为访问器属性，以区分数据属性。</p>

<p>当查询访问器属性时，JavaScript调用getter方法，返回值即属性值。当设置访问器属性时，JavaScript调用setter方法，传递赋值右侧的值，setter方法的返回值被忽略。</p>

<p>访问器属性不像数据属性那样具有可写属性。如果属性同时具有getter和setter方法，那么它就是可读/可写属性。如果它只有getter方法，它就是只读属性。如果它只有一个setter方法，那么它就是一个只写的属性，这对于数据属性不可能实现的，并且读取它总是返回undefined。</p>

<p>定义访问器属性的最简单方法是使用对象字面值语法：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">// An ordinary data property
</span><span class="c1"></span>    <span class="nx">data_prop</span><span class="o">:</span> <span class="nx">value</span><span class="p">,</span>
    <span class="c1">// An accessor property defined as a pair of functions
</span><span class="c1"></span>    <span class="nx">get</span> <span class="nx">accessor_prop</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* function body here */</span> <span class="p">},</span>
    <span class="nx">set</span> <span class="nx">accessor_prop</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* function body here */</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<p>访问器属性定义为一个或两个名称与属性名称相同的函数，并将function替换为get或set。没有使用冒号将属性的名称与访问该属性的函数分隔开，但是在函数体之后仍然需要使用逗号与下一个方法或数据属性分隔开。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">// x and y are regular read-write data properties.
</span><span class="c1"></span>    <span class="nx">x</span><span class="o">:</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="nx">y</span><span class="o">:</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="c1">// r is a read-write accessor property with getter and setter.
</span><span class="c1"></span>    <span class="c1">// Don&#39;t forget to put a comma after accessor methods.
</span><span class="c1"></span>    <span class="nx">get</span> <span class="nx">r</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sqrt</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="p">);</span> <span class="p">},</span>
    <span class="nx">set</span> <span class="nx">r</span><span class="p">(</span><span class="nx">newvalue</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">oldvalue</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sqrt</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="p">);</span>
        <span class="kd">var</span> <span class="nx">ratio</span> <span class="o">=</span> <span class="nx">newvalue</span><span class="o">/</span><span class="nx">oldvalue</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">*=</span> <span class="nx">ratio</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">*=</span> <span class="nx">ratio</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="c1">// theta is a read-only accessor property with getter only.
</span><span class="c1"></span>    <span class="nx">get</span> <span class="nx">theta</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">atan2</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<p>JavaScript将getter和setter函数作为定义它们的对象的方法，这意味着这些函数可以引用对象的属性。访问器属性是可以继承的，就像数据属性一样：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">q</span> <span class="o">=</span> <span class="nx">inherit</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span> <span class="c1">// Create a new object that inherits getters and setters
</span><span class="c1"></span><span class="nx">q</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Create q&#39;s own data properties
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">r</span><span class="p">);</span> <span class="c1">// And use the inherited accessor properties
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">theta</span><span class="p">);</span>
</code></pre></div>

<p>使用访问器属性的另一个原因是对属性写入进行完整性检查，并且可以在读取的属性返回不同的值：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">// This object generates strictly increasing serial numbers
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">serialnum</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">// This data property holds the next serial number.
</span><span class="c1"></span>    <span class="c1">// The $ in the property name hints that it is a private property.
</span><span class="c1"></span>    <span class="nx">$n</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="c1">// Return the current value and increment it
</span><span class="c1"></span>    <span class="nx">get</span> <span class="nx">next</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">$n</span><span class="o">++</span><span class="p">;</span> <span class="p">},</span>
    <span class="c1">// Set a new value of n, but only if it is larger than current
</span><span class="c1"></span>    <span class="nx">set</span> <span class="nx">next</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">&gt;=</span> <span class="k">this</span><span class="p">.</span><span class="nx">$n</span><span class="p">)</span> <span class="k">this</span><span class="p">.</span><span class="nx">$n</span> <span class="o">=</span> <span class="nx">n</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">throw</span> <span class="s2">&#34;serial number can only be set to a larger value&#34;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<p>最后，这里还有一个使用getter方法实现具有“神奇”行为的属性的示例：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">// This object has accessor properties that return random numbers.
</span><span class="c1">// The expression &#34;random.octet&#34;, for example, yields a random number
</span><span class="c1">// between 0 and 255 each time it is evaluated.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">random</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">get</span> <span class="nx">octet</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">256</span><span class="p">);</span> <span class="p">},</span>
    <span class="nx">get</span> <span class="nx">uint16</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">65536</span><span class="p">);</span> <span class="p">},</span>
    <span class="nx">get</span> <span class="nx">int16</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span><span class="o">*</span><span class="mi">65536</span><span class="p">)</span><span class="o">-</span><span class="mi">32768</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="属性的属性">属性的属性</h3>

<p>数据属性的四个属性是值、可写、可枚举和可配置。访问器属性没有值属性和可写属性，它们是否可写取决于setter存在与否。因此访问器属性的四个属性是get、set、枚举和可配置。</p>

<p>ES5查询和设置属性的方法使用一个称为属性描述符的对象来表示四个属性的集合。使用Object.getOwnPropertyDescriptor()获得指定对象的属性描述符：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">// Returns {value: 1, writable:true, enumerable:true, configurable:true}
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span><span class="mi">1</span><span class="p">},</span> <span class="s2">&#34;x&#34;</span><span class="p">);</span>
<span class="c1">// Now query the octet property of the random object defined above.
</span><span class="c1">// Returns { get: /func/, set:undefined, enumerable:true, configurable:true}
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">random</span><span class="p">,</span> <span class="s2">&#34;octet&#34;</span><span class="p">);</span>
<span class="c1">// Returns undefined for inherited properties and properties that don&#39;t exist.
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">({},</span> <span class="s2">&#34;x&#34;</span><span class="p">);</span> <span class="c1">// undefined, no such prop
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">({},</span> <span class="s2">&#34;toString&#34;</span><span class="p">);</span> <span class="c1">// undefined, inherited
</span></code></pre></div>

<p>getownpropertydescriptor()只适用于自己的属性。要查询继承属性的属性，必须显式地遍历原型链。</p>

<p>object.defineproperty()用于设置指定对象属性：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{};</span> <span class="c1">// Start with no properties at all
</span><span class="c1">// Add a nonenumerable data property x with value 1.
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="s2">&#34;x&#34;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">value</span> <span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="nx">writable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
    <span class="nx">configurable</span><span class="o">:</span> <span class="kc">true</span><span class="p">});</span>
<span class="c1">// Check that the property is there but is nonenumerable
</span><span class="c1"></span><span class="nx">o</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span> <span class="c1">// =&gt; 1
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="c1">// =&gt; []
</span><span class="c1">// Now modify the property x so that it is read-only
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="s2">&#34;x&#34;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">writable</span><span class="o">:</span> <span class="kc">false</span> <span class="p">});</span>
<span class="c1">// Try to change the value of the property
</span><span class="c1"></span><span class="nx">o</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// Fails silently or throws TypeError in strict mode
</span><span class="c1"></span><span class="nx">o</span><span class="p">.</span><span class="nx">x</span> <span class="c1">// =&gt; 1
</span><span class="c1">// The property is still configurable, so we can change its value like this:
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="s2">&#34;x&#34;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="mi">2</span> <span class="p">});</span>
<span class="nx">o</span><span class="p">.</span><span class="nx">x</span> <span class="c1">// =&gt; 2
</span><span class="c1">// Now change x from a data property to an accessor property
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="s2">&#34;x&#34;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span> <span class="p">});</span>
<span class="nx">o</span><span class="p">.</span><span class="nx">x</span> <span class="c1">// =&gt; 0
</span></code></pre></div>

<p>传递给Object.defineProperty()的属性描述符不需要包含所有四个属性。如果创建一个新属性，那么省略的属性值被设为false或undefined。如果修改现有属性，则忽略的属性将保持不变。Object.defineProperty()只能用于创建或修改自有属性，不会修改继承的属性。</p>

<p>如果要创建或修改多个属性，使用Object.defineProperties()。第一个参数是要修改的对象，第二个参数是一个对象，它将要创建或修改的属性名映射到相应的属性描述符：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperties</span><span class="p">({},</span> <span class="p">{</span>
    <span class="nx">x</span><span class="o">:</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">writable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">enumerable</span><span class="o">:</span><span class="kc">true</span><span class="p">,</span> <span class="nx">configurable</span><span class="o">:</span><span class="kc">true</span> <span class="p">},</span>
    <span class="nx">y</span><span class="o">:</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">writable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">enumerable</span><span class="o">:</span><span class="kc">true</span><span class="p">,</span> <span class="nx">configurable</span><span class="o">:</span><span class="kc">true</span> <span class="p">},</span>
    <span class="nx">r</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sqrt</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">xthis</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">ythis</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="p">},</span>
        <span class="nx">enumerable</span><span class="o">:</span><span class="kc">true</span><span class="p">,</span>
        <span class="nx">configurable</span><span class="o">:</span><span class="kc">true</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></div>

<p>Object.create方法的第一个参数是新创建对象的原型对象，它的第二个可选参数是与Object.defineProperties()的第二个参数相同的对象。如果您将一组属性描述符传递给object.create()，那么它们将用于向新创建的对象添加属性。</p>

<p>当不允许创建或修改属性时，Object.defineProperty()和Object.defineProperties()会抛出TypeError：</p>

<ul>
<li>如果对象不可扩展，可以编辑现有的属性，但不能向其添加新属性。</li>
<li>如果属性不可配置，则无法更改其可配置或可枚举属性。</li>
<li>如果访问器属性不可配置，则不能更改其getter或setter方法，也不能将其更改为数据属性。</li>
<li>如果数据属性不可配置，则不能将其更改为访问器属性。</li>
<li>如果数据属性不可配置，则不能将其可写属性从false更改为true，但可以将其从true更改为false。</li>
<li>如果数据属性不可配置且不可写入，则无法更改其值。但是您可以更改可配置但不可写入的属性的值。</li>
</ul>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="cm">/*
</span><span class="cm">* Add a nonenumerable extend() method to Object.prototype.
</span><span class="cm">* This method extends the object on which it is called by copying properties
</span><span class="cm">* from the object passed as its argument. All property attributes are
</span><span class="cm">* copied, not just the property value. All own properties (even non-
</span><span class="cm">* enumerable ones) of the argument object are copied unless a property
</span><span class="cm">* with the same name already exists in the target object.
</span><span class="cm">*/</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s2">&#34;extend&#34;</span><span class="p">,</span> <span class="c1">// Define Object.prototype.extend
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="nx">writable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span> <span class="c1">// Make it nonenumerable
</span><span class="c1"></span>        <span class="nx">configurable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="nx">value</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Its value is this function
</span><span class="c1"></span>            <span class="c1">// Get all own props, even nonenumerable ones
</span><span class="c1"></span>            <span class="kd">var</span> <span class="nx">names</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span><span class="p">(</span><span class="nx">o</span><span class="p">);</span>
            <span class="c1">// Loop through them
</span><span class="c1"></span>            <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">names</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Skip props already in this object
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="nx">names</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="k">in</span> <span class="k">this</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
                <span class="c1">// Get property description from o
</span><span class="c1"></span>                <span class="kd">var</span> <span class="nx">desc</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span><span class="nx">names</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
                <span class="c1">// Use it to create property on this
</span><span class="c1"></span>                <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">names</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">desc</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">});</span>
</code></pre></div>

<h4 id="getter和setter的遗留api">getter和setter的遗留API</h4>

<p><code>__lookupGetter__()</code>和<code>__lookupSetter__()</code>返回指定属性的getter或setter方法。<code>__defineGetter__()</code>和<code>__defineSetter__()</code>定义getter或setter方法，先传递属性名，然后传递getter或setter方法。这些方法是非标准方法。</p>

<h3 id="对象属性">对象属性</h3>

<p>每个对象都有相关的原型、类和可扩展属性。</p>

<h4 id="原型属性">原型属性</h4>

<p>对象的原型属性指定它从哪个对象继承属性。原型属性是在创建对象时设置的。用new创建的对象使用其构造函数的原型属性的值作为原型。使用Object.create()创建的对象使用该函数的第一个参数（可能为空）作为原型。</p>

<p>在ES5中，可以使用Object.getPrototypeOf()来查询任何对象的原型。ES3中没有等价的函数，但是通常可以使用o.constructor.prototype来确定对象o的原型。</p>

<p>要确定一个对象是另一个对象的原型或其原型链的一部分，使用isPrototypeOf()方法：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span><span class="mi">1</span><span class="p">};</span> <span class="c1">// Define a prototype object.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span> <span class="c1">// Create an object with that prototype.
</span><span class="c1"></span><span class="nx">p</span><span class="p">.</span><span class="nx">isPrototypeOf</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="c1">// =&gt; true: o inherits from p
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">isPrototypeOf</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="c1">// =&gt; true: p inherits from Object.prototype
</span></code></pre></div>

<p>Mozilla的JavaScript实现通过特殊命名的<code>__proto__</code>属性公开了原型属性，您可以使用该属性直接查询或设置任何对象的原型。</p>

<h4 id="类属性">类属性</h4>

<p>对象的类属性是一个字符串，它提供关于对象类型的信息。ES3和ES5都没有提供任何方法来设置这个属性，并且只有一种间接的技术来查询它。默认的toString()方法返回这种形式的字符串：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="p">[</span><span class="nx">object</span> <span class="kr">class</span><span class="p">]</span>
</code></pre></div>

<p>因此要获得对象的类，可以在其上调用toString()方法，并通过返回的字符提取。棘手的是，许多对象继承了其他更有用的toString()方法，为了调用正确的toString()版本，我们必须使用Function.call()方法间接地这样做：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">classof</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">o</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="s2">&#34;Null&#34;</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">o</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="k">return</span> <span class="s2">&#34;Undefined&#34;</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">o</span><span class="p">).</span><span class="nx">slice</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>数组和Date等对象具有与构造函数名称一样的类属性。宿主对象通常也具有有意义的类属性。通过对象字面值或Object.create创建的对象类属性为&rdquo;Object&rdquo;。自己定义的构造函数，创建的任何对象类属性都是&rdquo;Object&rdquo;：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">classof</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span> <span class="c1">// =&gt; &#34;Null&#34;
</span><span class="c1"></span><span class="nx">classof</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// =&gt; &#34;Number&#34;
</span><span class="c1"></span><span class="nx">classof</span><span class="p">(</span><span class="s2">&#34;&#34;</span><span class="p">)</span> <span class="c1">// =&gt; &#34;String&#34;
</span><span class="c1"></span><span class="nx">classof</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="c1">// =&gt; &#34;Boolean&#34;
</span><span class="c1"></span><span class="nx">classof</span><span class="p">({})</span> <span class="c1">// =&gt; &#34;Object&#34;
</span><span class="c1"></span><span class="nx">classof</span><span class="p">([])</span> <span class="c1">// =&gt; &#34;Array&#34;
</span><span class="c1"></span><span class="nx">classof</span><span class="p">(</span><span class="sr">/./</span><span class="p">)</span> <span class="c1">// =&gt; &#34;Regexp&#34;
</span><span class="c1"></span><span class="nx">classof</span><span class="p">(</span><span class="k">new</span> <span class="nb">Date</span><span class="p">())</span> <span class="c1">// =&gt; &#34;Date&#34;
</span><span class="c1"></span><span class="nx">classof</span><span class="p">(</span><span class="nb">window</span><span class="p">)</span> <span class="c1">// =&gt; &#34;Window&#34; (a client-side host object)
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{};</span> <span class="c1">// Define a custom constructor
</span><span class="c1"></span><span class="nx">classof</span><span class="p">(</span><span class="k">new</span> <span class="nx">f</span><span class="p">());</span> <span class="c1">// =&gt; &#34;Object&#34;
</span></code></pre></div>

<h4 id="可扩展属性">可扩展属性</h4>

<p>对象的可扩展属性指定是否可以向对象添加新属性。所有内置和用户定义的对象都是隐式可扩展的，宿主对象的可扩展性是由实现定义的。但在ES5中，可以将它们被转换为不可扩展的。</p>

<p>ES5定义了查询和设置对象可扩展性的函数。Object.isExtensible()确定对象是否可扩展。Object.preventExtensions()使对象不可扩展，一旦使对象不可扩展，就无法使其再次可扩展。preventExtensions()只会影响对象本身的可扩展性，如果将新属性添加到不可扩展对象的原型中，该对象将继承这些新属性。</p>

<p>可扩展属性的目的是能够将对象“锁定”为已知状态，并防止外部篡改。可扩展对象属性通常与可配置和可写的属性属性一起使用，ES5定义了一些函数，可以很容易地设置这些属性。</p>

<p>Object.seal()除了使对象不可扩展之外，它还使该对象的所有属性都不可配置。这意味着不能向对象添加新属性，也不能删除或配置现有属性。但是仍然可以设置可写的现有属性。没有办法解封这个对象。可以使用Object.isSealed()来确定一个对象是否被密封。</p>

<p>Object.freeze()将对象锁得更紧。除了使对象不可扩展和其属性不可配置之外，它还使对象的所有数据属性都是只读的。（如果对象具有setter方法的访问器属性，这些属性不会受到影响）使用Object.isFrozen()来确定一个对象是否被冻结。</p>

<p>Object.seal() 和Object.freeze()只影响传递给它们的对象，对它们对原型对象没有影响。如果您想彻底锁定一个对象，您可能还需要密封或冻结原型链中的对象。</p>

<p>Object.preventExtensions() ，Object.seal() 和Object.freeze()都返回传递给它们的对象：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">// Create a sealed object with a frozen prototype and a nonenumerable property
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">seal</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span><span class="mi">1</span><span class="p">}),</span>
    <span class="p">{</span><span class="nx">y</span><span class="o">:</span> <span class="p">{</span><span class="nx">value</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">writable</span><span class="o">:</span> <span class="kc">true</span><span class="p">}}));</span>
</code></pre></div>

<h3 id="序列化对象">序列化对象</h3>

<p>ES5提供JSON.stringify()和JSON.parse()来序列化和反序列化JavaScript对象：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">o</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span><span class="p">{</span><span class="nx">z</span><span class="o">:</span><span class="p">[</span><span class="kc">false</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="s2">&#34;&#34;</span><span class="p">]}};</span> <span class="c1">// Define a test object
</span><span class="c1"></span><span class="nx">s</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">o</span><span class="p">);</span> <span class="c1">// s is &#39;{&#34;x&#34;:1,&#34;y&#34;:{&#34;z&#34;:[false,null,&#34;&#34;]}}&#39;
</span><span class="c1"></span><span class="nx">p</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="c1">// p is a deep copy of o
</span></code></pre></div>

<p>JSON语法是JavaScript语法的一个子集，它不能表示所有JavaScript值。对象、数组、字符串、有限数字、true、false和null可以序列化和还原。NaN、 Infinity和-Infinity序列化为null。日期对象被序列化为ISO格式的日期字符串，但是JSON.parse()将这些字符串保留为字符串形式。函数、RegExp和Error对象以及undefined无法序列化或恢复。JSON.stringify()只序列化对象的可枚举属性。如果一个属性值不能被序列化，则忽略这个属性。JSON.stringify()和JSON.parse()都接受可选的第二个参数，具体参考文档。</p>

<h3 id="对象方法">对象方法</h3>

<h4 id="tostring">toString()</h4>

<p>toString()方法返回一个字符串，该字符串以某种方式表示对象的值。当需要将对象转换为字符串时，JavaScript将调用对象的此方法。由于这个默认方法没有太多有用的信息，许多类都定义了自己的toString()版本。</p>

<h4 id="tolocalestring">toLocaleString()</h4>

<p>除了toString()方法外，对象都有一个toLocaleString()。此方法的目的是返回对象的本地化字符串表示。Object定义的默认toLocaleString()方法本身不做任何本地化，它只调用toString()。Date和Number类定义了toLocaleString()的定制版本，这些版本试图根据本地约定格式化数字、日期和时间。Array定义了一个toLocaleString()方法，它的工作原理与toString()类似，只是它通过调用数组元素的toLocaleString()方法。</p>

<h4 id="tojson">toJSON()</h4>

<p>Object.prototype没有定义toJSON()方法，但是JSON.stringify()方法寻找toJSON()序列化对象。如果该方法存在，则调用该方法，而不是序列化原始对象。</p>

<h4 id="valueof">valueOf()</h4>

<p>valueOf()方法与toString()方法非常相似，但是当JavaScript需要将对象转换为字符串以外的基本类型时调用它。默认的valueOf()方法没有什么有趣的地方，但是一些内置类定义了它们自己的valueOf()方法。</p>
]]></content>
		</item>
		
		<item>
			<title>语句</title>
			<link>https://gitop.cc/posts/statements/</link>
			<pubDate>Tue, 30 Oct 2018 21:16:04 +0800</pubDate>
			
			<guid>https://gitop.cc/posts/statements/</guid>
			<description>JavaScript语句以分号结束。表达式被计算以产生值，但是语句被执行以使某些事情发生。 表达式语句 JavaScript中最简单的语句是具有</description>
			<content type="html"><![CDATA[

<p>JavaScript语句以分号结束。表达式被计算以产生值，但是语句被执行以使某些事情发生。</p>

<h3 id="表达式语句">表达式语句</h3>

<p>JavaScript中最简单的语句是具有副作用的表达式，比如赋值语句、自增自减运算符、delete操作符和函数调用：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">greeting</span> <span class="o">=</span> <span class="s2">&#34;Hello &#34;</span> <span class="o">+</span> <span class="nx">name</span><span class="p">;</span>
<span class="nx">i</span> <span class="o">*=</span> <span class="mi">3</span><span class="p">;</span>
<span class="nx">counter</span><span class="o">++</span><span class="p">;</span>
<span class="k">delete</span> <span class="nx">o</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">close</span><span class="p">();</span>
</code></pre></div>

<h3 id="复合语句和空语句">复合语句和空语句</h3>

<p>复合语句是包含在大括号中的语句序列，可以用在任何需要单个语句的地方。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="p">{</span>
    <span class="nx">x</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="p">;</span>
    <span class="nx">cx</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">cos</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;cos(π) = &#34;</span> <span class="o">+</span> <span class="nx">cx</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>空语句是只包含一个分号的语句。语法上需要一个语句，但逻辑上不需要，这个时候就用空语句。当你有意使用空语句时，最好注释一下，使别人可以明白你的意图。</p>

<h3 id="声明语句">声明语句</h3>

<h4 id="var">var</h4>

<p>var语句声明一个或多个变量，语法如下：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">name_1</span> <span class="p">[</span> <span class="o">=</span> <span class="nx">value_1</span><span class="p">],[</span> <span class="p">,...,</span> <span class="nx">name_n</span> <span class="p">[</span><span class="o">=</span> <span class="nx">value_n</span><span class="p">]]</span>
</code></pre></div>

<p>多次声明同一个变量是允许的。</p>

<h4 id="function">function</h4>

<p>函数声明语句具有以下语法：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">funcname</span><span class="p">([</span><span class="nx">arg1</span> <span class="p">[,</span> <span class="nx">arg2</span> <span class="p">[...,</span> <span class="nx">argn</span><span class="p">]]])</span> <span class="p">{</span>
    <span class="nx">statements</span>
<span class="p">}</span>
</code></pre></div>

<p>函数声明语句可以出现在顶层JavaScript代码中，也可以嵌套在其他函数中。当嵌套时，函数声明只能出现在它们所嵌套的函数的顶层。也就是说，函数定义不会出现在if语句、while循环或任何其他语句中。</p>

<p>函数声明语句与函数定义表达式的不同之处在于它们包含一个函数名。这两种形式都创建了一个新的函数对象，但是函数声明语句也将函数名声明为变量并将函数对象赋值给它。与用var声明的变量一样，用函数定义语句定义的函数被隐式地“提升”到包含脚本或函数的顶部，这样它们在整个脚本或函数中都是可见的。对于var，只有变量声明被挂起——变量初始化代码保留在放置它的位置。然而，在使用函数声明语句时，函数名和函数体都会被提升：在运行任何其他代码之前，脚本中的所有函数或函数中的所有嵌套函数都会被声明。这意味着您可以在声明一个JavaScript函数之前调用它。</p>

<p>与var语句一样，函数声明语句创建的变量不能被删除。然而，这些变量不是只读的，它们的值可以被重写。</p>

<h3 id="条件语句">条件语句</h3>

<p>条件语句根据指定表达式的值执行或跳过其他语句。这些语句是代码的决策点，有时也称为“分支”。</p>

<h4 id="if">if</h4>

<p>if语句是基本的控制语句，允许JavaScript有条件地执行语句。它有两种形式，第一种是：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">if</span> <span class="p">(</span><span class="nx">expression</span><span class="p">)</span>
    <span class="nx">statement</span>
</code></pre></div>

<p>if语句的第二种形式引入了else子句，该子句在表达式为false时执行：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">if</span> <span class="p">(</span><span class="nx">expression</span><span class="p">)</span>
    <span class="nx">statement1</span>
<span class="k">else</span>
    <span class="nx">statement2</span>
</code></pre></div>

<p>else子句默认匹配最近的if语句。</p>

<h4 id="switch">switch</h4>

<p>语法如下：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">switch</span><span class="p">(</span><span class="nx">expression</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">statements</span>
<span class="p">}</span>
</code></pre></div>

<p>switch先计算表达式的值，然后查找和表达式值相等（使用===运算符）的case标签。如果找到一个，就执行case标记处的代码块。如果没有匹配的标签，则使用default标签。如果default标签，则完全跳过代码块。</p>

<p>break语句使解释器跳出switch语句继续执行后面的语句。switch语句的case子句只指定代码执行的起点，没有指定任何结束点。在没有break语句的情况下，switch语句在case标签处开始执行它的代码块，继续执行语句直到语句块的末尾。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">convert</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="s1">&#39;number&#39;</span><span class="o">:</span> <span class="c1">// Convert the number to a hexadecimal integer
</span><span class="c1"></span>            <span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
        <span class="k">case</span> <span class="s1">&#39;string&#39;</span><span class="o">:</span> <span class="c1">// Return the string enclosed in quotes
</span><span class="c1"></span>            <span class="k">return</span> <span class="s1">&#39;&#34;&#39;</span> <span class="o">+</span> <span class="nx">x</span> <span class="o">+</span> <span class="s1">&#39;&#34;&#39;</span><span class="p">;</span>
        <span class="k">default</span><span class="o">:</span> <span class="c1">// Convert any other type in the usual way
</span><span class="c1"></span>            <span class="k">return</span> <span class="nb">String</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>ECMAScript标准允许case后面是任意表达式。</p>

<h3 id="循环">循环</h3>

<p>JavaScript有四种循环语句：while、do/while、for和for/in。</p>

<h4 id="while">while</h4>

<p>语法如下：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">while</span> <span class="p">(</span><span class="nx">expression</span><span class="p">)</span>
    <span class="nx">statement</span>
</code></pre></div>

<h4 id="do-while">do/while</h4>

<p>语法如下：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">do</span>
    <span class="nx">statement</span>
<span class="k">while</span> <span class="p">(</span><span class="nx">expression</span><span class="p">);</span>
</code></pre></div>

<h4 id="for">for</h4>

<p>语法如下：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">for</span><span class="p">(</span><span class="nx">initialize</span><span class="p">;</span> <span class="nx">test</span><span class="p">;</span> <span class="nx">increment</span><span class="p">)</span>
    <span class="nx">statement</span>
</code></pre></div>

<p>在for循环中可以省略这三个表达式中的任何一个，但分号不能少。如果省略测试表达式，循环将永远重复。<code>for(;;)</code>相当于<code>while(true)</code>，都是无限循环。</p>

<h4 id="for-in">for/in</h4>

<p>语法如下：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">for</span> <span class="p">(</span><span class="nx">variable</span> <span class="k">in</span> <span class="nx">object</span><span class="p">)</span>
    <span class="nx">statement</span>
</code></pre></div>

<p>variable可以是任何结果为左值的表达式或声明单个变量的var语句。object是结果为对象的表达式。</p>

<p>JavaScript解释器首先计算object表达式。如果它的为null或undefined，解释器跳过循环并继续执行下一个语句。如果表达式的值为一个原始值，这个值被转换为其等效的包装器对象。然后解释器为对象的每个可枚举属性执行一次循环体。在每次迭代之前，解释器会将属性的名称赋给varaible。这意味着每次迭代它的值可能不同：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span><span class="mi">2</span><span class="p">,</span> <span class="nx">z</span><span class="o">:</span><span class="mi">3</span><span class="p">};</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[],</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="o">++</span><span class="p">]</span> <span class="k">in</span> <span class="nx">o</span><span class="p">)</span> <span class="cm">/* empty */</span><span class="p">;</span>
</code></pre></div>

<p>JavaScript数组只是一种特殊的对象，数组索引是可以用for/in循环枚举的对象属性。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="k">in</span> <span class="nx">a</span><span class="p">)</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
</code></pre></div>

<p>for/in循环不会枚举对象的所有属性，只有可枚举属性。用户定义的所有属性和方法都是可枚举的。用户定义继承的属性也是可枚举的。</p>

<p>如果在for/in循环的中删除了尚未枚举的属性，则该属性将不会被枚举。如果在循环中定义了新的属性，这些属性通常不会被枚举。</p>

<h5 id="属性枚举顺序">属性枚举顺序</h5>

<p>ECMAScript规范没有指定for/in循环枚举对象属性的顺序。然而所有主流浏览器厂商的JavaScript实现都按照定义对象的顺序枚举对象的属性，先枚举旧的属性。对象字面值的枚举顺序与属性出现在字面值中的顺序相同。</p>

<p>一下情况枚举顺序依跟JavaScript不同实现有关：</p>

<ul>
<li>对象继承可枚举属性</li>
<li>对象具有整数数组索引的属性</li>
<li>使用delete删除对象的现有属性</li>
<li>使用Object.defineProperty()或类似的方法来改变对象属性的属性</li>
</ul>

<p>通常继承的属性在对象的所有非继承的“自有”属性之后枚举，按照定义属性的顺序。如果一个对象继承了多个“原型”的属性，即它的“原型链”中有多个对象，那么在枚举下一个对象的属性之前，按照创建顺序枚举链中的每个原型对象的属性。</p>

<h3 id="跳转">跳转</h3>

<h4 id="语句标签">语句标签</h4>

<p>任何语句可以在前面加上标识符和冒号来标记：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">identifier</span><span class="o">:</span> <span class="nx">statement</span>
</code></pre></div>

<p>break和continue是唯一使用语句标签的JavaScript语句。</p>

<p>标签的命名空间与变量和函数的命名空间不同，因此语句标签可以和变量或函数名相同。语句标签只定义在它们所应用的语句中。语句标签本身也可以标记，这意味着任何语句都可能有多个标签。</p>

<h4 id="break">break</h4>

<p>单独使用的break语句导致循环或switch语句立即退出。JavaScript还允许break关键字后面跟着一个语句标签：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">break</span> <span class="nx">labelname</span><span class="p">;</span>
</code></pre></div>

<p>当与语句标签一起使用时，break跳转到指定标签语句的末尾。这种形式的break不需要用在循环或switch中，它可以跳出任何包围它的语句。break和标签名之间不允许有换行符。break语句不能跨越函数。</p>

<h4 id="continue">continue</h4>

<p>语法如下：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">continue</span><span class="p">;</span>
<span class="k">continue</span> <span class="nx">labelname</span><span class="p">;</span>
</code></pre></div>

<p>continue语句只能在循环体中使用。当执行continue语句时，当前迭代终止，下一个迭代开始。对于不同类型的循环，这意味着不同的东西：</p>

<ul>
<li>在while循环中，将再次测试循环条件。</li>
<li>在do/while循环中，跳过循环体的底部，并再次测试循环条件。</li>
<li>在for循环中，将计算递增表达式，并再次测试循环条件。</li>
<li>在for/In循环中，将下一个属性名赋给指定的变量。</li>
</ul>

<p>与break语句一样，continue语句的标记形式可以在嵌套循环中使用。同样，continue语句与其标签名之间不允许换行。</p>

<h4 id="return">return</h4>

<p>语法如下：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">return</span><span class="p">;</span>
<span class="k">return</span> <span class="nx">expression</span><span class="p">;</span>
</code></pre></div>

<p>return语句只能出现在函数体中，出现在其他任何地方都是语法错误。当执行return语句时，包含该语句的函数将表达式的值返回给调用者。在没有return语句的情况下，函数调用依次执行函数体中的每个语句，然后返回undefined。单独的return语句也返回undefined。return语句与表达式之间不允许换行。</p>

<h4 id="throw">throw</h4>

<p>语法如下：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">throw</span> <span class="nx">expression</span><span class="p">;</span>
</code></pre></div>

<p>expression可以是任何类型的值。</p>

<p>异常表示发生了某种异常情况或错误。抛出异常就是发出这样一个错误或异常信息的信号。捕获异常就是处理异常。在try/catch/finally语句中捕获异常。</p>

<p>当JavaScript解释器本身抛出一个错误时，使用Error类及其子类。Error对象有一个name属性，指定了错误的类型，以及一个message属性，用于保存传递给构造函数的字符串。</p>

<p>当抛出异常时，JavaScript解释器立即停止程序执行并跳到最近的异常处理代码。try/catch/finally语句的catch子句用于处理异常。如果抛出异常的代码块没有关联的catch子句，解释器将检查下一个包含代码块，看看它是否有关联的异常处理代码。这个过程一直继续，直到找到一个为止。异常在调用堆栈间向上传播。</p>

<h4 id="try-catch-finally">try/catch/finally</h4>

<p>语法如下：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">try</span> <span class="p">{</span>
    <span class="nx">code</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">handler</span>
<span class="p">}</span> <span class="k">finally</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">cleanup</span>
<span class="p">}</span>
</code></pre></div>

<p>catch和finally都是可选的，但是必须至少包含其中一个。finally中通常执行必要的清理工作，并保证会执行。</p>

<p>catch后面括号中的标识符类似于函数参数。当捕获异常时，与异常关联的错误对象被赋值给此参数。与普通变量不同，catch子句关联的标识符具有块作用域，它只在catch块中定义。</p>

<p>如果finally本身使用return、continue、break、throw语句，或者通过调用抛出异常的方法导致跳转，解释器将放弃正在发生的跳转并执行新的跳转。</p>

<h3 id="其他语句">其他语句</h3>

<h4 id="with">with</h4>

<p>with语句用于临时扩展范围链。语法如下:</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">with</span> <span class="p">(</span><span class="nx">object</span><span class="p">)</span>
    <span class="nx">statement</span>
</code></pre></div>

<p>该语句将对象添加到作用域链的前面，执行语句，然后将作用域链恢复到原来状态。</p>

<p>with语句在严格模式下是禁止的，在非严格模式下应该被认为是废弃的:尽可能避免使用它。使用with的JavaScript代码很难优化，并且可能比不使用with语句编写的等效代码运行得更慢。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">with</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">forms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
    <span class="nx">name</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="s2">&#34;&#34;</span><span class="p">;</span>
    <span class="nx">address</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="s2">&#34;&#34;</span><span class="p">;</span>
    <span class="nx">email</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="s2">&#34;&#34;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>作用域链仅在查找标识符时使用，不能用于创建新标识符：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">with</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div>

<p>如果对象o具有属性x，那么该代码将1赋给该属性。但是如果x没有在o中定义，那么这段代码与没有with语句的<code>x = 1</code>是一样的。</p>

<h4 id="debugger">debugger</h4>

<p>debugger语句通常什么也不做。这条语句就像一个断点，JavaScript代码的执行停止，您可以使用调试器打印变量的值，检查调用堆栈等等。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">o</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="kr">debugger</span><span class="p">;</span> <span class="c1">// Temporary line for debugging purposes
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<p>现在，当没有参数调用f()时，执行将停止，您可以使用调试器检查调用堆栈，并找出这个错误调用来自哪里。</p>

<h4 id="use-strict">“use strict”</h4>

<p>&ldquo;use strict&rdquo;是ES5中引入的一个指令。&rdquo;use strict&rdquo;指令与常规语句有两个重要区别：</p>

<ul>
<li>它不包含任何语言关键字：这个指令只是一个表达式语句，由一个特殊的字符串字面值组成。没有实现ES5的JavaScript解释器只会看到一个没有副作用的表达式语句，什么也不做。未来版本的ECMAScript标准将引入use作为一个真正的关键字，并允许去掉引号。</li>
<li>它只能出现在脚本的开头或函数体的开头，在任何实际语句出现之前。&rdquo;use strict&rdquo;指令前面或后面可以有其他字符串字面值语句，JavaScript实现允许将这些字符串字面值解释为各个实现自定义的指令。正常语句之后的字符串字面值语句只是普通的表达式语句，不会产生任何效果。</li>
</ul>

<p>&ldquo;use strict&rdquo;指令的目的是指出后面的代码是严格的代码。严格的代码在严格模式下执行。ES5的严格模式是语言的一个受限子集，它修复了一些重要的语言缺陷，并提供了更强的错误检查和增强的安全性。严格模式和非严格模式的区别如下：</p>

<ul>
<li><p>在严格模式下不允许使用with语句。</p></li>

<li><p>在严格模式下，必须声明所有变量。向未声明的标识符赋值，抛出ReferenceError。在非严格模式下，通过向全局对象添加新属性隐式地声明一个全局变量。</p></li>

<li><p>在严格模式下，作为函调用的函数的this值为undefined。在非严格模式下，this值为全局对象。这个差异可以用来确定一个实现是否支持严格模式：</p></li>
</ul>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript">  <span class="kd">var</span> <span class="nx">hasStrictMode</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="s2">&#34;use strict&#34;</span><span class="p">;</span> <span class="k">return</span> <span class="k">this</span><span class="o">===</span><span class="kc">undefined</span> <span class="p">}());</span>
  
</code></pre></div>

<ul>
<li><p>在严格模式下，当使用call()或apply()调用函数时，this值是传递给call()或apply()的第一个参数。在非严格模式下，null和undefined的值被替换为全局对象，非对象值被转换为对象。</p></li>

<li><p>在严格模式下，对不可写属性的赋值和在不可扩展对象上创建新属性会抛出TypeError。在非严格模式下，悄悄失败。</p></li>

<li><p>在严格模式下，eval()不能在包围它的作用域里面声明函数或变量。函数或变量的声明在eva()自己的作用域。在非严格模式下，eval()可以在调用者范围内声明变量或定义函数。</p></li>

<li><p>在严格模式下，delete一个非限定标识符（例如变量、函数或函数参数），会抛出SyntaxError。在非严格模式下，这样的delete什么也不做，结果为false。</p></li>

<li><p>在严格模式下，删除不可配置属性会抛出TypeError。在非严格模式下，delete返回false。</p></li>

<li><p>在严格模式下，对象不能定义两个或多个相同名称的属性。在非严格模式下，不会发生错误。</p></li>

<li><p>在严格模式下，函数声明不能有两个或多个相同名称的参数。在非严格模式下，不会发生错误。</p></li>

<li><p>在严格模式下，不允许使用八进制整数。在非严格模式下，某些实现允许八进制数字。</p></li>

<li><p>在严格模式下，标识符eval和arguments被视为关键字，不允许更改它们的值。</p></li>

<li><p>在严格模式下，检查调用堆栈的能力受到限制。arguments.caller和arguments.callee都抛出TypeError。读取caller和arguments的属性也抛出TypeError。</p></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>表达式和操作符</title>
			<link>https://gitop.cc/posts/expressions_and_operators/</link>
			<pubDate>Sun, 28 Oct 2018 21:07:21 +0800</pubDate>
			
			<guid>https://gitop.cc/posts/expressions_and_operators/</guid>
			<description>表达式是JavaScript的一个短语，JavaScript解释器可以对其进行求值。 主表达式 最简单的表达式，称为主表达式，是那些独立的表达式</description>
			<content type="html"><![CDATA[

<p>表达式是JavaScript的一个短语，JavaScript解释器可以对其进行求值。</p>

<h3 id="主表达式">主表达式</h3>

<p>最简单的表达式，称为主表达式，是那些独立的表达式——它们不包含任何简单的表达式。JavaScript中的主要表达式是常量或文字值、特定语言关键字和变量引用。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kc">true</span> <span class="c1">// Evalutes to the boolean true value
</span><span class="c1"></span><span class="kc">false</span> <span class="c1">// Evaluates to the boolean false value
</span><span class="c1"></span><span class="kc">null</span> <span class="c1">// Evaluates to the null value
</span><span class="c1"></span><span class="k">this</span> <span class="c1">// Evaluates to the &#34;current&#34; object
</span><span class="c1"></span><span class="nx">i</span> <span class="c1">// Evaluates to the value of the variable i.
</span><span class="c1"></span><span class="nx">sum</span> <span class="c1">// Evaluates to the value of the variable sum.
</span><span class="c1"></span><span class="kc">undefined</span> <span class="c1">// undefined is a global variable, not a keyword like null.
</span></code></pre></div>

<p>当任何标识符单独出现在程序中时，JavaScript假设它是一个变量，并查找它的值。如果不存在具有该名称的变量，则表达式计算为未定义的值。然而，在ES5的严格模式中，计算不存在的变量会抛出一个ReferenceError。</p>

<h3 id="对象和数组初始化式">对象和数组初始化式</h3>

<p>数组初始化式是方括号中包含的以逗号分隔的表达式列表。数组初始化式的值是一个新创建的数组。这个新数组的元素被初始化为逗号分隔表达式的值：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="p">[]</span> <span class="c1">// An empty array: no expressions inside brackets means no elements
</span><span class="c1"></span><span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span> <span class="c1">// A 2-element array. First element is 3, second is 7
</span></code></pre></div>

<p>每次计算数组初始化式时，其中的元素表达式都会被计算。这意味着数组初始化式的值在每次求值时可能不同。通过在逗号之间省略值，可以将未定义的元素包含在数组字面值中：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">sparseArray</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,,,,</span><span class="mi">5</span><span class="p">];</span>
</code></pre></div>

<p>在数组初始化式最后一个表达式后面允许有一个逗号，并且不会创建未定义的元素。</p>

<p>对象初始化表达式类似于数组初始化表达式，但是方括号被大括号替换，并且每个子表达式的前缀都有一个属性名和一个冒号：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span><span class="o">:</span><span class="mf">2.3</span><span class="p">,</span> <span class="nx">y</span><span class="o">:-</span><span class="mf">1.2</span> <span class="p">};</span> <span class="c1">// An object with 2 properties
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">q</span> <span class="o">=</span> <span class="p">{};</span> <span class="c1">// An empty object with no properties
</span><span class="c1"></span><span class="nx">q</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mf">2.3</span><span class="p">;</span> <span class="nx">q</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.2</span><span class="p">;</span> <span class="c1">// Now q has the same properties as p
</span></code></pre></div>

<h3 id="函数定义表达式">函数定义表达式</h3>

<p>函数定义表达式定义了一个JavaScript函数，该表达式的值是新定义的函数。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">// This function returns the square of the value passed to it.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">square</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div>

<h3 id="属性访问表达式">属性访问表达式</h3>

<p>属性访问表达式求值为对象属性或数组元素的值。JavaScript为属性访问定义了两种语法：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">expression</span><span class="p">.</span><span class="nx">identifier</span>
<span class="nx">expression</span><span class="p">[</span><span class="nx">expression</span><span class="p">]</span>

<span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span><span class="nx">y</span><span class="o">:</span><span class="p">{</span><span class="nx">z</span><span class="o">:</span><span class="mi">3</span><span class="p">}};</span> <span class="c1">// An example object
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="nx">o</span><span class="p">,</span><span class="mi">4</span><span class="p">,[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]];</span> <span class="c1">// An example array that contains the object
</span><span class="c1"></span><span class="nx">o</span><span class="p">.</span><span class="nx">x</span> <span class="c1">// =&gt; 1: property x of expression o
</span><span class="c1"></span><span class="nx">o</span><span class="p">.</span><span class="nx">y</span><span class="p">.</span><span class="nx">z</span> <span class="c1">// =&gt; 3: property z of expression o.y
</span><span class="c1"></span><span class="nx">o</span><span class="p">[</span><span class="s2">&#34;x&#34;</span><span class="p">]</span> <span class="c1">// =&gt; 1: property x of object o
</span><span class="c1"></span><span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1">// =&gt; 4: element at index 1 of expression a
</span><span class="c1"></span><span class="nx">a2</span> <span class="c1">// =&gt; 6: element at index 1 of expression a[2]
</span><span class="c1"></span><span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">x</span> <span class="c1">// =&gt; 1: property x of expression a[0]
</span></code></pre></div>

<p>对于任一种属性访问表达式，.或[之前的表达式先计算。如果其值为null或undefined，抛出TypeError。如果指定的属性不存在，则属性访问表达式的值为undefined。</p>

<h3 id="调用表达式">调用表达式</h3>

<p>调用表达式用于JavaScript调用函数或方法。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">f</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// f is the function expression; 0 is the argument expression.
</span><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">,</span><span class="nx">z</span><span class="p">)</span> <span class="c1">// Math.max is the function; x, y and z are the arguments.
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">sort</span><span class="p">()</span> <span class="c1">// a.sort is the function; there are no arguments.
</span></code></pre></div>

<p>当对调用表达式求值时，首先对函数表达式求值，然后对参数表达式求值，以生成参数值列表。如果函数表达式的值不是可调用对象，则抛出TypeError。如果函数使用return语句返回值，则该值成为调用表达式的值。否则，调用表达式的值是undefined。</p>

<p>每一个调用表达式都包含一对括号和括号之前的表达式。如果该表达式是属性访问表达式，则调用称为方法调用。在方法调用中，对象或数组成为函数体执行时this参数的值。</p>

<p>非方法调用的调用表达式通常使用全局对象作为this关键字的值。在ES5中严格模式下定义的函数被调用时，this的值为undefined，而不是全局对象。</p>

<h3 id="对象创建表达式">对象创建表达式</h3>

<p>对象创建表达式创建一个新对象并调用一个函数（称为构造函数）来初始化该对象的属性。对象创建表达式类似于调用表达式，只是它们的前缀是关键字new：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">new</span> <span class="nb">Object</span><span class="p">()</span>
<span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
</code></pre></div>

<p>如果在对象创建表达式中没有参数传递给构造函数，则可以省略括号：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">new</span> <span class="nb">Object</span>
<span class="k">new</span> <span class="nb">Date</span>
</code></pre></div>

<p>当计算对象创建表达式时，JavaScript首先创建一个新的空对象，就像{}创建的对象一样。接下来，它使用指定的参数调用指定的函数，将新对象传递给this参数。然后函数可以使用this来初始化新创建对象的属性。构造函数不返回值，且对象创建表达式的值是新创建和初始化的对象。如果构造函数返回一个对象值，该值将成为对象创建表达式的值，新创建的对象将被丢弃。</p>

<h3 id="操作符概述">操作符概述</h3>

<p><img src="/static/images/2018/10/28/operators.jpg" alt="operators.jpg" /></p>

<h4 id="左值">左值</h4>

<p>左值是一个历史术语，意思是“可以合法地出现在赋值表达式左边的表达式”。在JavaScript中，变量、对象属性和数组元素都是lvalue。ECMAScript规范允许内置函数返回左值，但没有任何以这种方式运行的函数。</p>

<h4 id="操作符的副作用">操作符的副作用</h4>

<p>有些表达有副作用，它们的计算会影响到将来计算的结果。赋值操作符是最明显的例子：如果将值赋给变量或属性，则会更改使用该变量或属性的任何表达式的值。++和&ndash;操作符类似，因为它们执行隐式赋值。delete操作符也有副作用：删除一个属性就像给这个属性赋值undefined。</p>

<p>没有其他JavaScript操作符有副作用，但是如果函数或构造函数中使用的任何操作符有副作用，那么函数调用和对象创建表达式就会有副作用。</p>

<h4 id="运算符优先级">运算符优先级</h4>

<p>运算符优先控制执行操作的顺序。优先级较高的操作符在优先级较低的操作符之前执行。可以通过显式使用括号覆盖运算符优先级。属性访问和调用表达式的优先级高于上表任何操作符。</p>

<h4 id="运算符结合性">运算符结合性</h4>

<p>运算符的结合性指定执行相同优先级的操作的顺序。从左到右的结合律意味着操作是从左到右执行的。</p>

<h4 id="求值顺序">求值顺序</h4>

<p>运算符优先级和结合性指定在复杂表达式中执行操作的顺序，但它们没有指定计算子表达式的顺序。JavaScript总是严格按照从左到右的顺序计算表达式。</p>

<h3 id="算术表达式">算术表达式</h3>

<p>基本的算术运算符是*、/、%、+和-。我们将在后面单独讨论+运算符。其他四个运算符只是计算它们的操作数，如果需要的话，将值转换为数字，然后计算。不能转换为数字的操作数转换为NaN。如果操作数是NaN，则结果也是NaN。</p>

<p>在JavaScript中，所有数字都是浮点数，因此所有除法操的结果都是浮点数。除以0得到正无穷或负无穷，而0/0得到NaN。</p>

<p>运算符%计算第一个操作数对第二个操作数的取模，结果的符号与第一个操作数的符号相同。模运算符通常与整数操作数一起使用，但它也适用于浮点值。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="mi">5</span> <span class="o">%</span> <span class="mi">2</span> <span class="c1">//=&gt; 1
</span><span class="c1"></span><span class="o">-</span><span class="mi">5</span> <span class="o">%</span> <span class="mi">2</span> <span class="c1">//=&gt; -1
</span><span class="c1"></span><span class="mf">6.5</span> <span class="o">%</span> <span class="mf">2.1</span> <span class="c1">//=&gt; 0.2
</span></code></pre></div>

<h4 id="运算符">+运算符</h4>

<p>如果有一个操作数是对象，使用对象到原始类型转换：日期对象使用toString()方法，其他对象使用valueOf()方法。大多数对象没有一个有用的valueOf()方法，因此它们也通过toString()进行转换。</p>

<ul>
<li>如果任何一个操作数是字符串，那么另一个操作数将转换为字符串，并执行连接</li>
<li>将两个操作数转换为数字（或NaN）并执行加法。</li>
</ul>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="c1">// =&gt; 3: addition
</span><span class="c1"></span><span class="s2">&#34;1&#34;</span> <span class="o">+</span> <span class="s2">&#34;2&#34;</span> <span class="c1">// =&gt; &#34;12&#34;: concatenation
</span><span class="c1"></span><span class="s2">&#34;1&#34;</span> <span class="o">+</span> <span class="mi">2</span> <span class="c1">// =&gt; &#34;12&#34;: concatenation after number-to-string
</span><span class="c1"></span><span class="mi">1</span> <span class="o">+</span> <span class="p">{}</span> <span class="c1">// =&gt; &#34;1[object Object]&#34;: concatenation after object-to-string
</span><span class="c1"></span><span class="kc">true</span> <span class="o">+</span> <span class="kc">true</span> <span class="c1">// =&gt; 2: addition after boolean-to-number
</span><span class="c1"></span><span class="mi">2</span> <span class="o">+</span> <span class="kc">null</span> <span class="c1">// =&gt; 2: addition after null converts to 0
</span><span class="c1"></span><span class="mi">2</span> <span class="o">+</span> <span class="kc">undefined</span> <span class="c1">// =&gt; NaN: addition after undefined converts to NaN
</span></code></pre></div>

<h4 id="一元运算符">一元运算符</h4>

<p>在JavaScript中，一元运算符的优先级都很高，且都是右关联的。如果需要，算术一元运算符（+、-、++和&ndash;）都将其操作数转换为数字。</p>

<h4 id="位运算符">位运算符</h4>

<p>位运算符将其操作数转换为数字，通过删除小数部分和超过32位的部分，将数值强制转换为32位整数。NaN，Infinity和-Infinity都转换为0。</p>

<p><code>&amp;</code>运算符对操作数每个位执行与操作。只有两位都为1，结果才为1。</p>

<p><code>|</code>运算符对操作数每个位执行或操作。只有两位都为0，结果才为0。</p>

<p><code>^</code>运算符对操作数每个位执行异或操作。两位相同结果为0，两位不相同结果为1。</p>

<p><code>~</code>按位取反，相当于更改符号并减去1。</p>

<p><code>&lt;&lt;</code>左移运算符，将其第一个操作数中的所有位向左移动，移动的位置是第二个操作数指定的位数。</p>

<p><code>&gt;&gt;</code>右移操作符，将其第一个操作数中的所有位向右移动，移动的位置是第二个操作数指定的位数，左边填充符号位。</p>

<p><code>&gt;&gt;&gt;</code>类似于<code>&gt;&gt;</code>，只是左边总是填充0。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="mh">0x1234</span> <span class="o">&amp;</span> <span class="mh">0x00FF</span> <span class="c1">// 0x0034
</span><span class="c1"></span><span class="mh">0x1234</span> <span class="o">|</span> <span class="mh">0x00FF</span> <span class="c1">// 0x12FF
</span><span class="c1"></span><span class="mh">0xFF00</span> <span class="o">^</span> <span class="mh">0xF0F0</span> <span class="c1">// 0x0FF0
</span><span class="c1"></span><span class="o">~</span><span class="mh">0x0F</span> <span class="c1">// 0xFFFFFFF0
</span><span class="c1"></span><span class="mi">7</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="c1">// 28
</span><span class="c1"></span><span class="err">−</span><span class="mi">7</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span> <span class="c1">// −4
</span><span class="c1"></span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">4</span> <span class="c1">// 0x0FFFFFFF
</span></code></pre></div>

<h3 id="关系表达式">关系表达式</h3>

<h4 id="相等和不等操作符">相等和不等操作符</h4>

<p>JavaScript对象通过引用而不是值进行比较。严格相等运算符===计算其操作数，然后按照如下方式比较这两个值，不执行类型转换：</p>

<ul>
<li>如果这两个值有不同的类型，它们就不相等</li>
<li>如果两个值都为null或undefined ，则它们相等。</li>
<li>如果两个值都是布尔值true或都是布尔值false，则它们相等。</li>
<li>如果一个或两个值都是NaN，则它们不相等。NaN值永远不等于任何其他值，包括它自己。</li>
<li>如果两个值都是数字且值相同，则它们相等。0和-0相等。</li>
<li>如果两个值是字符串且长度和内容相同则它们相等，否则它们不相等。</li>
<li>如果两个值引用相同的对象、数组或函数，则它们相等。如果它们引用不同的对象，它们就不相等，即使两个对象具有相同的属性。</li>
</ul>

<p>==运算符没有===严格。如果两个操作数的值不是相同的类型，它会尝试一些类型转换并再次比较：</p>

<ul>
<li>如果两个值具有相同的类型，则用===比较它们。</li>

<li><p>如果两个值的类型不相同，使用以下规则和类型转换检查是否相等</p>

<ol>
<li>如果一个是null，另一个是undefined，它们相等。</li>
<li>如果一个是数字，另一个是字符串，将字符串转换为数字，再使用转换后的值进行比较</li>
<li>如果任一值为true或false，将其转换数字再进行比较。</li>
<li>如果一个是对象，另一个是数字或字符串，将对象转换原始类型再进行比较。</li>
</ol></li>

<li><p>任何其他值的组合都不相等</p></li>
</ul>

<h4 id="比较运算符">比较运算符（&lt;，&gt;，&lt;=，&gt;=）</h4>

<p>这些比较运算符的操作数可以是任何类型的。但是，比较只能在数字和字符串上执行，因此转换的操作数不是数字或字符串。比较和转换如下所示：</p>

<ul>
<li>如果操作数是一个对象，将该对象转换为原始值。如果valueOf()方法返回一个原始值，则使用该值。否则使用toString()方法返回的值。</li>
<li>如果进行对象到原始值转换之后，两个操作数都是字符串，那么使用字母顺序比较这两个字符串。</li>
<li>如果进行对象到原始值转换之后，至少有一个操作数不是字符串，那么两个操作数都转换为数字再进行数值比较。如果有一个是NaN，总是返回false。</li>
</ul>

<p>+偏爱字符串，如果任何一个操作数是字符串，它都会执行连接。比较运算符更喜欢数字，如果两个操作数都是字符串，才进行字符串比较。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="c1">// Addition. Result is 3.
</span><span class="c1"></span><span class="s2">&#34;1&#34;</span> <span class="o">+</span> <span class="s2">&#34;2&#34;</span> <span class="c1">// Concatenation. Result is &#34;12&#34;.
</span><span class="c1"></span><span class="s2">&#34;1&#34;</span> <span class="o">+</span> <span class="mi">2</span> <span class="c1">// Concatenation. 2 is converted to &#34;2&#34;. Result is &#34;12&#34;.
</span><span class="c1"></span><span class="mi">11</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="c1">// Numeric comparison. Result is false.
</span><span class="c1"></span><span class="s2">&#34;11&#34;</span> <span class="o">&lt;</span> <span class="s2">&#34;3&#34;</span> <span class="c1">// String comparison. Result is true.
</span><span class="c1"></span><span class="s2">&#34;11&#34;</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="c1">// Numeric comparison. &#34;11&#34; converted to 11. Result is false.
</span><span class="c1"></span><span class="s2">&#34;one&#34;</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="c1">// Numeric comparison. &#34;one&#34; converted to NaN. Result is false.
</span></code></pre></div>

<h4 id="in操作符">in操作符</h4>

<p>in操作符左边是字符串，右边是一个对象。如果左侧值是右侧对象的属性名，则结果为true：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">point</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span><span class="mi">1</span> <span class="p">};</span> <span class="c1">// Define an object
</span><span class="c1"></span><span class="s2">&#34;x&#34;</span> <span class="k">in</span> <span class="nx">point</span> <span class="c1">// =&gt; true: object has property named &#34;x&#34;
</span><span class="c1"></span><span class="s2">&#34;z&#34;</span> <span class="k">in</span> <span class="nx">point</span> <span class="c1">// =&gt; false: object has no &#34;z&#34; property.
</span><span class="c1"></span><span class="s2">&#34;toString&#34;</span> <span class="k">in</span> <span class="nx">point</span> <span class="c1">// =&gt; true: object inherits toString method
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">];</span> <span class="c1">// An array with elements 0, 1, and 2
</span><span class="c1"></span><span class="s2">&#34;0&#34;</span> <span class="k">in</span> <span class="nx">data</span> <span class="c1">// =&gt; true: array has an element &#34;0&#34;
</span><span class="c1"></span><span class="mi">1</span> <span class="k">in</span> <span class="nx">data</span> <span class="c1">// =&gt; true: numbers are converted to strings
</span><span class="c1"></span><span class="mi">3</span> <span class="k">in</span> <span class="nx">data</span> <span class="c1">// =&gt; false: no element 3
</span></code></pre></div>

<h4 id="instanceof操作符">instanceof操作符</h4>

<p>instanceof操作符左侧是一个对象，右侧是一个类。如果左边的对象是右侧类的实例，则结果为true：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span> <span class="c1">// Create a new object with the Date() constructor
</span><span class="c1"></span><span class="nx">d</span> <span class="k">instanceof</span> <span class="nb">Date</span><span class="p">;</span> <span class="c1">// Evaluates to true; d was created with Date()
</span><span class="c1"></span><span class="nx">d</span> <span class="k">instanceof</span> <span class="nb">Object</span><span class="p">;</span> <span class="c1">// Evaluates to true; all objects are instances of Object
</span><span class="c1"></span><span class="nx">d</span> <span class="k">instanceof</span> <span class="nb">Number</span><span class="p">;</span> <span class="c1">// Evaluates to false; d is not a Number object
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span> <span class="c1">// Create an array with array literal syntax
</span><span class="c1"></span><span class="nx">a</span> <span class="k">instanceof</span> <span class="nb">Array</span><span class="p">;</span> <span class="c1">// Evaluates to true; a is an array
</span><span class="c1"></span><span class="nx">a</span> <span class="k">instanceof</span> <span class="nb">Object</span><span class="p">;</span> <span class="c1">// Evaluates to true; all arrays are objects
</span><span class="c1"></span><span class="nx">a</span> <span class="k">instanceof</span> <span class="nb">RegExp</span><span class="p">;</span> <span class="c1">// Evaluates to false; arrays are not regular expressions
</span></code></pre></div>

<p>注意，所有对象都是Object的实例。instanceof在决定对象是否为类的实例考虑的是基类。如果instanceof的左边操作数不是对象，将返回false。如果右边不是函数，它会抛出TypeError 。</p>

<h3 id="逻辑表达式">逻辑表达式（&amp;&amp;，||，!）</h3>

<p>&amp;&amp;和||具有短路求值的特性：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="p">(</span><span class="nx">a</span> <span class="o">==</span> <span class="nx">b</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">stop</span><span class="p">();</span>
<span class="kd">function</span> <span class="nx">copy</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">p</span> <span class="o">=</span> <span class="nx">p</span> <span class="o">||</span> <span class="p">{};</span> <span class="c1">// If no object passed for p, use a newly created object.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<h3 id="赋值表达式">赋值表达式</h3>

<p>赋值运算符左侧是一个左值，右侧可以是任意类型的值。赋值表达式的值就是右侧操作数的值。作为副作用，赋值运算符将右侧的值赋给左侧的变量或属性。赋值运算符是右结合的。</p>

<p>大多数情况下，<code>a op= b</code>等价于<code>a = a op b</code>。只有当a包含了诸如函数调用或递增操作符等副作用时，它们不等价。</p>

<h3 id="估值表达式">估值表达式</h3>

<p>像许多解释语言一样，JavaScript能够解释JavaScript源代码字符串，并对其进行计算。JavaScript通过全局函数eval()来实现的。</p>

<h4 id="eval">eval()</h4>

<p>如果传递一个字符串，eval()将尝试解析该字符串为JavaScript代码，如果失败则抛出SyntaxError。如果成功，则返回字符串中最后一个表达式或语句的值，如果最后一个表达式或语句没有值，则返回undefined。如果该串代码抛出异常，eval()传播该异常。</p>

<p>如果传递其他值，则返回该值。</p>

<p>eval()会使用当前代码作用域的变量，也可以像本地代码一样定义变量和函数。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span> <span class="c1">// 1
</span><span class="c1"></span><span class="nb">eval</span><span class="p">(</span><span class="s2">&#34;function f() { return x+1; }&#34;</span><span class="p">);</span>
<span class="nx">f</span><span class="p">()</span> <span class="c1">// 2
</span></code></pre></div>

<p>如果从顶级代码调用eval()，它将对全局变量和全局函数进行操作。</p>

<h4 id="全局eval">全局eval()</h4>

<p>eval()更改本地变量的能力对JavaScript优化器来说是一个很大的问题。解释器对任何调用eval()的函数只做较少的优化。</p>

<p>ES5废弃了EvalError并标准化了eval()的行为。直接调用eval()使用调用上下文的变量环境。任何其他调用都使用全局对象作为其变量环境，不能读写或定义局部变量和函数：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">geval</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">;</span> <span class="c1">// Using another name does a global eval
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="s2">&#34;global&#34;</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="s2">&#34;global&#34;</span><span class="p">;</span> <span class="c1">// Two global variables
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// This function does a local eval
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="s2">&#34;local&#34;</span><span class="p">;</span> <span class="c1">// Define a local variable
</span><span class="c1"></span>    <span class="nb">eval</span><span class="p">(</span><span class="s2">&#34;x += &#39;changed&#39;;&#34;</span><span class="p">);</span> <span class="c1">// Direct eval sets local variable
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">x</span><span class="p">;</span> <span class="c1">// Return changed local variable
</span><span class="c1"></span><span class="p">}</span>
<span class="kd">function</span> <span class="nx">g</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// This function does a global eval
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="s2">&#34;local&#34;</span><span class="p">;</span> <span class="c1">// A local variable
</span><span class="c1"></span>    <span class="nx">geval</span><span class="p">(</span><span class="s2">&#34;y += &#39;changed&#39;;&#34;</span><span class="p">);</span> <span class="c1">// Indirect eval sets global variable
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">y</span><span class="p">;</span> <span class="c1">// Return unchanged local variable
</span><span class="c1"></span><span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">f</span><span class="p">(),</span> <span class="nx">x</span><span class="p">);</span> <span class="c1">// &#34;localchanged global&#34;
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">g</span><span class="p">(),</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// &#34;local globalchanged&#34;
</span></code></pre></div>

<p>在IE9之前，当使用不同的名称调用eval()时，它不会执行全局eval。也不会抛出一个EvalError，它只做局部运算。但IE定义了一个execScript()的全局函数，它会像执行顶级脚本一样执行字符串参数。然而，与eval()不同的是，execScript()总是返回null。</p>

<h3 id="严格eval">严格eval()</h3>

<p>ES5严格模式进一步限制eval()函数的行为，甚至是标识符eval的使用。当在严格模式中调用eval()时，eval()用私有变量环境执行本地eval。这意味着在严格模式下，求值代码可以查询和设置局部变量，但不能在局部作用域中定义新的变量或函数。</p>

<p>此外，严格eval()更像操作符。不允许使用新值覆盖eval()函数，且不允许使用“eval”名称声明变量、函数、函数参数或catch块参数。</p>

<h3 id="其他运算符">其他运算符</h3>

<h4 id="条件运算符">条件运算符（?:）</h4>

<p>条件运算符的操作数可以是任何类型的。如果第一个操作数的值为真，则计算第二个操作数，并返回其值。否则，计算第三个操作数并返回其值。</p>

<h4 id="typeof运算符">typeof运算符</h4>

<p><img src="/static/images/2018/10/28/typeof.png" alt="typeof.png" /></p>

<p>JavaScript在函数和“可调用对象”之间做了细微的区分。所有的函数都是可调用的，但也有可能一个可调用对象不是一个真正的函数。ES3规范说所有可调用的本机对象返回&rdquo;function&rdquo;。ES5规范对此进行了扩展，要求所有可调用对象都返回&rdquo;function&rdquo;。</p>

<h3 id="delete运算符">delete运算符</h3>

<p>delete是一个一元运算符，它删除指定对象的属性或数组元素。与赋值、递增和递减运算符一样，使用delete通常是为了其副作用，而不是返回的值。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">2</span><span class="p">};</span> <span class="c1">// Start with an object
</span><span class="c1"></span><span class="k">delete</span> <span class="nx">o</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span> <span class="c1">// Delete one of its properties
</span><span class="c1"></span><span class="s2">&#34;x&#34;</span> <span class="k">in</span> <span class="nx">o</span> <span class="c1">// =&gt; false: the property does not exist anymore
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">];</span> <span class="c1">// Start with an array
</span><span class="c1"></span><span class="k">delete</span> <span class="nx">a</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// Delete the last element of the array
</span><span class="c1"></span><span class="nx">a</span><span class="p">.</span><span class="nx">length</span> <span class="c1">// =&gt; 2: array only has two elements now
</span></code></pre></div>

<p>删除属性或数组元素不等同于将其值设为undefined。当一个属性被删除时，该属性就不存在了。尝试读取不存在的属性将返回未定义的值，但是可以使用in操作符测试属性的是否存在。</p>

<p>delete的操作数是一个左值。如果它不是左值，delete不采取任何操作并返回true。否则，delete尝试删除该左值。如果d删除成功，则返回true。并不是所有的属性都可以删除：一些内置的核心属性和客户端属性不受删除的影响，并且不能删除使用var语句声明的用户定义的变量。由function声明的函数和参数也不能删除。</p>

<p>在ES5严格模式下，如果delete的操作数是一个非限定的标识符（如变量、函数或函数参数），那么它抛出SyntaxError错误，只有当操作数是一个属性访问表达式时，它才会工作。如果删除任何不可配置属性，将抛出TypeError。在严格模式之外，这些情况下不会发生异常，delete返回false表示操作数无法删除：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span><span class="mi">2</span><span class="p">};</span> <span class="c1">// Define a variable; initialize it to an object
</span><span class="c1"></span><span class="k">delete</span> <span class="nx">o</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span> <span class="c1">// Delete one of the object properties; returns true
</span><span class="c1"></span><span class="k">typeof</span> <span class="nx">o</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span> <span class="c1">// Property does not exist; returns &#34;undefined&#34;
</span><span class="c1"></span><span class="k">delete</span> <span class="nx">o</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span> <span class="c1">// Delete a nonexistent property; returns true
</span><span class="c1"></span><span class="k">delete</span> <span class="nx">o</span><span class="p">;</span> <span class="c1">// Can&#39;t delete a declared variable; returns false.
</span><span class="c1">// Would raise an exception in strict mode.
</span><span class="c1"></span><span class="k">delete</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// Argument is not an lvalue: returns true
</span><span class="c1"></span><span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// Define a property of the a global object without var
</span><span class="c1"></span><span class="k">delete</span> <span class="nx">x</span><span class="p">;</span> <span class="c1">// Try to delete it: returns true in non-strict mode
</span><span class="c1"></span>		  <span class="c1">// Exception in strict mode. Use &#39;delete this.x&#39; instead
</span><span class="c1"></span><span class="k">delete</span> <span class="nx">x</span><span class="p">;</span> <span class="c1">// Runtime error: x is not defined
</span></code></pre></div>

<h4 id="void运算符">void运算符</h4>

<p>void是一个一元运算符，其操作数可以是任何类型。它计算并丢弃其操作数的值，然后返回undefined。由于操作数的值被丢弃，所以只有当操作数有副作用时，使用void运算符才有意义。</p>

<p>这个操作符最常见的用法是在客户端javascript的URL中，它允许你为了表达式的副作用，而不需要浏览器显示表达式的值。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="o">&lt;</span><span class="nx">a</span> <span class="nx">href</span><span class="o">=</span><span class="s2">&#34;javascript:void window.open();&#34;</span><span class="o">&gt;</span><span class="nx">Open</span> <span class="nx">New</span> <span class="nx">Window</span><span class="o">&lt;</span><span class="err">/a&gt;</span>
</code></pre></div>

<h4 id="逗号运算符">逗号运算符</h4>

<p>逗号操作符是一个二进制操作符，其操作数可以是任何类型。它从左到右计算操作数，然后返回右操作数的值。</p>
]]></content>
		</item>
		
		<item>
			<title>类型、值和变量</title>
			<link>https://gitop.cc/posts/types_values_variables/</link>
			<pubDate>Sun, 28 Oct 2018 14:24:21 +0800</pubDate>
			
			<guid>https://gitop.cc/posts/types_values_variables/</guid>
			<description>Javascript类型可以分为两大类：原始类型和对象类型。JavaScript原始类型包括数字、字符串、布尔值、null和undefine</description>
			<content type="html"><![CDATA[

<p>Javascript类型可以分为两大类：原始类型和对象类型。JavaScript原始类型包括数字、字符串、布尔值、null和undefined。null和undefined是它们自己类型的唯一成员。任何不是原始类型的Javascript值都是一个对象。每个对象都是类型Object的成员，由一组属性的集合组成，每个属性有一个名字和一个值。</p>

<p>一个普通的JavaScript 对象是一组无序的键值集合。JavaScript还定义了一种特殊的对象，数组，代表有序的编号的值。JavaScript还定义了另一种特殊的对象，函数。函数在Javascript里面是值。用来初始化新创建的对象的函数称为构造函数。每个构造函数定义了一类对象。类可以认为是对象的子类型。除了Array和Function类，Javascript核心定义了三种其他有用的类。Date、RegExp、Error 。</p>

<p>JavaScript解释器自动执行垃圾回收。当一个对象不再可访问时，解释器自动回收它占有的内存。</p>

<p>JavaScript是一门面向对象的语言。只有JavaScript对象拥有方法，数字、字符串和布尔值表现得好像它们有方法。在JavaScript里面，只有null和undefined没有方法。</p>

<table>
<thead>
<tr>
<th></th>
<th>number</th>
<th>string</th>
<th>boolean</th>
<th>null</th>
<th>undefined</th>
<th>object</th>
</tr>
</thead>

<tbody>
<tr>
<td>isPrimitive</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td>hasMethod</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>

<tr>
<td>mutable</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody>
</table>

<p>JavaScript自由地转换一种类型为另外一种。当程序期待某种类型的时候，它会将其他类型自动转换为需要的类型。</p>

<p>JavaScript变量是无类型的，你可以将任意类型的值赋给一个变量。JavaScript使用词法域，定义在函数之外的变量在任何地方可见，在函数中定义的变量只在函数中可见。</p>

<h3 id="数字">数字</h3>

<p>JavaScript中所有数字都是使用IEEE 754标准表示的64位浮点数。 JavaScript数字格式允许你精确表示$ -2^{53} $和$ 2^{53} $之间的整数。注意JavaScript中有些操作是用32位整数执行的，比如数组下标和位运算符。</p>

<h4 id="整型字面值">整型字面值</h4>

<p>除了10进制整型字面值，JavaScript支持16进制数值。16进制字面值以&rdquo;0x&rdquo;或&rdquo;0X&rdquo;开头，后跟16进制数字。尽管ECMAScript标准不支持8进制数值，一些JavaScript实现允许你使用8进制数值（以0开头后跟8进制数字）。在ES5严格模式下，8进制数值被明确禁止。</p>

<h4 id="浮点型字面值">浮点型字面值</h4>

<p>语法为：<code>[digits][.digits][(E|e)[(+|-)]digits]</code></p>

<h4 id="数学运算">数学运算</h4>

<p>JavaScript提供几种算术运算符：+, -, *, /, %。Math对象支持更复杂的数学运算：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">53</span><span class="p">)</span> <span class="c1">// =&gt; 9007199254740992: 2 to the power 53
</span><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">round</span><span class="p">(</span><span class="mf">.6</span><span class="p">)</span> <span class="c1">// =&gt; 1.0: round to the nearest integer
</span><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">ceil</span><span class="p">(</span><span class="mf">.6</span><span class="p">)</span> <span class="c1">// =&gt; 1.0: round up to an integer
</span><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="mf">.6</span><span class="p">)</span> <span class="c1">// =&gt; 0.0: round down to an integer
</span><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span> <span class="c1">// =&gt; 5: absolute value
</span><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">,</span><span class="nx">z</span><span class="p">)</span> <span class="c1">// Return the largest argument
</span><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">,</span><span class="nx">z</span><span class="p">)</span> <span class="c1">// Return the smallest argument
</span><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="c1">// Pseudo-random number x where 0 &lt;= x &lt; 1.0
</span><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="c1">// π: circumference of a circle / diameter
</span><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">E</span> <span class="c1">// e: The base of the natural logarithm
</span><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// The square root of 3
</span><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// The cube root of 3
</span><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">sin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// Trigonometry: also Math.cos, Math.atan, etc.
</span><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1">// Natural logarithm of 10
</span><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">/</span><span class="nb">Math</span><span class="p">.</span><span class="nx">LN10</span> <span class="c1">// Base 10 logarithm of 100
</span><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">512</span><span class="p">)</span><span class="o">/</span><span class="nb">Math</span><span class="p">.</span><span class="nx">LN2</span> <span class="c1">// Base 2 logarithm of 512
</span><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">exp</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// Math.E cubed
</span></code></pre></div>

<p>JavaScript中算术运算不会抛出异常。当算术操作的值比最大可表示的值大时，得到Infinity，类似当一个负数比最小可表示的值小时，得到-Infinity。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="mi">0</span><span class="o">/</span><span class="mi">0</span> <span class="c1">//=&gt;NaN
</span><span class="c1"></span><span class="nb">Math</span><span class="p">.</span><span class="nx">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">//=&gt;NaN
</span><span class="c1"></span><span class="mi">1</span> <span class="o">-</span> <span class="s1">&#39;a&#39;</span> <span class="c1">//=&gt;NaN  对不能转换为数字的运算对象使用算术运算符结果为NaN
</span><span class="c1"></span><span class="kc">Infinity</span> <span class="o">+</span> <span class="kc">Infinity</span> <span class="c1">//=&gt;Infinity
</span><span class="c1"></span><span class="kc">Infinity</span> <span class="o">-</span> <span class="kc">Infinity</span> <span class="c1">//=&gt;NaN
</span><span class="c1"></span><span class="kc">Infinity</span> <span class="o">*</span> <span class="kc">Infinity</span> <span class="c1">//=&gt;Infinity
</span><span class="c1"></span><span class="kc">Infinity</span> <span class="o">/</span> <span class="kc">Infinity</span> <span class="c1">//=&gt;NaN
</span></code></pre></div>

<p>JavaScript预定义了全局变量Infinity和NaN保存正无穷大和非数值。在ES3标准中，这些值是可以改变的。ES5中更正为只读。ES3中Number对象定义了只读的替代品：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kc">Infinity</span> <span class="c1">// A read/write variable initialized to Infinity.
</span><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nx">POSITIVE_INFINITY</span> <span class="c1">// Same value, read-only.
</span><span class="c1"></span><span class="mi">1</span><span class="o">/</span><span class="mi">0</span> <span class="c1">// This is also the same value.
</span><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nx">MAX_VALUE</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// This also evaluates to Infinity.
</span><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nx">NEGATIVE_INFINITY</span> <span class="c1">// These expressions are negative infinity.
</span><span class="c1"></span><span class="o">-</span><span class="kc">Infinity</span>
<span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">0</span>
<span class="o">-</span><span class="nb">Number</span><span class="p">.</span><span class="nx">MAX_VALUE</span> <span class="o">-</span> <span class="mi">1</span>
<span class="kc">NaN</span> <span class="c1">// A read/write variable initialized to NaN.
</span><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="kc">NaN</span> <span class="c1">// A read-only property holding the same value.
</span><span class="c1"></span><span class="mi">0</span><span class="o">/</span><span class="mi">0</span> <span class="c1">// Evaluates to NaN.
</span><span class="c1"></span><span class="nb">Number</span><span class="p">.</span><span class="nx">MIN_VALUE</span><span class="o">/</span><span class="mi">2</span> <span class="c1">// Underflow: evaluates to 0
</span><span class="c1"></span><span class="o">-</span><span class="nb">Number</span><span class="p">.</span><span class="nx">MIN_VALUE</span><span class="o">/</span><span class="mi">2</span> <span class="c1">// Negative zero
</span><span class="c1"></span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="kc">Infinity</span> <span class="c1">// Also negative 0
</span><span class="c1"></span><span class="o">-</span><span class="mi">0</span>
</code></pre></div>

<p>NaN和任何值都不相等包括它自己。你可以使用<code>x != x</code>来判断是否是NaN。函数isNaN()判断参数是否为NaN，相关函数isFinite()判断函数参数是否是一个非NaN, Infinity或-Infinity的数字。</p>

<p>负0和正0只有用在除数上不一样，其他情况相等：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">zero</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Regular zero
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">negz</span> <span class="o">=</span> <span class="o">-</span><span class="mi">0</span><span class="p">;</span> <span class="c1">// Negative zero
</span><span class="c1"></span><span class="nx">zero</span> <span class="o">===</span> <span class="nx">negz</span> <span class="c1">// =&gt; true: zero and negative zero are equal
</span><span class="c1"></span><span class="mi">1</span><span class="o">/</span><span class="nx">zero</span> <span class="o">===</span> <span class="mi">1</span><span class="o">/</span><span class="nx">negz</span> <span class="c1">// =&gt; false: infinity and -infinity are not equal
</span></code></pre></div>

<h4 id="二进制浮点数和舍入误差">二进制浮点数和舍入误差</h4>

<p>浮点数的二进制表示不能精确表示简单如0.1的十进制浮点数。JavaScript未来也许会支持Decimal数字类型来避免舍入问题。</p>

<h4 id="日期和时间">日期和时间</h4>

<p>核心JavaScript包含一个Date()构造函数，用于创建表示日期和时间的对象：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">then</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">(</span><span class="mi">2010</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// The 1st day of the 1st month of 2010
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">later</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">(</span><span class="mi">2010</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span> <span class="c1">// Same day, at 530pm, local time
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">now</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span> <span class="c1">// The current date and time
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">elapsed</span> <span class="o">=</span> <span class="nx">now</span> <span class="o">-</span> <span class="nx">then</span><span class="p">;</span> <span class="c1">// Date subtraction: interval in milliseconds
</span><span class="c1"></span><span class="nx">later</span><span class="p">.</span><span class="nx">getFullYear</span><span class="p">()</span> <span class="c1">// =&gt; 2010
</span><span class="c1"></span><span class="nx">later</span><span class="p">.</span><span class="nx">getMonth</span><span class="p">()</span> <span class="c1">// =&gt; 0: zero-based months
</span><span class="c1"></span><span class="nx">later</span><span class="p">.</span><span class="nx">getDate</span><span class="p">()</span> <span class="c1">// =&gt; 1: one-based days
</span><span class="c1"></span><span class="nx">later</span><span class="p">.</span><span class="nx">getDay</span><span class="p">()</span> <span class="c1">// =&gt; 5: day of week. 0 is Sunday 5 is Friday.
</span><span class="c1"></span><span class="nx">later</span><span class="p">.</span><span class="nx">getHours</span><span class="p">()</span> <span class="c1">// =&gt; 17: 5pm, local time
</span><span class="c1"></span><span class="nx">later</span><span class="p">.</span><span class="nx">getUTCHours</span><span class="p">()</span> <span class="c1">// hours in UTC time; depends on timezone
</span><span class="c1"></span>
<span class="nx">later</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span> <span class="c1">// =&gt; &#34;Fri Jan 01 2010 1730 GMT-0800 (PST)&#34;
</span><span class="c1"></span><span class="nx">later</span><span class="p">.</span><span class="nx">toUTCString</span><span class="p">()</span> <span class="c1">// =&gt; &#34;Sat, 02 Jan 2010 0130 GMT&#34;
</span><span class="c1"></span><span class="nx">later</span><span class="p">.</span><span class="nx">toLocaleDateString</span><span class="p">()</span> <span class="c1">// =&gt; &#34;01/01/2010&#34;
</span><span class="c1"></span><span class="nx">later</span><span class="p">.</span><span class="nx">toLocaleTimeString</span><span class="p">()</span> <span class="c1">// =&gt; &#34;0530 PM&#34;
</span><span class="c1"></span><span class="nx">later</span><span class="p">.</span><span class="nx">toISOString</span><span class="p">()</span> <span class="c1">// =&gt; &#34;2010-01-02T0130.000Z&#34;; ES5 only
</span></code></pre></div>

<h3 id="文本">文本</h3>

<p>字符串是由16位值组成的不可变的有序序列，每个值通常表示一个Unicode字符。字符串的长度是它包含的16位值的个数。JavaScript使用UTF-16字符集，JavaScript字符串是16位数值的序列。</p>

<h4 id="字符串字面值">字符串字面值</h4>

<p>由单引号或双引号括起来的字符串。在ES3中字符串字面值必须写在一行上。在ES5中，你可以通过在每行末尾加上反斜杠来在多行之间分隔字符串字面值。</p>

<p>在客户端JavaScript编程中，像JavaScript一样，HTML使用单引号或双引号来分隔字符串。因此，在结合使用JavaScript和HTML时，最好对JavaScript使用一种引号，对HTML使用另一种引号。</p>

<h4 id="转义序列">转义序列</h4>

<p>反斜杠在JavaScript字符串中有特殊的用途。与其后的字符组合，它表示字符串中不能表示的字符：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="err">\</span><span class="mi">0</span> <span class="nx">The</span> <span class="nx">NUL</span> <span class="nx">character</span> <span class="p">(</span> <span class="nx">\u0000</span> <span class="p">)</span>
<span class="err">\</span><span class="nx">b</span> <span class="nx">Backspace</span> <span class="p">(</span> <span class="nx">\u0008</span> <span class="p">)</span>
<span class="err">\</span><span class="nx">t</span> <span class="nx">Horizontal</span> <span class="nx">tab</span> <span class="p">(</span> <span class="nx">\u0009</span> <span class="p">)</span>
<span class="err">\</span><span class="nx">n</span> <span class="nx">Newline</span> <span class="p">(</span> <span class="nx">\u000A</span> <span class="p">)</span>
<span class="err">\</span><span class="nx">v</span> <span class="nx">Vertical</span> <span class="nx">tab</span> <span class="p">(</span> <span class="nx">\u000B</span> <span class="p">)</span>
<span class="err">\</span><span class="nx">f</span> <span class="nx">Form</span> <span class="nx">feed</span> <span class="p">(</span> <span class="nx">\u000C</span> <span class="p">)</span>
<span class="err">\</span><span class="nx">r</span> <span class="nx">Carriage</span> <span class="k">return</span> <span class="p">(</span> <span class="nx">\u000D</span> <span class="p">)</span>
<span class="err">\&#34;</span> <span class="nx">Double</span> <span class="nx">quote</span> <span class="p">(</span> <span class="nx">\u0022</span> <span class="p">)</span>
<span class="err">\&#39;</span> <span class="nx">Apostrophe</span> <span class="nx">or</span> <span class="nx">single</span> <span class="nx">quote</span> <span class="p">(</span> <span class="nx">\u0027</span> <span class="p">)</span>
<span class="err">\\</span> <span class="nx">Backslash</span> <span class="p">(</span> <span class="nx">\u005C</span> <span class="p">)</span>
<span class="err">\</span><span class="nx">x</span> <span class="nx">XX</span> <span class="nx">The</span> <span class="nx">Latin</span><span class="o">-</span><span class="mi">1</span> <span class="nx">character</span> <span class="nx">specified</span> <span class="nx">by</span> <span class="nx">the</span> <span class="nx">two</span> <span class="nx">hexadecimal</span> <span class="nx">digits</span> <span class="nx">XX</span>
<span class="err">\</span><span class="nx">u</span> <span class="nx">XXXX</span> <span class="nx">The</span> <span class="nx">Unicode</span> <span class="nx">character</span> <span class="nx">specified</span> <span class="nx">by</span> <span class="nx">the</span> <span class="nx">four</span> <span class="nx">hexadecimal</span> <span class="nx">digits</span> <span class="nx">XXXX</span>
</code></pre></div>

<p>反斜杠后跟任何其它字符，反斜杠被忽略。</p>

<h4 id="使用字符串">使用字符串</h4>

<p>对字符串使用+连接字符串，使用length属性获取字符串的长度。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="s2">&#34;hello, world&#34;</span> <span class="c1">// Start with some text.
</span><span class="c1"></span><span class="nx">s</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// =&gt; &#34;h&#34;: the first character.
</span><span class="c1"></span><span class="nx">s</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// =&gt; &#34;d&#34;: the last character.
</span><span class="c1"></span><span class="nx">s</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="c1">// =&gt; &#34;ell&#34;: the 2nd, 3rd and 4th characters.
</span><span class="c1"></span><span class="nx">s</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="c1">// =&gt; &#34;ell&#34;: same thing
</span><span class="c1"></span><span class="nx">s</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// =&gt; &#34;rld&#34;: last 3 characters
</span><span class="c1"></span><span class="nx">s</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s2">&#34;l&#34;</span><span class="p">)</span> <span class="c1">// =&gt; 2: position of first letter l.
</span><span class="c1"></span><span class="nx">s</span><span class="p">.</span><span class="nx">lastIndexOf</span><span class="p">(</span><span class="s2">&#34;l&#34;</span><span class="p">)</span> <span class="c1">// =&gt; 10: position of last letter l.
</span><span class="c1"></span><span class="nx">s</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s2">&#34;l&#34;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// =&gt; 3: position of first &#34;l&#34; at or after 3
</span><span class="c1"></span><span class="nx">s</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s2">&#34;, &#34;</span><span class="p">)</span> <span class="c1">// =&gt; [&#34;hello&#34;, &#34;world&#34;] split into substrings
</span><span class="c1"></span><span class="nx">s</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="s2">&#34;h&#34;</span><span class="p">,</span> <span class="s2">&#34;H&#34;</span><span class="p">)</span> <span class="c1">// =&gt; &#34;Hello, world&#34;: replaces all instances
</span><span class="c1"></span><span class="nx">s</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">()</span> <span class="c1">// =&gt; &#34;HELLO, WORLD&#34;
</span></code></pre></div>

<p>在ES5中，字符串可以被认为是只读数组，可以使用下标访问单个字符：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">s</span> <span class="o">=</span> <span class="s2">&#34;hello, world&#34;</span><span class="p">;</span>
<span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">// =&gt; &#34;h&#34;
</span><span class="c1"></span><span class="nx">s</span><span class="p">[</span><span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1">// =&gt; &#34;d&#34;
</span></code></pre></div>

<h4 id="模式匹配">模式匹配</h4>

<p>JavaScript定义了RegExp()构造函数，用于创建表示文本模式的对象。Javascript使用一对斜杠之间的文本组成正则表达式：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="sr">/^HTML/</span> <span class="c1">// Match the letters HTML at the start of a string
</span><span class="c1"></span><span class="sr">/1-9*/</span> <span class="c1">// Match a non-zero digit, followed by any # of digits
</span><span class="c1"></span><span class="sr">/\bjavascript\b/i</span> <span class="c1">// Match &#34;javascript&#34; as a word, case-insensitive
</span></code></pre></div>

<p>RegExp对象定义了许多有用的方法，字符串也有接受RegExp参数的方法：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">text</span> <span class="o">=</span> <span class="s2">&#34;testing: 1, 2, 3&#34;</span><span class="p">;</span> <span class="c1">// Sample text
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">pattern</span> <span class="o">=</span> <span class="sr">/\d+/g</span> <span class="c1">// Matches all instances of one or more digits
</span><span class="c1"></span><span class="nx">pattern</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span> <span class="c1">// =&gt; true: a match exists
</span><span class="c1"></span><span class="nx">text</span><span class="p">.</span><span class="nx">search</span><span class="p">(</span><span class="nx">pattern</span><span class="p">)</span> <span class="c1">// =&gt; 9: position of first match
</span><span class="c1"></span><span class="nx">text</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">pattern</span><span class="p">)</span> <span class="c1">// =&gt; [&#34;1&#34;, &#34;2&#34;, &#34;3&#34;]: array of all matches
</span><span class="c1"></span><span class="nx">text</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="nx">pattern</span><span class="p">,</span> <span class="s2">&#34;#&#34;</span><span class="p">);</span> <span class="c1">// =&gt; &#34;testing: #, #, #&#34;
</span><span class="c1"></span><span class="nx">text</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="sr">/\D+/</span><span class="p">);</span> <span class="c1">// =&gt; [&#34;&#34;,&#34;1&#34;,&#34;2&#34;,&#34;3&#34;]: split on non-digits
</span></code></pre></div>

<h3 id="布尔值">布尔值</h3>

<p>布尔值只有2个值：true, false。任何JavaScript值都可以转换为布尔值，下面这些值转换为false：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kc">undefined</span>
<span class="kc">null</span>
<span class="mi">0</span>
<span class="o">-</span><span class="mi">0</span>
<span class="kc">NaN</span>
<span class="s2">&#34;&#34;</span> <span class="c1">// the empty string
</span></code></pre></div>

<p>所有其他值转换为true。布尔值有个toString()方法将它们转换为&rdquo;true&rdquo;或&rdquo;false&rdquo;。</p>

<h3 id="null和undefined">null和undefined</h3>

<table>
<thead>
<tr>
<th></th>
<th>null</th>
<th>undefined</th>
</tr>
</thead>

<tbody>
<tr>
<td>isKeyword</td>
<td>Yes</td>
<td>No</td>
</tr>

<tr>
<td>typeof</td>
<td>&ldquo;object&rdquo;</td>
<td>&ldquo;undefined&rdquo;</td>
</tr>

<tr>
<td>Boolean</td>
<td>false</td>
<td>false</td>
</tr>

<tr>
<td>hasMethod</td>
<td>No</td>
<td>No</td>
</tr>
</tbody>
</table>

<p><strong>null表示&rdquo;没有对象&rdquo;，即该处不应该有值。</strong></p>

<p><strong>undefined表示&rdquo;缺少值&rdquo;，就是此处应该有一个值，但是还没有定义。</strong>以下情况均为undefined：</p>

<ul>
<li>声明变量却没有赋值</li>

<li><p>对象没有赋值的属性</p></li>

<li><p>访问不存在的数组元素</p></li>

<li><p>函数调用时没有提供参数</p></li>

<li><p>函数没有返回值</p></li>
</ul>

<p>undefined是一个预定义的全局变量，被初始化为undefined值。在ES3中，undefined是一个可读可写的变量。在ES5中被更正为只读。</p>

<p>==操作符认为null和undefined相等。使用.或[]访问它们的属性或方法引起TypeError。</p>

<p>你可以认为undefined表示系统级别、意外或类似错误的值缺失，而null表示程序级别、正常或预期的值缺失。</p>

<h3 id="全局对象">全局对象</h3>

<p>全局对象是一个普通的JavaScript对象，它的属性是JavaScript程序可用的全局定义符号。当JavaScript解释器启动时(或当web浏览器加载新页面时)，它创建一个新的全局对象，并为其提供一组初始属性：</p>

<ul>
<li>全局属性，如undefined，Infinity和NaN</li>
<li>全局函数，如isNaN()，parseInt()</li>
<li>构造函数，如Date()，RegExp()，String()，Object()和Array()</li>
<li>全局对象，如Math和JSON</li>
</ul>

<p>全局对象的初始属性不是保留字，但是它们应该被视为保留字。对于客户端JavaScript，window对象定义了其他全局变量。在顶级代码中（不属于函数的javascript代码），可以使用JavaScript关键字this来引用全局对象。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">global</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span> <span class="c1">// Define a global variable to refer to the global object
</span></code></pre></div>

<p>在客户端JavaScript中，window对象作为表示浏览器窗口的全局对象，定义了核心全局属性，但它也定义了许多特定于web浏览器和客户端JavaScript的全局属性。</p>

<p>当第一次创建时，全局对象定义了所有JavaScript预定义的全局变量值。但是它也包含了程序定义的全局变量。如果你的代码声明了一个全局变量，那么这个变量就是全局对象的一个属性。</p>

<h3 id="包装对象">包装对象</h3>

<p>当你试图引用字符串s的属性时，JavaScript会将字符串转换为对象，就像调用new String(s)一样。一旦属性被解析，新创建的对象就会被丢弃。数字和布尔值具有与字符串相同的方法:使用Number()或Boolean()构造函数创建临时对象，并使用该临时对象解析该方法。</p>

<p>考虑下面这段代码：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="s2">&#34;test&#34;</span><span class="p">;</span> <span class="c1">// Start with a string value.
</span><span class="c1"></span><span class="nx">s</span><span class="p">.</span><span class="nx">len</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// Set a property on it.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">len</span><span class="p">;</span> <span class="c1">// Now query the property. t is undefined
</span></code></pre></div>

<p>当访问字符串、数字或布尔值的属性时创建的临时对象称为包装对象。JavaScript根据需要将包装对象转换为原始类型值。==运算符将基础值及其包装对象视为相等的，但是你可以使用===严格相等运算符来区分它们。typeof运算符也将显示基础值与其包装对象之间的区别。</p>

<h3 id="不可变原始类型值和可变对象">不可变原始类型值和可变对象</h3>

<p>原始类型值是不可变的，它们通过值进行比较。对象是可变的，它们通过引用进行比较。2个对象值是相同的当且仅当它们引用相同的底层对象。这段代码定义了一个用来比较两个数组的函数：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">equalArrays</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">length</span> <span class="o">!=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// Different-size arrays not equal
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">a</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">// Loop through all elements
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!==</span> <span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// If any differ, arrays not equal
</span><span class="c1"></span>    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span> <span class="c1">// Otherwise they are equal
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<h3 id="类型转换">类型转换</h3>

<p>当JavaScript需要布尔值时，你可以提供任何类型的值，JavaScript将根据需要对其进行转换。如果JavaScript想要一个字符串，它会将你给它的任何值转换成字符串。如果JavaScript想要一个数字，它会尝试将你给它的值转换为一个数字(如果它不能执行有意义的转换，则转换为NaN)。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="mi">10</span> <span class="o">+</span> <span class="s2">&#34; objects&#34;</span> <span class="c1">// =&gt; &#34;10 objects&#34;. Number 10 converts to a string
</span><span class="c1"></span><span class="s2">&#34;7&#34;</span> <span class="o">*</span> <span class="s2">&#34;4&#34;</span> <span class="c1">// =&gt; 28: both strings convert to numbers
</span><span class="c1"></span>
<span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="s2">&#34;x&#34;</span><span class="p">;</span> <span class="c1">// =&gt; NaN: string &#34;x&#34; can&#39;t convert to a number
</span><span class="c1"></span><span class="nx">n</span> <span class="o">+</span> <span class="s2">&#34; objects&#34;</span> <span class="c1">// =&gt; &#34;NaN objects&#34;: NaN converts to string &#34;NaN&#34;
</span></code></pre></div>

<p><img src="/static/images/2018/10/28/conversion.png" alt="conversion.png" /></p>

<h4 id="转换和相等">转换和相等</h4>

<p>因为JavaScript可以灵活地转换值，所以它的==等号操作符也可以灵活地转换相等的概念：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kc">null</span> <span class="o">==</span> <span class="kc">undefined</span> <span class="c1">// These two values are treated as equal.
</span><span class="c1"></span><span class="s2">&#34;0&#34;</span> <span class="o">==</span> <span class="mi">0</span> <span class="c1">// String converts to a number before comparing.
</span><span class="c1"></span><span class="mi">0</span> <span class="o">==</span> <span class="kc">false</span> <span class="c1">// Boolean converts to number before comparing.
</span><span class="c1"></span><span class="s2">&#34;0&#34;</span> <span class="o">==</span> <span class="kc">false</span> <span class="c1">// Both operands convert to numbers before comparing.
</span></code></pre></div>

<p>记住，一个值与另一个值的可转换并不意味着这两个值相等。</p>

<h4 id="显式转换">显式转换</h4>

<p>最简单的执行显示类型转换的方式是使用Boolean()，Number() ，String() 或Object()函数。除了null和undefined，各个值的toString()返回的结果和使用String()返回的结果一般是相同的。对null或undefined使用Object()函数不会抛出异常，它只是返回一个新创建的空对象。</p>

<p>某些JavaScript操作符执行隐式类型转换，有时特意用于类型转换。如果+运算符的一个操作数是字符串，它将把另一个转换为字符串。一元+运算符将其操作数转换为数字。!运算符将其操作数转换为布尔值并否定它。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">x</span> <span class="o">+</span> <span class="s2">&#34;&#34;</span> <span class="c1">// Same as String(x)
</span><span class="c1"></span><span class="o">+</span><span class="nx">x</span> <span class="c1">// Same as Number(x). You may also see x-0
</span><span class="c1"></span><span class="o">!!</span><span class="nx">x</span> <span class="c1">// Same as Boolean(x). Note double !
</span></code></pre></div>

<p>Number类定义的toString()方法接受一个可选参数，该参数指定一个基数。默认以10进制进行转换，也可以使用在其他基数（2-36）。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>
<span class="nx">binary_string</span> <span class="o">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">toString</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// Evaluates to &#34;10001&#34;
</span><span class="c1"></span><span class="nx">octal_string</span> <span class="o">=</span> <span class="s2">&#34;0&#34;</span> <span class="o">+</span> <span class="nx">n</span><span class="p">.</span><span class="nx">toString</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span> <span class="c1">// Evaluates to &#34;021&#34;
</span><span class="c1"></span><span class="nx">hex_string</span> <span class="o">=</span> <span class="s2">&#34;0x&#34;</span> <span class="o">+</span> <span class="nx">n</span><span class="p">.</span><span class="nx">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span> <span class="c1">// Evaluates to &#34;0x11&#34;
</span></code></pre></div>

<p>toFixed()将数字转换为小数点后具有指定位数的字符串，不使用指数符号。</p>

<p>toExponential()使用指数符号将数字转换为字符串，小数点前有一位数字，小数点后有指定的位数。</p>

<p>toPrecision()将一个数字转换为一个具有指定的有效位数的字符串。如果有效数字的数量不足以显示该数字的整个整数部分，则使用指数符号。</p>

<p>这三个方法会适当地舍弃结尾数字或在后面添加0。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="mf">123456.789</span><span class="p">;</span>
<span class="nx">n</span><span class="p">.</span><span class="nx">toFixed</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// &#34;123457&#34;
</span><span class="c1"></span><span class="nx">n</span><span class="p">.</span><span class="nx">toFixed</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// &#34;123456.79&#34;
</span><span class="c1"></span><span class="nx">n</span><span class="p">.</span><span class="nx">toFixed</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// &#34;123456.78900&#34;
</span><span class="c1"></span><span class="nx">n</span><span class="p">.</span><span class="nx">toExponential</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// &#34;1.2e+5&#34;
</span><span class="c1"></span><span class="nx">n</span><span class="p">.</span><span class="nx">toExponential</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// &#34;1.235e+5&#34;
</span><span class="c1"></span><span class="nx">n</span><span class="p">.</span><span class="nx">toPrecision</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// &#34;1.235e+5&#34;
</span><span class="c1"></span><span class="nx">n</span><span class="p">.</span><span class="nx">toPrecision</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span> <span class="c1">// &#34;123456.8&#34;
</span><span class="c1"></span><span class="nx">n</span><span class="p">.</span><span class="nx">toPrecision</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// &#34;123456.7890&#34;
</span></code></pre></div>

<p>Number()函数只适用于10进制数，且不允许后接不属于数字的字符。parseInt()和parseFloat()函数更灵活，它们是全局函数，不是任何类的方法。parseInt()只解析整数，而parseFloat()解析整数和浮点数。如果字符串以“0x”或“0x”开头，parseInt()将其解释为十六进制数。parseInt()和parseFloat()都跳过前导空白，尽可能多地解析数字字符，并忽略后面的任何内容。如果第一个非空格字符不是有效数字文字的一部分，则返回NaN：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nb">parseInt</span><span class="p">(</span><span class="s2">&#34;3 blind mice&#34;</span><span class="p">)</span> <span class="c1">// =&gt; 3
</span><span class="c1"></span><span class="nb">parseFloat</span><span class="p">(</span><span class="s2">&#34; 3.14 meters&#34;</span><span class="p">)</span> <span class="c1">// =&gt; 3.14
</span><span class="c1"></span><span class="nb">parseInt</span><span class="p">(</span><span class="s2">&#34;-12.34&#34;</span><span class="p">)</span> <span class="c1">// =&gt; -12
</span><span class="c1"></span><span class="nb">parseInt</span><span class="p">(</span><span class="s2">&#34;0xFF&#34;</span><span class="p">)</span> <span class="c1">// =&gt; 255
</span><span class="c1"></span><span class="nb">parseInt</span><span class="p">(</span><span class="s2">&#34;0xff&#34;</span><span class="p">)</span> <span class="c1">// =&gt; 255
</span><span class="c1"></span><span class="nb">parseInt</span><span class="p">(</span><span class="s2">&#34;-0XFF&#34;</span><span class="p">)</span> <span class="c1">// =&gt; -255
</span><span class="c1"></span><span class="nb">parseFloat</span><span class="p">(</span><span class="s2">&#34;.1&#34;</span><span class="p">)</span> <span class="c1">// =&gt; 0.1
</span><span class="c1"></span><span class="nb">parseInt</span><span class="p">(</span><span class="s2">&#34;0.1&#34;</span><span class="p">)</span> <span class="c1">// =&gt; 0
</span><span class="c1"></span><span class="nb">parseInt</span><span class="p">(</span><span class="s2">&#34;.1&#34;</span><span class="p">)</span> <span class="c1">// =&gt; NaN: integers can&#39;t start with &#34;.&#34;
</span><span class="c1"></span><span class="nb">parseFloat</span><span class="p">(</span><span class="s2">&#34;$72.47&#34;</span><span class="p">);</span> <span class="c1">// =&gt; NaN: numbers can&#39;t start with &#34;$&#34;
</span></code></pre></div>

<p>parseInt()接受第二个可选参数，指定要解析数字的基数，合法值在2到36之间：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nb">parseInt</span><span class="p">(</span><span class="s2">&#34;11&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// =&gt; 3 (12 + 1)
</span><span class="c1"></span><span class="nb">parseInt</span><span class="p">(</span><span class="s2">&#34;ff&#34;</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span> <span class="c1">// =&gt; 255 (1516 + 15)
</span><span class="c1"></span><span class="nb">parseInt</span><span class="p">(</span><span class="s2">&#34;zz&#34;</span><span class="p">,</span> <span class="mi">36</span><span class="p">);</span> <span class="c1">// =&gt; 1295 (3536 + 35)
</span><span class="c1"></span><span class="nb">parseInt</span><span class="p">(</span><span class="s2">&#34;077&#34;</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span> <span class="c1">// =&gt; 63 (78 + 7)
</span><span class="c1"></span><span class="nb">parseInt</span><span class="p">(</span><span class="s2">&#34;077&#34;</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span> <span class="c1">// =&gt; 77 (7*10 + 7)
</span></code></pre></div>

<h4 id="对象到原始类型的转换">对象到原始类型的转换</h4>

<p>对象到布尔转换很简单：所有对象都转换为true。甚至对于包装器对象也是如此：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">if</span> <span class="p">(</span><span class="k">new</span> <span class="nb">Boolean</span><span class="p">(</span><span class="kc">false</span><span class="p">))</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span> <span class="c1">//=&gt; true
</span></code></pre></div>

<p>所有对象都继承两个转换方法。第一个是toString()，它的任务是返回对象的字符串表示形式。</p>

<p>许多类定义了自己的toString()方法。数组的toString()方法将每个数组元素转换为字符串，并用逗号连接在一起。函数的toString()方法返回一个由实现定义的函数表示。Date类的toString()方法，返回人类可读的日期和时间字符串。RegExp类的toString()方法，将RegExp对象转换为一个看起来像RegExp字面值的字符串：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">].</span><span class="nx">toString</span><span class="p">()</span> <span class="c1">// =&gt; &#34;1,2,3&#34;
</span><span class="c1"></span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="p">}).</span><span class="nx">toString</span><span class="p">()</span> <span class="c1">// =&gt; &#34;function(x) {\n f(x);\n}&#34;
</span><span class="c1"></span><span class="sr">/\d+/g</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span> <span class="c1">// =&gt; &#34;/\d+/g&#34;
</span><span class="c1"></span><span class="k">new</span> <span class="nb">Date</span><span class="p">(</span><span class="mi">2010</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">).</span><span class="nx">toString</span><span class="p">()</span> <span class="c1">// =&gt; &#34;Fri Jan 01 2010 0000 GMT-0800 (PST)&#34;
</span></code></pre></div>

<p>另一个转换方法是valueOf()。包装类的valueOf()返回其原始类型。数组，函数和正则表达式只是继承默认方法。调用这些类型实例的valueOf()只是返回对象本身。Date类的valueOf()返回自1970年1月1日以来的毫秒数。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">(</span><span class="mi">2010</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// January 1st, 2010, (Pacific time)
</span><span class="c1"></span><span class="nx">d</span><span class="p">.</span><span class="nx">valueOf</span><span class="p">()</span> <span class="c1">// =&gt; 1262332800000
</span></code></pre></div>

<p>要将对象转换为字符串，JavaScript执行以下步骤：</p>

<ul>
<li>如果对象有toString()方法，JavaScript会调用它。如果返回一个原始值，JavaScript会将该值转换为字符串并返回转换的结果。</li>
<li>如果对象没有toString()方法，或者该方法不返回原始值，那么JavaScript将查找valueOf()方法。如果该方法存在，JavaScript将调用它。如果返回值是一个原始值，JavaScript会将该值转换为字符串并返回转换后的结果。</li>
<li>否则，JavaScript无法从toString()或valueOf()中获得原始值，并抛出TypeError。</li>
</ul>

<p>要将一个对象转换为一个数字，JavaScript做同样的事情，但是它首先尝试valueOf()方法：</p>

<ul>
<li>如果对象的valueOf()方法返回原始值，JavaScript会将原始值转换为数字并返回结果。</li>
<li>否则，如果对象有一个toString()方法返回一个原始值，JavaScript将转换并返回该值。</li>
<li>否则JavaScript抛出TypeError。</li>
</ul>

<p>JavaScript中的+运算符执行数字加法和字符串连接。如果它的任何一个操作数是一个对象，JavaScript将使用一个特殊的对象到原始类型的转换来转换对象。==运算符是相似的。如果将对象与原始值进行比较，则使用对象到原始类型的转换转换对象。对于所有非日期的对象，对象到原始类型的转换基本上是对象到数字的转换（valueof()优先）。而对于Date类则使用对象到字符串的转换（toString()优先）。由valueOf()或toString()返回的原始值直接使用不用再转换为数字或字符串。</p>

<p>&lt;运算符和其他关系运算符执行对象到原始类型的转换时，任何对象都是通过先尝试valueOf()然后再尝试toString()来转换的。获得的任何原始值都直接使用，而无需进一步转换为数字或字符串。</p>

<p>只有+，==，!=和关系运算符是执行这种特殊的字符串到原始类型转换。其他操作符显示地转换为指定类型：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">now</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span> <span class="c1">// Create a Date object
</span><span class="c1"></span><span class="k">typeof</span> <span class="p">(</span><span class="nx">now</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// =&gt; &#34;string&#34;: + converts dates to strings
</span><span class="c1"></span><span class="k">typeof</span> <span class="p">(</span><span class="nx">now</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// =&gt; &#34;number&#34;: - uses object-to-number conversion
</span><span class="c1"></span><span class="nx">now</span> <span class="o">==</span> <span class="nx">now</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span> <span class="c1">// =&gt; true: implicit and explicit string conversions
</span><span class="c1"></span><span class="nx">now</span> <span class="o">&gt;</span> <span class="p">(</span><span class="nx">now</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// =&gt; true: &gt; converts a Date to a number
</span></code></pre></div>

<h3 id="变量声明">变量声明</h3>

<p>在JavaScript程序中使用变量之前，应该声明它。变量用var关键字声明，如下：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">i</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">sum</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">sum</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">message</span> <span class="o">=</span> <span class="s2">&#34;hello&#34;</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div>

<h4 id="重复和省略声明">重复和省略声明</h4>

<p>如果试图读取未声明变量的值，JavaScript将产生一个错误。在ES5严格模式下，给未声明的变量赋值也是一个错误。然而在非严格模式下，如果您为未声明的变量赋值，JavaScript实际上会创建该变量作为全局对象的属性，它的工作方式与正确声明的全局变量非常相似。</p>

<h3 id="变量作用域">变量作用域</h3>

<p>变量的作用域是定义变量的程序源代码的区域。全局变量具有全局作用域，JavaScript代码中到处都可见。函数中声明的变量只在函数体中定义。它们是局部变量，具有局部作用域。函数参数也算作局部变量，并且仅在函数体中定义。</p>

<p>在函数体中，局部变量优先于同名的全局变量。如果声明了一个与全局变量同名的局部变量或函数参数，则可以有效地隐藏全局变量：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">scope</span> <span class="o">=</span> <span class="s2">&#34;global&#34;</span><span class="p">;</span> <span class="c1">// Declare a global variable
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">checkscope</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">scope</span> <span class="o">=</span> <span class="s2">&#34;local&#34;</span><span class="p">;</span> <span class="c1">// Declare a local variable with the same name
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">scope</span><span class="p">;</span> <span class="c1">// Return the local value, not the global one
</span><span class="c1"></span><span class="p">}</span>
<span class="nx">checkscope</span><span class="p">()</span> <span class="c1">// =&gt; &#34;local&#34;
</span></code></pre></div>

<p>虽然在全局作用域内编写代码时可以避免使用var语句，但是必须始终使用var来声明局部变量：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">scope</span> <span class="o">=</span> <span class="s2">&#34;global&#34;</span><span class="p">;</span> <span class="c1">// Declare a global variable, even without var.
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">checkscope2</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">scope</span> <span class="o">=</span> <span class="s2">&#34;local&#34;</span><span class="p">;</span> <span class="c1">// Oops! We just changed the global variable.
</span><span class="c1"></span>    <span class="nx">myscope</span> <span class="o">=</span> <span class="s2">&#34;local&#34;</span><span class="p">;</span> <span class="c1">// This implicitly declares a new global variable.
</span><span class="c1"></span>    <span class="k">return</span> <span class="p">[</span><span class="nx">scope</span><span class="p">,</span> <span class="nx">myscope</span><span class="p">];</span> <span class="c1">// Return two values.
</span><span class="c1"></span><span class="p">}</span>
<span class="nx">checkscope2</span><span class="p">()</span> <span class="c1">// =&gt; [&#34;local&#34;, &#34;local&#34;]: has side effects!
</span><span class="c1"></span><span class="nx">scope</span> <span class="c1">// =&gt; &#34;local&#34;: global variable has changed.
</span><span class="c1"></span><span class="nx">myscope</span> <span class="c1">// =&gt; &#34;local&#34;: global namespace cluttered up.
</span></code></pre></div>

<p>函数定义可以嵌套。每个函数都有自己的局部作用域，因此可以有几个嵌套的局部作用域：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">scope</span> <span class="o">=</span> <span class="s2">&#34;global scope&#34;</span><span class="p">;</span> <span class="c1">// A global variable
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">checkscope</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">scope</span> <span class="o">=</span> <span class="s2">&#34;local scope&#34;</span><span class="p">;</span> <span class="c1">// A local variable
</span><span class="c1"></span>    <span class="kd">function</span> <span class="nx">nested</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">scope</span> <span class="o">=</span> <span class="s2">&#34;nested scope&#34;</span><span class="p">;</span> <span class="c1">// A nested scope of local variables
</span><span class="c1"></span>        <span class="k">return</span> <span class="nx">scope</span><span class="p">;</span> <span class="c1">// Return the value in scope here
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">nested</span><span class="p">();</span>
<span class="p">}</span>
<span class="nx">checkscope</span><span class="p">()</span> <span class="c1">// =&gt; &#34;nested scope&#34;
</span></code></pre></div>

<h4 id="函数作用域和提升">函数作用域和提升</h4>

<p>JavaScript的函数作用域意味着函数中声明的所有变量在函数体中都是可见的。这意味着变量在声明之前是可见的。JavaScript的这个特性通常被称为<strong>hoisting</strong>：函数中的所有变量声明，不包括赋值，都被“提升”到函数的顶部。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">scope</span> <span class="o">=</span> <span class="s2">&#34;global&#34;</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">scope</span><span class="p">);</span> <span class="c1">// Prints &#34;undefined&#34;, not &#34;global&#34;
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">scope</span> <span class="o">=</span> <span class="s2">&#34;local&#34;</span><span class="p">;</span> <span class="c1">// Variable initialized here, but defined everywhere
</span><span class="c1"></span>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">scope</span><span class="p">);</span> <span class="c1">// Prints &#34;local&#34;
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<h4 id="变量作为属性">变量作为属性</h4>

<p>当你声明一个全局JavaScript变量，你实际上做的是定义一个全局对象的属性，如果你使用var声明变量，创建的属性是不可配置的，这意味着它不能被删除。如果不使用严格模式，并且为未声明的变量赋值，JavaScript会自动为您创建一个全局变量。以这种方式创建的变量是全局对象的常规可配置属性，可以删除它们：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">truevar</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// A properly declared global variable, nondeletable.
</span><span class="c1"></span><span class="nx">fakevar</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// Creates a deletable property of the global object.
</span><span class="c1"></span><span class="k">this</span><span class="p">.</span><span class="nx">fakevar2</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// This does the same thing.
</span><span class="c1"></span><span class="k">delete</span> <span class="nx">truevar</span> <span class="c1">// =&gt; false: variable not deleted
</span><span class="c1"></span><span class="k">delete</span> <span class="nx">fakevar</span> <span class="c1">// =&gt; true: variable deleted
</span><span class="c1"></span><span class="k">delete</span> <span class="k">this</span><span class="p">.</span><span class="nx">fakevar2</span> <span class="c1">// =&gt; true: variable deleted
</span></code></pre></div>

<p>JavaScript允许我们使用this关键字引用全局对象，但它没有提供任何方式引用存储本地变量的对象。</p>

<h4 id="作用域链">作用域链</h4>

<p>如果我们认为局部变量是某种对象的属性，那么还有另一种考虑变量作用域的方法。每个JavaScript代码块（全局代码或函数）都有一个关联的作用域链。这个作用域链是一个对象链，它定义了代码的作用域内的变量。当JavaScript需要查找变量x的值时，它首先查看链中的第一个对象。如果该对象有一个名为x的属性，则使用该属性的值。如果第一个对象没有名为x的属性，JavaScript将继续使用链中的下一个对象进行搜索。如果第二个对象没有一个名为x的属性，则搜索继续到下一个对象，依此类推。如果x不是作用域链中任何对象的属性，则x不在该代码的作用域内，并产生ReferenceError。</p>

<p>理解如何创建这个对象链是很重要的。当一个函数被定义时，它存储有效作用域链。当调用该函数时，它创建一个新对象来存储其本地变量，并将该新对象添加到存储的作用域链中，以创建一个新的、更长的、表示该函数调用作用域的链。对于嵌套函数来说，这变得更加有趣，因为每次调用外部函数时，都会重新定义内部函数。由于作用域链在每次调用外部函数时都不同，每次定义内部函数时，内部函数都会略有不同——每次调用外部函数时，内部函数的代码都相同，但与该代码关联的作用域链会不同。</p>
]]></content>
		</item>
		
		<item>
			<title>词法结构</title>
			<link>https://gitop.cc/posts/lexical_structure/</link>
			<pubDate>Tue, 16 Oct 2018 08:29:23 +0800</pubDate>
			
			<guid>https://gitop.cc/posts/lexical_structure/</guid>
			<description>介绍 JavaScript是一门大小写敏感的语言 JavaScript程序使用Unicode字符集编写 JavaScript使用\u后跟4位16进</description>
			<content type="html"><![CDATA[

<h3 id="介绍">介绍</h3>

<ul>
<li>JavaScript是一门大小写敏感的语言</li>
<li>JavaScript程序使用Unicode字符集编写</li>
<li>JavaScript使用\u后跟4位16进制数字代表任何16位Unicode码点</li>
</ul>

<h3 id="字面值">字面值</h3>

<p>字面值是程序中直接出现的数据值，下列这些都是字面值：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="mi">12</span>				<span class="c1">// The number twelve
</span><span class="c1"></span><span class="mf">1.2</span> 			<span class="c1">// The number one point two
</span><span class="c1"></span><span class="s2">&#34;hello world&#34;</span>	<span class="c1">// A string of text
</span><span class="c1"></span><span class="s1">&#39;Hi&#39;</span> 			<span class="c1">// Another string
</span><span class="c1"></span><span class="kc">true</span> 			<span class="c1">// A Boolean value
</span><span class="c1"></span><span class="kc">false</span> 			<span class="c1">// The other Boolean value
</span><span class="c1"></span><span class="sr">/javascript/gi</span>	<span class="c1">// A &#34;regular expression&#34; literal (for pattern matching)
</span><span class="c1"></span><span class="kc">null</span> 			<span class="c1">// Absence of an object
</span><span class="c1"></span><span class="p">{</span> <span class="nx">x</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span><span class="mi">2</span> <span class="p">}</span> 	<span class="c1">// An object initializer
</span><span class="c1"></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> 	<span class="c1">// An array initializer
</span></code></pre></div>

<h3 id="标识符和保留字">标识符和保留字</h3>

<p><strong>标识符</strong>必须以字母，下划线(_)，或美元符($)开头，后续字符可以是字母，数字，下划线或美元符。</p>

<p><strong>关键字</strong></p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">break</span>		<span class="k">delete</span>	<span class="kd">function</span> 	<span class="k">return</span> 	<span class="k">typeof</span>
<span class="k">case</span> 		<span class="k">do</span> 		<span class="k">if</span> 			<span class="k">switch</span> 	<span class="kd">var</span>
<span class="k">catch</span> 		<span class="k">else</span> 	<span class="k">in</span> 			<span class="k">this</span> 	<span class="k">void</span>
<span class="k">continue</span>	<span class="kc">false</span>	<span class="k">instanceof</span>	<span class="k">throw</span>	<span class="k">while</span>
<span class="kr">debugger</span> 	<span class="k">finally</span>	<span class="k">new</span> 		<span class="kc">true</span> 	<span class="kd">with</span>
<span class="k">default</span> 	<span class="k">for</span> 	<span class="kc">null</span> 		<span class="k">try</span>
</code></pre></div>

<p>JavaScript也保留了一些当前未使用但是未来可能会用到的关键字。ES5保留了下面的关键字：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">class</span>	<span class="kr">const</span>	<span class="kr">enum</span>	<span class="kr">export</span>	<span class="kr">extends</span>	<span class="kr">import</span>	<span class="kr">super</span>
</code></pre></div>

<p>此外，下列这些词在普通的Javascript代码中是合法的，但是在严格模式下被保留：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">implements</span>	<span class="kd">let</span> 	<span class="kr">private</span> 	<span class="kr">public</span>	<span class="k">yield</span>
<span class="kr">interface</span> 	<span class="kr">package</span>	<span class="kr">protected</span> 	<span class="kr">static</span>
</code></pre></div>

<p>严格模式还对以下标识符施加限制。它们没有完全被保留，但是不允许用作变量，函数名或参数名：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">arguments</span>	<span class="nb">eval</span>
</code></pre></div>

<p>ES3保留了所有Java语言的关键字，虽然在ES5中放松了，但是如果想要代码能在ES3下运行，你仍应该避免使用这些标识符：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">abstract</span>	<span class="kr">double</span> 	<span class="kr">goto</span> 		<span class="kr">native</span> 		<span class="kr">static</span>
<span class="kr">boolean</span> 	<span class="kr">enum</span> 	<span class="kr">implements</span>	<span class="kr">package</span> 	<span class="kr">super</span>
<span class="kr">byte</span> 		<span class="kr">export</span> 	<span class="kr">import</span> 		<span class="kr">private</span> 	<span class="kr">synchronized</span>
<span class="kr">char</span> 		<span class="kr">extends</span>	<span class="kr">int</span> 		<span class="kr">protected</span>	<span class="kr">throws</span>
<span class="kr">class</span> 		<span class="kr">final</span> 	<span class="kr">interface</span> 	<span class="kr">public</span> 		<span class="kr">transient</span>
<span class="kr">const</span> 		<span class="kr">float</span> 	<span class="kr">long</span> 		<span class="kr">short</span> 		<span class="kr">volatile</span>
</code></pre></div>

<p>JavaScript预定义了很多全局变量和函数，你应该避免使用它们作为自己的变量或函数名：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">arguments</span> 			<span class="nb">encodeURI</span> 			<span class="kc">Infinity</span> 	<span class="nb">Number</span> 			<span class="nb">RegExp</span>
<span class="nb">Array</span> 				<span class="nb">encodeURIComponent</span>	<span class="nb">isFinite</span>	<span class="nb">Object</span> 			<span class="nb">String</span>
<span class="nb">Boolean</span> 			<span class="nb">Error</span> 				<span class="nb">isNaN</span> 		<span class="nb">parseFloat</span> 		<span class="nx">SyntaxError</span>
<span class="nb">Date</span> 				<span class="nb">eval</span> 				<span class="nx">JSON</span> 		<span class="nb">parseInt</span> 		<span class="nx">TypeError</span>
<span class="nb">decodeURI</span> 			<span class="nx">EvalError</span> 			<span class="nb">Math</span> 		<span class="nx">RangeError</span> 		<span class="kc">undefined</span>
<span class="nb">decodeURIComponent</span>	<span class="nb">Function</span> 			<span class="kc">NaN</span> 		<span class="nx">ReferenceError</span>	<span class="nx">URIError</span>
</code></pre></div>

<h3 id="可选的分号">可选的分号</h3>

<p>JavaScript不会将每个换行符当成分号，如果下一个非空字符不能解释成当前语句的延续时，Javascript将换行当成分号。如果一个语句以(，[，/，+，或-开头，就有可能被解释成上一个语句的延续。下面是2个例外：</p>

<p><strong>return，break和continue语句</strong>，Javascript总是将它们后面的换行符当成分号。</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">return</span>
<span class="kc">true</span><span class="p">;</span>
</code></pre></div>

<p>JavaScript认为是：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">return</span><span class="p">;</span> <span class="kc">true</span><span class="p">;</span>
</code></pre></div>

<p><strong>++和&ndash;操作符</strong>，这些操作可以是前缀操作符或后缀操作符。如果你想使用它们作为后缀操作符，那么它们必须出现在它们所应用的表达式同一行上。否则换行符会被当做分号，而++或&ndash;将被解释为作用于后面代码的前置操作符。比如：</p>

<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">x</span>
<span class="o">++</span>
<span class="nx">y</span>
</code></pre></div>

<p>被解释为<code>x; ++y;</code>，而不是<code>x++; y</code>。</p>
]]></content>
		</item>
		
		<item>
			<title>docker安装greenplum集群</title>
			<link>https://gitop.cc/posts/install-greenplum-in-docker/</link>
			<pubDate>Tue, 21 Aug 2018 19:15:14 +0800</pubDate>
			
			<guid>https://gitop.cc/posts/install-greenplum-in-docker/</guid>
			<description>本文参考这里安装greenplum成功，并记录一下过程 创建docker节点 拉取centos镜像 [xiaoyu@xiaoyu ~]$ docker pull centos 创建几个容器，作为greenplum</description>
			<content type="html"><![CDATA[

<p>本文参考<a href="https://my.oschina.net/u/876354/blog/1606419">这里</a>安装greenplum成功，并记录一下过程</p>

<h2 id="创建docker节点">创建docker节点</h2>

<p>拉取centos镜像</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>xiaoyu@xiaoyu ~<span class="o">]</span>$ docker pull centos</code></pre></div>

<p>创建几个容器，作为greenplum的节点</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>xiaoyu@xiaoyu ~<span class="o">]</span>$ docker run -it --name gp-master centos /bin/bash
<span class="o">[</span>xiaoyu@xiaoyu ~<span class="o">]</span>$ docker run -it --name gp-segment1 centos /bin/bash
<span class="o">[</span>xiaoyu@xiaoyu ~<span class="o">]</span>$ docker run -it --name gp-segment2 centos /bin/bash
<span class="o">[</span>xiaoyu@xiaoyu ~<span class="o">]</span>$ docker run -it --name gp-segment3 centos /bin/bash</code></pre></div>

<h2 id="配置基础环境">配置基础环境</h2>

<p>进入每个greenplum节点，配置基础环境</p>

<ul>
<li>安装相关的依赖包</li>
</ul>

<p>由于docker的centos镜像是centos的简化版本，里面有很多包是没有安装的，会影响到后面部署greenplum，因此在docker的每个节点中安装相关的依赖包</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>root@00bcc0ba2b3f ~<span class="o">]</span><span class="c1"># yum install -y net-tools which openssh-clients openssh-server less zip unzip iproute</span></code></pre></div>

<ul>
<li>启动ssh</li>
</ul>

<p>docker中默认没有启动ssh，为了方便各节点之间的互连，创建相关的认证key，并启动docker的每个节点里面的ssh</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>root@00bcc0ba2b3f ~<span class="o">]</span><span class="c1"># ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key</span>
<span class="o">[</span>root@00bcc0ba2b3f ~<span class="o">]</span><span class="c1"># ssh-keygen -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key</span>
<span class="o">[</span>root@00bcc0ba2b3f ~<span class="o">]</span><span class="c1"># ssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key</span>
<span class="o">[</span>root@00bcc0ba2b3f ~<span class="o">]</span><span class="c1"># /usr/sbin/sshd</span></code></pre></div>

<ul>
<li>修改/etc/hosts文件</li>
</ul>

<p>在每个docker节点中添加如下配置，方便后续greenplum集群的配置文件中用到，ip为各个docker节点中的ip地址</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>root@00bcc0ba2b3f ~<span class="o">]</span><span class="c1"># vi /etc/hosts</span>
<span class="m">172</span>.17.0.2 dw-greenplum-1 mdw
<span class="m">172</span>.17.0.3 dw-greenplum-2 sdw1
<span class="m">172</span>.17.0.4 dw-greenplum-3 sdw2
<span class="m">172</span>.17.0.5 dw-greenplum-4 sdw3</code></pre></div>

<p>同时修改所有节点里面的<code>/etc/sysconfig/network</code>文件，保持与主机名一致</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>root@00bcc0ba2b3f ~<span class="o">]</span><span class="c1"># vi /etc/sysconfig/network</span>
<span class="nv">NETWORKING</span><span class="o">=</span>yes
<span class="nv">HOSTNAME</span><span class="o">=</span>mdw</code></pre></div>

<ul>
<li>创建greenplum的用户和用户组</li>
</ul>

<p>为了方便安装greenplum集群，且使greenplum自带的python不与系统的python版本相冲突，在每个节点中创建greenplum的用户和用户组</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>root@00bcc0ba2b3f ~<span class="o">]</span><span class="c1"># groupadd -g 530 gpadmin</span>
<span class="o">[</span>root@00bcc0ba2b3f ~<span class="o">]</span><span class="c1"># useradd -g 530 -u 530 -m -d /home/gpadmin -s /bin/bash gpadmin</span>
<span class="o">[</span>root@00bcc0ba2b3f ~<span class="o">]</span><span class="c1"># chown -R gpadmin:gpadmin /home/gpadmin</span>
<span class="o">[</span>root@00bcc0ba2b3f ~<span class="o">]</span><span class="c1"># passwd gpadmin</span></code></pre></div>

<ul>
<li>修改每个节点上的文件打开数量限制</li>
</ul>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>root@00bcc0ba2b3f ~<span class="o">]</span><span class="c1"># vi /etc/security/limits.conf</span>
<span class="c1"># End of file</span>
* soft nofile <span class="m">65536</span>
* hard nofile <span class="m">65536</span>
* soft nproc <span class="m">131072</span>
* hard nproc <span class="m">131072</span></code></pre></div>

<ul>
<li>关闭每个节点上的防火墙，关闭selinux</li>
</ul>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>root@00bcc0ba2b3f ~<span class="o">]</span><span class="c1"># service iptables stop</span>
<span class="o">[</span>root@00bcc0ba2b3f ~<span class="o">]</span><span class="c1"># chkconfig iptables off</span>
<span class="o">[</span>root@00bcc0ba2b3f ~<span class="o">]</span><span class="c1"># vi /etc/selinux/config</span> 
<span class="c1"># This file controls the state of SELinux on the system.</span>
<span class="c1"># SELINUX= can take one of these three values:</span>
<span class="c1">#     enforcing - SELinux security policy is enforced.</span>
<span class="c1">#     permissive - SELinux prints warnings instead of enforcing.</span>
<span class="c1">#     disabled - No SELinux policy is loaded.</span>
<span class="nv">SELINUX</span><span class="o">=</span>disabled
<span class="c1"># SELINUXTYPE= can take one of these two values:</span>
<span class="c1">#     targeted - Targeted processes are protected,</span>
<span class="c1">#     mls - Multi Level Security protection.</span>
<span class="nv">SELINUXTYPE</span><span class="o">=</span>targeted </code></pre></div>

<h2 id="下载greenplum安装包">下载greenplum安装包</h2>

<p>到greenplum的官网上，下载<a href="https://network.pivotal.io/products/pivotal-gpdb">greenplum安装包</a>，点开Greenplum Database Server，根据自己的操作系统下载安装包，我下载当前最新的greenplum-db-5.10.2-rhel7-x86_64.zip，将其拷到master节点的<code>/home/gpadmin</code>目录中</p>

<h2 id="在master节点上安装greenplum">在master节点上安装greenplum</h2>

<p>切换到gpadmin用户</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>root@00bcc0ba2b3f ~<span class="o">]</span><span class="c1"># su gpadmin</span></code></pre></div>

<p>解压下载后的zip文件</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>gpadmin@mdw ~<span class="o">]</span>$ unzip greenplum-db-5.10.2-rhel7-x86_64.zip</code></pre></div>

<p>执行安装文件</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>gpadmin@mdw ~<span class="o">]</span>$ ./greenplum-db-5.10.2-rhel7-x86_64.bin</code></pre></div>

<p>安装期间需要配置安装目录，输入<code>/home/gpadmin/greenplum-db-5.10.2</code></p>

<p>为了方便安装集群，greenplum提供了批量操作节点的命令，通过指定配置文件使用批处理命令</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>gpadmin@mdw ~<span class="o">]</span>$ vi ./conf/hostlist 
mdw
sdw1
sdw2
sdw3
<span class="o">[</span>gpadmin@mdw ~<span class="o">]</span>$ vi ./conf/seg_hosts 
sdw1
sdw2
sdw3</code></pre></div>

<p><code>greenplum-db/greenplum_path.sh</code>中保存了运行greenplum的一些环境变量，包括GPHOME、PYTHONHOME等，在gpadmin账号下设置环境变量，并将master节点的key交换到各个segment节点</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>gpadmin@mdw ~<span class="o">]</span>$ <span class="nb">source</span> /home/gpadmin/greenplum-db/greenplum_path.sh 
<span class="o">[</span>gpadmin@mdw ~<span class="o">]</span>$ gpssh-exkeys -f /home/gpadmin/conf/hostlist
<span class="o">[</span>STEP <span class="m">1</span> of <span class="m">5</span><span class="o">]</span> create <span class="nb">local</span> ID and authorize on <span class="nb">local</span> host

<span class="o">[</span>STEP <span class="m">2</span> of <span class="m">5</span><span class="o">]</span> keyscan all hosts and update known_hosts file

<span class="o">[</span>STEP <span class="m">3</span> of <span class="m">5</span><span class="o">]</span> authorize current user on remote hosts
  ... send to mdw
  ... send to sdw1
  ***
  *** Enter password <span class="k">for</span> sdw1: 
  ... send to sdw2
  ... send to sdw3

<span class="o">[</span>STEP <span class="m">4</span> of <span class="m">5</span><span class="o">]</span> determine common authentication file content

<span class="o">[</span>STEP <span class="m">5</span> of <span class="m">5</span><span class="o">]</span> copy authentication files to all remote hosts
  ... finished key exchange with mdw
  ... finished key exchange with sdw1
  ... finished key exchange with sdw2
  ... finished key exchange with sdw3

<span class="o">[</span>INFO** completed successfully</code></pre></div>

<p>交换成功后，后续就可以使用一些命令执行批量操作</p>

<p><strong>注意</strong>：使用gpssh-exkeys命令时一定要使用gpadmin用户，因为会在<code>/home/gpadmin/.ssh</code>中生成ssh的免密码登录秘钥，如果使用其它账号登录，则会在其它账号下生成密钥，在gpadmin账号下就无法使用gpssh的批处理命令</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>gpadmin@mdw ~<span class="o">]</span>$ gpssh -f /home/gpadmin/conf/hostlist
<span class="o">=</span>&gt; <span class="nb">pwd</span>
<span class="o">[</span>sdw1<span class="o">]</span> /home/gpadmin
<span class="o">[</span>sdw3<span class="o">]</span> /home/gpadmin
<span class="o">[</span> mdw<span class="o">]</span> /home/gpadmin
<span class="o">[</span>sdw2<span class="o">]</span> /home/gpadmin
<span class="o">=</span>&gt; ls
<span class="o">[</span>sdw1<span class="o">]</span>
<span class="o">[</span>sdw3<span class="o">]</span>
<span class="o">[</span> mdw<span class="o">]</span> conf  greenplum-db  greenplum-db-5.10.2
<span class="o">[</span>sdw2<span class="o">]</span>
<span class="o">=</span>&gt; exit</code></pre></div>

<p>pwd命令是linux中的查看路径命令，在这里也是查看批量操作时各个节点当前所在的路径，从中可以看到已经成功连通了4个节点</p>

<h2 id="分发安装包到每个子节点">分发安装包到每个子节点</h2>

<p>打包master节点上的安装包</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>gpadmin@mdw ~<span class="o">]</span>$ tar -czf gp.tar.gz greenplum-db-5.10.2</code></pre></div>

<p>使用gpscp命令将这个文件复制到每个子节点</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>gpadmin@mdw ~<span class="o">]</span>$ gpscp -f /home/gpadmin/conf/seg_hosts gp.tar.gz <span class="o">=</span>:/home/gpadmin</code></pre></div>

<p>批量解压，并创建软链接</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>gpadmin@mdw ~<span class="o">]</span>$ gpssh -f /home/gpadmin/conf/seg_hosts
<span class="o">=</span>&gt; tar -zxf gp.tar.gz
<span class="o">[</span>sdw3<span class="o">]</span>
<span class="o">[</span>sdw1<span class="o">]</span>
<span class="o">[</span>sdw2<span class="o">]</span>
<span class="o">=</span>&gt; ln -s greenplum-db-5.10.2 greenplum-db
<span class="o">[</span>sdw3<span class="o">]</span>
<span class="o">[</span>sdw2<span class="o">]</span>
<span class="o">[</span>sdw1<span class="o">]</span></code></pre></div>

<p>这样就完成了所有子节点数据库的安装</p>

<h2 id="初始化安装数据库">初始化安装数据库</h2>

<ul>
<li>批量创建数据目录</li>
</ul>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>gpadmin@mdw ~<span class="o">]</span>$ gpssh -f /home/gpadmin/conf/hostlist
<span class="o">=</span>&gt; mkdir gpdata
<span class="o">[</span>sdw1<span class="o">]</span>
<span class="o">[</span>sdw3<span class="o">]</span>
<span class="o">[</span> mdw<span class="o">]</span>
<span class="o">[</span>sdw2<span class="o">]</span>
<span class="o">=</span>&gt; <span class="nb">cd</span> gpdata
<span class="o">[</span>sdw1<span class="o">]</span>
<span class="o">[</span>sdw3<span class="o">]</span>
<span class="o">[</span> mdw<span class="o">]</span>
<span class="o">[</span>sdw2<span class="o">]</span>
<span class="o">=</span>&gt; mkdir gpmaster gpdatap1 gpdatap2 gpdatam1 gpdatam2
<span class="o">[</span>sdw1<span class="o">]</span>
<span class="o">[</span>sdw3<span class="o">]</span>
<span class="o">[</span> mdw<span class="o">]</span>
<span class="o">[</span>sdw2<span class="o">]</span>
<span class="o">=</span>&gt; exit</code></pre></div>

<ul>
<li>在master节点上修改<code>.bash_profile</code>配置环境变量，并发送给其他子节点，确保这些环境变量生效</li>
</ul>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>gpadmin@mdw ~<span class="o">]</span>$ vi .bash_profile 
<span class="nb">source</span> /opt/gpadmin/greenplum-db/greenplum_path.sh
<span class="nb">export</span> <span class="nv">MASTER_DATA_DIRECTORY</span><span class="o">=</span>/home/gpadmin/gpdata/gpmaster/gpseg-1
<span class="nb">export</span> <span class="nv">PGPORT</span><span class="o">=</span><span class="m">2345</span>
<span class="nb">export</span> <span class="nv">PGDATABASE</span><span class="o">=</span>testDB
<span class="o">[</span>gpadmin@mdw ~<span class="o">]</span>$ <span class="nb">source</span> .bash_profile
<span class="o">[</span>gpadmin@mdw ~<span class="o">]</span>$ gpscp -f /home/gpadmin/conf/seg_hosts /home/gpadmin/.bash_profile
<span class="o">[</span>gpadmin@sdw1 ~<span class="o">]</span>$ <span class="nb">source</span> .bash_profile
<span class="o">[</span>gpadmin@sdw2 ~<span class="o">]</span>$ <span class="nb">source</span> .bash_profile
<span class="o">[</span>gpadmin@sdw3 ~<span class="o">]</span>$ <span class="nb">source</span> .bash_profile</code></pre></div>

<ul>
<li>初始化配置文件</li>
</ul>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>gpadmin@mdw ~<span class="o">]</span>$ vi /home/gpadmin/conf/gpinitsystem_config
<span class="nv">ARRAY_NAME</span><span class="o">=</span><span class="s2">&#34;Greenplum&#34;</span>
<span class="nv">MACHINE_LIST_FILE</span><span class="o">=</span>/home/gpadmin/conf/seg_hosts

<span class="c1"># Segment 的名称前缀</span>
<span class="nv">SEG_PREFIX</span><span class="o">=</span>gpseg
<span class="c1"># Primary Segment 起始的端口号</span>
<span class="nv">PORT_BASE</span><span class="o">=</span><span class="m">33000</span>
<span class="c1"># 指定 Primary Segment 的数据目录</span>
<span class="nb">declare</span> -a <span class="nv">DATA_DIRECTORY</span><span class="o">=(</span>/home/gpadmin/gpdata/gpdatap1 /home/gpadmin/gpdata/gpdatap2<span class="o">)</span>
<span class="c1"># Master 所在机器的 Hostname</span>
<span class="nv">MASTER_HOSTNAME</span><span class="o">=</span>mdw
<span class="c1"># 指定 Master 的数据目录</span>
<span class="nv">MASTER_DIRECTORY</span><span class="o">=</span>/home/gpadmin/gpdata/gpmaster
<span class="c1"># Master 的端口</span> 
<span class="nv">MASTER_PORT</span><span class="o">=</span><span class="m">2345</span>
<span class="c1"># 指定Bash的版本</span>
<span class="nv">TRUSTED_SHELL</span><span class="o">=</span>/usr/bin/ssh
<span class="c1"># Mirror Segment起始的端口号</span>
<span class="nv">MIRROR_PORT_BASE</span><span class="o">=</span><span class="m">43000</span>
<span class="c1"># Primary Segment 主备同步的起始端口号</span>
<span class="nv">REPLICATION_PORT_BASE</span><span class="o">=</span><span class="m">34000</span>
<span class="c1"># Mirror Segment 主备同步的起始端口号</span>
<span class="nv">MIRROR_REPLICATION_PORT_BASE</span><span class="o">=</span><span class="m">44000</span>
<span class="c1"># Mirror Segment 的数据目录</span>
<span class="nb">declare</span> -a <span class="nv">MIRROR_DATA_DIRECTORY</span><span class="o">=(</span>/home/gpadmin/gpdata/gpdatam1 /home/gpadmin/gpdata/gpdatam2<span class="o">)</span></code></pre></div>

<ul>
<li>初始化数据库</li>
</ul>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>gpadmin@mdw ~<span class="o">]</span>$ gpinitsystem -c /home/gpadmin/conf/gpinitsystem_config -s sdw3</code></pre></div>

<p>其中，<code>-s sdw3</code>是指配置master的standby节点，然后按照提示步骤就能完成安装了</p>

<p>如果gpinitsystem不成功，在master节点的<code>/home/gpadmin/gpAdminLogs</code>目录下gpinitsystem_*.log文件中查看日志信息，找出原因进行修改，然后再重新执行gpinitsystem进行初始化安装</p>
]]></content>
		</item>
		
		<item>
			<title>Idea快捷键</title>
			<link>https://gitop.cc/posts/idea-key-bindings/</link>
			<pubDate>Sat, 18 Aug 2018 16:15:19 +0800</pubDate>
			
			<guid>https://gitop.cc/posts/idea-key-bindings/</guid>
			<description>编辑基础 快捷键 说明 Ctrl+Shift+向右箭头 向右选择一个单词 Ctrl+Shift+向左箭头 向左选择一个单词 Alt+Shift+向上箭头 逐</description>
			<content type="html"><![CDATA[

<h2 id="编辑基础">编辑基础</h2>

<table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>Ctrl+Shift+向右箭头</td>
<td>向右选择一个单词</td>
</tr>

<tr>
<td>Ctrl+Shift+向左箭头</td>
<td>向左选择一个单词</td>
</tr>

<tr>
<td>Alt+Shift+向上箭头</td>
<td>逐级选择一个代码块</td>
</tr>

<tr>
<td>Alt+Shift+向下箭头</td>
<td>逐级缩小代码块选择</td>
</tr>

<tr>
<td>Shift+向下箭头</td>
<td>向下选择多行</td>
</tr>

<tr>
<td>Shift+向上箭头</td>
<td>向上选择多行</td>
</tr>

<tr>
<td>Ctrl+A</td>
<td>选择整个文件</td>
</tr>

<tr>
<td>Ctrl+/</td>
<td>注释一行或多行/取消注释</td>
</tr>

<tr>
<td>Ctrl+D</td>
<td>删除行</td>
</tr>

<tr>
<td>Ctrl+Z</td>
<td>撤销</td>
</tr>

<tr>
<td>菜单Editor-&gt;Duplicate Line</td>
<td>重复一行或多行</td>
</tr>

<tr>
<td>菜单Code-&gt;Move Line Down</td>
<td>向下移动一行</td>
</tr>

<tr>
<td>菜单Code-&gt;Move Line Up</td>
<td>向上移动一行</td>
</tr>

<tr>
<td>Alt+向上箭头</td>
<td>向上移动整个语句</td>
</tr>

<tr>
<td>Alt+向下箭头</td>
<td>向下移动整个语句</td>
</tr>

<tr>
<td>Ctrl+NumPad-</td>
<td>代码折叠</td>
</tr>

<tr>
<td>Ctrl+NumPad+</td>
<td>代码展开</td>
</tr>

<tr>
<td>Ctrl+Shift+NumPad/</td>
<td>折叠所有代码</td>
</tr>

<tr>
<td>Ctrl+NumPad*</td>
<td>展开所有代码</td>
</tr>

<tr>
<td>Alt+Y</td>
<td>选择多个相同字符</td>
</tr>

<tr>
<td>Alt+Shift+Y</td>
<td>取消上一个选择字符</td>
</tr>

<tr>
<td>Ctrl+Alt+Y</td>
<td>选择文件中出现的所有相同字符</td>
</tr>
</tbody>
</table>

<h2 id="代码补全"><strong>代码补全</strong></h2>

<table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>Ctrl+空格</td>
<td>基础补全</td>
</tr>

<tr>
<td>Alt+Shift+空格</td>
<td>列出可行的候选项</td>
</tr>

<tr>
<td>Ctrl+Shift+Enter</td>
<td>语句补全</td>
</tr>

<tr>
<td>Tab</td>
<td>选择候选项</td>
</tr>
</tbody>
</table>

<h2 id="重构">重构</h2>

<table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>Alt+Shift+R</td>
<td>重命名（成员变量修改后，IDEA会自动提醒修改getter方法）</td>
</tr>

<tr>
<td>Alt+Shift+L</td>
<td>提取变量或域</td>
</tr>

<tr>
<td>Alt+Shift+M</td>
<td>提取方法</td>
</tr>

<tr>
<td>Ctrl+Alt+C</td>
<td>提取表达式为常量</td>
</tr>

<tr>
<td>Ctrl+Alt+P</td>
<td>提取表达式为函数参数</td>
</tr>
</tbody>
</table>

<h2 id="代码助手">代码助手</h2>

<table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>Ctrl+Shift+F</td>
<td>格式化代码</td>
</tr>

<tr>
<td>菜单View-&gt;Parameter Info</td>
<td>查看参数信息</td>
</tr>

<tr>
<td>F2</td>
<td>查看文档信息</td>
</tr>

<tr>
<td>Esc</td>
<td>关闭弹出框</td>
</tr>

<tr>
<td>Ctrl+Shift+I</td>
<td>查看定义</td>
</tr>

<tr>
<td>菜单Navigate-&gt;Next Highlighted Error</td>
<td>查看下一个高亮错误</td>
</tr>

<tr>
<td>Alt+Enter</td>
<td>修复错误</td>
</tr>

<tr>
<td>Alt+Shift+Z</td>
<td>用语句块包含代码</td>
</tr>

<tr>
<td>Alt+Shift+O</td>
<td>高亮代码中所有相同的字符</td>
</tr>
</tbody>
</table>

<h2 id="代码导航">代码导航</h2>

<table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>F12</td>
<td>查看源码</td>
</tr>

<tr>
<td>F3</td>
<td>查看声明</td>
</tr>

<tr>
<td>Ctrl+T</td>
<td>查看实现</td>
</tr>

<tr>
<td>Ctrl+F3</td>
<td>查看源文件结构</td>
</tr>

<tr>
<td>Enter或Ctrl+K</td>
<td>查找下一个</td>
</tr>

<tr>
<td>Ctrl+Shift+K</td>
<td>查找上一个</td>
</tr>
</tbody>
</table>
]]></content>
		</item>
		
		<item>
			<title>Ubuntu 18.04</title>
			<link>https://gitop.cc/posts/ubuntu-18.04/</link>
			<pubDate>Sat, 18 Aug 2018 09:19:20 +0800</pubDate>
			
			<guid>https://gitop.cc/posts/ubuntu-18.04/</guid>
			<description>Ubuntu 18.04安装后做的事情 安装openssh-server sudo apt install openssh-server 安装curl sudo apt install curl 安装git sudo apt install git 安装zsh sudo apt install zsh 安装oh my zsh sh -c &amp;#34;$(curl</description>
			<content type="html"><![CDATA[

<h2 id="ubuntu-18-04安装后做的事情">Ubuntu 18.04安装后做的事情</h2>

<h3 id="安装openssh-server">安装openssh-server</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo apt install openssh-server</code></pre></div>

<h3 id="安装curl">安装curl</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo apt install curl</code></pre></div>

<h3 id="安装git">安装git</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo apt install git</code></pre></div>

<h3 id="安装zsh">安装zsh</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo apt install zsh</code></pre></div>

<p>安装<code>oh my zsh</code></p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sh -c <span class="s2">&#34;</span><span class="k">$(</span>curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh<span class="k">)</span><span class="s2">&#34;</span></code></pre></div>

<h3 id="安装jdk">安装JDK</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo apt install openjdk-11-jdk
sudo apt install openjdk-8-jdk</code></pre></div>

<h3 id="安装svn">安装SVN</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo apt install subversion</code></pre></div>

<h3 id="安装mariadb">安装mariadb</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo apt install mariadb-server</code></pre></div>

<h3 id="安装vim">安装Vim</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo apt install vim</code></pre></div>

<h3 id="安装emacs">安装emacs</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo apt install emacs</code></pre></div>

<h3 id="安装nginx">安装nginx</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo apt install nginx</code></pre></div>

<h3 id="安装redis">安装redis</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo apt install redis</code></pre></div>

<h3 id="安装tomcat">安装tomcat</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo apt install tomcat8</code></pre></div>

<h3 id="安装keepassx2">安装keepassx2</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo apt install keepassx</code></pre></div>

<h3 id="安装chromium">安装chromium</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo apt install chromium-browser</code></pre></div>

<h3 id="安装shadowsocks客户端">安装shadowsocks客户端</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo apt install python3-pip
sudo pip3 install shadowsocks</code></pre></div>

<h3 id="安装git-cola">安装git-cola</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo apt install git-cola</code></pre></div>

<h3 id="安装ibus-pinyin">安装ibus-pinyin</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo apt install ibus-pinyin</code></pre></div>

<h3 id="安装typora">安装typora</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE
sudo add-apt-repository <span class="s1">&#39;deb https://typora.io/linux ./&#39;</span>
sudo apt-get install typora</code></pre></div>
]]></content>
		</item>
		
		<item>
			<title>Centos7环境配置</title>
			<link>https://gitop.cc/posts/centos7-environment-setup/</link>
			<pubDate>Thu, 02 Aug 2018 20:31:02 +0800</pubDate>
			
			<guid>https://gitop.cc/posts/centos7-environment-setup/</guid>
			<description>开启EPEL仓库 EPEL(Extra Packages for Enterprise Linux)是Fedora小组维护的一个软件仓库项目，为RHEL/CentOS提供他们默认不提供的软件包。 wget http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm sudo rpm -ivh</description>
			<content type="html"><![CDATA[

<h3 id="开启epel仓库">开启EPEL仓库</h3>

<p>EPEL(Extra Packages for Enterprise Linux)是Fedora小组维护的一个软件仓库项目，为RHEL/CentOS提供他们默认不提供的软件包。</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">wget http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm
sudo rpm -ivh epel-release-latest-7.noarch.rpm
sudo yum update</code></pre></div>

<h3 id="安装git">安装git</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo yum install git</code></pre></div>

<h3 id="安装zsh">安装zsh</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo yum install zsh</code></pre></div>

<p>安装<code>oh my zsh</code></p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sh -c <span class="s2">&#34;</span><span class="k">$(</span>curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh<span class="k">)</span><span class="s2">&#34;</span></code></pre></div>

<h3 id="安装开发工具">安装开发工具</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo yum groupinstall <span class="s2">&#34;Development Tools&#34;</span></code></pre></div>

<h3 id="安装cmake">安装cmake</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo yum install cmake</code></pre></div>

<h3 id="安装jdk">安装JDK</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo rpm -e --nodeps java-1.7.0-openjdk-headless-1.7.0.181-2.6.14.8.el7_5.x86_64
sudo rpm -e --nodeps java-1.7.0-openjdk-1.7.0.181-2.6.14.8.el7_5.x86_64
sudo yum install java-1.8.0-openjdk-devel
sudo yum install java-1.8.0-openjdk-accessibility java-1.8.0-openjdk-demo java-1.8.0-openjdk-javadoc java-1.8.0-openjdk-src</code></pre></div>

<h3 id="安装svn">安装SVN</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo yum install subversion</code></pre></div>

<h3 id="安装tomcat">安装tomcat</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo yum install tomcat</code></pre></div>

<h3 id="安装mariadb">安装mariadb</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo yum install mariadb mariadb-server</code></pre></div>

<p>设置开机启动</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo systemctl <span class="nb">enable</span> mariadb</code></pre></div>

<p>配置<code>mariadb</code>字符集，修改<code>/etc/my.cnf</code>，在<code>[mysqld]</code>标签下面添加以下内容</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">init_connect</span><span class="o">=</span><span class="s1">&#39;SET collation_connection = utf8_unicode_ci&#39;</span>
<span class="nv">init_connect</span><span class="o">=</span><span class="s1">&#39;SET NAMES utf8&#39;</span>
character-set-server<span class="o">=</span>utf8
collation-server<span class="o">=</span>utf8_unicode_ci
skip-character-set-client-handshake</code></pre></div>

<p>修改<code>/etc/my.cnf.d/client.cnf</code>，在<code>[client]</code>标签添加</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">default-character-set<span class="o">=</span>utf8</code></pre></div>

<p>修改<code>/etc/my.cnf.d/mysql-clients.cnf</code>，在<code>[mysql]</code>标签添加</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">default-character-set<span class="o">=</span>utf8</code></pre></div>

<p>启动<code>mariadb</code></p>

<p><div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo systemctl start mariadb</code></pre></div>
简单配置<code>mariadb</code></p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">mysql_secure_installation</code></pre></div>

<p>进入<code>mariadb</code>查看字符集</p>

<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SHOW</span> <span class="n">VARIABLES</span> <span class="k">LIKE</span> <span class="s1">&#39;%character%&#39;</span><span class="p">;</span>
<span class="k">SHOW</span> <span class="n">VARIABLES</span> <span class="k">LIKE</span> <span class="s1">&#39;%collation%&#39;</span><span class="p">;</span></code></pre></div>

<p>添加用户，设置权限</p>

<div class="highlight"><pre class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span> <span class="k">USER</span> <span class="n">test</span><span class="o">@</span><span class="n">localhost</span> <span class="n">IDENTIFIED</span> <span class="k">BY</span> <span class="s1">&#39;test901120&#39;</span><span class="p">;</span>
<span class="k">DELETE</span> <span class="k">FROM</span> <span class="k">user</span> <span class="k">WHERE</span> <span class="k">USER</span><span class="o">=</span><span class="s2">&#34;test&#34;</span> <span class="k">AND</span> <span class="k">HOST</span><span class="o">=</span><span class="s2">&#34;localhost&#34;</span><span class="p">;</span>
<span class="k">GRANT</span> <span class="k">ALL</span> <span class="k">ON</span> <span class="o">*</span><span class="p">.</span><span class="o">*</span> <span class="k">TO</span> <span class="n">test</span><span class="o">@</span><span class="s1">&#39;%&#39;</span> <span class="n">IDENTIFIED</span> <span class="k">BY</span> <span class="s1">&#39;test901120&#39;</span><span class="p">;</span></code></pre></div>

<p>防火墙开启3306端口</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo firewall-cmd --zone<span class="o">=</span>public --add-port<span class="o">=</span><span class="m">3306</span>/tcp --permanent
sudo firewall-cmd --reload</code></pre></div>

<h3 id="centos7防火墙命令">centos7防火墙命令</h3>

<p>查看已经开放的端口：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo firewall-cmd --list-ports</code></pre></div>

<p>开启端口:</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">firewall-cmd --zone<span class="o">=</span>public --add-port<span class="o">=</span><span class="m">80</span>/tcp --permanent</code></pre></div>

<p>重启防火墙：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo firewall-cmd --reload
sudo systemctl stop firewalld.service
sudo systemctl disable firewalld.service
sudo firewall-cmd --state</code></pre></div>

<h3 id="安装emacs">安装emacs</h3>

<p>CentOS7软件仓库里面的emacs版本是24的，版本低了一点，所以选择编译安装一个最新版的。删除原来的emacs</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo yum remove emacs
sudo yum autoremove</code></pre></div>

<p>下载emacs-26.1.tar.gz，<a href="http://mirrors.ustc.edu.cn/gnu/emacs。">http://mirrors.ustc.edu.cn/gnu/emacs。</a></p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">tar zxf emacs-26.1.tar.gz
<span class="nb">cd</span> emacs-26.1
./configure --prefix<span class="o">=</span>/usr/local
make
sudo make install</code></pre></div>

<p>编译过程中可能会出错，提示缺少一些库，只需按照提示安装相应的开发库即可。可能会缺少的库如下</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">gtk3-devel
libXpm-devel
libjpeg-turbo-devel
giflib-devel
libtiff-devel
gnutls-devel
ncurses-devel</code></pre></div>

<p>安装spacemacs</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">git clone https://github.com/syl20bnr/spacemacs ~/.emacs.d</code></pre></div>

<h3 id="下载idea">下载IDEA</h3>

<p>下载地址：<a href="http://www.jetbrains.com/idea/download/">http://www.jetbrains.com/idea/download/</a></p>

<p>解压ideaIU-2018.1.5.tar.gz</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">tar zxf ideaIU-2018.1.5.tar.gz</code></pre></div>

<h3 id="激活idea">激活IDEA</h3>

<p>下载<a href="http://idea.lanyus.com/jar/JetbrainsCrack-2.8-release-enc.jar">JetbrainsCrack-2.8-release-enc.jar</a>，将它拷贝到idea的<code>bin</code>目录下面，编辑<code>idea64.vmoptions</code>，在最后添加如下内容：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">-javaagent:/YourPath/idea-IU-181.5281.24/bin/JetbrainsCrack-2.8-release-enc.jar</code></pre></div>

<p>运行<code>bin</code>目录下面的<code>idea.sh</code>启动idea，然后在激活码输入任意字符激活idea。</p>

<h3 id="安装nginx">安装nginx</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo yum install nginx</code></pre></div>

<p>启动nginx并设置开机启动</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo systemctl start nginx
sudo systemctl <span class="nb">enable</span> nginx</code></pre></div>

<p>防火墙开启80端口</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo firewall-cmd --zone<span class="o">=</span>public --add-port<span class="o">=</span><span class="m">80</span>/tcp --permanent
sudo firewall-cmd --reload</code></pre></div>

<h3 id="安装redis">安装redis</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo yum install redis</code></pre></div>

<h3 id="安装keepassx2">安装keepassx2</h3>

<p>Keepassx是一个跨平台的密码管理工具，平时都用它来存储各个网站的账号密码，以防忘记</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo yum install keepassx2</code></pre></div>

<h3 id="centos桌面美化">centos桌面美化</h3>

<p><strong>删除底部栏</strong></p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">cd</span> /usr/share/gnome-shell/extensions
sudo mv window-list@gnome-shell-extensions.gcampax.github.com window-list@gnome-shell-extensions.gcampax.github.com.bak</code></pre></div>

<p><strong>隐藏顶栏</strong>（不建议）</p>

<p>修改<code>/usr/share/gnome-shell/modes/classic.json</code></p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">cd</span> /usr/share/gnome-shell/modes
sudo cp classic.json classic.json.back</code></pre></div>

<p>修改panel为：</p>

<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="s2">&#34;panel&#34;</span><span class="err">:</span> <span class="p">{</span> <span class="nt">&#34;left&#34;</span><span class="p">:</span> <span class="p">[],</span>
               <span class="nt">&#34;center&#34;</span><span class="p">:</span> <span class="p">[],</span>
               <span class="nt">&#34;right&#34;</span><span class="p">:</span> <span class="p">[]</span>
             <span class="p">}</span></code></pre></div>

<p>修改<code>/usr/share/gnome-shell/theme/gnome-classic.css</code></p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">cd</span> /usr/share/gnome-shell/theme
sudo cp gnome-classic.css gnome-classic.css.bak</code></pre></div>

<p>修改panel为：</p>

<div class="highlight"><pre class="chroma"><code class="language-css" data-lang="css"><span class="p">#</span><span class="nn">panel</span> <span class="p">{</span>
    <span class="k">background-color</span><span class="p">:</span> <span class="mh">#e9e9e9</span><span class="p">;</span>
    <span class="n">background-gradient-direction</span><span class="p">:</span> <span class="kc">vertical</span><span class="p">;</span>
    <span class="n">background-gradient-end</span><span class="p">:</span> <span class="mh">#d0d0d0</span><span class="p">;</span>
    <span class="k">border-top-color</span><span class="p">:</span> <span class="mh">#666</span><span class="p">;</span> <span class="c">/* we don&#39;t supportnon-uniform border-colors and
</span><span class="c">                               use the top bordercolor for any border, so we
</span><span class="c">                               need to set iteven if all we want is a bottom
</span><span class="c">                               border */</span>
    <span class="k">border-bottom</span><span class="p">:</span> <span class="mi">1</span><span class="kt">px</span> <span class="kc">solid</span> <span class="mh">#666</span><span class="p">;</span>
    <span class="n">app-icon-bottom-clip</span><span class="p">:</span> <span class="mi">0</span><span class="kt">px</span><span class="p">;</span>
     <span class="k">color</span><span class="p">:</span> <span class="kc">transparent</span><span class="p">;</span>
     <span class="c">/* hrm, still no multipoint gradients
</span><span class="c">      background-image: linear-gradient(left,rgba(255, 255, 255, 0),rgba(255, 255, 255, 1) 50%，rgba(255, 255, 255, 0)) !important;*/</span>
   <span class="p">}</span></code></pre></div>

<h3 id="安装chromium">安装chromium</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo yum install chromium</code></pre></div>

<h3 id="安装shadowsocks客户端">安装shadowsocks客户端</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo yum install python-pip
sudo pip install --upgrade pip <span class="c1"># 升级pip</span>
sudo pip install shadowsocks</code></pre></div>

<p>启动shadowsocks客户端</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">nohup sslocal -s your_server_ip -p your_server_port -l <span class="m">1080</span> -k your_server_passwd -t <span class="m">600</span> -m rc4-md5 &gt; /dev/null <span class="m">2</span>&gt;<span class="p">&amp;</span><span class="m">1</span> <span class="p">&amp;</span></code></pre></div>

<p>为了更方便，建议新建一个json的文件，将上述信息放里面，比如<code>/etc/shadowsocks.json</code>内容为：</p>

<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
    <span class="nt">&#34;server&#34;</span><span class="p">:</span><span class="s2">&#34;your_server_ip&#34;</span><span class="p">,</span>      <span class="err">#ss服务器IP</span>
    <span class="nt">&#34;server_port&#34;</span><span class="p">:</span><span class="err">your_server_port</span><span class="p">,</span> <span class="err">#端口</span>
    <span class="nt">&#34;local_address&#34;</span><span class="p">:</span> <span class="s2">&#34;127.0.0.1&#34;</span><span class="p">,</span>   <span class="err">#本地ip</span>
    <span class="nt">&#34;local_port&#34;</span><span class="p">:</span><span class="mi">1080</span><span class="p">,</span>              <span class="err">#本地端口</span>
    <span class="nt">&#34;password&#34;</span><span class="p">:</span><span class="s2">&#34;your_server_passwd&#34;</span><span class="p">,</span><span class="err">#连接ss密码</span>
    <span class="nt">&#34;timeout&#34;</span><span class="p">:</span><span class="mi">300</span><span class="p">,</span>                  <span class="err">#等待超时</span>
    <span class="nt">&#34;method&#34;</span><span class="p">:</span><span class="s2">&#34;rc4-md5&#34;</span><span class="p">,</span>             <span class="err">#加密方式</span>
    <span class="nt">&#34;fast_open&#34;</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>             <span class="err">#</span> <span class="err">true</span> <span class="err">或</span> <span class="err">false。如果你的服务器</span> <span class="err">Linux</span> <span class="err">内核在3.7+，可以开启</span> <span class="err">fast_open</span> <span class="err">以降低延迟。开启方法：</span> <span class="err">echo</span> <span class="err">3</span> <span class="err">&gt;</span> <span class="err">/proc/sys/net/ipv4/tcp_fastopen</span> <span class="err">开启之后，将</span> <span class="err">fast_open</span> <span class="err">的配置设置为</span> <span class="err">true</span> <span class="err">即可</span>
    <span class="nt">&#34;workers&#34;</span><span class="p">:</span> <span class="mi">1</span>                    <span class="err">#</span> <span class="err">工作线程数</span>
<span class="p">}</span></code></pre></div>

<h3 id="安装privoxy">安装privoxy</h3>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo yum install privoxy</code></pre></div>
]]></content>
		</item>
		
		<item>
			<title>第12章 动态内存</title>
			<link>https://gitop.cc/posts/cpp-primer-12/</link>
			<pubDate>Fri, 28 Oct 2016 14:46:23 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/cpp-primer-12/</guid>
			<description>静态内存用来存储静态局部对象，类静态成员和全局对象。栈内存用于定义在函数内的非静态对象。静态内存和栈内存分配的对象由编译器自动创建和销毁。栈</description>
			<content type="html"><![CDATA[

<p>静态内存用来存储静态局部对象，类静态成员和全局对象。栈内存用于定义在函数内的非静态对象。静态内存和栈内存分配的对象由编译器自动创建和销毁。栈对象只当其定义的块在执行时存在。静态对象在被使用之前已经创建，当程序结束时销毁。</p>

<p>除了静态内存和栈内存，每一个程序还有一个自由存储区或叫堆。程序使用堆来动态创建对象。由程序控制动态对象的生命周期。必须显式销毁不再需要的动态对象。</p>

<h2 id="12-1-动态内存和智能指针">12.1 动态内存和智能指针</h2>

<p>C++使用<code>new</code>和<code>delete</code>来管理动态内存。<code>new</code>在堆上分配并初始化一个对象，返回指向该对象的指针。<code>delete</code>使用指向一个动态对象的指针，销毁该对象，释放相关的内存。</p>

<p>新标准定义了2种智能指针。<code>shared_ptr</code>允许多个指针指向同一个对象，<code>unique_ptr</code>独占其指向的对象。新标准还定义了一个<code>weak_ptr</code>，它是<code>shared_ptr</code>管理对象的一个弱引用。这3个都定义在<strong>memory</strong>头文件中。</p>

<h3 id="12-1-1-shared-ptr类">12.1.1 shared_ptr类</h3>

<p>和<code>vector</code>一样，智能指针是模板。因此当创建智能指针时，需要提供指向的类型信息：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">;</span>    <span class="c1">// shared_ptr that can point at a string
</span><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">p2</span><span class="p">;</span> <span class="c1">// shared_ptr that can point at a list of ints
</span></code></pre></div>

<p>默认初始化的智能指针保存一个空指针。智能指针的用法和普通指针类似。解引用智能指针返回所指向的对象，当在条件中使用智能指针时，其效果是测试指针是否为空：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// if p1 is not null, check whether it&#39;s the empty string
</span><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="n">p1</span> <span class="o">&amp;&amp;</span> <span class="n">p1</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">())</span>
    <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="s">&#34;hi&#34;</span><span class="p">;</span>  <span class="c1">// if so, dereference p1 to assign a new value to that string
</span></code></pre></div>

<p>下面是<code>shared_ptr</code>和<code>unique_ptr</code>共有的操作：</p>

<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">shared_ptr&lt;T&gt; sp<br>unique_ptr&lt;T&gt; up</td>
<td align="left">指向T的空指针</td>
</tr>

<tr>
<td align="left">p</td>
<td align="left">使用p作为条件，如果p指向对象则为true</td>
</tr>

<tr>
<td align="left">*p</td>
<td align="left">解引用p获得p指向的对象</td>
</tr>

<tr>
<td align="left">p-&gt;mem</td>
<td align="left">等同于(*p).mem</td>
</tr>

<tr>
<td align="left">p.get()</td>
<td align="left">返回p维护的底层指针。小心使用，返回指针指向的对象可能被智能指针删除</td>
</tr>

<tr>
<td align="left">swap(p, q)</td>
<td align="left">交换p和q的底层指针</td>
</tr>

<tr>
<td align="left">p.swap(q)</td>
<td align="left">同上</td>
</tr>
</tbody>
</table>

<p>特定于<code>shared_ptr</code>的操作：</p>

<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">make_shared&lt;T&gt;(args)</td>
<td align="left">返回指向动态创建的T类型对象的shared_ptr，使用args初始化该对象</td>
</tr>

<tr>
<td align="left">shared_ptr&lt;T&gt; p(q)</td>
<td align="left">p是q的一个拷贝，增加q的引用计数。q包含的指针必须能转换成T*</td>
</tr>

<tr>
<td align="left">p = q</td>
<td align="left">p和q包含的指针可以转换为另一个。减少p的引用计数，增加q的引用计数。如果p的引用计数为0，删除p指向的对象</td>
</tr>

<tr>
<td align="left">p.unique()</td>
<td align="left">如果p.use_count()为1，返回true，否则返回false</td>
</tr>

<tr>
<td align="left">p.use_count()</td>
<td align="left">返回引用计数的个数。可能是一个慢操作，主要用于调试</td>
</tr>
</tbody>
</table>

<p><strong>make_shared</strong>函数</p>

<p>分配和使用动态内存最安全的方式是调用<code>make_shared</code>库函数。它定义在<strong>memory</strong>头文件中，是一个函数模板。这个函数在堆上分配和初始化一个对象并返回指向该对象的<code>shared_ptr</code>：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// shared_ptr that points to an int with value 42
</span><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="c1">// p4 points to a string with value 9999999999
</span><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p4</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="sc">&#39;9&#39;</span><span class="p">);</span>
<span class="c1">// p5 points to an int that is value initialized (§ 3.3.1 (p. 98)) to 0
</span><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p5</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>
</code></pre></div>

<p>和顺序容器的<code>emplace</code>成员函数一样，<code>make_shared</code>使用其参数构造一个指定类型的对象。如果不传任何参数，则对象被值初始化。当然通常使用<code>auto</code>可以简化<code>make_shared</code>返回指针的定义：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// p6 points to a dynamically allocated, empty vector&lt;string&gt;
</span><span class="c1"></span><span class="k">auto</span> <span class="n">p6</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span><span class="p">();</span>
</code></pre></div>

<p><strong>复制和赋值shared_ptr</strong></p>

<p>当复制或赋值一个<code>shared_ptr</code>时，每一个<code>shared_ptr</code>跟踪指向同一个对象的<code>shared_ptr</code>的个数：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="c1">// object to which p points has one user
</span><span class="c1"></span><span class="k">auto</span> <span class="nf">q</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// p and q point to the same object
</span><span class="c1"></span>           <span class="c1">// object to which p and q point has two users
</span></code></pre></div>

<p>引用计数增加的场景：
* 复制一个<code>shared_ptr</code>
* 赋值操作符右边的操作数
* 传值方式传递给函数参数
* 从函数通过值返回</p>

<p>引用计数减少的场景：
* 赋值操作符左边的操作数
* <code>shared_ptr</code>本身被销毁</p>

<p>当引用计数为0时，<code>shared_ptr</code>自动销毁它管理的对象：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="c1">// int to which r points has one user
</span><span class="c1"></span><span class="n">r</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>  <span class="c1">// assign to r, making it point to a different address
</span><span class="c1"></span>        <span class="c1">// increase the use count for the object to which q points
</span><span class="c1"></span>    　　<span class="c1">// reduce the use count of the object to which r had pointed
</span><span class="c1"></span>　　　　<span class="c1">// the object r had pointed to has no users; that object is automatically　freed
</span></code></pre></div>

<blockquote>
<p><strong>注解</strong>
是否使用计数器或其他数据结构来跟踪有多少个指针共享状态取决于实现。关键点是<code>shared_ptr</code>类跟踪有多少个<code>shared_ptr</code>指针指向相同对象并在合适的时候自动释放该对象。</p>
</blockquote>

<p><code>shared_ptr</code>的析构函数减少指向对象的引用计数。当引用计数为0时，<code>shared_ptr</code>析构函数销毁指向的对象并释放内存。</p>

<blockquote>
<p><strong>注解</strong>
如果将<code>shared_ptr</code>放进容器，记得删除不需要的<code>shared_ptr</code>元素以释放内存。</p>
</blockquote>

<p><strong>拥有动态生命周期资源的类</strong></p>

<p>程序倾向于使用动态内存的3个目的：
1. 不知道需要多少个对象
2. 不知道所需对象的准确类型
3. 想要在多个对象之间共享数据</p>

<p><strong>定义StrBlob类</strong></p>

<p>实现一个新的集合类型最简单的方法是使用一个标准库容器管理元素。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">StrBlob</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">size_type</span> <span class="n">size_type</span><span class="p">;</span>
    <span class="n">StrBlob</span><span class="p">();</span>
    <span class="n">StrBlob</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span>
    <span class="n">size_type</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">();</span> <span class="p">}</span>
    <span class="c1">// add and remove elements
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">t</span><span class="p">);}</span>
    <span class="kt">void</span> <span class="nf">pop_back</span><span class="p">();</span>
    <span class="c1">// element access
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">front</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">back</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">data</span><span class="p">;</span>
    <span class="c1">// throws msg if data[i] isn&#39;t valid
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">check</span><span class="p">(</span><span class="n">size_type</span> <span class="n">i</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="12-1-2-直接管理内存">12.1.2 直接管理内存</h3>

<p>C++定义了2个操作符管理内存。<code>new</code>分配内存，<code>delete</code>释放由<code>new</code>分配的内存。使用<code>new</code>和<code>delete</code>直接管理内存容易出错，而且直接管理内存的类不能依赖默认定义的复制，赋值和析构成员函数。</p>

<p><strong>使用new动态分配和初始化对象</strong></p>

<p>动态分配的对象默认初始化，这意味着内置类型或组合类型的值未定义，类对象的值由默认构造函数初始化。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">string</span> <span class="o">*</span><span class="n">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">;</span>  <span class="c1">// initialized to empty string
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span>        <span class="c1">// pi points to an uninitialized int
</span></code></pre></div>

<p>可以直接初始化动态分配的对象，可以使用传统的()，也可以使用新标准的列表初始化{}</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span> <span class="c1">// object to which pi points has value 1024
</span><span class="c1"></span><span class="n">string</span> <span class="o">*</span><span class="n">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="sc">&#39;9&#39;</span><span class="p">);</span>   <span class="c1">// *ps is &#34;9999999999&#34;
</span><span class="c1">// vector with ten elements with values from 0 to 9
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">pv</span> <span class="o">=</span> <span class="k">new</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span>
</code></pre></div>

<p>也可以值初始化动态对象，通过类型名加一对空括号：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">string</span> <span class="o">*</span><span class="n">ps1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">;</span>  <span class="c1">// default initialized to the empty string
</span><span class="c1"></span><span class="n">string</span> <span class="o">*</span><span class="n">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">();</span> <span class="c1">// value initialized to the empty string
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">pi1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span>        <span class="c1">// default initialized; *pi1 is undefined
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">pi2</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">();</span>      <span class="c1">// value initialized to 0; *pi2 is 0
</span></code></pre></div>

<blockquote>
<p>最佳实践
和初始化变量的原因一样，最好初始化动态分配的对象</p>
</blockquote>

<p><strong>C++11</strong>：当在括号里面提供初始值时，可以使用<code>auto</code>推导出我们要分配的对象。由于编译器使用初始值的类型推导要动态分配的对象类型，因此<code>auto</code>只能使用括号初始化，新分配的对象用括号里面的值初始化：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="k">auto</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>   <span class="c1">// p points to an object of the type of obj
</span><span class="c1"></span>                           <span class="c1">// that object is initialized from obj
</span><span class="c1"></span><span class="k">auto</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="k">auto</span><span class="p">{</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">};</span> <span class="c1">// error: must use parentheses for the initializer
</span></code></pre></div>

<p><strong>动态分配的const对象</strong></p>

<p>使用<code>new</code>动态分配const对象合法：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// allocate and initialize a const int
</span><span class="c1"></span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pci</span> <span class="o">=</span> <span class="k">new</span> <span class="k">const</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span>
<span class="c1">// allocate a default-initialized const empty string
</span><span class="c1"></span><span class="k">const</span> <span class="n">string</span> <span class="o">*</span><span class="n">pcs</span> <span class="o">=</span> <span class="k">new</span> <span class="k">const</span> <span class="n">string</span><span class="p">;</span>
</code></pre></div>

<p><strong>内存耗尽</strong></p>

<p>如果<code>new</code>不能分配内存，默认抛出<code>bad_alloc</code>异常。可以使用另一种形式的<code>new</code>阻止抛出异常：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// if allocation fails, new returns a null pointer
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span> <span class="c1">// if allocation fails, new throws std::bad_alloc
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="p">(</span><span class="n">nothrow</span><span class="p">)</span> <span class="kt">int</span><span class="p">;</span> <span class="c1">// if allocation fails, new returns a null pointer
</span></code></pre></div>

<p>这种形式的<code>new</code>称为<strong>placement new</strong>。<strong>placement new</strong>表达式允许传递额外的参数给<code>new</code>。我们传递标准库定义的<code>nothrow</code>对象给<code>new</code>，告诉<code>new</code>不能抛出异常。如果<code>new</code>不能分配内存，则返回空指针。<code>bad_alloc</code>和<code>nothrow</code>都定义在头文件<strong>new</strong>中。</p>

<p><strong>释放动态内存</strong></p>

<p>delete销毁指针指向的对象，并释放相应的内存。传给delete的指针必须是指向动态分配的内存的指针或者是空指针。删除非new返回的指针或删除同一个指针多次是未定义的：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">pi1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">pi2</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="kt">double</span> <span class="o">*</span><span class="n">pd</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">(</span><span class="mi">33</span><span class="p">),</span> <span class="o">*</span><span class="n">pd2</span> <span class="o">=</span> <span class="n">pd</span><span class="p">;</span>
<span class="k">delete</span> <span class="n">i</span><span class="p">;</span>   <span class="c1">// error: i is not a pointer
</span><span class="c1"></span><span class="k">delete</span> <span class="n">pi1</span><span class="p">;</span> <span class="c1">// undefined: pi1 refers to a local
</span><span class="c1"></span><span class="k">delete</span> <span class="n">pd</span><span class="p">;</span>  <span class="c1">// ok
</span><span class="c1"></span><span class="k">delete</span> <span class="n">pd2</span><span class="p">;</span> <span class="c1">// undefined: the memory pointed to by pd2 was already freed
</span><span class="c1"></span><span class="k">delete</span> <span class="n">pi2</span><span class="p">;</span> <span class="c1">// ok: it is always ok to delete a null pointer
</span></code></pre></div>

<p><strong>警告：动态内存管理是容易出错的</strong></p>

<ol>
<li>忘记释放内存。</li>
<li>使用一个已被释放的对象。</li>
<li>同一片内存释放2次。</li>
</ol>

<p><strong>删除时重置指针值</strong></p>

<p>当删除一个指针时，指针就无效了。尽管指针无效，在多数机器上指针还是保存了被释放内存的地址，即指针成为所谓的<strong>悬垂指针</strong>。悬垂指针拥有未初始化指针的所有问题。可以将<code>nullptr</code>赋值给被删除的指针，清晰地指明指针不指向任何对象。</p>

<p>删除时重置指针值只提供有限的保护。如果多个指针指向同一个对象，重置被删除的那个指针值并不影响其他指针。</p>

<h3 id="12-1-3-用new使用shared-ptr">12.1.3 用new使用shared_ptr</h3>

<p>可以使用<code>new</code>返回的指针初始化智能指针：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">;</span> <span class="c1">// shared_ptr that can point at a double
</span><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p2</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span> <span class="c1">// p2 points to an int with value 42
</span></code></pre></div>

<p>其他定义和改变shared_ptr的方式：</p>

<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">shared_ptr&lt;T&gt; p(q)</td>
<td align="left">p管理内置指针q指向的对象，q必须是new返回的指针且能转换为T*</td>
</tr>

<tr>
<td align="left">shared_ptr&lt;T&gt; p(u)</td>
<td align="left">p从unique_ptr指针u接管所有权，使u变成nullptr</td>
</tr>

<tr>
<td align="left">shared_ptr&lt;T&gt; p(q, d)</td>
<td align="left">p接管内置指针q所指向的对象，q必须能转化为T*，p使用可调用对象d替代delete释放内存</td>
</tr>

<tr>
<td align="left">shared_ptr&lt;T&gt; p(p2, d)</td>
<td align="left">p是shared_ptr p2的拷贝，使用可调用对象d释放内存</td>
</tr>

<tr>
<td align="left">p.reset()<br>p.reset(q)<br>p.reset(q, d)</td>
<td align="left">如果p是指向对象的唯一shared_ptr，reset释放指向的对象。如果传递了可选的内置指针q，则使p指向q，否则使p为空指针。如果提供了可调用对象d，则用d释放内存</td>
</tr>
</tbody>
</table>

<p>智能指针带指针参数的构造函数是<code>explicit</code>的，因此不能隐式将内置指针转换为智能指针，必须使用直接初始化形式初始化智能指针：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span>  <span class="c1">// error: must use direct initialization
</span><span class="c1"></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p2</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1024</span><span class="p">));</span>   <span class="c1">// ok: uses direct initialization
</span></code></pre></div>

<p><strong>不要混合使用普通指针和智能指针</strong></p>

<p>一个shared_ptr只能和其他是自己拷贝的shared_ptr协调销毁操作。这是我们推荐使用<code>make_shared</code>的一个原因。它在对象创建的同时绑定到shared_ptr，这样就没有办法将一个地址绑定到多个独立创建的shared_ptr。</p>

<p>考虑下面的代码：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// ptr is created and initialized when process is called
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">process</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// use ptr
</span><span class="c1"></span><span class="p">}</span> <span class="c1">// ptr goes out of scope and is destroyed
</span><span class="c1"></span>
<span class="kt">int</span> <span class="o">*</span><span class="nf">x</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1024</span><span class="p">));</span> <span class="c1">// dangerous: x is a plain pointer, not a smart　pointer
</span><span class="c1"></span><span class="n">process</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>  <span class="c1">// error: cannot convert int* to shared_ptr&lt;int&gt;
</span><span class="c1"></span><span class="n">process</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">));</span> <span class="c1">// legal, but the memory will be deleted!
</span><span class="c1"></span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="o">*</span><span class="n">x</span><span class="p">;</span>  <span class="c1">// undefined: x is a dangling pointer!
</span></code></pre></div>

<blockquote>
<p><strong>警告</strong>
使用内置指针访问由智能指针管理的对象是非常危险的，因为我们不知道这个对象什么时候被释放了。</p>
</blockquote>

<p><strong>不要使用get初始化或赋值另一个智能指针</strong></p>

<p>智能指针类型定义了一个get函数返回其管理对象的内置指针。使用get返回指针的代码不能删除该指针。将get返回的指针绑定到另外一个智能指针是错的。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span> <span class="c1">// reference count is 1
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>  <span class="c1">// ok: but don&#39;t use q in any way that might delete its pointer
</span><span class="c1"></span><span class="p">{</span> <span class="c1">// new block
</span><span class="c1"></span>    <span class="c1">// undefined: two independent shared_ptrs point to the same memory
</span><span class="c1"></span>    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="p">}</span> <span class="c1">// block ends, q is destroyed, and the memory to which q points is freed
</span><span class="c1"></span><span class="kt">int</span> <span class="n">foo</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="c1">// undefined; the memory to which p points was freed
</span></code></pre></div>

<h3 id="12-1-4-智能指针和异常">12.1.4 智能指针和异常</h3>

<p>使用异常处理的程序需要确保当异常发生时资源被正确释放，一个简单的方法是使用智能指针。</p>

<p><strong>智能指针和哑巴类</strong></p>

<p>我们通常可以使用管理动态内存一样的技巧管理没有良好析构函数的类。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">destination</span><span class="p">;</span>  <span class="c1">// represents what we are connecting to
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">connection</span><span class="p">;</span>   <span class="c1">// information needed to use the connection
</span><span class="c1"></span><span class="n">connection</span> <span class="nf">connect</span><span class="p">(</span><span class="n">destination</span><span class="o">*</span><span class="p">);</span>  <span class="c1">// open the connection
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">disconnect</span><span class="p">(</span><span class="n">connection</span><span class="p">);</span>       <span class="c1">// close the given connection
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">destination</span> <span class="o">&amp;</span><span class="n">d</span> <span class="cm">/* other parameters */</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// get a connection; must remember to close it when done
</span><span class="c1"></span>    <span class="n">connection</span> <span class="n">c</span> <span class="o">=</span> <span class="n">connect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>
    <span class="c1">// use the connection
</span><span class="c1"></span>    <span class="c1">// if we forget to call disconnect before exiting f, there will be no way to close c
</span><span class="c1"></span><span class="p">}</span>

<span class="kt">void</span> <span class="nf">end_connection</span><span class="p">(</span><span class="n">connection</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="n">disconnect</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span> <span class="p">}</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">destination</span> <span class="o">&amp;</span><span class="n">d</span> <span class="cm">/* other parameters */</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">connection</span> <span class="n">c</span> <span class="o">=</span> <span class="n">connect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>
    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">connection</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="n">end_connection</span><span class="p">);</span>
    <span class="c1">// use the connection
</span><span class="c1"></span>    <span class="c1">// when f exits, even if by an exception, the connection will be properly closed
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<p><strong>警告：智能指针陷阱</strong></p>

<ul>
<li>不要使用相同内置指针初始化（或重置）多个智能指针</li>
<li>不要delete从get()返回的指针</li>
<li>不要使用get()初始化或重置另一个智能指针</li>
<li>如果使用get()返回的指针，记住当最后一个智能指针消失后，这个指针变无效</li>
<li>如果使用智能指针管理不是new分配的资源，记得传递一个deleter</li>
</ul>

<h3 id="12-1-5-unique-ptr">12.1.5 unique_ptr</h3>

<p>一个unique_ptr拥有其指向的对象。不像shared_ptr，一次只有一个unique_ptr指向指定的对象。当unique_ptr销毁时，其指向的对象也被销毁。</p>

<p>unique_ptr操作：</p>

<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">unique_ptr&lt;T&gt; u1<br>unique_ptr&lt;T, D&gt; u2</td>
<td align="left">指向T的空指针。u1使用delete释放指针，u2使用可调用对象D释放指针</td>
</tr>

<tr>
<td align="left">unique_ptr&lt;T, D&gt; u(d)</td>
<td align="left">指向T的空指针，使用d替代delete，d必须是D类型的对象</td>
</tr>

<tr>
<td align="left">u=nullptr</td>
<td align="left">删除u指向的对象，使u为空指针</td>
</tr>

<tr>
<td align="left">u.release()</td>
<td align="left">释放指针u的控制，返回u保存的指针，使u为空指针</td>
</tr>

<tr>
<td align="left">u.reset()<br>u.reset(q)<br>u.reset(nullptr)</td>
<td align="left">删除u指向的对象。如果提供内置指针q，则是u指向那个对象，否则使u为空指针</td>
</tr>
</tbody>
</table>

<p>因为unique_ptr拥有其指向的对象，所以它不支持复制或赋值：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="s">&#34;Stegosaurus&#34;</span><span class="p">));</span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p2</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>  <span class="c1">// error: no copy for unique_ptr
</span><span class="c1"></span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p3</span><span class="p">;</span>
<span class="n">p3</span> <span class="o">=</span> <span class="n">p2</span><span class="p">;</span>                    <span class="c1">// error: no assign for unique_ptr
</span></code></pre></div>

<p>尽管不支持复制和赋值操作，可以通过调用release或reset转移所有权：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// transfers ownership from p1 (which points to the string Stegosaurus) to p2
</span><span class="c1"></span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p2</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">release</span><span class="p">());</span> <span class="c1">// release makes p1 null
</span><span class="c1"></span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p3</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="s">&#34;Trex&#34;</span><span class="p">));</span>
<span class="c1">// transfers ownership from p3 to p2
</span><span class="c1"></span><span class="n">p2</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">p3</span><span class="p">.</span><span class="n">release</span><span class="p">());</span> <span class="c1">// reset deletes the memory to which p2 had pointed
</span></code></pre></div>

<p>如果不使用另一个智能指针保存从release返回的指针，则记住要释放资源放。</p>

<p><strong>返回unique_ptr</strong></p>

<p>不能复制unique_ptr有一个例外，可以复制或赋值一个即将销毁的unique_ptr。最常见的例子是从函数返回一个unique_ptr：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ok: explicitly create a unique_ptr&lt;int&gt; from int*
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ret</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span> <span class="p">(</span><span class="n">p</span><span class="p">));</span>
    <span class="c1">// . . .
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<blockquote>
<p><strong>向后兼容</strong>
早期版本的库包含一个auto_ptr类，它拥有一些但不是全部unique_ptr的特性。特别是auto_ptr不能存进容器，也不能从函数返回。尽管auto_ptr仍然是标准库的一部分，程序应该使用unique_ptr</p>
</blockquote>

<p><strong>传递deleter给unique_ptr</strong></p>

<p>和shared_ptr一样，unique_ptr默认使用delete释放其指向的对象。同样，可以覆盖unique_ptr的默认deleter。必须在尖括号里面提供deleter类型</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// p points to an object of type objT and uses an object of type delT to free that
</span><span class="c1"></span><span class="n">object</span>
<span class="c1">// it will call an object named fcn of type delT
</span><span class="c1"></span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">objT</span><span class="p">,</span> <span class="n">delT</span><span class="o">&gt;</span> <span class="n">p</span> <span class="p">(</span><span class="k">new</span> <span class="n">objT</span><span class="p">,</span> <span class="n">fcn</span><span class="p">);</span>
</code></pre></div>

<h3 id="12-1-6-weak-ptr">12.1.6 weak_ptr</h3>

<p>weak_ptr是一个智能指针，它不控制其指向对象的生命周期。相反，weak_ptr指向一个由shared_ptr管理的对象。绑定一个weak_ptr到shared_ptr上不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr销毁后，对象本身也被销毁，即使有weak_ptr指向它。</p>

<p>weak_ptr的操作：</p>

<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">weak_ptr&lt;T&gt; w</td>
<td align="left">可以指向T的空weak_ptr</td>
</tr>

<tr>
<td align="left">weak_ptr&lt;T&gt; w(sp)</td>
<td align="left">和shared_ptr sp指向相同对象的weak_ptr，T必须可以转换为sp指向的类型</td>
</tr>

<tr>
<td align="left">w = p</td>
<td align="left">p可以是shared_ptr或weak_ptr。赋值后，w于p共享所有权</td>
</tr>

<tr>
<td align="left">w.reset()</td>
<td align="left">使用w为空</td>
</tr>

<tr>
<td align="left">w.use_count()</td>
<td align="left">和w共享所有权的shared_ptr的数量</td>
</tr>

<tr>
<td align="left">w.expired()</td>
<td align="left">返回true如果w.use_count()为0，否则返回false</td>
</tr>

<tr>
<td align="left">w.lock()</td>
<td align="left">如果expired为true，返回一个空的shared_ptr，否则返回一个指向w所指对象的shared_ptr</td>
</tr>
</tbody>
</table>

<p>当创建一个weak_ptr时，用shared_ptr初始化它：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">wp</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>  <span class="c1">// wp weakly shares with p; use count in p is unchanged
</span></code></pre></div>

<p>因为对象可能不再存在，不能使用weak_ptr直接访问对象。为了访问对象，必须调用lock。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">if</span> <span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">np</span> <span class="o">=</span> <span class="n">wp</span><span class="p">.</span><span class="n">lock</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// true if np is not null
</span><span class="c1"></span>    <span class="c1">// inside the if, np shares its object with p
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>
]]></content>
		</item>
		
		<item>
			<title>安装完Ubuntu后需要做的事</title>
			<link>https://gitop.cc/posts/after-ubuntu-installation/</link>
			<pubDate>Wed, 26 Oct 2016 16:03:15 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/after-ubuntu-installation/</guid>
			<description>我会安装的工具 开发相关 g++，必须的，C++编译器 clang，据说是比gcc更好用的编译器，emacs的一些补全工具会用这个做后端 emacs</description>
			<content type="html"><![CDATA[

<h2 id="我会安装的工具">我会安装的工具</h2>

<p><strong>开发相关</strong></p>

<ul>
<li>g++，必须的，C++编译器</li>
<li>clang，据说是比gcc更好用的编译器，emacs的一些补全工具会用这个做后端</li>
<li>emacs，编辑器之神，谁用谁知道，入门门槛稍微高了一点，我现在还是菜鸟hoho</li>
<li>git，连接github开源代码</li>
<li>vim，自从加入emacs阵营后，这个就用的少了</li>
<li>subversion，公司代码还是用svn管理</li>
<li>cmake，使用cmake自动生成Makefile，编译工程很方便</li>
<li>global，emacs里面用来生成GTAGS，利于阅读代码</li>
<li>meld，文件比较工具，支持整个目录的比较，以及版本控制系统，比如svn，git</li>
<li>git cola，一个非常好用的git客户端工具</li>
<li>LiteIDE，Go语言IDE</li>
<li>CLion，JetBrains出品的C++IDE，很少用，最大的缺点耗内存，其他功能都不错</li>
<li>curl，命令行抓取工具</li>
<li>CodeBlocks，C++IDE，公司目前用的，比较少用，只用来编译发布。下面的操作安装最新的16.01版本。</li>
</ul>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo add-apt-repository ppa:damien-moore/codeblocks-stable
sudo apt-get update
sudo apt-get install codeblocks</code></pre></div>

<p><strong>日常使用</strong></p>

<ul>
<li>ubuntu-tweak，该工具已经停止更新，16.04已经不能安装了，我是14.04升级到16.04，保留了该工具</li>
<li>cryptomator，本地目录加密工具，加密指定目录所有文件。</li>
</ul>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo add-apt-repository ppa:sebastian-stenzel/cryptomator
sudo apt-get update
sudo apt-get install cryptomator</code></pre></div>

<ul>
<li><p>keepassx，本地密码管理软件，再也不用担心忘记密码了，只需记住一个主密码即可，保险一点可以再加一个key文件。这里讲一个配合cryptomator和云盘（推荐坚果云）的靠谱方法：</p>

<ol>
<li>首先用keepassx生成一个密码库的key文件</li>
<li>将key文件放入cryptomator加密的目录（称为保险箱吧）中</li>
<li>将保险箱同步到云盘</li>
<li>密码库文件不用放入保险箱，同步到云盘。</li>
</ol>

<p>这样就可以在不同机器上使用和修改密码库文件，云盘会自动同步。因为key文件放在保险箱里面，非常安全。没有key文件和主密码是打不开密码库的。当然理论上存在保险箱被破解的可能，如果你觉得不放心，可以将key文件保存在自己认为安全的地方（千万不能丢）。</p></li>

<li><p>坚果云（Nutstore），<a href="https://www.jianguoyun.com/s/downloads/linux">下载地址</a></p></li>
</ul>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo apt install default-jre-headless
sudo dpkg -i nautilus_nutstore_amd64.deb</code></pre></div>

<ul>
<li><p><a href="https://getlantern.org/">蓝灯</a>，<a href="https://github.com/getlantern/lantern-binaries">下载地址</a></p></li>

<li><p>搜狗输入法，<a href="http://pinyin.sogou.com/linux/?r=pinyin">下载地址</a>。安装完成后，设置系统输入法，通过<strong>系统设置&gt;语言支持&gt;键盘输入方式系统</strong>，选择<strong>fcitx</strong>，注销并重新登录即可</p></li>
</ul>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo apt install fcitx fcitx-libs fcitx-libs-qt
sudo dpkg -i sogoupinyin_2.1.0.0082_amd64.deb</code></pre></div>

<ul>
<li>oh-my-zsh，首先要安装zsh。</li>
</ul>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sh -c <span class="s2">&#34;</span><span class="k">$(</span>curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh<span class="k">)</span><span class="s2">&#34;</span></code></pre></div>

<h2 id="你自己的github-通过坚果云管理代码-参见-http-blog-jianguoyun-com-p-321">你自己的Github-通过坚果云管理代码（<a href="http://blog.jianguoyun.com/?p=321">参见</a>）</h2>

<p>切换到用来管理代码的目录，初始化本地仓库</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ git init
$ git add .
$ git commit -m <span class="s2">&#34;first commit&#34;</span></code></pre></div>

<p>在坚果云同步目录中创建远程仓库</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ mkdir -p ~/Nutstore/git/project
$ <span class="nb">cd</span> ~/Nutstore/git/project
$ git init –bare</code></pre></div>

<p>回到本地仓库目录，push代码到坚果云中</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ git remote add orig ~/Nutstore/git/project
$ git push orig master</code></pre></div>

<p>这样在所有装了坚果云的电脑上都可以用git管理自己的代码。另一台电脑可以这样拉取代码：</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ git init
$ git remote add orig ~/Nutstore/git/project
$ git pull orig master</code></pre></div>

<h2 id="ubuntu美化">Ubuntu美化</h2>

<p><strong>安装主题numix（强烈推荐）</strong></p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo add-apt-repository ppa:numix/ppa
sudo apt update
sudo apt install numix-gtk-theme numix-icon-theme-circle</code></pre></div>

<p>numix安装完成后，使用unity-tweak-tool将gtk主题换成Numix，图标换成Numix-Circle就大功告成了。</p>

<p><strong>安装Plank</strong></p>

<p>Plank是一个轻量的Dock工具。将Ubuntu侧边栏收起，Plank设置自动隐藏，可以获得一个很大的桌面空间，赏心悦目。在Dash里面搜索<strong>startup</strong>，打开<strong>Startup Applications</strong>，<strong>命令</strong>项填<code>sh -c &quot;sleep 10 &amp;&amp; plank&quot;</code>将Plank添加为自启动。如果不设置延迟，则关机会变成注销，这是unity的一个bug。</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo apt install plank</code></pre></div>

<h2 id="安装jekyll-用于github-page-步骤">安装jekyll（用于github page）步骤</h2>

<p>安装ruby和ruby-dev</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo apt install ruby ruby-dev</code></pre></div>

<p>到<a href="https://rubygems.org">RubyGems</a>网站下载最新的ruby-gem，解压安装</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo ruby setup.rb</code></pre></div>

<p>由于ruby-gem官方源很慢，所以更换成国内源</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/</code></pre></div>

<p>安装jekyll，bundler</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">sudo gem install jekyll bundler</code></pre></div>

<p>更换bundle源</p>

<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">bundle config mirror.https://rubygems.org https://gems.ruby-china.org</code></pre></div>

<h2 id="一些开发用到的库-请忽略">一些开发用到的库（请忽略）</h2>

<ul>
<li>libboost-all-dev</li>
<li>libxerces-c-dev</li>
<li>libjsoncpp-dev</li>
<li>libcurl4-gnutls-dev</li>
<li>libmysqlcppconn-dev</li>
<li>libssl-dev</li>
<li>libmemcached-dev</li>
<li>libiconv-1.14</li>
</ul>

<p>编译libiconv-1.14代码会出错，需要改动srclib/stdio.in.h文件，将698行的代码：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">_GL_WARN_ON_USE</span> <span class="p">(</span><span class="n">gets</span><span class="p">,</span> <span class="s">&#34;gets is a security hole - use fgets instead&#34;</span><span class="p">);</span></code></pre></div>

<p>替换为：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#if defined(__GLIBC__) &amp;&amp; !defined(__UCLIBC__) &amp;&amp; !__GLIBC_PREREQ(2, 16)
</span><span class="cp"></span><span class="n">_GL_WARN_ON_USE</span> <span class="p">(</span><span class="n">gets</span><span class="p">,</span> <span class="s">&#34;gets is a security hole - use fgets instead&#34;</span><span class="p">);</span>
<span class="cp">#endif</span></code></pre></div>
]]></content>
		</item>
		
		<item>
			<title>第17章 特殊的库设施</title>
			<link>https://gitop.cc/posts/cpp-primer-17/</link>
			<pubDate>Mon, 17 Oct 2016 09:15:58 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/cpp-primer-17/</guid>
			<description>17.1 tuple类型 tuple是一个类似pair的模板。每一个pair类型有2个不同类型的成员。一个tuple同样有不同类型的成员，但是它可以有</description>
			<content type="html"><![CDATA[

<h2 id="17-1-tuple类型">17.1 tuple类型</h2>

<p>tuple是一个类似pair的模板。每一个pair类型有2个不同类型的成员。一个tuple同样有不同类型的成员，但是它可以有任意数量的成员。tuple类型定义在tuple头文件。</p>

<blockquote>
<p><strong>注解</strong>
tuple可以认为是一个“快捷且脏”的数据结构。</p>
</blockquote>

<h3 id="17-1-1-定义和初始化tuple">17.1.1 定义和初始化tuple</h3>

<p>当我们定义一个tuple，需要指定每个成员的类型：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">tuple</span><span class="o">&lt;</span><span class="n">size_t</span><span class="p">,</span> <span class="n">size_t</span><span class="p">,</span> <span class="n">size_t</span><span class="o">&gt;</span> <span class="n">threeD</span><span class="p">;</span> <span class="c1">// all three members set to 0
</span><span class="c1"></span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span>
    <span class="n">someVal</span><span class="p">(</span><span class="s">&#34;constants&#34;</span><span class="p">,</span> <span class="p">{</span><span class="mf">3.14</span><span class="p">,</span> <span class="mf">2.718</span><span class="p">},</span> <span class="mi">42</span><span class="p">,</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">});</span>
</code></pre></div>

<p>tuple默认构造函数值初始化每一个成员。tuple构造函数是explicit的，因此必须使用直接初始化语法：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">tuple</span><span class="o">&lt;</span><span class="n">size_t</span><span class="p">,</span> <span class="n">size_t</span><span class="p">,</span> <span class="n">size_t</span><span class="o">&gt;</span> <span class="n">threeD</span> <span class="o">=</span>  <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>  <span class="c1">// error
</span><span class="c1"></span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">size_t</span><span class="p">,</span> <span class="n">size_t</span><span class="p">,</span> <span class="n">size_t</span><span class="o">&gt;</span> <span class="n">threeD</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>      <span class="c1">// ok
</span></code></pre></div>

<p>类似于make_pair函数，标准库定义了一个make_tuple函数生成tuple对象：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// tuple that represents a bookstore transaction: ISBN, count, price per book
</span><span class="c1"></span><span class="k">auto</span> <span class="n">item</span> <span class="o">=</span> <span class="n">make_tuple</span><span class="p">(</span><span class="s">&#34;0-999-78345-X&#34;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">20.00</span><span class="p">);</span>
</code></pre></div>

<p>和make_pair一样，make_tuple函数使用其参数的类型推导tuple的类型。上面这个例子种，item类型为tupple<const char*, int, double>。</p>

<h4 id="访问tuple成员">访问tuple成员</h4>

<p>tuple的成员是未命名的，我们通过一个标准库函数模板get访问其成员。为了使用get我们必须指定一个显式模板实参，这个实参是我们想要访问的成员的位置。传递tuple对象给get，get返回指定成员的引用：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="n">book</span> <span class="o">=</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>      <span class="c1">// returns the first member of item
</span><span class="c1"></span><span class="k">auto</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>       <span class="c1">// returns the second member of item
</span><span class="c1"></span><span class="k">auto</span> <span class="n">price</span> <span class="o">=</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="o">/</span><span class="n">cnt</span><span class="p">;</span> <span class="c1">// returns the last member of item
</span><span class="c1"></span><span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">*=</span> <span class="mf">0.8</span><span class="p">;</span>           <span class="c1">// apply 20% discount
</span></code></pre></div>

<p>尖括号&lt;&gt;中的值必须是整形常量表达式。</p>

<p>如果不知道tuple的类型，我们可以使用2个辅助的类模板找出tuple成员的数量和类型：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="nf">decltype</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="n">trans</span><span class="p">;</span> <span class="c1">// trans is the type of item
</span><span class="c1">// returns the number of members in object&#39;s of type trans
</span><span class="c1"></span><span class="n">size_t</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">tuple_size</span><span class="o">&lt;</span><span class="n">trans</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>  <span class="c1">// returns 3
</span><span class="c1">// cnt has the same type as the second member in item
</span><span class="c1"></span><span class="n">tuple_element</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="n">trans</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">item</span><span class="p">);</span> <span class="c1">// cnt is an int
</span></code></pre></div>

<p>为了使用tuple_size或tuple_element，我们需要直到tuple对象的类型。通常最简单的确定对象类型的方法是使用decltype。</p>

<p>tuple_size有一个公开的静态数据成员value，表示指定tuple成员的数量。tuple_element有一个公开成员type表示指定成员的类型。</p>

<h4 id="关系和相等操作符">关系和相等操作符</h4>

<p>只有当2个tuple有相同数量的成员时，才能进行比较。为使用==操作符，tuple之间的每一对成员必须可以使用==操作符。关系操作符同样的规则。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">tuple</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">duo</span><span class="p">(</span><span class="s">&#34;1&#34;</span><span class="p">,</span> <span class="s">&#34;2&#34;</span><span class="p">);</span>
<span class="n">tuple</span><span class="o">&lt;</span><span class="n">size_t</span><span class="p">,</span> <span class="n">size_t</span><span class="o">&gt;</span> <span class="n">twoD</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="kt">bool</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">duo</span> <span class="o">==</span> <span class="n">twoD</span><span class="p">);</span> <span class="c1">// error: can&#39;t compare a size_t and a string
</span><span class="c1"></span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">size_t</span><span class="p">,</span> <span class="n">size_t</span><span class="p">,</span> <span class="n">size_t</span><span class="o">&gt;</span> <span class="n">threeD</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">twoD</span> <span class="o">&lt;</span> <span class="n">threeD</span><span class="p">);</span>    <span class="c1">// error: differing number of members
</span><span class="c1"></span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">size_t</span><span class="p">,</span> <span class="n">size_t</span><span class="o">&gt;</span> <span class="n">origin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">origin</span> <span class="o">&lt;</span> <span class="n">twoD</span><span class="p">);</span>    <span class="c1">// ok: b is true
</span></code></pre></div>

<blockquote>
<p><strong>注解</strong>
因为tuple定义&lt;和==操作符，我们可以将tuple的元素传递给标准库算法，也可以将tuple作为ordered容器的键。</p>
</blockquote>

<h3 id="17-1-2-使用tuple返回多个值">17.1.2 使用tuple返回多个值</h3>

<p>tuple的一个常见应用是从一个函数返回多个值。</p>

<h4 id="返回tuple的函数">返回tuple的函数</h4>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// matches has three members: an index of a store and iterators into that store&#39;s vector
</span><span class="c1"></span><span class="k">typedef</span> <span class="n">tuple</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Sales_data</span><span class="o">&gt;::</span><span class="n">size_type</span><span class="p">,</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Sales_data</span><span class="o">&gt;::</span><span class="n">const_iterator</span><span class="p">,</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Sales_data</span><span class="o">&gt;::</span><span class="n">const_iterator</span><span class="o">&gt;</span> <span class="n">matches</span><span class="p">;</span>
<span class="c1">// files holds the transactions for every store
</span><span class="c1">// findBook returns a vector with an entry for each store that sold the given book
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">matches</span><span class="o">&gt;</span>
<span class="n">findBook</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Sales_data</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">files</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">book</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">matches</span><span class="o">&gt;</span> <span class="n">ret</span><span class="p">;</span> <span class="c1">// initially empty
</span><span class="c1"></span>    <span class="c1">// for each store find the range of matching books, if any
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">files</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">files</span><span class="p">.</span><span class="n">cend</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// find the range of Sales_data that have the same ISBN
</span><span class="c1"></span>        <span class="k">auto</span> <span class="n">found</span> <span class="o">=</span> <span class="n">equal_range</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">cend</span><span class="p">(),</span>
            <span class="n">book</span><span class="p">,</span> <span class="n">compareIsbn</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">.</span><span class="n">first</span> <span class="o">!=</span> <span class="n">found</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="c1">// this store had sales
</span><span class="c1"></span>            <span class="c1">// remember the index of this store and the matching range
</span><span class="c1"></span>            <span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">it</span> <span class="o">-</span> <span class="n">files</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span>
                <span class="n">found</span><span class="p">.</span><span class="n">first</span><span class="p">,</span>
                <span class="n">found</span><span class="p">.</span><span class="n">second</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span> <span class="c1">// empty if no matches found
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<h4 id="使用函数返回的tuple">使用函数返回的tuple</h4>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">reportResults</span><span class="p">(</span><span class="n">istream</span> <span class="o">&amp;</span><span class="n">in</span><span class="p">,</span> <span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Sales_data</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">files</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">string</span> <span class="n">s</span><span class="p">;</span>  <span class="c1">// book to look for
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">in</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">trans</span> <span class="o">=</span> <span class="n">findBook</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span> <span class="c1">// stores that sold this book
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; not found in any stores&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>  <span class="c1">// get the next book to look for
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="nl">store</span> <span class="p">:</span> <span class="n">trans</span><span class="p">)</span>  <span class="c1">// for every store with a sale
</span><span class="c1"></span>            <span class="c1">// get&lt;n&gt; returns the specified member from the tuple in store
</span><span class="c1"></span>            <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;store &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">store</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; sales: &#34;</span>
                <span class="o">&lt;&lt;</span> <span class="n">accumulate</span><span class="p">(</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">store</span><span class="p">),</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">store</span><span class="p">),</span> <span class="n">Sales_data</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
                <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="17-2-bitset类型">17.2 bitset类型</h2>

<p>bitset类型定义在bitset头文件</p>

<h3 id="17-2-1-定义和初始化bitset">17.2.1 定义和初始化bitset</h3>

<p>bitset类是一个类模板，和array类一样，拥有固定长度。当定义bitset对象时，需要指定bitset将要包含的位数：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">bitset</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span> <span class="n">bitvec</span><span class="p">(</span><span class="mi">1U</span><span class="p">);</span> <span class="c1">// 32 bits; low-order bit is 1, remaining bits are 0
</span></code></pre></div>

<p>bitset中的位通过位置访问。</p>

<h4 id="用unsigned值初始化bitset">用unsigned值初始化bitset</h4>

<p>当使用一个整型值初始化一个bitset时，值被转化为unsigned long long的位模式。如果bitset大小比unsigned long long大，则剩下的高位置为0，否则超出bitset大小的高位被丢弃。
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// bitvec1 is smaller than the initializer; high-order bits from the initializer are discarded
</span><span class="c1"></span><span class="n">bitset</span><span class="o">&lt;</span><span class="mi">13</span><span class="o">&gt;</span> <span class="n">bitvec1</span> <span class="p">(</span><span class="mh">0xbeef</span><span class="p">);</span>  <span class="c1">// bits are 1111011101111
</span><span class="c1">// bitvec2 is larger than the initializer; high-order bits in bitvec2 are set to zero
</span><span class="c1"></span><span class="n">bitset</span><span class="o">&lt;</span><span class="mi">20</span><span class="o">&gt;</span> <span class="n">bitvec2</span><span class="p">(</span><span class="mh">0xbeef</span><span class="p">);</span>  <span class="c1">// bits are 00001011111011101111
</span><span class="c1">// on machines with 64-bit long long 0ULL is 64 bits of 0, so ~0ULL  is 64 ones
</span><span class="c1"></span><span class="n">bitset</span><span class="o">&lt;</span><span class="mi">128</span><span class="o">&gt;</span> <span class="n">bitvec3</span><span class="p">(</span><span class="o">~</span><span class="mi">0ULL</span><span class="p">);</span> <span class="c1">// bits 0 ... 63 are one; 63 ... 127 are zero
</span></code></pre></div></p>

<h4 id="用字符串初始化bitset">用字符串初始化bitset</h4>

<p>可以使用string或指向字符数组的指针初始化bitset。任一种情况，字符直接表示位模式。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">bitset</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span> <span class="n">bitvec4</span><span class="p">(</span><span class="s">&#34;1100&#34;</span><span class="p">);</span> <span class="c1">// bits 2 and 3 are 1, all others are 0
</span></code></pre></div>

<p>如果字符串包含少于bitset大小的字符，则高位置为0。</p>

<blockquote>
<p><strong>注解</strong>
string和bitset的下标是相反关联的：string最右边的字符用来初始化bitset最低位。</p>
</blockquote>

<p>可以使用子字符串初始化bitset：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">string</span> <span class="nf">str</span><span class="p">(</span><span class="s">&#34;1111111000000011001101&#34;</span><span class="p">);</span>
<span class="n">bitset</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span> <span class="n">bitvec5</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// four bits starting at str[5], 1100
</span><span class="c1"></span><span class="n">bitset</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span> <span class="n">bitvec6</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">str</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// use last four characters
</span></code></pre></div>

<h3 id="bitset操作">bitset操作</h3>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">bitset</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span> <span class="n">bitvec</span><span class="p">(</span><span class="mi">1U</span><span class="p">);</span> <span class="c1">// 32 bits; low-order bit is 1, remaining bits are 0
</span><span class="c1"></span><span class="kt">bool</span> <span class="n">is_set</span> <span class="o">=</span> <span class="n">bitvec</span><span class="p">.</span><span class="n">any</span><span class="p">();</span>      <span class="c1">// true, one bit is set
</span><span class="c1"></span><span class="kt">bool</span> <span class="n">is_not_set</span> <span class="o">=</span> <span class="n">bitvec</span><span class="p">.</span><span class="n">none</span><span class="p">();</span> <span class="c1">// false, one bit is set
</span><span class="c1"></span><span class="kt">bool</span> <span class="n">all_set</span> <span class="o">=</span> <span class="n">bitvec</span><span class="p">.</span><span class="n">all</span><span class="p">();</span>     <span class="c1">// false, only one bit is set
</span><span class="c1"></span><span class="n">size_t</span> <span class="n">onBits</span> <span class="o">=</span> <span class="n">bitvec</span><span class="p">.</span><span class="n">count</span><span class="p">();</span>  <span class="c1">// returns 1
</span><span class="c1"></span><span class="n">size_t</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">bitvec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>       <span class="c1">// returns 32
</span><span class="c1"></span><span class="n">bitvec</span><span class="p">.</span><span class="n">flip</span><span class="p">();</span>     <span class="c1">// reverses the value of all the bits in bitvec
</span><span class="c1"></span><span class="n">bitvec</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>    <span class="c1">// sets all the bits to 0
</span><span class="c1"></span><span class="n">bitvec</span><span class="p">.</span><span class="n">set</span><span class="p">();</span>      <span class="c1">// sets all the bits to 1
</span><span class="c1"></span><span class="n">bitvec</span><span class="p">.</span><span class="n">flip</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>   <span class="c1">// reverses the value of the first bit
</span><span class="c1"></span><span class="n">bitvec</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">bitvec</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// turns on the last bit
</span><span class="c1"></span><span class="n">bitvec</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// turns off the first bit
</span><span class="c1"></span><span class="n">bitvec</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>  <span class="c1">// turns off the ith bit
</span><span class="c1"></span><span class="n">bitvec</span><span class="p">.</span><span class="n">test</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>   <span class="c1">// returns false because the first bit is off
</span><span class="c1"></span><span class="n">bitvec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">// turn off the bit at position 0
</span><span class="c1"></span><span class="n">bitvec</span><span class="p">[</span><span class="mi">31</span><span class="p">]</span> <span class="o">=</span> <span class="n">bitvec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// set the last bit to the same value as the first bit
</span><span class="c1"></span><span class="n">bitvec</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">flip</span><span class="p">();</span> <span class="c1">// flip the value of the bit at position 0
</span><span class="c1"></span><span class="o">~</span><span class="n">bitvec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// equivalent operation; flips the bit at position 0
</span><span class="c1"></span><span class="kt">bool</span> <span class="n">b</span> <span class="o">=</span> <span class="n">bitvec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// convert the value of bitvec[0] to bool
</span></code></pre></div>

<p>####　获取bitset的值</p>

<p>to_ulong和to_ullong操作返回和bitset对象同样位模式的数值。只有在bitset大小小于或等于unsigned long或unsigned long long类型时才可用：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ulong</span> <span class="o">=</span> <span class="n">bitvec3</span><span class="p">.</span><span class="n">to_ulong</span><span class="p">();</span>
</code></pre></div>

<blockquote>
<p><strong>注解</strong>
如果bitset不能放进指定类型，这2个操作抛出overflow_error异常。</p>
</blockquote>

<h4 id="bitset-io操作">bitset IO操作</h4>

<p>输入操作符从输入流读取字符到一个临时string对象，直到读满bitset大小或遇到一个不是0或1的字符，或者遇到输入操作。然后bitset由这个临时string初始化。输出操作符打印bitset对象的位模式。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">bitset</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">bits</span><span class="p">;</span>
<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">bits</span><span class="p">;</span>  <span class="c1">// read up to 16 1 or 0 characters from cin
</span><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;bits: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">bits</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// print what we just read
</span></code></pre></div>

<h4 id="使用bitset">使用bitset</h4>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">bool</span> <span class="n">status</span><span class="p">;</span>
<span class="c1">// version using bitwise operators
</span><span class="c1"></span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">quizA</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>      <span class="c1">// this value is used as a collection of bits
</span><span class="c1"></span><span class="n">quizA</span> <span class="o">|=</span> <span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">27</span><span class="p">;</span>           <span class="c1">// indicate student number 27 passed
</span><span class="c1"></span><span class="n">status</span> <span class="o">=</span> <span class="n">quizA</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">27</span><span class="p">);</span> <span class="c1">// check how student number 27 did
</span><span class="c1"></span><span class="n">quizA</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">27</span><span class="p">);</span>        <span class="c1">// student number 27 failed
</span><span class="c1">// equivalent actions using the bitset library
</span><span class="c1"></span><span class="n">bitset</span><span class="o">&lt;</span><span class="mi">30</span><span class="o">&gt;</span> <span class="n">quizB</span><span class="p">;</span>     <span class="c1">// allocate one bit per student; all bits initialized to 0
</span><span class="c1"></span><span class="n">quizB</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="mi">27</span><span class="p">);</span>        <span class="c1">// indicate student number 27 passed
</span><span class="c1"></span><span class="n">status</span> <span class="o">=</span> <span class="n">quizB</span><span class="p">[</span><span class="mi">27</span><span class="p">];</span>   <span class="c1">// check how student number 27 did
</span><span class="c1"></span><span class="n">quizB</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="mi">27</span><span class="p">);</span>      <span class="c1">// student number 27 failed
</span></code></pre></div>

<h2 id="17-3-正则表达式">17.3 正则表达式</h2>

<p>正则表达式是描述一串字符的一种方式。RE库定义在regex头文件，是新库的一部分。</p>

<table>
<thead>
<tr>
<th>类</th>
<th align="left">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>regex</td>
<td align="left">正则表达式类</td>
</tr>

<tr>
<td>regex_match</td>
<td align="left">根据正则表达式匹配字符串</td>
</tr>

<tr>
<td>regex_search</td>
<td align="left">查找第一个匹配正则表达式的子串</td>
</tr>

<tr>
<td>regex_replace</td>
<td align="left">使用指定的格式替换正则表达式</td>
</tr>

<tr>
<td>sregex_iterator</td>
<td align="left">迭代器适配器，调用regex_search遍历字符串中匹配项</td>
</tr>

<tr>
<td>smatch</td>
<td align="left">容器类，包含查找的结果集</td>
</tr>

<tr>
<td>ssub_match</td>
<td align="left">匹配子表达式的结果集</td>
</tr>
</tbody>
</table>

<p>regex类表示一个正则表达式。除了初始化和赋值，regex没有什么操作。函数regex_match和regex_search确定给定的字符串是否匹配指定的regex。如果整个字符串匹配正则表达式，regex_match返回true。如果有子串匹配，则regex_search返回true。还有一个regex_replace函数。</p>

<p>regex_match和regex_search的参数</p>

<p>(seq, m, r, mft)
(seq, r, mft)</p>

<h3 id="使用正则表达式库">使用正则表达式库</h3>
]]></content>
		</item>
		
		<item>
			<title>Asio.Cookbook 第2章 IO操作</title>
			<link>https://gitop.cc/posts/io-operations/</link>
			<pubDate>Thu, 18 Aug 2016 08:55:42 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/io-operations/</guid>
			<description>介绍 IO操作是任何分布式应用的网络基础设施的关键操作。它们直接参与数据交换的过程。输入操作用来接收数据，输出操作用来发送数据。 IO缓冲区 网络</description>
			<content type="html"><![CDATA[

<h2 id="介绍">介绍</h2>

<p>IO操作是任何分布式应用的网络基础设施的关键操作。它们直接参与数据交换的过程。输入操作用来接收数据，输出操作用来发送数据。</p>

<h3 id="io缓冲区">IO缓冲区</h3>

<p>网络编程都是关于通过计算机网络进行进程间通信。像其他类型的IO操作一样，网络IO操作涉及使用内存缓冲区。</p>

<h3 id="同步和异步io操作">同步和异步IO操作</h3>

<p>Boost.Asio支持两种类型的IO操作：同步和异步。同步操作阻塞当前线程的执行直到操作完成。异步操作在初始化时关联一个回调函数，当操作完成时，Boost.Asio会调用回调函数。</p>

<p>在一个或多个异步操作初始化后，程序使用一个线程来运行Boost.Asio库。Boost.Asio库使用这个线程运行事件循环并调用回调函数通知异步操作完成，异步操作的结果作为参数传递给回调函数。</p>

<h3 id="附加操作">附加操作</h3>

<ol>
<li><p>取消异步操作。
取消之前初始化的异步操作的能力很重要。它允许程序声明之前初始化的异步操作不再有效。</p></li>

<li><p>shutdown套接字。
shutdown套接字很有用，如果需要通知另一个程序整个报文已发送。</p></li>

<li><p>close套接字。</p></li>
</ol>

<h2 id="使用固定长度io缓冲区">使用固定长度IO缓冲区</h2>

<p>固定长度的IO缓冲区通常用在报文长度已知的情况下。在Boost.Asio里面，固定长度IO缓冲区由asio::mutable_buffer或asio::const_buffer表示。asio::mutable_buffer表示可写缓冲区，asio::const_buffer表示只读缓冲区。</p>

<p>但是asio::mutable_buffer和asio::const_buffer并不能直接在Boost.Asio的IO函数中直接使用。相反MutableBufferSequence和ConstBufferSequence概念被引入。MutableBufferSequence指定一个对象表示asio::mutable_buffer对象的集合。相应地，ConstBufferSequence指定一个对象表示asio::const_buffer对象的集合。</p>

<p>asio::buffer()自由函数拥有28个重载形式，接收多种缓冲区表示形式并返回一个asio::mutable_buffers_1或asio::const_buffers_1对象。如果传给asio::buffer()函数的参数是只读类型，则返回asio::const_buffers_1对象，反之返回asio::mutable_buffers_1对象。asio::mutable_buffers_1和asio::const_buffers_1是asio::mutable_buffer和asio::const_buffer相应的适配。</p>

<h3 id="为输出操作准备缓冲区">为输出操作准备缓冲区</h3>

<ol>
<li>分配一个缓冲区。</li>
<li>将输出数据填入缓冲区。</li>
<li>将缓冲区表示为满足ConstBufferSequence需求的对象。</li>
<li>缓冲区已经可以用在Boost.Asio的输出函数或方法。</li>
</ol>

<p><div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">buf</span> <span class="o">=</span> <span class="s">&#34;Hello&#34;</span><span class="p">;</span>
<span class="n">asio</span><span class="o">::</span><span class="n">const_buffer_1</span> <span class="n">output_buf</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="c1">// output_buf can be used in Boost.Asio output operations
</span></code></pre></div>
为了更好的理解为什么需要将缓冲区表示成满足ConstBufferSequence需求，可以看一下send()的声明：</p>

<p><div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">ConstBufferSequence</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">send</span><span class="p">(</span><span class="k">const</span> <span class="n">ConstBufferSequence</span><span class="o">&amp;</span> <span class="n">buffers</span><span class="p">);</span>
</code></pre></div>
为了使用send()发送string对象，我们可以这样做：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">asio</span><span class="o">::</span><span class="n">const_buffer</span> <span class="n">asio_buf</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">buf</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">asio</span><span class="o">::</span><span class="n">const_buffer</span><span class="o">&gt;</span> <span class="n">buffers_sequence</span><span class="p">;</span>
<span class="n">buffers_sequence</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">asio_buf</span><span class="p">);</span>
</code></pre></div>

<p>但是这样没有使用asio::buffer()方便。</p>

<h3 id="为输入操作准备缓冲区">为输入操作准备缓冲区</h3>

<ol>
<li>分配一个缓冲区。缓冲区的大小必须足以保存接收到的数据。</li>
<li>将缓冲区表示为满足MutableBufferSequence需求的对象。</li>
<li>缓冲区已经可以用在Boost.Asio的输入函数或方法。</li>
</ol>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="n">size_t</span> <span class="n">BUF_SIZE_BYTES</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">[]</span><span class="o">&gt;</span> <span class="n">buf</span><span class="p">(</span><span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">BUF_SIZE_BYTES</span><span class="p">]);</span>
<span class="n">asio</span><span class="o">::</span><span class="n">mutable_buffers_1</span> <span class="n">input_buf</span> <span class="o">=</span>
    <span class="n">asio</span><span class="o">::</span><span class="n">buffer</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">get</span><span class="p">()),</span> <span class="n">BUF_SIZE_BYTES</span><span class="p">);</span>
<span class="c1">// input_buf can be used in Boost.Asio input operations
</span></code></pre></div>

<blockquote>
<p>缓冲区所有权
asio::mutable_buffer，asio::const_buffer，asio::mutable_buffers_1，asio::const_buffers_1等并不拥有原始缓冲区的所有权，它们只提供访问缓冲区的接口，不控制其生命周期。</p>
</blockquote>

<h2 id="使用可扩展面向流的io缓冲区">使用可扩展面向流的IO缓冲区</h2>

<p>可扩展缓冲区是当新数据写入时可以动态增长的缓冲区。它们经常用于从套接字读取未知大小的报文。</p>

<p>可扩展面向流的缓冲区在Boost.Asio中由asio::streambuf类表示：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="n">basic_streambuf</span><span class="o">&lt;&gt;</span> <span class="n">streambuf</span><span class="p">;</span>
</code></pre></div>

<p>asio::basic_streambuf&lt;&gt;类继承自std::streambuf。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">asio</span><span class="o">::</span><span class="n">streambuf</span> <span class="n">buf</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="n">output</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>

<span class="c1">// Writing the message to the stream-based buffer.
</span><span class="c1"></span><span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Message&#34;</span><span class="p">;</span>

<span class="c1">// Instantiate an input stream which uses our stream buffer.
</span><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">istream</span> <span class="n">input</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">message</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
</code></pre></div>

<h2 id="同步写tcp套接字">同步写TCP套接字</h2>

<p>写套接字最基本的方法是使用Boost.Asio中的asio::ip::tcp::socket类的write_some()方法：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ConstBufferSequence</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">write_some</span><span class="p">(</span><span class="k">const</span> <span class="n">ConstBufferSequence</span><span class="o">&amp;</span> <span class="n">buffers</span><span class="p">);</span>
</code></pre></div>

<p>如果方法成功执行，返回写入的字节数。需要强调的是这个方法可能不会发送参数指定的所有数据，它只保证如果错误不发生至少发送一个字节。这意味着为了发送缓冲区中所有数据需要调用write_some()多次。</p>

<ol>
<li>在客户端程序中，分配，打开并连接一个主动TCP套接字。在服务端程序中，通过接收器套接字接收一个主动TCP套接字的连接请求。</li>
<li>分配缓冲区并将要写到套接字的数据填充进缓冲区。</li>
<li>在一个循环中调用套接字的write_some()方法多次直到缓冲区中的数据都发送完。</li>
</ol>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">writeToSocket</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">socket</span><span class="o">&amp;</span> <span class="n">sock</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">buf</span> <span class="o">=</span> <span class="s">&#34;Hello&#34;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">total_bytes_written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">total_bytes_written</span> <span class="o">!=</span> <span class="n">buf</span><span class="p">.</span><span class="n">length</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">total_bytes_written</span> <span class="o">+=</span> <span class="n">sock</span><span class="p">.</span><span class="n">write_some</span><span class="p">(</span>
            <span class="n">asio</span><span class="o">::</span><span class="n">buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">c_str</span><span class="p">()</span> <span class="o">+</span> <span class="n">total_bytes_written</span><span class="p">,</span>
                <span class="n">buf</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="n">total_bytes_written</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="替代品-send-方法">替代品——send()方法</h3>

<p>asio::ip::tcp::socket类包含另外一个同步写数据的方法send()。它有3种重载形式。其中一个和write_some()方法一样，有一样的签名并提供同样的功能。</p>

<p>第二个重载函数接收一个额外的参数：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ConstBufferSequence</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">send</span><span class="p">(</span><span class="k">const</span> <span class="n">ConstBufferSequence</span><span class="o">&amp;</span> <span class="n">buffers</span><span class="p">,</span>
    <span class="n">socket_base</span><span class="o">::</span><span class="n">message_flags</span> <span class="n">flags</span><span class="p">);</span>
</code></pre></div>

<p>第三个重载函数和第二个一样，但是它不抛出异常，而是接收一个boost::system::error_code的参数。</p>

<p>使用write_some()方法向套接字写数据看起来非常复杂，因为必须使用一个循环，并且每一次迭代都需要正确构造缓冲区并跟踪已写的数据。幸运的是，Boost.Asio提供一个自由函数asio::write()简化向套接字写数据。asio::write()有8种重载形式。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">SyncWriteStream</span><span class="p">,</span> <span class="k">typename</span> <span class="n">ConstBufferSequence</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">write</span><span class="p">(</span><span class="n">SyncWriteStream</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="n">ConstBufferSequence</span><span class="o">&amp;</span> <span class="n">buffers</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">WriteToSocketEnhanced</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">socket</span><span class="o">&amp;</span> <span class="n">sock</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">buf</span> <span class="o">=</span> <span class="s">&#34;hello&#34;</span><span class="p">;</span>
    <span class="n">asio</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">asio</span><span class="o">::</span><span class="n">buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="同步读tcp套接字">同步读TCP套接字</h2>

<p>由Boost.Asio提供的从套接字读取数据最基本的方法是asio::ip::tcp::socket类的read_some()方法。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">MutableBufferSequence</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">read_some</span><span class="p">(</span><span class="k">const</span> <span class="n">MutableBufferSequence</span><span class="o">&amp;</span> <span class="n">buffers</span><span class="p">);</span>
</code></pre></div>

<p>需要注意的是没有办法控制read_some()将会读取多少数据。它只保证如果错误不发生至少读取一个字节。通常情况下，为了从套接字读取某一数量的数据需要调用read_some()多次。</p>

<ol>
<li>在客户端程序中，分配，打开并连接一个主动TCP套接字。在服务端程序中，通过接收器套接字接收一个主动TCP套接字的连接请求。</li>
<li>分配足够大小的缓冲区使得能够装下预期的报文。</li>
<li>在一个循环中调用套接字的read_some()方法多次直到读完数据。</li>
</ol>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">readFromSocket</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">socket</span><span class="o">&amp;</span> <span class="n">sock</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">MESSAGE_SIZE</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MESSAGE_SIZE</span><span class="p">];</span>
    <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">total_bytes_read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">total_bytes_read</span> <span class="o">!=</span> <span class="n">MESSAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">total_bytes_read</span> <span class="o">+=</span> <span class="n">sock</span><span class="p">.</span><span class="n">read_some</span><span class="p">(</span>
            <span class="n">asio</span><span class="o">::</span><span class="n">buffer</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">total_bytes_read</span><span class="p">,</span>
                <span class="n">MESSAGE_SIZE</span> <span class="o">-</span> <span class="n">total_bytes_read</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">total_bytes_read</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="替代品-receive-方法">替代品——receive()方法</h3>

<p>asio::ip::tcp::socket类包含另外一个同步读数据的方法receive()。它有3种重载形式。其中一个和read_some()方法一样，有一样的签名并提供同样的功能。</p>

<p>第二个重载函数接收一个额外的参数：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">MutableBufferSequence</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">receive</span><span class="p">(</span><span class="k">const</span> <span class="n">MutableBufferSequence</span><span class="o">&amp;</span> <span class="n">buffers</span><span class="p">,</span>
    <span class="n">socket_base</span><span class="o">::</span><span class="n">message_flags</span> <span class="n">flags</span><span class="p">);</span>
</code></pre></div>

<p>第三个重载函数和第二个一样，但是它不抛出异常，而是接收一个boost::system::error_code的参数。</p>

<p>使用read_some()方法向套接字写数据看起来非常复杂，因为必须使用一个循环，并且每一次迭代都需要正确构造缓冲区并跟踪已写的数据。幸运的是，Boost.Asio提供一组自由函数简化向套接字写数据。有3种读函数，每个有7种重载形式。</p>

<h3 id="asio-read-函数">asio::read()函数</h3>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">SyncReadStream</span><span class="p">,</span> <span class="k">typename</span> <span class="n">MutableBufferSequence</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">read</span><span class="p">(</span><span class="n">SyncReadStream</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="n">MutableBufferSequence</span><span class="o">&amp;</span> <span class="n">buffers</span><span class="p">)</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">readFromSocketEnhanced</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">socket</span><span class="o">&amp;</span> <span class="n">sock</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">MESSAGE_SIZE</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MESSAGE_SIZE</span><span class="p">];</span>
    <span class="n">asio</span><span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">asio</span><span class="o">::</span><span class="n">buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">MESSAGE_SIZE</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">MESSAGE_SIZE</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="read-until-函数">read_until()函数</h3>

<p>asio::read_until()函数从套接字读取数据直到遇到指定的模式，它有8种重载形式。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">SyncReadStream</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Allocator</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">read_until</span><span class="p">(</span>
    <span class="n">SyncReadStream</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">basic_streambuf</span><span class="o">&lt;</span><span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">,</span>
    <span class="kt">char</span> <span class="n">delim</span><span class="p">);</span>
</code></pre></div>

<p>asio::read_until从套接字s读取数据到缓冲区b直到遇到指定的字符delim。需要注意的是asio::read_until内部使用read_some()方法读取数据的。当函数返回时，缓冲区b中可能包含在delim后的数据。也就是说程序员需要处理这种情况。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">readFromSocketDelim</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">socket</span><span class="o">&amp;</span> <span class="n">sock</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">asio</span><span class="o">::</span><span class="n">streambuf</span> <span class="n">buf</span><span class="p">;</span>
    <span class="n">asio</span><span class="o">::</span><span class="n">read_until</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">message</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">istream</span> <span class="n">input_stream</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">input_stream</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">message</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="read-at-函数">read_at()函数</h3>

<p>asio::read_at()函数从特定位置开始读数据，参考Boost文档。</p>

<h2 id="异步写tcp套接字">异步写TCP套接字</h2>

<p>Boost.Asio提供的异步写数据最基本的工具是asio::ip::tcp::socket类的async_write_some()方法。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ConstBufferSequence</span><span class="p">,</span> <span class="k">typename</span> <span class="n">WriteHandler</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">async_write_some</span><span class="p">(</span><span class="k">const</span> <span class="n">ConstBufferSequence</span><span class="o">&amp;</span> <span class="n">buffers</span><span class="p">,</span>
    <span class="n">WriteHandler</span> <span class="n">handler</span><span class="p">);</span>
</code></pre></div>

<p>async_write_some()方法初始化一个写操作并立即返回。第一个参数包含要写到套接字的数据，第二个参数是个回调函数，当初始化操作完成后由Boost.Asio调用。</p>

<p>回调应该具有下述的签名：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">write_handler</span><span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">ec</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">bytes_transferred</span><span class="p">);</span>
</code></pre></div>

<p>async_write_some()方法保证如果不发生错误，至少写一个字节数据。这意味着通常情况下，为了将所有数据写到套接字，需要调用async_write_some()多次。</p>

<ol>
<li>定义一个数据结构，包含指向套接字的指针，一个缓冲区和一个用来统计已写数据的变量</li>
<li>定义一个回调函数</li>
<li>在客户端程序中，分配，打开并连接一个主动TCP套接字。在服务端程序中，通过接收器套接字接收一个主动TCP套接字的连接请求。</li>
<li>分配一个缓冲区，并填充要写到套接字的数据</li>
<li>调用async_write_some()方法初始化一个写操作，指定步骤2的函数为回调函数</li>
<li>调用asio::io_service类的run()方法</li>
<li>在回调中，增加已写的数据。如果已写数据小于需要写的总数据，再初始化一个异步写操作</li>
</ol>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">Session</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">asio</span><span class="o">::</span><span class="n">socket</span><span class="o">&gt;</span> <span class="n">sock</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">buf</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">total_bytes_written</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">callback</span><span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">ec</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">bytes_transferred</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Session</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ec</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Error code = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">ec</span><span class="p">.</span><span class="n">value</span><span class="p">()</span>
        <span class="o">&lt;&lt;</span> <span class="s">&#34;. Message: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">ec</span><span class="p">.</span><span class="n">message</span><span class="p">();</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">total_bytes_written</span> <span class="o">+=</span> <span class="n">bytes_transferred</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">total_bytes_written</span> <span class="o">==</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">length</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">async_write_some</span><span class="p">(</span>
        <span class="n">asio</span><span class="o">::</span><span class="n">buffer</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">c_str</span><span class="p">()</span> <span class="o">+</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">total_bytes_written</span><span class="p">,</span>
            <span class="n">s</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">total_bytes_written</span><span class="p">),</span>
        <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">callback</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">_1</span><span class="p">,</span>
            <span class="n">std</span><span class="o">::</span><span class="n">_2</span><span class="p">,</span> <span class="n">s</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">writeToSocket</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">asio</span><span class="o">::</span><span class="n">socket</span><span class="o">&gt;</span> <span class="n">sock</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Session</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">(</span><span class="k">new</span> <span class="n">Session</span><span class="p">);</span>
    
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&#34;Hello&#34;</span><span class="p">);</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">total_bytes_written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">sock</span> <span class="o">=</span> <span class="n">sock</span><span class="p">;</span>
    
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">async_write_some</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">buffer</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">),</span>
        <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">callback</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">_1</span><span class="p">,</span>
            <span class="n">std</span><span class="o">::</span><span class="n">_2</span><span class="p">,</span> <span class="n">s</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">raw_ip_address</span> <span class="o">=</span> <span class="s">&#34;127.0.0.1&#34;</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port_num</span> <span class="o">=</span> <span class="mi">3333</span><span class="p">;</span>
    
    <span class="k">try</span> <span class="p">{</span>
        <span class="n">asio</span><span class="o">::</span><span class="n">endpoint</span> <span class="n">ep</span><span class="p">(</span>
            <span class="n">asio</span><span class="o">::</span><span class="n">from_string</span><span class="p">(</span><span class="n">raw_ip_address</span><span class="p">),</span> <span class="n">port_num</span><span class="p">);</span>
        <span class="n">asio</span><span class="o">::</span><span class="n">io_service</span> <span class="n">ios</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">asio</span><span class="o">::</span><span class="n">socket</span><span class="o">&gt;</span> <span class="n">sock</span><span class="p">(</span>
            <span class="k">new</span> <span class="n">asio</span><span class="o">::</span><span class="n">socket</span><span class="p">(</span><span class="n">ios</span><span class="p">,</span> <span class="n">ep</span><span class="p">.</span><span class="n">protocol</span><span class="p">()));</span>
        
        <span class="n">sock</span><span class="o">-&gt;</span><span class="n">connect</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
        <span class="n">writeToSocket</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
        
        <span class="n">ios</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">system</span><span class="o">::</span><span class="n">system_error</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">e</span><span class="p">.</span><span class="n">code</span><span class="p">().</span><span class="n">value</span><span class="p">();</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Boost.Asio提供一个自由函数asio::async_write()方法可以更方便地异步写到套接字：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">AsyncWriteStream</span><span class="p">,</span> <span class="k">typename</span> <span class="n">ConstBufferSequence</span><span class="p">,</span>
    <span class="k">typename</span> <span class="n">WriteHandler</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">async_write</span><span class="p">(</span><span class="n">AsyncWriteStream</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">ConstBufferSequence</span><span class="o">&amp;</span> <span class="n">buffers</span><span class="p">,</span> <span class="n">WriteHandler</span> <span class="n">handler</span><span class="p">);</span>
</code></pre></div>

<p>asio::async_write()函数是通过多次调用async_write_some()方法实现的。</p>

<h2 id="异步读tcp套接字">异步读TCP套接字</h2>
]]></content>
		</item>
		
		<item>
			<title>Asio.Cookbook 第1章 基础</title>
			<link>https://gitop.cc/posts/asio-cookbook-1/</link>
			<pubDate>Tue, 16 Aug 2016 08:45:19 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/asio-cookbook-1/</guid>
			<description>介绍 TCP协议是具有下列特性的传输层协议： 它是可靠的。这意味着TCP协议保证报文以正确的顺序传输，或者通知报文没有传输成功。TCP协议包含错</description>
			<content type="html"><![CDATA[

<h2 id="介绍">介绍</h2>

<p>TCP协议是具有下列特性的传输层协议：</p>

<ul>
<li>它是可靠的。这意味着TCP协议保证报文以正确的顺序传输，或者通知报文没有传输成功。TCP协议包含错误处理机制。</li>
<li>它假定建立逻辑连接。在一个程序通过TCP协议与另一个程序通信之前，它必须根据标准通过交换服务报文建立一个逻辑连接。</li>
<li>它假定点对点通信模型。也就是在单个连接上只有两个程序可以通信，不支持多播消息。</li>
<li>它是面向数据流的。这意味着一个程序发送给另一个程序的数据会被TCP协议解释为字节流。</li>
</ul>

<p>UDP协议是一个与TCP协议不同的传输层协议，它具有下列特性：</p>

<ul>
<li>它是不可靠的。这意味着如果一个发送者通过UDP协议发送一个报文，不保证报文会被发送。UDP协议不会尝试检查或修复任何错误。开发者负责所有的错误处理。</li>
<li>它是无连接的。这意味着在程序通信之前不需要建立连接。</li>
<li>它支持一对一或一对多通信模型。UDP协议支持多播消息。</li>
<li>它是面向数据报的。这意味着UDP协议将数据解释为特定大小的报文并且会尝试将报文作为一个整体发送。数据报文要么被作为一个整体发送，要么当发送失败时根本不会发送。</li>
</ul>

<p>因为UDP协议是不可靠的，它通常被用在可靠的局域网。如果想在因特网使用UDP协议，开发者必须实现错误处理机制。当需要在因特网传输时，因为可靠性，TCP协议通常是最好的选择。</p>

<h2 id="创建一个端点">创建一个端点</h2>

<p>端点服务两个目标：</p>

<ul>
<li>客户端程序使用端点指定一个想要通信的特定的服务端程序。</li>
<li>服务端程序使用端点指定一个本地的IP地址和端口，在此之上接收来自客户端的报文。</li>
</ul>

<h3 id="客户端创建端点">客户端创建端点</h3>

<ol>
<li>获取服务器程序的IP地址和端口。IP地址应该是点号隔开的字符串（IPv4）或者16进制的字符串（IPv6）。</li>
<li>使用一个asio::ip::address对象代表IP地址。</li>
<li>用address对象和端口初始化一个asio::ip::tcp::endpoint对象。</li>
</ol>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;boost/asio.hpp&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">raw_ip_address</span> <span class="o">=</span> <span class="s">&#34;127.0.0.1&#34;</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port_num</span> <span class="o">=</span> <span class="mi">3333</span><span class="p">;</span>

<span class="n">boost</span><span class="o">::</span><span class="n">error_code</span> <span class="n">ec</span><span class="p">;</span>
<span class="n">asio</span><span class="o">::</span><span class="n">address</span> <span class="n">ip_address</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">from_string</span><span class="p">(</span><span class="n">raw_ip_address</span><span class="p">,</span> <span class="n">ec</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ec</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// handle error
</span><span class="c1"></span><span class="p">}</span>

<span class="n">asio</span><span class="o">::</span><span class="n">endpoint</span> <span class="n">ep</span><span class="p">(</span><span class="n">ip_address</span><span class="p">,</span> <span class="n">port_num</span><span class="p">);</span>
</code></pre></div>

<h3 id="服务端创建端点">服务端创建端点</h3>

<ol>
<li>获取一个服务器将要监听请求的端口。</li>
<li>创建一个特殊的asio::ip::address对象表示这个服务器所有可用的IP地址。</li>
<li>使用address对象和端口初始化一个asio::ip::tcp::endpoint对象。</li>
</ol>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;boost/asio.hpp&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port_num</span> <span class="o">=</span> <span class="mi">3333</span><span class="p">;</span>

<span class="c1">// IPv6
</span><span class="c1"></span><span class="n">asio</span><span class="o">::</span><span class="n">address</span> <span class="n">ip_address</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">any</span><span class="p">();</span>
<span class="n">asio</span><span class="o">::</span><span class="n">endpoint</span> <span class="n">ep</span><span class="p">(</span><span class="n">ip_address</span><span class="p">,</span> <span class="n">port_num</span><span class="p">);</span>
</code></pre></div>

<p>Boost.Asio提供3个类用来表示IP地址：</p>

<ul>
<li>asio::ip::address_v4，代表IPv4地址</li>
<li>asio::ip::address_v6，代表IPv6地址</li>
<li>asio::ip::address，代表IPv4或IPv6地址</li>
</ul>

<p>from_string()是asio::ip::address的静态方法，它有4个重载形式：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">static</span> <span class="n">asio</span><span class="o">::</span><span class="n">address</span> <span class="n">from_string</span><span class="p">(</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">);</span>
    
<span class="k">static</span> <span class="n">asio</span><span class="o">::</span><span class="n">address</span> <span class="n">from_string</span><span class="p">(</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">,</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">ec</span><span class="p">);</span>
    
<span class="k">static</span> <span class="n">asio</span><span class="o">::</span><span class="n">address</span> <span class="n">from_string</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
    
<span class="k">static</span> <span class="n">asio</span><span class="o">::</span><span class="n">address</span> <span class="n">from_string</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">ec</span><span class="p">);</span>
</code></pre></div>

<p>为了表示主机可用的所有IP地址，asio::ip::address_v4和asio::ip::address_v6提供了一个静态方法any()。</p>

<p>asio::ip::tcp::endpoint其实是basic_endpoint&lt;&gt;模板的一个特例。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="n">basic_endpoint</span><span class="o">&lt;</span><span class="n">tcp</span><span class="o">&gt;</span> <span class="n">endpoint</span><span class="p">;</span>
</code></pre></div>

<p>同样asio::ip::udp::endpoint也是basic_endpoint&lt;&gt;模板的一个特例。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="n">basic_endpoint</span><span class="o">&lt;</span><span class="n">udp</span><span class="o">&gt;</span> <span class="n">endpoint</span><span class="p">;</span>
</code></pre></div>

<h2 id="创建一个主动套接字">创建一个主动套接字</h2>

<p>基本上，套接字有两种类型。主动套接字用来发起一个连接建立过程。被动套接字用来被动地等待传入的连接请求。</p>

<ol>
<li>创建一个asio::io_service实例，或者使用之前创建的。</li>
<li>创建一个代表传输层协议（TCP或UDP）和下层IP协议（IPv4或IPv6）的类对象。</li>
<li>创建一个代表套接字的对象，传递asio::io_service给它的构造函数。</li>
<li>调用open()方法，传递协议参数给它。</li>
</ol>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">asio_io_service</span> <span class="n">ios</span><span class="p">;</span>
<span class="n">asio</span><span class="o">::</span><span class="n">tcp</span> <span class="n">protocol</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">v4</span><span class="p">();</span>
<span class="n">asio</span><span class="o">::</span><span class="n">socket</span> <span class="n">sock</span><span class="p">(</span><span class="n">ios</span><span class="p">);</span>
<span class="n">boost</span><span class="o">::</span><span class="n">error_code</span> <span class="n">ec</span><span class="p">;</span>
<span class="n">sock</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">protocol</span><span class="p">,</span> <span class="n">ec</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ec</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// handle error
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Error code = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">ec</span><span class="p">.</span><span class="n">value</span><span class="p">()</span>
        <span class="o">&lt;&lt;</span> <span class="s">&#34; Message: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">ec</span><span class="p">.</span><span class="n">message</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">ec</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<p>asio::ip::tcp类代表TCP协议，它没有提供功能，而是像一个数据结构包含一组描述协议的值。</p>

<p>asio::ip::tcp没有公开的构造函数。相反它提供了2个静态方法（v4()和v6()）返回该类对象。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">tcp</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">typedef</span> <span class="n">basic_endpoint</span><span class="o">&lt;</span><span class="n">tcp</span><span class="o">&gt;</span> <span class="n">endpoint</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">basic_stream_socket</span><span class="o">&lt;</span><span class="n">tcp</span><span class="o">&gt;</span> <span class="n">socket</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">basic_socket_acceptor</span><span class="o">&lt;</span><span class="n">tcp</span><span class="o">&gt;</span> <span class="n">acceptor</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>使用UDP协议创建主动套接字和TCP类似：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">asio</span><span class="o">::</span><span class="n">io_service</span> <span class="n">ios</span><span class="p">;</span>
<span class="n">asio</span><span class="o">::</span><span class="n">udp</span> <span class="n">protocol</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">v6</span><span class="p">();</span>
<span class="k">try</span> <span class="p">{</span>
    <span class="n">asio</span><span class="o">::</span><span class="n">socket</span> <span class="n">sock</span><span class="p">(</span><span class="n">ios</span><span class="p">,</span> <span class="n">protocol</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">system_error</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">code</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="创建一个被动套接字">创建一个被动套接字</h2>

<p>一个被动套接字或者接收器套接字是一种用来等待建立连接请求的套接字。它有2个重要的暗示：</p>

<ul>
<li>被动套接字只用在服务端程序或者既是服务端又是客户端的程序。</li>
<li>被动套接字只被TCP协议定义。</li>
</ul>

<p>在Boost.Asio里面一个被动套接字由asio::ip::tcp::acceptor类来表示。</p>

<ol>
<li>创建一个asio::io_service实例或使用之前创建的。</li>
<li>创建一个asio::ip::tcp类对象代表TCP协议和所需底层的IP协议（IPv4和IPv6）。</li>
<li>创建一个asio::ip::tcp::acceptor类对象表示接收器套接字，传递asio::io_service类对象给它的构造函数。</li>
<li>调用接收器套接字的open()函数，传递第2步创建的对象给它。</li>
</ol>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">asio</span><span class="o">::</span><span class="n">io_service</span> <span class="n">ios</span><span class="p">;</span>
<span class="n">asio</span><span class="o">::</span><span class="n">tcp</span> <span class="n">protocol</span> <span class="o">=</span> <span class="n">asio</span><span class="o">::</span><span class="n">v6</span><span class="p">();</span>
<span class="n">asio</span><span class="o">::</span><span class="n">acceptor</span> <span class="n">acceptor</span><span class="p">(</span><span class="n">ios</span><span class="p">);</span>
<span class="n">boost</span><span class="o">::</span><span class="n">error_code</span> <span class="n">ec</span><span class="p">;</span>
<span class="n">acceptor</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">protocol</span><span class="p">,</span> <span class="n">ec</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ec</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">ec</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">ec</span><span class="p">.</span><span class="n">message</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="解析域名">解析域名</h2>

<p>域名系统是一个分布式的命名系统，它允许将人类友好的名字和计算机网络中的设备关联起来。一个域名是一个表示计算机网络设备名字的字符串。更确切地说，一个域名是一个或多个IP地址的别名。</p>

<p>域名系统作为一个分布式的数据库，存储了域名到相应IP地址的映射，并提供一个接口，允许查询一个特定域名所映射的IP地址。将域名转换为相应IP地址的过程称为域名解析。</p>

<ol>
<li>获取DNS域名和端口，并用字符串表示。</li>
<li>创建一个asio::io_service实例或使用之前创建的。</li>
<li>创建一个resolver::query类对象。</li>
<li>创建一个适合必要协议的DNS解析对象。</li>
<li>调用解析器的resolve()方法，用query对象作为参数。</li>
</ol>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">host</span> <span class="o">=</span> <span class="s">&#34;samplehost.com&#34;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">port_num</span> <span class="o">=</span> <span class="s">&#34;3333&#34;</span><span class="p">;</span>

<span class="n">asio</span><span class="o">::</span><span class="n">io_service</span> <span class="n">ios</span><span class="p">;</span>

<span class="n">asio</span><span class="o">::</span><span class="n">query</span> <span class="n">query</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port_num</span><span class="p">,</span>
    <span class="n">asio</span><span class="o">::</span><span class="n">numeric_service</span><span class="p">);</span>
    
<span class="n">asio</span><span class="o">::</span><span class="n">resolver</span> <span class="n">resolver</span><span class="p">(</span><span class="n">ios</span><span class="p">);</span>

<span class="n">boost</span><span class="o">::</span><span class="n">error_code</span> <span class="n">ec</span><span class="p">;</span>
<span class="n">asio</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> 
    <span class="n">resolver</span><span class="p">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">ec</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ec</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// handle error
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<p>asio::ip::tcp::resolver::iterator类是一个迭代器，它指向解析结果的第一个元素，元素类型是asio::ip::basic_resolver_entry&lt;tcp&gt;。每一个结果包含一个endpoint对象，可以通过asio::ip::basic_resolver_entry&lt;tcp&gt;::endpoint()获取。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">asio</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span>
    <span class="n">resolver</span><span class="p">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">ec</span><span class="p">);</span>
<span class="n">asio</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it_end</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">it_end</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">asio</span><span class="o">::</span><span class="n">endpoint</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">endpoint</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<p>当域名被映射到多个IP地址，并且有些是IPv4，有些是IPv6时，则结果集合中包含2种endpoint。</p>

<p>通过UDP协议解析域名也是类似的。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">host</span> <span class="o">=</span> <span class="s">&#34;www.samplehost.com&#34;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">port_num</span> <span class="o">=</span> <span class="s">&#34;3333&#34;</span><span class="p">;</span>

<span class="n">asio</span><span class="o">::</span><span class="n">io_service</span> <span class="n">ios</span><span class="p">;</span>

<span class="n">asio</span><span class="o">::</span><span class="n">query</span> <span class="n">query</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port_num</span><span class="p">,</span>
    <span class="n">asio</span><span class="o">::</span><span class="n">numeric_service</span><span class="p">);</span>

<span class="n">asio</span><span class="o">::</span><span class="n">resolver</span> <span class="n">resolver</span><span class="p">(</span><span class="n">ios</span><span class="p">);</span>

<span class="n">boost</span><span class="o">::</span><span class="n">error_code</span> <span class="n">ec</span><span class="p">;</span>
<span class="n">asio</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> 
    <span class="n">resolver</span><span class="p">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">ec</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ec</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// handle error
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<h2 id="绑定套接字到端点">绑定套接字到端点</h2>

<p>有些操作隐式绑定未绑定套接字。比如主动套接字连接服务器，客户端程序不需要特定的端点与服务器通信，因此它通常将选择绑定IP地址和端口的权利委托给操作系统。服务端程序通常需要显示将被动套接字绑定到特定的端点。</p>

<ol>
<li>获取服务器监听连接请求的端口。</li>
<li>创建一个表示主机所有可用IP地址的端点。</li>
<li>创建并打开一个接收器套接字。</li>
<li>调用接收器套接字的bind()方法，将断点作为参数传给它。</li>
</ol>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port_num</span> <span class="o">=</span> <span class="mi">3333</span><span class="p">;</span>
<span class="n">asio</span><span class="o">::</span><span class="n">endpoint</span> <span class="n">ep</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">any</span><span class="p">(),</span> <span class="n">port_num</span><span class="p">);</span>
<span class="n">asio</span><span class="o">::</span><span class="n">acceptor</span> <span class="n">acceptor</span><span class="p">(</span><span class="n">ios</span><span class="p">,</span> <span class="n">ep</span><span class="p">.</span><span class="n">protocol</span><span class="p">());</span>

<span class="n">boost</span><span class="o">::</span><span class="n">error_code</span> <span class="n">ec</span><span class="p">;</span>
<span class="n">acceptor</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">ec</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ec</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// handle error
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<p>UDP服务器不建立连接，而且使用主动套接字等待到来的请求。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port_num</span> <span class="o">=</span> <span class="mi">3333</span><span class="p">;</span>
<span class="n">asio</span><span class="o">::</span><span class="n">endpoint</span> <span class="n">ep</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">any</span><span class="p">(),</span> <span class="n">port_num</span><span class="p">);</span>
<span class="n">asio</span><span class="o">::</span><span class="n">io_service</span> <span class="n">ios</span><span class="p">;</span>
<span class="n">asio</span><span class="o">::</span><span class="n">socket</span> <span class="n">sock</span><span class="p">(</span><span class="n">ios</span><span class="p">,</span> <span class="n">ep</span><span class="p">.</span><span class="n">protocol</span><span class="p">());</span>

<span class="n">boost</span><span class="o">::</span><span class="n">error_code</span> <span class="n">ec</span><span class="p">;</span>
<span class="n">sock</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">ec</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ec</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// handle error
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<h2 id="连接一个套接字">连接一个套接字</h2>

<ol>
<li>获取服务器程序的IP地址和端口。</li>
<li>用IP地址和端口创建一个endpoint对象。</li>
<li>创建并打开一个主动套接字。</li>
<li>用endpoint对象作参数调用connect()方法。</li>
<li>如果方法成功，套接字被认为已连接并可以用来发送和接收来自服务器的数据。</li>
</ol>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">raw_ip_address</span> <span class="o">=</span> <span class="s">&#34;127.0.0.1&#34;</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port_num</span> <span class="o">=</span> <span class="mi">3333</span><span class="p">;</span>
<span class="k">try</span> <span class="p">{</span>
    <span class="n">asio</span><span class="o">::</span><span class="n">endpoint</span> <span class="n">ep</span><span class="p">(</span>
        <span class="n">asio</span><span class="o">::</span><span class="n">from_string</span><span class="p">(</span><span class="n">raw_ip_address</span><span class="p">),</span> <span class="n">port_num</span><span class="p">);</span>
    <span class="n">asio</span><span class="o">::</span><span class="n">io_service</span> <span class="n">ios</span><span class="p">;</span>
    <span class="n">asio</span><span class="o">::</span><span class="n">socket</span> <span class="n">sock</span><span class="p">(</span><span class="n">ios</span><span class="p">,</span> <span class="n">ep</span><span class="p">.</span><span class="n">protocol</span><span class="p">());</span>
    <span class="n">sock</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
    <span class="c1">// At this point socket &#39;sock&#39; is connected to the server
</span><span class="c1"></span>    <span class="c1">// connect()方法会将客户端IP地址和操作系统选好端口绑定到&#39;sock&#39;
</span><span class="c1"></span><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">system_error</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">code</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<p>自由函数asio::connect()接收一个主动套接字对象和一个asio::ip::tcp::resolver::iterator对象作为参数，遍历所有端点。</p>

<ol>
<li>获取DNS域名和端口，并用字符串表示。</li>
<li>使用asio::ip::tcp::resolver类解析域名。</li>
<li>创建一个主动套接字，不打开它。</li>
<li>调用asio::connect()函数。</li>
</ol>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">host</span> <span class="o">=</span> <span class="s">&#34;samplehost.com&#34;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">port_num</span> <span class="o">=</span> <span class="s">&#34;3333&#34;</span><span class="p">;</span>

<span class="n">asio</span><span class="o">::</span><span class="n">query</span> <span class="n">query</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port_num</span>
    <span class="n">asio</span><span class="o">::</span><span class="n">numeric_service</span><span class="p">);</span>
    
<span class="n">asio</span><span class="o">::</span><span class="n">io_service</span> <span class="n">ios</span><span class="p">;</span>

<span class="n">asio</span><span class="o">::</span><span class="n">resolver</span> <span class="n">resolver</span><span class="p">(</span><span class="n">ios</span><span class="p">);</span>

<span class="k">try</span> <span class="p">{</span>
    <span class="n">asio</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> 
        <span class="n">resolver</span><span class="p">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">query</span><span class="p">);</span>
    
    <span class="n">asio</span><span class="o">::</span><span class="n">socket</span> <span class="n">sock</span><span class="p">(</span><span class="n">ios</span><span class="p">);</span>

    <span class="n">asio</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">it</span><span class="p">);</span>
    <span class="c1">// At this point &#39;sock&#39; is connected to the server
</span><span class="c1"></span><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">system_error</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">code</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="接受连接">接受连接</h2>

<ol>
<li>获取服务器监听连接请求的端口。</li>
<li>创建一个端点。</li>
<li>初始化并打开一个接收器套接字。</li>
<li>绑定接收器套接字到端点。</li>
<li>调用listen()方法开始监听端点上到来的连接请求。</li>
<li>初始化一个主动套接字对象。</li>
<li>当准备好处理连接请求时，用主动套接字作为参数，调用接收器套接字的accept()方法。</li>
<li>如果调用成功，主动套接字和客户端程序就连上了，可以用来通信了。</li>
</ol>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="kt">int</span> <span class="n">BACKLOG_SIZE</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">port_num</span> <span class="o">=</span> <span class="mi">3333</span><span class="p">;</span>
<span class="n">asio</span><span class="o">::</span><span class="n">endpoint</span> <span class="n">ep</span><span class="p">(</span><span class="n">asio</span><span class="o">::</span><span class="n">any</span><span class="p">(),</span> <span class="n">port_num</span><span class="p">);</span>

<span class="n">asio</span><span class="o">::</span><span class="n">io_service</span> <span class="n">ios</span><span class="p">;</span>

<span class="k">try</span> <span class="p">{</span>
    <span class="n">asio</span><span class="o">::</span><span class="n">acceptor</span> <span class="n">acceptor</span><span class="p">(</span><span class="n">ios</span><span class="p">,</span> <span class="n">ep</span><span class="p">.</span><span class="n">protocol</span><span class="p">());</span>
    <span class="n">acceptor</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>

    <span class="n">acceptor</span><span class="p">.</span><span class="n">listen</span><span class="p">(</span><span class="n">BACKLOG_SIZE</span><span class="p">);</span>

    <span class="n">asio</span><span class="o">::</span><span class="n">socket</span> <span class="n">sock</span><span class="p">(</span><span class="n">ios</span><span class="p">);</span>
    <span class="n">acceptor</span><span class="p">.</span><span class="n">accept</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
    <span class="c1">// At this point &#39;sock&#39; is connected to the client
</span><span class="c1"></span><span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">system_error</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">code</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<p>注意UDP服务器不使用接收器套接字，因为UDP协议不需要建立连接。相反，主动套接字被使用来绑定到一个端点并监听到来的报文，而且同一个主动套接字也用来通信。</p>
]]></content>
		</item>
		
		<item>
			<title>MySQL Cookbook 第5章 处理字符串</title>
			<link>https://gitop.cc/posts/mysql-cookbook-5/</link>
			<pubDate>Thu, 07 Apr 2016 22:45:02 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/mysql-cookbook-5/</guid>
			<description>5.0. Introduction A string can be binary or nonbinary. Binary strings are used for raw data such as images, music files, or encrypted values. Nonbinary strings are used for character data such as text and are associated with a character set and collation (sort order). A character set determines which characters are legal in a string. You can choose collations according to whether you need comparisons to be case sensitive</description>
			<content type="html"><![CDATA[

<h1 id="5-0-introduction">5.0. Introduction</h1>

<ul>
<li>A string can be binary or nonbinary. Binary strings are used for raw data such as
images, music files, or encrypted values. Nonbinary strings are used for character
data such as text and are associated with a character set and collation (sort order).</li>
<li>A character set determines which characters are legal in a string. You can choose
collations according to whether you need comparisons to be case sensitive or case
insensitive, or to use the rules of a particular language.</li>
<li>Data types for binary strings are BINARY, VARBINARY, and BLOB. Data types for
nonbinary strings are CHAR, VARCHAR, and TEXT, each of which permits CHARACTER
SET and COLLATE attributes.</li>
<li>You can convert a binary string to a nonbinary string and vice versa, or convert a
nonbinary string from one character set or collation to another.</li>
<li>You can use a string in its entirety or extract substrings from it. Strings can be
combined with other strings.</li>
<li>You can apply pattern-matching operations to strings.</li>
<li>Full-text searching is available for efficient queries on large collections of text.</li>
</ul>

<h1 id="5-1-string-properties">5.1. String Properties</h1>

<p>One string property is whether it is binary or nonbinary:</p>

<ul>
<li>A binary string is a sequence of bytes. It can contain any type of information, such
as images, MP3 files, or compressed or encrypted data. A binary string is not as‐
sociated with a character set, even if you store a value such as abc that looks like
ordinary text. Binary strings are compared byte by byte using numeric byte values.</li>
<li>A nonbinary string is a sequence of characters. It stores text that has a particular
character set and collation. The character set defines which characters can be stored
in the string. The collation defines the character ordering, which affects comparison
and sorting operations.</li>
</ul>

<p>To see which character sets are available for nonbinary strings, use this statement:</p>

<pre><code>mysql&gt; SHOW CHARACTER SET;
+----------|-----------------------------|---------------------|--------+
| Charset  | Description                 | Default collation   | Maxlen |
+----------|-----------------------------|---------------------|--------+
| big5     | Big5 Traditional Chinese    | big5_chinese_ci     |      2 | 
| dec8     | DEC West European           | dec8_swedish_ci     |      1 | 
| cp850    | DOS West European           | cp850_general_ci    |      1 | 
| hp8      | HP West European            | hp8_english_ci      |      1 | 
</code></pre>

<p>The default character set in MySQL is latin1. If you must store characters from several
languages in a single column, consider using one of the Unicode character sets (such as
utf8 or ucs2) because they can represent characters from multiple languages.</p>

<p>To determine whether a given string contains multibyte characters, use the LENGTH()
and CHAR_LENGTH() functions, which return the length of a string in bytes and charac‐
ters, respectively. If LENGTH() is greater than CHAR_LENGTH() for a given string, multibyte
characters are present:
* The utf8 Unicode character set has multibyte characters, but a given utf8 string
might contain only single-byte characters, as in the following example:</p>

<pre><code>    mysql&gt; SET @s = CONVERT('abc' USING utf8);
    mysql&gt; SELECT LENGTH(@s), CHAR_LENGTH(@s);
    +------------|-----------------+
    | LENGTH(@s) | CHAR_LENGTH(@s) |
    +------------|-----------------+
    |          3 |               3 | 
    +------------|-----------------+
</code></pre>

<ul>
<li><p>For the ucs2 Unicode character set, all characters are encoded using two bytes, even
if they are single-byte characters in another character set such as latin1. Thus,
every ucs2 string contains multibyte characters:</p>

<pre><code>mysql&gt; SET @s = CONVERT('abc' USING ucs2);
mysql&gt; SELECT LENGTH(@s), CHAR_LENGTH(@s);
+------------|-----------------+
| LENGTH(@s) | CHAR_LENGTH(@s) |
+------------|-----------------+
|          6 |               3 | 
+------------|-----------------+
</code></pre>

<p>Another property of nonbinary strings is collation, which determines the sort order of
characters in the character set. Use SHOW COLLATION to see all available collations; add a
LIKE clause to see the collations for a particular character set:</p>

<pre><code>mysql&gt; SHOW COLLATION LIKE 'latin1%';
+-------------------|---------|----|---------|----------|---------+
| Collation         | Charset | Id | Default | Compiled | Sortlen |
+-------------------|---------|----|---------|----------|---------+
| latin1_german1_ci | latin1  |  5 |         | Yes      |       1 | 
| latin1_swedish_ci | latin1  |  8 | Yes     | Yes      |       1 | 
| latin1_danish_ci  | latin1  | 15 |         | Yes      |       1 | 
| latin1_german2_ci | latin1  | 31 |         | Yes      |       2 | 
| latin1_bin        | latin1  | 47 |         | Yes      |       1 | 
| latin1_general_ci | latin1  | 48 |         | Yes      |       1 | 
| latin1_general_cs | latin1  | 49 |         | Yes      |       1 | 
| latin1_spanish_ci | latin1  | 94 |         | Yes      |       1 | 
+-------------------|---------|----|---------|----------|---------+
</code></pre>

<p>In contexts where no collation is specified explicitly, strings in a given character set use
the collation with Yes in the Default column. As shown, the default collation for lat
in1 is latin1_swedish_ci. (Default collations are also displayed by SHOW CHARACTER
SET.)</p></li>
</ul>

<p>A collation can be case sensitive (a and A are different), case insensitive (a and A are the
same), or binary (two characters are the same or different based on whether their nu‐
meric values are equal). A collation name ending in _ci, _cs, or _bin is case insensitive,
case sensitive, or binary, respectively.</p>

<p>The following example illustrates how collation affects sort order. Suppose that a table
contains a latin1 string column and has the following rows:</p>

<pre><code>mysql&gt; CREATE TABLE t (c CHAR(3) CHARACTER SET latin1);
mysql&gt; INSERT INTO t (c) VALUES('AAA'),('bbb'),('aaa'),('BBB');
mysql&gt; SELECT c FROM t;
+------+
| c    |
+------+
| AAA  | 
| bbb  | 
| aaa  | 
| BBB  | 
+------+
</code></pre>

<p>By applying the COLLATE operator to the column, you can choose which collation to use
for sorting and thus affect the order of the result:</p>

<ul>
<li><p>A case-insensitive collation sorts a and A together, placing them before b and B.
However, for a given letter, it does not necessarily order one lettercase before an‐
other, as shown by the following result:</p>

<pre><code>mysql&gt; SELECT c FROM t ORDER BY c COLLATE latin1_swedish_ci;
+------+
| c    |
+------+
| AAA  | 
| aaa  | 
| bbb  | 
| BBB  | 
+------+
</code></pre></li>

<li><p>A case-sensitive collation puts A and a before B and b, and sorts uppercase before
lowercase:</p>

<pre><code>mysql&gt; SELECT c FROM t ORDER BY c COLLATE latin1_general_cs;
+------+
| c    |
+------+
| AAA  | 
| aaa  | 
| BBB  | 
| bbb  | 
+------+
</code></pre></li>

<li><p>A binary collation sorts characters using their numeric values. Assuming that up‐
percase letters have numeric values less than those of lowercase letters, a binary
collation results in the following ordering:</p>

<pre><code>mysql&gt; SELECT c FROM t ORDER BY c COLLATE latin1_bin;
+------+
| c    |
+------+
| AAA  | 
| BBB  | 
| aaa  | 
| bbb  | 
+------+
</code></pre>

<p>If you require that comparison and sorting operations use the sorting rules of a particular
language, choose a language-specific collation. For example, if you store strings using
the utf8 character set, the default collation (utf8_general_ci) treats ch and ll as twocharacter strings. To use the traditional Spanish ordering that treats ch and ll as single
characters that follow c and l, respectively, specify the utf8_spanish2_ci collation. The
two collations produce different results, as shown here:</p>

<pre><code>mysql&gt; CREATE TABLE t (c CHAR(2) CHARACTER SET utf8);
mysql&gt; INSERT INTO t (c) VALUES('cg'),('ch'),('ci'),('lk'),('ll'),('lm');
mysql&gt; SELECT c FROM t ORDER BY c COLLATE utf8_general_ci;
mysql&gt; SELECT c FROM t ORDER BY c COLLATE utf8_spanish2_ci;
</code></pre></li>
</ul>

<h1 id="5-2-choosing-a-string-data-type">5.2. Choosing a String Data Type</h1>

<p>Problem</p>

<p>You want to store string data but aren’t sure which is the most appropriate data type.</p>

<p>Solution</p>

<p>Choose the data type according to the characteristics of the information to be stored
and how you need to use it. Consider questions such as these:
* Are the strings binary or nonbinary?
* Does case sensitivity matter?
* What is the maximum string length?
* Do you want to store fixed- or variable-length values?
* Do you need to retain trailing spaces?
* Is there a fixed set of permitted values?</p>

<p>Discussion</p>

<p>MySQL provides several binary and nonbinary string data types. These types come in
pairs as shown in the following table. The maximum length is in bytes, whether the type
is binary or nonbinary. For nonbinary types, the maximum number of characters is less
for strings that contain multibyte characters:</p>

<p>| Binary data type | Nonbinary data type | Maximum length |
| &ndash; | &ndash; | &ndash; |
| BINARY | CHAR | 255 |
| VARBINARY | VARCHAR | 65,535 |
| TINYBLOB | TINYTEXT | 255 |
| BLOB | TEXT | 65,535 |
| MEDIUMBLOB | MEDIUMTEXT | 16,777,215 |
| LONGBLOB | LONGTEXT | 4,294,967,295 |</p>

<p>For the BINARY and CHAR data types, MySQL stores column values using a fixed width.
For example, values stored in a BINARY(10) or CHAR(10) column always take 10 bytes
or 10 characters, respectively. Shorter values are padded to the required length as nec‐essary when stored. For BINARY, the pad value is 0x00 (the zero-valued byte, also known
as ASCII NUL). CHAR values are padded with spaces for storage and trailing spaces are
stripped upon retrieval.
For VARBINARY, VARCHAR, and the BLOB and TEXT types, MySQL stores values using only
as much storage as required, up to the maximum column length. No padding is added
or stripped when values are stored or retrieved.
To preserve trailing pad values that are present in the original strings that are stored,
use a data type for which no stripping occurs. For example, if you store character (non‐
binary) strings that might end with spaces, and want to preserve them, use VARCHAR or
one of the TEXT data types. The following statements illustrate the difference in trailingspace handling for CHAR and VARCHAR columns:</p>

<pre><code>mysql&gt; CREATE TABLE t (c1 CHAR(10), c2 VARCHAR(10));
mysql&gt; INSERT INTO t (c1,c2) VALUES('abc ','abc ');
mysql&gt; SELECT c1, c2, CHAR_LENGTH(c1), CHAR_LENGTH(c2) FROM t;
+------|------|-----------------|-----------------+
| c1   | c2   | CHAR_LENGTH(c1) | CHAR_LENGTH(c2) |
+------|------|-----------------|-----------------+
| abc  | abc  |               3 |               4 | 
+------|------|-----------------|-----------------+
</code></pre>

<p>A table can include a mix of binary and nonbinary string columns, and its nonbinary
columns can use different character sets and collations. When you declare a nonbinary
string column, use the CHARACTER SET and COLLATE attributes if you require a particular
character set and collation. For example, if you need to store utf8 (Unicode) and sjis
(Japanese) strings, you might define a table with two columns like this:</p>

<pre><code>CREATE TABLE mytbl
(
    utf8str VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_danish_ci,
    sjisstr VARCHAR(100) CHARACTER SET sjis COLLATE sjis_japanese_ci
);
</code></pre>

<p>The CHARACTER SET and COLLATE clauses are each optional in a column definition:
* If you specify CHARACTER SET and omit COLLATE, the default collation for the char‐
acter set is used.
* If you specify COLLATE and omit CHARACTER SET, the character set implied by the
collation name (the first part of the name) is used. For example, utf8_danish_ci
and sjis_japanese_ci imply utf8 and sjis, respectively. This means that the
CHARACTER SET attributes could have been omitted from the preceding CREATE TABLE
statement.</p>

<ul>
<li>If you omit both CHARACTER SET and COLLATE, the column is assigned the table
default character set and collation. A table definition can include those attributes
following the closing parenthesis at the end of the CREATE TABLE statement. If
present, they apply to columns that have no explicit character set or collation of
their own. If omitted, the table defaults are taken from the database defaults. You
can specify the database defaults when you create the database with the CREATE
DATABASE statement. The server defaults apply to the database if they are omitted.</li>
</ul>

<p>The server default character set and collation are latin1 and latin1_swedish_ci, so
strings by default use the latin1 character set and are not case sensitive. To change this,
set the character_set_server and collation_server system variables at server start‐
up</p>

<p>MySQL also supports ENUM and SET string types, which are used for columns that have
a fixed set of permitted values. The CHARACTER SET and COLLATE attributes apply to these
data types as well.</p>

<h1 id="5-3-setting-the-client-connection-character-set">5.3. Setting the Client Connection Character Set</h1>

<p>Problem</p>

<p>You’re executing SQL statements or producing query results that don’t use the default
character set.</p>

<p>Solution</p>

<p>Use SET NAMES or an equivalent method to set your connection to the proper character
set</p>

<p>Discussion</p>

<p>To deal with this problem, configure your connection to use the appropriate character
set. You have several ways to do this:</p>

<ul>
<li><p>Issue a SET NAMES statement after you connect:</p>

<pre><code>mysql&gt; SET NAMES 'utf8';
</code></pre>

<p>SET NAMES permits the connection collation to be specified as well:</p>

<pre><code>mysql&gt; SET NAMES 'utf8' COLLATE 'utf8_general_ci';
</code></pre></li>

<li><p>If your client program supports the &ndash;default-character-set option, you can use
it to specify the character set at program invocation time. mysql is one such program.
Put the option in an option file so that it takes effect each time you connect to the
server:</p>

<pre><code>[mysql]
default-character-set=utf8
</code></pre></li>

<li><p>If you set the environment for your working environment using the LANG or LC_ALL
environment variable on Unix, or the code page setting on Windows, MySQL client
programs automatically detect which character set to use. For example, setting
LC_ALL to en_US.UTF-8 causes programs such as mysql to use utf8.</p></li>

<li><p>Some programming interfaces provide their own method of setting the character
set. For example, MySQL Connector/J for Java clients detects the character set used
on the server side automatically when you connect, but you can specify a different
set explicitly using the characterEncoding property in the connection URL. The
property value should be the Java-style character-set name. To select utf8, you
might use a connection URL like this:</p>

<pre><code>jdbc:mysql://localhost/cookbook?characterEncoding=UTF-8
</code></pre>

<p>This is preferable to SET NAMES because Connector/J performs character-set con‐
version on behalf of the application, but is unaware of which character set applies
if you use SET NAMES. Similar principles apply to programs written for other APIs.
For PDO, use a charset option in your data source name (DSN) string (this works
in PHP 5.3.6 or later):</p>

<pre><code>$dsn = &quot;mysql:host=localhost;dbname=cookbook;charset=utf8&quot;;
</code></pre>

<p>For Connector/Python, specify a charset connection parameter:</p>

<pre><code>conn_params = {
&quot;database&quot;: &quot;cookbook&quot;,
&quot;host&quot;: &quot;localhost&quot;,
&quot;user&quot;: &quot;cbuser&quot;,
&quot;password&quot;: &quot;cbpass&quot;,
&quot;charset&quot;: &quot;utf8&quot;,
}
</code></pre>

<p>Some APIs may also provide a parameter to specify the collation.</p></li>
</ul>

<h1 id="5-4-writing-string-literals">5.4. Writing String Literals</h1>

<p>Problem</p>

<p>You need to write literal strings in SQL statements.</p>

<p>Solution</p>

<p>Learn the syntax rules that govern string values.</p>

<p>Discussion</p>

<p>You can write strings several ways:</p>

<ul>
<li><p>Enclose the text of the string within single quotes or double quotes:
&lsquo;my string&rsquo;
&ldquo;my string&rdquo;
When the ANSI_QUOTES SQL mode is enabled, you cannot use double quotes for
quoting strings: the server interprets double quote as the quoting character for
identifiers such as table or column names, and not for strings</p></li>

<li><p>Use hexadecimal notation. Each pair of hex digits produces one byte of the string.
abcd can be written using any of these formats:
0x61626364
X&rsquo;61626364&rsquo;
x&rsquo;61626364&rsquo;
MySQL treats strings written using hex notation as binary strings. Not coinciden‐
tally, it’s common for applications to use hex strings when constructing SQL state‐
ments that refer to binary values:</p></li>
</ul>

<p>INSERT INTO t SET binary_col = 0xdeadbeef;</p>

<ul>
<li>To specify a character set for interpretation of a literal string, use an introducer
consisting of a character-set name preceded by an underscore:
_latin1 &lsquo;abcd&rsquo;
_ucs2 &lsquo;abcd&rsquo;
An introducer tells the server how to interpret the string that follows it. For _lat
in1 &lsquo;abcd&rsquo;, the server produces a string consisting of four single-byte characters.
For _ucs2 &lsquo;abcd&rsquo;, the server produces a string consisting of two two-byte characters
because ucs2 is a double-byte character set.</li>
</ul>

<p>A quoted string that includes the same quote character produces a syntax error:</p>

<pre><code>mysql&gt; SELECT 'I'm asleep';
ERROR 1064 (42000): You have an error in your SQL syntax near 'asleep''
</code></pre>

<p>You have several ways to deal with this:
* Enclose a string containing single quotes within double quotes (assuming that
ANSI_QUOTES is disabled), or enclose a string containing double quotes within single
quotes:</p>

<pre><code>    mysql&gt; SELECT &quot;I'm asleep&quot;, 'He said, &quot;Boo!&quot;';
    +------------|-----------------+
    | I'm asleep | He said, &quot;Boo!&quot; |
    +------------|-----------------+
    | I'm asleep | He said, &quot;Boo!&quot; | 
    +------------|-----------------+
</code></pre>

<ul>
<li><p>To include a quote character within a string quoted by the same kind of quote,
double the quote or precede it with a backslash. When MySQL reads the statement,
it strips the extra quote or the backslash:</p>

<pre><code>mysql&gt; SELECT 'I''m asleep', 'I\'m wide awake';
+------------|----------------+
| I'm asleep | I'm wide awake |
+------------|----------------+
| I'm asleep | I'm wide awake | 
+------------|----------------+
mysql&gt; SELECT &quot;He said, &quot;&quot;Boo!&quot;&quot;&quot;, &quot;And I said, \&quot;Yikes!\&quot;&quot;;
+-----------------|----------------------+
| He said, &quot;Boo!&quot; | And I said, &quot;Yikes!&quot; |
+-----------------|----------------------+
| He said, &quot;Boo!&quot; | And I said, &quot;Yikes!&quot; | 
+-----------------|----------------------+
</code></pre>

<p>A backslash turns off any special meaning of the following character, including
itself. To write a literal backslash within a string, double it:</p>

<pre><code>mysql&gt; SELECT 'Install MySQL in C:\\mysql on Windows';
+--------------------------------------+
| Install MySQL in C:\mysql on Windows |
+--------------------------------------+
| Install MySQL in C:\mysql on Windows | 
+--------------------------------------+
</code></pre></li>

<li><p>Write the string as a hex value:</p>

<pre><code>mysql&gt; SELECT 0x49276D2061736C656570;
+------------------------+
| 0x49276D2061736C656570 |
+------------------------+
| I'm asleep             | 
+------------------------+
</code></pre></li>
</ul>

<h1 id="5-5-checking-or-changing-a-string-s-character-set-or-collation">5.5. Checking or Changing a String’s Character Set or Collation</h1>

<p>Problem</p>

<p>You want to know the character set or collation of a string, or change a string to some
other character set or collation.</p>

<p>Solution</p>

<p>To check a string’s character set or collation, use the CHARSET() or COLLATION() func‐
tion. To change its character set, use the CONVERT() function. To change its collation,
use the COLLATE operator.</p>

<p>Discussion</p>

<p>To determine a string’s character set or collation, use the CHARSET() or COLLATION()
function. For example, did you know that the USER() function returns a Unicode string?</p>

<pre><code>mysql&gt; SELECT USER(), CHARSET(USER()), COLLATION(USER());
+------------------|-----------------|-------------------+
| USER()           | CHARSET(USER()) | COLLATION(USER()) |
+------------------|-----------------|-------------------+
| cbuser@localhost | utf8            | utf8_general_ci   | 
+------------------|-----------------|-------------------+
</code></pre>

<p>String values that take their character set and collation from the current configuration
may change properties if the configuration changes. This is true for literal strings:</p>

<pre><code>mysql&gt; SET NAMES 'latin1';
mysql&gt; SELECT CHARSET('abc'), COLLATION('abc');
+----------------|-------------------+
| CHARSET('abc') | COLLATION('abc')  |
+----------------|-------------------+
| latin1         | latin1_swedish_ci | 
+----------------|-------------------+
mysql&gt; SET NAMES utf8 COLLATE 'utf8_bin';
mysql&gt; SELECT CHARSET('abc'), COLLATION('abc');
+----------------|------------------+
| CHARSET('abc') | COLLATION('abc') |
+----------------|------------------+
| utf8           | utf8_bin         | 
+----------------|------------------+
</code></pre>

<p>For a binary string, the CHARSET() or COLLATION() functions return a value of binary,
which means that the string is compared and sorted based on numeric byte values, not
character collation values.
To convert a string from one character set to another, use the CONVERT() function:</p>

<pre><code>mysql&gt; SET @s1 = _latin1 'my string', @s2 = CONVERT(@s1 USING utf8);
mysql&gt; SELECT CHARSET(@s1), CHARSET(@s2);
+--------------|--------------+
| CHARSET(@s1) | CHARSET(@s2) |
+--------------|--------------+
| latin1       | utf8         | 
+--------------|--------------+
</code></pre>

<p>To change the collation of a string, use the COLLATE operator:</p>

<pre><code>mysql&gt; SET @s1 = _latin1 'my string', @s2 = @s1 COLLATE latin1_spanish_ci;
mysql&gt; SELECT COLLATION(@s1), COLLATION(@s2);
+-------------------|-------------------+
| COLLATION(@s1)    | COLLATION(@s2)    |
+-------------------|-------------------+
| latin1_swedish_ci | latin1_spanish_ci | 
+-------------------|-------------------+
</code></pre>

<p>The new collation must be legal for the character set of the string. For example, you can
use the utf8_general_ci collation with utf8 strings, but not with latin1 strings:</p>

<pre><code>mysql&gt; SELECT _latin1 'abc' COLLATE utf8_bin;
ERROR 1253 (42000): COLLATION 'utf8_bin' is not valid for
CHARACTER SET 'latin1'
</code></pre>

<p>To convert both the character set and collation of a string, use CONVERT() to change the
character set, and apply the COLLATE operator to the result:</p>

<pre><code>mysql&gt; SET @s1 = _latin1 'my string';
mysql&gt; SET @s2 = CONVERT(@s1 USING utf8) COLLATE utf8_spanish_ci;
mysql&gt; SELECT CHARSET(@s1), COLLATION(@s1), CHARSET(@s2), COLLATION(@s2);
+--------------|-------------------|--------------|-----------------+
| CHARSET(@s1) | COLLATION(@s1)    | CHARSET(@s2) | COLLATION(@s2)  |
+--------------|-------------------|--------------|-----------------+
| latin1       | latin1_swedish_ci | utf8         | utf8_spanish_ci | 
+--------------|-------------------|--------------|-----------------+
</code></pre>

<p>The CONVERT() function can also convert binary strings to nonbinary strings and vice
versa. To produce a binary string, use binary; any other character-set name produces
a nonbinary string:</p>

<pre><code>mysql&gt; SET @s1 = _latin1 'my string';
mysql&gt; SET @s2 = CONVERT(@s1 USING binary);
mysql&gt; SET @s3 = CONVERT(@s2 USING utf8);
mysql&gt; SELECT CHARSET(@s1), CHARSET(@s2), CHARSET(@s3);
+--------------|--------------|--------------+
| CHARSET(@s1) | CHARSET(@s2) | CHARSET(@s3) |
+--------------|--------------|--------------+
| latin1       | binary       | utf8         | 
+--------------|--------------|--------------+
</code></pre>

<p>Alternatively, produce binary strings using the BINARY operator, which is equivalent to
CONVERT(str USING binary):</p>

<pre><code>mysql&gt; SELECT CHARSET(BINARY _latin1 'my string');
+-------------------------------------+
| CHARSET(BINARY _latin1 'my string') |
+-------------------------------------+
| binary                              | 
+-------------------------------------+
</code></pre>

<h1 id="5-6-converting-the-lettercase-of-a-string">5.6. Converting the Lettercase of a String</h1>

<p>Problem</p>

<p>You want to convert a string to uppercase or lowercase.</p>

<p>Solution</p>

<p>Use the UPPER() or LOWER() function. If they don’t work, you’re probably trying to
convert a binary string. Convert it to a nonbinary string that has a character set and
collation and is subject to case mapping.</p>

<p>Discussion</p>

<p>The UPPER() and LOWER() functions convert the lettercase of a string:</p>

<pre><code>mysql&gt; SELECT thing, UPPER(thing), LOWER(thing) FROM limbs;
+--------------|--------------|--------------+
| thing        | UPPER(thing) | LOWER(thing) |
+--------------|--------------|--------------+
| human        | HUMAN        | human        | 
| insect       | INSECT       | insect       | 
| squid        | SQUID        | squid        | 
| fish         | FISH         | fish         | 
</code></pre>

<p>But some strings are “stubborn” and resist lettercase conversion:</p>

<pre><code>mysql&gt; CREATE TABLE t (b BLOB) SELECT 'aBcD' AS b;
mysql&gt; SELECT b, UPPER(b), LOWER(b) FROM t;
+------|----------|----------+
| b    | UPPER(b) | LOWER(b) |
+------|----------|----------+
| aBcD | aBcD     | aBcD     | 
+------|----------|----------+
</code></pre>

<p>This problem occurs for strings that have a BINARY or BLOB data type. These are binary
strings that have no character set or collation. Lettercase does not apply, and UPPER()
and LOWER() do nothing.</p>

<p>To map a binary string to a given lettercase, convert it to a nonbinary string, choosing
a character set that has uppercase and lowercase characters. The case-conversion func‐
tions then work as you expect because the collation provides case mapping</p>

<pre><code>mysql&gt; SELECT b,
    -&gt; UPPER(CONVERT(b USING latin1)) AS upper,
    -&gt; LOWER(CONVERT(b USING latin1)) AS lower
    -&gt; FROM t;
+------|-------|-------+
| b    | upper | lower |
+------|-------|-------+
| aBcD | ABCD  | abcd  | 
+------|-------|-------+
</code></pre>

<p>To convert the lettercase of only part of a string, break it into pieces, convert the relevant
piece, and put the pieces back together. Suppose that you want to convert only the initial
character of a string to uppercase. The following expression accomplishes that:</p>

<p>CONCAT(UPPER(LEFT(str,1)),MID(str,2))</p>

<p>But it’s ugly to write an expression like that each time you need it. For convenience,
define a stored function:</p>

<pre><code>mysql&gt; CREATE FUNCTION initial_cap (s VARCHAR(255))
    -&gt; RETURNS VARCHAR(255) DETERMINISTIC
    -&gt; RETURN CONCAT(UPPER(LEFT(s,1)),MID(s,2));
</code></pre>

<p>Then you can capitalize initial characters more easily:</p>

<pre><code>mysql&gt; SELECT thing, initial_cap(thing) FROM limbs;
+--------------|--------------------+
| thing        | initial_cap(thing) |
+--------------|--------------------+
| human        | Human              | 
| insect       | Insect             | 
| squid        | Squid              | 
| fish         | Fish               | 
| centipede    | Centipede          | 
| table        | Table              | 
| armchair     | Armchair           | 
| phonograph   | Phonograph         | 
| tripod       | Tripod             | 
| Peg Leg Pete | Peg Leg Pete       | 
| space alien  | Space alien        | 
+--------------|--------------------+
</code></pre>
]]></content>
		</item>
		
		<item>
			<title>MySQL Cookbook 第4章 表管理</title>
			<link>https://gitop.cc/posts/mysql-cookbook-4/</link>
			<pubDate>Thu, 07 Apr 2016 21:19:39 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/mysql-cookbook-4/</guid>
			<description>4.0. Introduction This chapter covers topics that relate to creating and populating tables: • Cloning a table • Copying from one table to another • Using temporary tables • Generating unique table names • Determining what storage engine a table uses or converting it from one storage engine to another 4.1. Cloning a Table Problem You want to create a table that has exactly the same structure as an existing</description>
			<content type="html"><![CDATA[

<h1 id="4-0-introduction">4.0. Introduction</h1>

<p>This chapter covers topics that relate to creating and populating tables:
• Cloning a table
• Copying from one table to another
• Using temporary tables
• Generating unique table names
• Determining what storage engine a table uses or converting it from one storage
engine to another</p>

<h1 id="4-1-cloning-a-table">4.1. Cloning a Table</h1>

<p>Problem</p>

<p>You want to create a table that has exactly the same structure as an existing table.</p>

<p>Solution</p>

<p>Use CREATE TABLE &hellip; LIKE to clone the table structure. To also copy some or all of the
rows from the original table to the new one, use INSERT INTO &hellip; SELECT .</p>

<p>Discussion</p>

<p>To create a new table that is just like an existing table, use this statement:</p>

<pre><code>CREATE TABLE new_table LIKE original_table;
</code></pre>

<p>The structure of the new table is the same as that of the original table, with a few ex‐
ceptions: CREATE TABLE &hellip; LIKE does not copy foreign key definitions, and it doesn’t
copy any DATA DIRECTORY or INDEX DIRECTORY table options that the table might use.</p>

<p>The new table is empty. If you also want the contents to be the same as the original table,
copy the rows using an INSERT INTO &hellip; SELECT statement:</p>

<pre><code>INSERT INTO new_table SELECT * FROM original_table;
</code></pre>

<p>To copy only part of the table, add an appropriate WHERE clause that identifies which
rows to copy. For example, these statements create a copy of the mail table named
mail2 , populated only with the rows for mail sent by barb :</p>

<pre><code>CREATE TABLE mail2 LIKE mail;
INSERT INTO mail2 SELECT * FROM mail WHERE srcuser = 'barb';
</code></pre>

<h1 id="4-2-saving-a-query-result-in-a-table">4.2. Saving a Query Result in a Table</h1>

<p>Problem</p>

<p>You want to save the result from a SELECT statement to a table rather than display it.</p>

<p>Solution</p>

<p>If the table exists, retrieve rows into it using INSERT INTO &hellip; SELECT . If the table does
not exist, create it on the fly using CREATE TABLE &hellip; SELECT .</p>

<p>Discussion</p>

<p>The MySQL server normally returns the result of a SELECT statement to the client that
executed the statement. For example, when you execute a statement from within the
mysql program, the server returns the result to mysql, which in turn displays it on the
screen. It’s possible to save the results of a SELECT statement in a table instead, which is
useful in several ways:</p>

<p>• You can easily create a complete or partial copy of a table. If you’re developing an
algorithm that modifies a table, it’s safer to work with a copy of a table so that you
need not worry about the consequences of mistakes. If the original table is large,
creating a partial copy can speed the development process because queries run
against it take less time.</p>

<p>• For a data-loading operation based on information that might be malformed, load
new rows into a temporary table, perform some preliminary checks, and correct
the rows as necessary. When you’re satisfied that the new rows are okay, copy them
from the temporary table to your main table.</p>

<p>• Some applications maintain a large repository table and a smaller working table
into which rows are inserted on a regular basis, copying the working table rows to
the repository periodically and clearing the working table.
• To perform summary operations on a large table more efficiently, avoid running
expensive summary operations repeatedly on it. Instead, select summary informa‐
tion once into a second table and use that for further analysis.</p>

<pre><code>INSERT INTO dst_tbl (i, s) SELECT val, name FROM src_tbl;
</code></pre>

<p>The number of columns to be inserted must match the number of selected columns,
with the correspondence between columns based on position rather than name. To copy
all columns, you can shorten the statement to this form:</p>

<pre><code>INSERT INTO dst_tbl SELECT * FROM src_tbl;
</code></pre>

<p>To copy only certain rows, add a WHERE clause that selects those rows:</p>

<pre><code>INSERT INTO dst_tbl SELECT * FROM src_tbl
WHERE val &gt; 100 AND name LIKE 'A%';
</code></pre>

<p>The SELECT statement can produce values from expressions, too. For example, the fol‐
lowing statement counts the number of times each name occurs in src_tbl and stores
both the counts and the names in dst_tbl :</p>

<pre><code>INSERT INTO dst_tbl (i, s) SELECT COUNT(*), name
FROM src_tbl GROUP BY name;

CREATE TABLE dst_tbl SELECT * FROM src_tbl;
</code></pre>

<p>MySQL creates the columns in dst_tbl based on the name, number, and type of the
columns in src_tbl . To copy only certain rows, add an appropriate WHERE clause. To
create an empty table, use a WHERE clause that selects no rows:</p>

<pre><code>CREATE TABLE dst_tbl SELECT * FROM src_tbl WHERE FALSE;
</code></pre>

<p>To create columns in an order different from that in which they appear in the source
table, name them in the desired order. If the source table contains columns a , b , and c
that should appear in the destination table in the order c , a , b , do this:</p>

<pre><code>CREATE TABLE dst_tbl SELECT c, a, b FROM src_tbl;
</code></pre>

<p>To create columns in the destination table in addition to those selected from the source
table, provide appropriate column definitions in the CREATE TABLE part of the statement.
The following statement creates id as an AUTO_INCREMENT column in dst_tbl and adds
columns a , b , and c from src_tbl :</p>

<pre><code>CREATE TABLE dst_tbl
(
    id INT NOT NULL AUTO_INCREMENT,
    PRIMARY KEY (id)
)
SELECT a, b, c FROM src_tbl;
</code></pre>

<p>If you derive a column’s values from an expression, its default name is the expression
itself, which can be difficult to work with later. In this case, it’s prudent to give the column
a better name by providing an alias (see Recipe 3.2). Suppose that src_tbl contains
invoice information that lists items in each invoice. The following statement generates
a summary that lists each invoice named in the table and the total cost of its items, using
an alias for the expression:</p>

<pre><code>CREATE TABLE dst_tbl
SELECT inv_no, SUM(unit_cost*quantity) AS total_cost
FROM src_tbl GROUP BY inv_no;
</code></pre>

<p>CREATE TABLE &hellip; SELECT is extremely convenient, but has some limitations that arise
from the fact that the information available from a result set is not as extensive as what
you can specify in a CREATE TABLE statement. For example, MySQL has no idea whether
a result set column should be indexed or what its default value is. If it’s important to
include this information in the destination table, use the following techniques:</p>

<p>• To make the destination table an exact copy of the source table, use the cloning
technique described in Recipe 4.1.
• To include indexes in the destination table, specify them explicitly. For example, if
src_tbl has a PRIMARY KEY on the id column, and a multiple-column index on
state and city , specify them for dst_tbl as well:</p>

<pre><code>CREATE TABLE dst_tbl (PRIMARY KEY (id), INDEX(state,city))
SELECT * FROM src_tbl;
</code></pre>

<p>• Column attributes such as AUTO_INCREMENT and a column’s default value are not
copied to the destination table. To preserve these attributes, create the table, then
use ALTER TABLE to apply the appropriate modifications to the column definition.
For example, if src_tbl has an id column that is not only a PRIMARY KEY but also
an AUTO_INCREMENT column, copy the table and modify the copy:</p>

<pre><code>CREATE TABLE dst_tbl (PRIMARY KEY (id)) SELECT * FROM src_tbl;
ALTER TABLE dst_tbl MODIFY id INT UNSIGNED NOT NULL AUTO_INCREMENT;
</code></pre>

<h1 id="4-3-creating-temporary-tables">4.3. Creating Temporary Tables</h1>

<p>Problem</p>

<p>You need a table only for a short time, after which you want it to disappear automatically.</p>

<p>Solution</p>

<p>Create a table using the TEMPORARY keyword, and let MySQL take care of removing it.</p>

<p>Discussion</p>

<p>Some operations require a table that exists only temporarily and that should disappear
when it’s no longer needed. You can, of course, execute a DROP TABLE statement explicitly
to remove a table when you’re done with it. Another option is to use CREATE TEMPORA
RY TABLE . This statement is like CREATE TABLE but creates a transient table that disappears
when your session with the server ends, if you haven’t already removed it yourself. This
is extremely useful behavior because MySQL drops the table for you automatically; you
need not remember to do it. TEMPORARY can be used with the usual table-creation meth‐
ods:</p>

<p>• Create the table from explicit column definitions:
CREATE TEMPORARY TABLE tbl_name (&hellip;column definitions&hellip;);
• Create the table from an existing table:
CREATE TEMPORARY TABLE new_table LIKE original_table;
• Create the table on the fly from a result set:
CREATE TEMPORARY TABLE tbl_name SELECT &hellip; ;</p>

<p>A temporary table can have the same name as a permanent table. In this case, the tem‐
porary table “hides” the permanent table for the duration of its existence, which can be
useful for making a copy of a table that you can modify without affecting the original
by mistake. The DELETE statement in the following example removes rows from a tem‐
porary mail table, leaving the original permanent table unaffected:</p>

<p>mysql&gt; CREATE TEMPORARY TABLE mail SELECT * FROM mail;
mysql&gt; SELECT COUNT(<em>) FROM mail;
+&mdash;&mdash;&mdash;-+
| COUNT(</em>) |
+&mdash;&mdash;&mdash;-+
|       16 |
+&mdash;&mdash;&mdash;-+
mysql&gt; DELETE FROM mail;
mysql&gt; SELECT COUNT(<em>) FROM mail;
+&mdash;&mdash;&mdash;-+
| COUNT(</em>) |
+&mdash;&mdash;&mdash;-+
|        0 |
+&mdash;&mdash;&mdash;-+
mysql&gt; DROP TEMPORARY TABLE mail;
mysql&gt; SELECT COUNT(<em>) FROM mail;
+&mdash;&mdash;&mdash;-+
| COUNT(</em>) |
+&mdash;&mdash;&mdash;-+
|       16 |
+&mdash;&mdash;&mdash;-+
Although temporary tables created with CREATE TEMPORARY TABLE have the benefits just
discussed, keep the following caveats in mind:</p>

<p>• To reuse a temporary table within a given session, you must still drop it explicitly
before re-creating it. Attempting to create a second temporary table with the same
name results in an error.
• If you modify a temporary table that “hides” a permanent table with the same name,
be sure to test for errors resulting from dropped connections if you use a program‐
ming interface that has reconnect capability enabled. If a client program automat‐
ically reconnects after detecting a dropped connection, modifications affect the
permanent table after the reconnect, not the temporary table.
• Some APIs support persistent connections or connection pools. These prevent
temporary tables from being dropped as you expect when your script ends because
the connection remains open for reuse by other scripts. Your script has no control
over when the connection closes. This means it can be prudent to execute the fol‐
lowing statement prior to creating a temporary table, just in case it’s still in existence
from a previous execution of the script:
DROP TEMPORARY TABLE IF EXISTS tbl_name</p>

<h1 id="4-4-generating-unique-table-names">4.4. Generating Unique Table Names</h1>

<p>Problem</p>

<p>You need to create a table with a name guaranteed not to exist.</p>

<p>Solution</p>

<p>If you create a TEMPORARY table, it doesn’t matter whether a permanent table with that
name exists. Otherwise, try to generate a value that is unique to your client program
and incorporate it into the table name.</p>

<p>Discussion</p>

<p>If you cannot or do not want to use a TEMPORARY table, make sure that each invocation
of the script creates a uniquely named table and drops the table when it is no longer
needed.</p>

<p>Pro‐
cess ID (PID) values are a better source of unique values. PIDs are reused over time,
but never for two processes at the same time, so a given PID is guaranteed to be unique
among the set of currently executing processes.</p>

<p>Connection identifiers are another source of unique values. The MySQL server reuses
these numbers over time, but no two simultaneous connections to the server have the
same ID.</p>

<p>It’s possible to incorporate a connection ID into a table name within SQL by using
prepared statements. The following example illustrates this, referring to the table name
in the CREATE TABLE statement and a precautionary DROP TABLE statement:</p>

<pre><code>SET @tbl_name = CONCAT('tmp_tbl_', CONNECTION_ID());
SET @stmt = CONCAT('DROP TABLE IF EXISTS ', @tbl_name);
PREPARE stmt FROM @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
SET @stmt = CONCAT('CREATE TABLE ', @tbl_name, ' (i INT)');
PREPARE stmt FROM @stmt;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
</code></pre>

<h1 id="4-5-checking-or-changing-a-table-storage-engine">4.5. Checking or Changing a Table Storage Engine</h1>

<p>Problem</p>

<p>You want to check which storage engine a table uses so that you can determine what
engine capabilities are applicable. Or you need to change a table’s storage engine because
you realize that the capabilities of another engine are more suitable for the way you use
the table.</p>

<p>Solution</p>

<p>To determine a table’s storage engine, you can use any of several statements. To change
the table’s engine, use ALTER TABLE with an ENGINE clause.</p>

<p>Discussion</p>

<p>MySQL supports multiple storage engines, which have differing characteristics. For
example, the InnoDB engine supports transactions, whereas MyISAM does not.</p>

<p>To determine the current engine for a table, check INFORMATION_SCHEMA or use the SHOW
TABLE STATUS or SHOW CREATE TABLE statement. For the mail table, obtain engine in‐
formation as follows:</p>

<pre><code>mysql&gt; SELECT ENGINE FROM INFORMATION_SCHEMA.TABLES
    -&gt; WHERE TABLE_SCHEMA = 'cookbook' AND TABLE_NAME = 'mail';
+--------+
| ENGINE |
+--------+
| InnoDB |
+--------+

mysql&gt; SHOW TABLE STATUS LIKE 'mail'\G
*************************** 1. row ***************************
           Name: mail
         Engine: InnoDB
        Version: 10
     Row_format: Compact
           Rows: 16
 Avg_row_length: 1024
    Data_length: 16384
Max_data_length: 0
   Index_length: 16384
      Data_free: 0
 Auto_increment: NULL
    Create_time: 2016-04-07 21:23:27
    Update_time: NULL
     Check_time: NULL
      Collation: latin1_swedish_ci
       Checksum: NULL
 Create_options: 
        Comment: 
mysql&gt; SHOW CREATE TABLE mail\G
*************************** 1. row ***************************
       Table: mail
Create Table: CREATE TABLE `mail` (
  `t` datetime DEFAULT NULL,
  `srcuser` varchar(8) DEFAULT NULL,
  `srchost` varchar(20) DEFAULT NULL,
  `dstuser` varchar(8) DEFAULT NULL,
  `dsthost` varchar(20) DEFAULT NULL,
  `size` bigint(20) DEFAULT NULL,
  KEY `t` (`t`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
</code></pre>

<p>To change the storage engine for a table, use ALTER TABLE with an ENGINE specifier. For
example, to convert the mail table to use the MyISAM storage engine, use this statement:</p>

<pre><code>ALTER TABLE mail ENGINE = MyISAM;
</code></pre>

<p>Be aware that converting a large table to a different storage engine might take a long
time and be expensive in terms of CPU and I/O activity.</p>

<p>To determine which storage engines your MySQL server supports, check the output
from the SHOW ENGINES statement or query the INFORMATION_SCHEMA ENGINES table.</p>

<h1 id="4-6-copying-a-table-using-mysqldump">4.6. Copying a Table Using mysqldump</h1>

<p>Problem</p>

<p>You want to copy a table or tables, either among the databases managed by a MySQL
server, or from one server to another.</p>

<p>Solution</p>

<p>Use the mysqldump program.</p>

<p>Discussion</p>

<p>The mysqldump program makes a backup file that can be reloaded to re-create the
original table or tables:
% mysqldump cookbook mail &gt; mail.sql
The output file mail.sql consists of a CREATE TABLE statement to create the mail table
and a set of INSERT statements to insert its rows. You can reload the file to re-create the
table should the original be lost:
% mysql cookbook &lt; mail.sql</p>

<p>This method also makes it easy to deal with any triggers the table has. By default,
mysqldump writes the triggers to the dump file, so reloading the file copies the triggers
along with the table with no special handling.</p>

<h2 id="copying-tables-within-a-single-mysql-server">Copying tables within a single MySQL server</h2>

<p>• Copy a single table to a different database:
% mysqldump cookbook mail &gt; mail.sql
% mysql other_db &lt; mail.sql
To dump multiple tables, name them all following the database name argument.
• Copy all tables in a database to a different database:
% mysqldump cookbook &gt; cookbook.sql
% mysql other_db &lt; cookbook.sql
When you name no tables after the database name, mysqldump dumps them all. To
also include stored routines and events, add the &ndash;routines and &ndash;events options
to the mysqldump command. (There is also a &ndash;triggers option, but it’s unneeded
because, as mentioned previously, mysqldump dumps triggers with their associated
tables by default.)
• Copy a table, using a different name for the copy:
• Dump the table:
% mysqldump cookbook mail &gt; mail.sql
• Reload the table into a different database that does not contain a table with that
name:
% mysql other_db &lt; mail.sql
• Rename the table:
% mysql other_db
mysql&gt; RENAME mail TO mail2;
Or, to move the table into another database at the same time, qualify the new
name with the database name:
% mysql other_db
mysql&gt; RENAME mail TO cookbook.mail2;</p>

<p>To perform a table-copying operation without an intermediary file, use a pipe to connect
the mysqldump and mysql commands:
% mysqldump cookbook mail | mysql other_db
% mysqldump cookbook | mysql other_db</p>

<h2 id="copying-tables-between-mysql-servers">Copying tables between MySQL servers</h2>

<p>Suppose that you want to copy the mail table from the cook
book database on the local host to the other_db database on the host other-
host.example.com. One way to do this is to dump the output into a file:</p>

<p>% mysqldump cookbook mail &gt; mail.sql</p>

<p>Then copy mail.sql to other-host.example.com, and run the following command there
to load the table into that MySQL server’s other_db database:</p>

<p>% mysql other_db &lt; mail.sql</p>

<p>To accomplish this without an intermediary file, use a pipe to send the output of mysql‐
dump directly over the network to the remote MySQL server. If you can connect to both
servers from your local host, use this command:
% mysqldump cookbook mail | mysql -h other-host.example.com other_db</p>

<p>If you cannot connect directly to the remote server using mysql from your local host,
send the dump output into a pipe that uses ssh to invoke mysql remotely on other-
host.example.com:
% mysqldump cookbook mail | ssh other-host.example.com mysql other_db</p>
]]></content>
		</item>
		
		<item>
			<title>MySQL Cookbook 第3章 从表中查询数据</title>
			<link>https://gitop.cc/posts/mysql-cookbook-3/</link>
			<pubDate>Thu, 07 Apr 2016 12:14:29 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/mysql-cookbook-3/</guid>
			<description>3.0. 介绍 本章专注使用SELECT语句从你的数据库获取信息。 3.1. 指定SELECT哪行哪列 问题 你想要从一张表中展示特定行和列。 解决方法 为了指示展示哪</description>
			<content type="html"><![CDATA[

<h1 id="3-0-介绍">3.0. 介绍</h1>

<p>本章专注使用SELECT语句从你的数据库获取信息。</p>

<h1 id="3-1-指定select哪行哪列">3.1. 指定SELECT哪行哪列</h1>

<p><strong>问题</strong></p>

<p>你想要从一张表中展示特定行和列。</p>

<p><strong>解决方法</strong></p>

<p>为了指示展示哪一列，在输出列表中指定它。为了指示展示哪一行，使用WHERE语句指定满足条件的行。</p>

<p><strong>讨论</strong></p>

<p>从一个表中显示列最简单的方式是使用SELECT * FROM tbl_name。*限定符意思是“所有列”：</p>

<pre><code>mysql&gt; SELECT * FROM mail; 
+---------------------|---------|---------|---------|---------|---------+
| t                   | srcuser | srchost | dstuser | dsthost | size    |
+---------------------|---------|---------|---------|---------|---------+
| 2014-05-11 10:15:08 | barb    | saturn  | tricia  | mars    |   58274 | 
| 2014-05-12 12:48:13 | tricia  | mars    | gene    | venus   |  194925 | 
| 2014-05-12 15:02:49 | phil    | mars    | phil    | saturn  |    1048 | 
| 2014-05-12 18:59:18 | barb    | saturn  | tricia  | venus   |     271 | 
</code></pre>

<p>显式命名列使你可以以任意顺序查询感兴趣的列：</p>

<pre><code>mysql&gt; SELECT srcuser, srchost, t, size FROM mail;
+---------|---------|---------------------|---------+
| srcuser | srchost | t                   | size    |
+---------|---------|---------------------|---------+
| barb    | saturn  | 2014-05-11 10:15:08 |   58274 | 
| tricia  | mars    | 2014-05-12 12:48:13 |  194925 | 
| phil    | mars    | 2014-05-12 15:02:49 |    1048 | 
| barb    | saturn  | 2014-05-12 18:59:18 |     271 | 
</code></pre>

<p>除非你以某种方式限制SELECT查询，它获取表中每一行。更确切地说，提供一个WHERE语句指定一个或多个条件行必须满足。</p>

<p>条件可以用来测试相等，不相等或相关的顺序。对于一些数据类型，比如字符串，可以使用模式匹配：</p>

<pre><code>mysql&gt; SELECT t, srcuser, srchost FROM mail WHERE srchost = 'venus';
+---------------------|---------|---------+
| t                   | srcuser | srchost |
+---------------------|---------|---------+
| 2014-05-14 09:31:37 | gene    | venus   | 
| 2014-05-14 14:42:21 | barb    | venus   | 
| 2014-05-15 08:50:57 | phil    | venus   | 
| 2014-05-16 09:00:28 | gene    | venus   | 
| 2014-05-16 23:04:19 | phil    | venus   | 
+---------------------|---------|---------+
mysql&gt; SELECT t, srcuser, srchost FROM mail WHERE srchost LIKE 's%';
+---------------------|---------|---------+
| t                   | srcuser | srchost |
+---------------------|---------|---------+
| 2014-05-11 10:15:08 | barb    | saturn  | 
| 2014-05-12 18:59:18 | barb    | saturn  | 
| 2014-05-14 17:03:01 | tricia  | saturn  | 
| 2014-05-15 17:35:31 | gene    | saturn  | 
| 2014-05-19 22:21:51 | gene    | saturn  | 
+---------------------|---------|---------+
</code></pre>

<p>LIKE操作符执行一个模式匹配，%作为一个通配符匹配任意 字符串。WHERE语句可以测试多个条件且不同条件可以测试不同列：</p>

<pre><code>mysql&gt; SELECT * FROM mail WHERE srcuser = 'barb' AND dstuser = 'tricia';
+---------------------|---------|---------|---------|---------|-------+
| t                   | srcuser | srchost | dstuser | dsthost | size  |
+---------------------|---------|---------|---------|---------|-------+
| 2014-05-11 10:15:08 | barb    | saturn  | tricia  | mars    | 58274 | 
| 2014-05-12 18:59:18 | barb    | saturn  | tricia  | venus   |   271 | 
+---------------------|---------|---------|---------|---------|-------+
</code></pre>

<p>输出列可以由表达式计算：</p>

<pre><code>mysql&gt; SELECT t, CONCAT(srcuser,'@',srchost), size FROM mail;
+---------------------|-----------------------------|---------+
| t                   | CONCAT(srcuser,'@',srchost) | size    |
+---------------------|-----------------------------|---------+
| 2014-05-11 10:15:08 | barb@saturn                 |   58274 | 
| 2014-05-12 12:48:13 | tricia@mars                 |  194925 | 
| 2014-05-12 15:02:49 | phil@mars                   |    1048 | 
| 2014-05-12 18:59:18 | barb@saturn                 |     271 | 
</code></pre>

<h1 id="3-2-命名查询结果列">3.2. 命名查询结果列</h1>

<p><strong>问题</strong></p>

<p>查询结果中的列名字不合适，丑陋或难以处理。</p>

<p><strong>解决方法</strong></p>

<p>使用别名选择你自己的列名字。</p>

<p><strong>讨论</strong></p>

<p>当你获取一个结果集，MySQL给每一个输出列一个名字。默认地，MySQL用创建表的列名赋值给输出列，你可以使用别名指定自己的列名。</p>

<p>如果你通过计算一个表达式生成一列，表达式本身就是列名：</p>

<pre><code>mysql&gt; SELECT
    -&gt; DATE_FORMAT(t, '%M %e, %Y'), CONCAT(srcuser, '@', srchost), size
    -&gt; FROM mail;
+-----------------------------|-------------------------------|---------+
| DATE_FORMAT(t, '%M %e, %Y') | CONCAT(srcuser, '@', srchost) | size    |
+-----------------------------|-------------------------------|---------+
| May 11, 2014                | barb@saturn                   |   58274 | 
| May 12, 2014                | tricia@mars                   |  194925 | 
| May 12, 2014                | phil@mars                     |    1048 | 
| May 12, 2014                | barb@saturn                   |     271 |
</code></pre>

<p>使用AS命名语句指定一列别名（关键字AS是可选的）：</p>

<pre><code>mysql&gt; SELECT
    -&gt; DATE_FORMAT(t,'%M %e, %Y') AS date_sent,
    -&gt; CONCAT(srcuser,'@',srchost) AS sender,
    -&gt; size FROM mail;
+--------------|---------------|---------+
| date_sent    | sender        | size    |
+--------------|---------------|---------+
| May 11, 2014 | barb@saturn   |   58274 | 
| May 12, 2014 | tricia@mars   |  194925 | 
| May 12, 2014 | phil@mars     |    1048 | 
| May 12, 2014 | barb@saturn   |     271 | 
</code></pre>

<p>别名使列名更准确，更容易阅读和更有意义。别名受到一些限制。比如，如果它们是SQL关键字，数字或包含空格或其它特殊字符，则必须被引用：</p>

<pre><code>mysql&gt; SELECT
    -&gt; DATE_FORMAT(t,'%M %e, %Y') AS 'Date of message',
    -&gt; CONCAT(srcuser,'@',srchost) AS 'Message sender',
    -&gt; size AS 'Number of bytes' FROM mail;
mysql&gt; SELECT 1 AS INTEGER;
You have an error in your SQL syntax near 'INTEGER'
mysql&gt; SELECT 1 AS 'INTEGER';
+---------+
| INTEGER |
+---------+
|       1 | 
+---------+
</code></pre>

<p>你不能在WHERE语句中引用列的别名，因此下面这个语句非法：</p>

<pre><code>mysql&gt; SELECT t, srcuser, dstuser, size/1024 AS kilobytes
    -&gt; FROM mail WHERE kilobytes &gt; 500;
</code></pre>

<h1 id="3-3-排序查询结果">3.3. 排序查询结果</h1>

<p><strong>问题</strong></p>

<p>你的查询结果没有按照你想要的方式排序。</p>

<p><strong>解决方法</strong></p>

<p>使用ORDER BY语句告诉MySQL怎样排序结果行。</p>

<p><strong>讨论</strong></p>

<p>当你查询行时，MySQL服务器可以自由地以任意顺序返回它们，除非你通知怎么排序它们。有很多中排序的方式。简单地使用ORDER BY语句排序：</p>

<pre><code>mysql&gt; SELECT * FROM mail WHERE dstuser = 'tricia'
    -&gt; ORDER BY srchost, srcuser;
+---------------------|---------|---------|---------|---------|--------+
| t                   | srcuser | srchost | dstuser | dsthost | size   |
+---------------------|---------|---------|---------|---------|--------+
| 2014-05-15 10:25:52 | gene    | mars    | tricia  | saturn  | 998532 | 
| 2014-05-14 11:52:17 | phil    | mars    | tricia  | saturn  |   5781 | 
| 2014-05-19 12:49:23 | phil    | mars    | tricia  | saturn  |    873 | 
| 2014-05-11 10:15:08 | barb    | saturn  | tricia  | mars    |  58274 | 
| 2014-05-12 18:59:18 | barb    | saturn  | tricia  | venus   |    271 | 
+---------------------|---------|---------|---------|---------|--------+
</code></pre>

<p>为了以相反的顺序排序列，在ORDER BY语句后面添加DESC关键字：</p>

<pre><code>mysql&gt; SELECT * FROM mail WHERE size &gt; 50000 ORDER BY size DESC;
+---------------------|---------|---------|---------|---------|---------+
| t                   | srcuser | srchost | dstuser | dsthost | size    |
+---------------------|---------|---------|---------|---------|---------+
| 2014-05-14 17:03:01 | tricia  | saturn  | phil    | venus   | 2394482 | 
| 2014-05-15 10:25:52 | gene    | mars    | tricia  | saturn  |  998532 | 
| 2014-05-12 12:48:13 | tricia  | mars    | gene    | venus   |  194925 | 
| 2014-05-14 14:42:21 | barb    | venus   | barb    | venus   |   98151 | 
| 2014-05-11 10:15:08 | barb    | saturn  | tricia  | mars    |   58274 | 
+---------------------|---------|---------|---------|---------|---------+
</code></pre>

<h1 id="3-4-去除重复行">3.4. 去除重复行</h1>

<p><strong>问题</strong></p>

<p>查询结果包含重复行，你想要消除它们。</p>

<p><strong>解决方法</strong></p>

<p>使用DISTINCT。</p>

<p><strong>讨论</strong></p>

<p>某些查询产生包含重复行的结果：</p>

<pre><code>mysql&gt; SELECT srcuser FROM mail;
+---------+
| srcuser |
+---------+
| barb    | 
| tricia  | 
| phil    | 
| barb    | 
| gene    | 
| phil    | 
| barb    | 
| tricia  | 
| gene    | 
| phil    | 
| gene    | 
| gene    | 
| gene    | 
| phil    | 
| phil    | 
| gene    | 
+---------+
</code></pre>

<p>为了删除重复行，产生唯一值的集合，添加DISTINCT到查询：</p>

<pre><code>mysql&gt; SELECT DISTINCT srcuser FROM mail;
+---------+
| srcuser |
+---------+
| barb    | 
| tricia  | 
| phil    | 
| gene    | 
+---------+
mysql&gt; SELECT COUNT(DISTINCT srcuser) FROM mail;
+-------------------------+
| COUNT(DISTINCT srcuser) |
+-------------------------+
|                       4 | 
+-------------------------+
</code></pre>

<p>DISTINCT也可以处理多列：</p>

<pre><code>mysql&gt; SELECT DISTINCT YEAR(t), MONTH(t), DAYOFMONTH(t) FROM mail;
+---------|----------|---------------+
| YEAR(t) | MONTH(t) | DAYOFMONTH(t) |
+---------|----------|---------------+
|    2014 |        5 |            11 | 
|    2014 |        5 |            12 | 
|    2014 |        5 |            14 | 
|    2014 |        5 |            15 | 
|    2014 |        5 |            16 | 
|    2014 |        5 |            19 | 
+---------|----------|---------------+
</code></pre>

<h1 id="3-5-处理null值">3.5. 处理NULL值</h1>

<p><strong>问题</strong></p>

<p>你尝试将列的值与NULL比较，但是不起作用。</p>

<p><strong>解决方法</strong></p>

<p>使用合适的比较操作符：IS NULL，IS NOT NULL或&lt;=&gt;。</p>

<p><strong>讨论</strong></p>

<p>Conditions that involve NULL are special because NULL means “unknown value.” Con‐
sequently, comparisons such as value = NULL or value &lt;&gt; NULL always produce a result
of NULL (not true or false) because it’s impossible to tell whether they are true or false.
Even NULL = NULL produces NULL because you can’t determine whether one unknown
value is the same as another.</p>

<pre><code>mysql&gt; SELECT * FROM expt WHERE score = NULL;
Empty set (0.01 sec)

mysql&gt; SELECT * FROM expt WHERE score &lt;&gt; NULL;
Empty set (0.00 sec)

mysql&gt; SELECT * FROM expt WHERE score IS NULL;
+---------|------|-------+
| subject | test | score |
+---------|------|-------+
| Jane    | C    |  NULL | 
| Jane    | D    |  NULL | 
| Marvin  | D    |  NULL | 
+---------|------|-------+
mysql&gt; SELECT * FROM expt WHERE score IS NOT NULL;
+---------|------|-------+
| subject | test | score |
+---------|------|-------+
| Jane    | A    |    47 | 
| Jane    | B    |    50 | 
| Marvin  | A    |    52 | 
| Marvin  | B    |    45 | 
| Marvin  | C    |    53 | 
+---------|------|-------+
</code></pre>

<p>The MySQL-specific &lt;=&gt; comparison operator, unlike the = operator, is true even for
two NULL values:</p>

<pre><code>mysql&gt; SELECT NULL = NULL, NULL &lt;=&gt; NULL;
+-------------|---------------+
| NULL = NULL | NULL &lt;=&gt; NULL |
+-------------|---------------+
|        NULL |             1 | 
+-------------|---------------+
</code></pre>

<p>Sometimes it’s useful to map NULL values onto some other value that has more meaning
in the context of your application. For example, use IF() to map NULL onto the string
Unknown:</p>

<pre><code>mysql&gt; SELECT subject, test, IF(score IS NULL,'Unknown',score) AS 'score'
    -&gt; FROM expt;
+---------|------|---------+
| subject | test | score   |
+---------|------|---------+
| Jane    | A    | 47      | 
| Jane    | B    | 50      | 
| Jane    | C    | Unknown | 
| Jane    | D    | Unknown | 
| Marvin  | A    | 52      | 
| Marvin  | B    | 45      | 
| Marvin  | C    | 53      | 
| Marvin  | D    | Unknown | 
+---------|------|---------+
</code></pre>

<p>The preceding query can be written more concisely using IFNULL(), which tests its first
argument and returns it if it’s not NULL, or returns its second argument otherwise:</p>

<pre><code>SELECT subject, test, IFNULL(score,'Unknown') AS 'score'
FROM expt;
</code></pre>

<p>In other words, these two tests are equivalent:</p>

<pre><code>IF(expr1 IS NOT NULL,expr1,expr2)
IFNULL(expr1,expr2)
</code></pre>

<p>From a readability standpoint, IF() often is easier to understand than IFNULL(). From
a computational perspective, IFNULL() is more efficient because expr1 need not be
evaluated twice, as happens with IF().</p>

<h1 id="3-6-writing-comparisons-involving-null-in-programs">3.6. Writing Comparisons Involving NULL in Programs</h1>

<p>Problem</p>

<p>You’re writing a program that looks for rows containing a specific value, but it fails when
the value is NULL.</p>

<p>Solution</p>

<p>Choose the proper comparison operator according to whether the comparison value is
or is not NULL.</p>

<p>Discussion</p>

<p>A comparison of score = NULL is never true, so that statement returns no rows. To take
into account the possibility that $score could be undef, construct the statement using
the appropriate comparison operator like this:</p>

<pre><code>$operator = defined ($score) ? &quot;=&quot; : &quot;IS&quot;;
$sth = $dbh-&gt;prepare (&quot;SELECT * FROM expt WHERE score $operator ?&quot;);
$sth-&gt;execute ($score);
</code></pre>

<p>For inequality tests, set $operator like this instead:</p>

<pre><code>$operator = defined ($score) ? &quot;&lt;&gt;&quot; : &quot;IS NOT&quot;;
</code></pre>

<h1 id="3-7-using-views-to-simplify-table-access">3.7. Using Views to Simplify Table Access</h1>

<p>Problem</p>

<p>You want to refer to values calculated from expressions without writing the expressions
each time you retrieve them.</p>

<p>Solution</p>

<p>Use a view defined such that its columns perform the desired calculations.</p>

<p>Discussion</p>

<p>To make the statement results easier to access, use a view, which is a virtual table
that contains no data. Instead, it’s defined as the SELECT statement that retrieves the data
of interest. The following view, mail_view, is equivalent to the SELECT statement just
shown:</p>

<pre><code>mysql&gt; CREATE VIEW mail_view AS
    -&gt; SELECT
    -&gt; DATE_FORMAT(t,'%M %e, %Y') AS date_sent,
    -&gt; CONCAT(srcuser,'@',srchost) AS sender,
    -&gt; CONCAT(dstuser,'@',dsthost) AS recipient,
    -&gt; size FROM mail;
</code></pre>

<p>To access the view contents, refer to it like any other table. You can select some or all of
its columns, add a WHERE clause to restrict which rows to retrieve, use ORDER BY to sort
the rows, and so forth. For example:</p>

<pre><code>mysql&gt; SELECT date_sent, sender, size FROM mail_view
    -&gt; WHERE size &gt; 100000 ORDER BY size;
+--------------|---------------|---------+
| date_sent    | sender        | size    |
+--------------|---------------|---------+
| May 12, 2014 | tricia@mars   |  194925 | 
| May 15, 2014 | gene@mars     |  998532 | 
| May 14, 2014 | tricia@saturn | 2394482 | 
+--------------|---------------|---------+
</code></pre>

<p>Stored programs provide another way to encapsulate calculations</p>

<h1 id="3-8-selecting-data-from-multiple-tables">3.8. Selecting Data from Multiple Tables</h1>

<p>Problem</p>

<p>The answer to a question requires data from more than one table.</p>

<p>Solution</p>

<p>Use a join or a subquery.</p>

<p>Discussion</p>

<p>The queries shown so far select data from a single table, but sometimes you must retrieve
information from multiple tables. Two types of statements that accomplish this are joins
and subqueries. A join matches rows in one table with rows in another and enables you
to retrieve output rows that contain columns from either or both tables. A subquery is
one query nested within another, to perform a comparison between values selected by
the inner query against values selected by the outer query</p>

<pre><code>mysql&gt; SELECT id, name, service, contact_name
    -&gt; FROM profile INNER JOIN profile_contact ON id = profile_id;
+----|---------|----------|--------------+
| id | name    | service  | contact_name |
+----|---------|----------|--------------+
|  1 | Sybil   | Twitter  | user1-twtrid | 
|  1 | Sybil   | Facebook | user1-fbid   | 
|  2 | Nancy   | Twitter  | user2-fbrid  | 
|  2 | Nancy   | Facebook | user2-msnid  | 
|  2 | Nancy   | LinkedIn | user2-lnkdid | 
|  4 | Lothair | LinkedIn | user4-lnkdid | 
+----|---------|----------|--------------+
mysql&gt; SELECT * FROM profile_contact
    -&gt; WHERE profile_id = (SELECT id FROM profile WHERE name = 'Nancy');
+------------|----------|--------------+
| profile_id | service  | contact_name |
+------------|----------|--------------+
|          2 | Twitter  | user2-fbrid  | 
|          2 | Facebook | user2-msnid  | 
|          2 | LinkedIn | user2-lnkdid | 
+------------|----------|--------------+
</code></pre>

<h1 id="3-9-selecting-rows-from-the-beginning-end-or-middle-of-query-results">3.9. Selecting Rows from the Beginning, End, or Middle of Query Results</h1>

<p>Problem</p>

<p>You want only certain rows from a result set, such as the first one, the last five, or rows
21 through 40.</p>

<p>Solution</p>

<p>Use a LIMIT clause, perhaps in conjunction with an ORDER BY clause.</p>

<p>Discussion</p>

<p>MySQL supports a LIMIT clause that tells the server to return only part of a result set.
LIMIT is a MySQL-specific extension to SQL that is extremely valuable when your result
set contains more rows than you want to see at a time. It enables you to retrieve an
arbitrary section of a result set. Typical LIMIT uses include the following kinds of prob‐
lems:</p>

<p>• Answering questions about first or last, largest or smallest, newest or oldest, least
or most expensive, and so forth.
• Splitting a result set into sections so that you can process it one piece at a time. This
technique is common in web applications for displaying a large search result across
several pages. Showing the result in sections enables display of smaller, easier-to-
understand pages.</p>

<pre><code>mysql&gt; SELECT * FROM profile LIMIT 1;
+----|-------|------------|-------|----------------------|------+
| id | name  | birth      | color | foods                | cats |
+----|-------|------------|-------|----------------------|------+
|  1 | Sybil | 1970-04-13 | black | lutefisk,fadge,pizza |    0 |
+----|-------|------------|-------|----------------------|------+
mysql&gt; SELECT * FROM profile LIMIT 3;
+----|-------|------------|-------|-----------------------|------+
| id | name  | birth      | color | foods                 | cats |
+----|-------|------------|-------|-----------------------|------+
|  1 | Sybil | 1970-04-13 | black | lutefisk,fadge,pizza  |    0 |
|  2 | Nancy | 1969-09-30 | white | burrito,curry,eggroll |    3 |
|  3 | Ralph | 1973-11-02 | red   | eggroll,pizza         |    4 |
+----|-------|------------|-------|-----------------------|------+
</code></pre>

<p>LIMIT n means “return at most n rows.” If you specify LIMIT 10 , and the result set has
only four rows, the server returns four rows.</p>

<pre><code>mysql&gt; SELECT * FROM profile ORDER BY birth LIMIT 1;
+----|--------|------------|-------|----------------|------+
| id | name   | birth      | color | foods          | cats |
+----|--------|------------|-------|----------------|------+
|  7 | Joanna | 1952-08-20 | green | lutefisk,fadge |    0 |
+----|--------|------------|-------|----------------|------+
mysql&gt; SELECT * FROM profile ORDER BY birth DESC LIMIT 1;
+----|-------|------------|-------|---------------|------+
| id | name  | birth      | color | foods         | cats |
+----|-------|------------|-------|---------------|------+
|  3 | Ralph | 1973-11-02 | red   | eggroll,pizza |    4 |
+----|-------|------------|-------|---------------|------+
mysql&gt; SELECT name, DATE_FORMAT(birth,'%m-%d') AS birthday
    -&gt; FROM profile ORDER BY birthday LIMIT 1;
+-------|----------+
| name  | birthday |
+-------|----------+
| Henry | 02-14    |
+-------|----------+
mysql&gt; SELECT * FROM profile ORDER BY birth LIMIT 2,1;
+----|---------|------------|-------|---------------|------+
| id | name    | birth      | color | foods         | cats |
+----|---------|------------|-------|---------------|------+
|  4 | Lothair | 1963-07-04 | blue  | burrito,curry |    5 |
+----|---------|------------|-------|---------------|------+
mysql&gt; SELECT * FROM profile ORDER BY birth DESC LIMIT 2,1;
+----|-------|------------|-------|-----------------------|------+
| id | name  | birth      | color | foods                 | cats |
+----|-------|------------|-------|-----------------------|------+
|  2 | Nancy | 1969-09-30 | white | burrito,curry,eggroll |    3 |
+----|-------|------------|-------|-----------------------|------+

SELECT * FROM profile ORDER BY name LIMIT 0, 3;
SELECT * FROM profile ORDER BY name LIMIT 3, 3;
SELECT * FROM profile ORDER BY name LIMIT 6, 3;

SELECT SQL_CALC_FOUND_ROWS * FROM profile ORDER BY name LIMIT 4;
SELECT FOUND_ROWS();
</code></pre>

<p>The keyword SQL_CALC_FOUND_ROWS in the first statement tells MySQL to calculate the
size of the entire result set even though the statement requests that only part of it be
returned. The row count is available by calling FOUND_ROWS() . If that function returns
a value greater than three, there are other rows yet to be retrieved.</p>

<p>LIMIT is useful in combination with RAND() to make random selections from a set of
items. See Recipe 15.8.
You can use LIMIT to restrict the effect of a DELETE or UPDATE statement to a subset of
the rows that would otherwise be deleted or updated, respectively. For more information
about using LIMIT for duplicate row removal, see Recipe 16.4.</p>

<h1 id="3-10-what-to-do-when-limit-requires-the-wrong-sort-order">3.10. What to Do When LIMIT Requires the “Wrong” Sort Order</h1>

<p>Problem</p>

<p>LIMIT usually works best in conjunction with an ORDER BY clause that sorts rows. But
sometimes that sort order differs from what you want for the final result.</p>

<p>Solution</p>

<p>Use LIMIT in a subquery to retrieve the desired rows, then use the outer query to sort
them.</p>

<p>Discussion</p>

<p>If you want the last four rows of a result set, you can obtain them easily by sorting the
set in reverse order and using LIMIT 4 .What if you want the output rows to appear in ascending order instead?
Use the SELECT as a subquery of an outer statement that re-sorts the rows in the desired
final order:</p>

<pre><code>mysql&gt; SELECT * FROM
    -&gt; (SELECT name, birth FROM profile ORDER BY birth DESC LIMIT 4) AS t
    -&gt; ORDER BY birth;
+-------|------------+
| name  | birth      |
+-------|------------+
| Aaron | 1968-09-17 |
| Nancy | 1969-09-30 |
| Sybil | 1970-04-13 |
| Ralph | 1973-11-02 |
+-------|------------+
</code></pre>

<p>AS t is used here because any table referred to in the FROM clause must have a name, even
a “derived” table produced from a subquery.</p>

<h1 id="3-11-calculating-limit-values-from-expressions">3.11. Calculating LIMIT Values from Expressions</h1>

<p>Problem</p>

<p>You want to use expressions to specify the arguments for LIMIT.</p>

<p>Solution</p>

<p>Sadly, you cannot. LIMIT arguments must be literal integers—unless you issue the state‐
ment in a context that permits the statement string to be constructed dynamically. In
that case, you can evaluate the expressions yourself and insert the resulting values into
the statement string.</p>

<p>Discussion</p>

<p>Arguments to LIMIT must be literal integers, not expressions. Statements such as the
following are illegal:</p>

<pre><code>SELECT * FROM profile LIMIT 5+5;
SELECT * FROM profile LIMIT @skip_count, @show_count;
</code></pre>

<p>The same “no expressions permitted” principle applies if you use an expression to cal‐
culate a LIMIT value in a program that constructs a statement string. You must evaluate
the expression first, and then place the resulting value in the statement. For example, if
you produce a statement string in Perl or PHP as follows, an error will result when you
attempt to execute the statement:</p>

<pre><code>$str = &quot;SELECT * FROM profile LIMIT $x + $y&quot;;
</code></pre>

<p>To avoid the problem, evaluate the expression first:</p>

<pre><code>$z = $x + $y;
$str = &quot;SELECT * FROM profile LIMIT $z&quot;;
</code></pre>

<p>Or do this (don’t omit the parentheses or the expression won’t evaluate properly):</p>

<pre><code>$str = &quot;SELECT * FROM profile LIMIT &quot; . ($x + $y);
</code></pre>
]]></content>
		</item>
		
		<item>
			<title>MySQL Cookbook 第2章 编写基于MySQL的程序</title>
			<link>https://gitop.cc/posts/mysql-cookbook-2/</link>
			<pubDate>Tue, 05 Apr 2016 21:32:29 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/mysql-cookbook-2/</guid>
			<description>2.0. 介绍 MySQL Client API Architecture Each MySQL programming interface covered in this book uses a two-level architecture: The upper level provides database-independent methods that implement database access in a portable way that’s the same whether you use MySQL, PostgreSQL, Ora‐ cle, or whatever. The lower level consists of a set of drivers, each of which implements the details for a</description>
			<content type="html"><![CDATA[

<h1 id="2-0-介绍">2.0. 介绍</h1>

<h2 id="mysql-client-api-architecture">MySQL Client API Architecture</h2>

<p>Each MySQL programming interface covered in this book uses a two-level architecture:</p>

<ul>
<li>The upper level provides database-independent methods that implement database
access in a portable way that’s the same whether you use MySQL, PostgreSQL, Ora‐
cle, or whatever.</li>
<li>The lower level consists of a set of drivers, each of which implements the details for
a single database system.</li>
</ul>

<h1 id="2-1-connecting-selecting-a-database-and-disconnecting">2.1. Connecting, Selecting a Database, and Disconnecting</h1>

<p>Problem</p>

<p>You need to establish a connection to the database server and shut down the connection
when you’re done.</p>

<p>Solution</p>

<p>Each API provides routines for connecting and disconnecting. The connection routines
require that you provide parameters specifying the host on which the MySQL server is
running and the MySQL account to use. You can also select a default database.</p>

<p>Discussion</p>

<p>Establishing a connection to the MySQL server
    Every program that uses MySQL does this, no matter which API you use. The details
    on specifying connection parameters vary between APIs, and some APIs provide
    more flexibility than others. However, there are many common parameters, such
    as the host on which the server is running, and the username and password of the
    MySQL account to use for accessing the server.</p>

<p>Selecting a database
    Most MySQL programs select a default database.</p>

<p>Disconnecting from the server
    Each API provides a way to close an open connection. It’s best to do so as soon as
    you’re done using the server. If your program holds the connection open longer
    than necessary, the server cannot free up resources allocated to servicing the con‐
    nection. It’s also preferable to close the connection explicitly. If a program simply
    terminates, the MySQL server eventually notices, but an explicit close on the user
    end enables the server to perform an immediate orderly close on its end.</p>

<p>This section includes example programs that show how to use each API to connect to
the server, select the cookbook database, and disconnect. The discussion for each API
also indicates how to connect without selecting any default database. This might be the
case if you plan to execute a statement that doesn’t require a default database, such as
SHOW VARIABLES or SELECT VERSION() . Or perhaps you’re writing a program that enables
the user to specify the database after the connection has been made.</p>

<h1 id="2-2-checking-for-errors">2.2. Checking for Errors</h1>

<p>Problem</p>

<p>Something went wrong with your program, and you don’t know what.</p>

<p>Solution</p>

<p>Everyone has problems getting programs to work correctly. But if you don’t anticipate
problems by checking for errors, the job becomes much more difficult. Add some error-
checking code so your programs can help you figure out what went wrong.</p>

<p>Discussion</p>

<p>It’s
also a good idea to know how to check for errors and how to retrieve specific error
information from the API</p>

<p>When an error occurs, MySQL provides three values:</p>

<ul>
<li>A MySQL-specific error number</li>
<li>A MySQL-specific descriptive text error message</li>
<li>A five-character SQLSTATE error code defined according to the ANSI and ODBC
standards</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>MySQL Cookbook 第1章 使用mysql客户端</title>
			<link>https://gitop.cc/posts/mysql-cookbook-1/</link>
			<pubDate>Tue, 05 Apr 2016 15:56:30 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/mysql-cookbook-1/</guid>
			<description>1.0 介绍 本章描述了mysql的能力以使你能够更有效的使用它： 设置一个MySQL账户以使用cookbook数据库 指定连接参数和使用配置文件 交互模</description>
			<content type="html"><![CDATA[

<h1 id="1-0-介绍">1.0 介绍</h1>

<p>本章描述了mysql的能力以使你能够更有效的使用它：</p>

<ul>
<li>设置一个MySQL账户以使用cookbook数据库</li>
<li>指定连接参数和使用配置文件</li>
<li>交互模式和批量模式执行SQL语句</li>
<li>控制mysql输出格式</li>
<li>使用用户定义的变量保存信息</li>
</ul>

<p>为了你自己试验本书中的例子，你需要一个MySQL用户和一个数据库。接下来假设：:</p>

<ul>
<li>MySQL服务器运行在本地系统中</li>
<li>你的MySQL用户和密码是cbuser和cbpass</li>
<li>你的数据库是cookbook</li>
</ul>

<h1 id="1-1-创建一个mysql用户">1.1 创建一个MySQL用户</h1>

<p><strong>问题</strong></p>

<p>你需要一个账户来连接MySQL服务器</p>

<p><strong>解决方法</strong></p>

<p>使用<strong>CREATE USER</strong>和<strong>GRANT</strong>语句配置账户，然后使用账户名密码连接服务器</p>

<p><strong>讨论</strong></p>

<pre><code>% mysql -h localhost -u root -p
Enter password: ******
mysql&gt; CREATE USER 'cbuser'@'localhost' IDENTIFIED BY 'cbpass';
mysql&gt; GRANT ALL ON cookbook.* TO 'cbuser'@'localhost';
Query OK, 0 rows affected (0.09 sec)
mysql&gt; quit
Bye
</code></pre>

<p>如果你想要连接到其他主机的服务器上，在<strong>CREATE USER</strong>和<strong>GRANT</strong>语句里面替换为其他主机，语句类似：</p>

<pre><code>mysql&gt; CREATE USER 'cbuser'@'myhost.example.com' IDENTIFIED BY 'cbpass';
mysql&gt; GRANT ALL ON cookbook.* TO 'cbuser'@'myhost.example.com';
</code></pre>

<p><strong>CREATE USER</strong>和<strong>GRANT</strong>只能被有管理权限的用户比如root使用。创建cbuser用户后，确认你能使用它连接MySQL：</p>

<pre><code>% mysql -h localhost -u cbuser -p
Enter password: cbpass
</code></pre>

<h1 id="1-2-创建一个数据库和一个样例表">1.2 创建一个数据库和一个样例表</h1>

<p><strong>问题</strong></p>

<p>你想要创建一个数据库并在里面创建表</p>

<p><strong>解决方法</strong></p>

<p>使用<strong>CREATE DATABASE</strong>语句创建数据库，<strong>CREATE TABLE</strong>语句创建每一个表，<strong>INSERT</strong>语句添加行到表中。</p>

<p><strong>讨论</strong></p>

<p>如下创建一个数据库：</p>

<pre><code>mysql&gt; CREATE DATABASE cookbook;
</code></pre>

<p>既然有了一个数据库，你可以在里面创建表。首先，选择cookbook作为默认数据库：</p>

<pre><code>mysql&gt; USE cookbook;
</code></pre>

<p>然后创建一个简单的表：</p>

<pre><code>mysql&gt; CREATE TABLE limbs (thing VARCHAR(20), legs INT, arms INT);
</code></pre>

<p>并用一些行填充它：</p>

<pre><code>mysql&gt; INSERT INTO limbs (thing,legs,arms) VALUES('human',2,2);
mysql&gt; INSERT INTO limbs (thing,legs,arms) VALUES('insect',6,0);
mysql&gt; INSERT INTO limbs (thing,legs,arms) VALUES('squid',0,10);
mysql&gt; INSERT INTO limbs (thing,legs,arms) VALUES('fish',0,0);
mysql&gt; INSERT INTO limbs (thing,legs,arms) VALUES('centipede',100,0);
mysql&gt; INSERT INTO limbs (thing,legs,arms) VALUES('table',4,0);
mysql&gt; INSERT INTO limbs (thing,legs,arms) VALUES('armchair',4,2);
mysql&gt; INSERT INTO limbs (thing,legs,arms) VALUES('phonograph',0,1);
mysql&gt; INSERT INTO limbs (thing,legs,arms) VALUES('tripod',3,0);
mysql&gt; INSERT INTO limbs (thing,legs,arms) VALUES('Peg Leg Pete',1,2);
mysql&gt; INSERT INTO limbs (thing,legs,arms) VALUES('space alien',NULL,NULL);
</code></pre>

<p>执行<strong>SELECT</strong>语句确认这些行被添加进表：</p>

<pre><code>mysql&gt; SELECT * FROM limbs;
+--------------|------|------+
| thing        | legs | arms |
+--------------|------|------+
| human        |    2 |    2 | 
| insect       |    6 |    0 | 
| squid        |    0 |   10 | 
| fish         |    0 |    0 | 
| centipede    |  100 |    0 | 
| table        |    4 |    0 | 
| armchair     |    4 |    2 | 
| phonograph   |    0 |    1 | 
| tripod       |    3 |    0 | 
| Peg Leg Pete |    1 |    2 | 
| space alien  | NULL | NULL | 
+--------------|------|------+
</code></pre>

<h1 id="1-3-如果mysql找不到要做什么">1.3 如果mysql找不到要做什么</h1>

<p><strong>问题</strong></p>

<p>当你从命令行调用mysql时，命令行解释器找不到mysql。</p>

<p><strong>解决方法</strong></p>

<p>添加mysql所在目录到<strong>PATH</strong>路径。</p>

<p><strong>讨论</strong></p>

<p>告诉命令解释器哪里查找mysql的一种方法是使用绝对路径。Unix下面命令可能看起来像：</p>

<pre><code>% /usr/local/mysql/bin/mysql
</code></pre>

<p>Windows下面看起来像：</p>

<pre><code>C:\&gt; &quot;C:\Program Files\MySQL\MySQL Server 5.6\bin\mysql&quot;
</code></pre>

<p>一个更好的方案是修改你的<strong>PATH</strong>搜索路径环境变量，添加mysql所在目录，然后你就可以在任何地方调用mysql了。</p>

<p>可以从任何地方调用mysql有一个显著的额外的好处是，你不需要将数据文件放在mysql安装目录，你可以自由地以你认为合理的方式组织这些文件。</p>

<h1 id="1-4-指定mysql命令选项">1.4. 指定mysql命令选项</h1>

<p><strong>问题</strong></p>

<p>当你调用mysql程序不带命令选项时，程序返回一个“拒绝访问”的信息并立即退出。</p>

<p><strong>解决方法</strong></p>

<p>你必须指定连接参数，在命令行，配置文件或两者结合。</p>

<p><strong>讨论</strong></p>

<p>每一个选项是单破折号“短”形式：-h和-u指定主机名和用户名，-p提示输入密码。也有相应的双破折号“长”形式：&ndash;host，&ndash;user和&ndash;password。像这样使用：</p>

<pre><code>% mysql --host=localhost --user=cbuser --password
Enter password: cbpass
</code></pre>

<p>使用这个命令了解mysql支持的所有选项：</p>

<pre><code>% mysql --help
</code></pre>

<p>为mysql指定的命令选项也适用于其他MySQL程序，比如mysqldump和mysqladmin。</p>

<pre><code>% mysqldump -h localhost -u cbuser -p cookbook &gt; cookbook.sql
Enter password: cbpass
</code></pre>

<p>某些操作需要一个MySQL管理员用户。mysqladmin可以执行MySQL root用户才能够的操作：</p>

<pre><code>% mysqladmin -h localhost -u root -p shutdown
Enter password: ← enter MySQL root account password here
</code></pre>

<p>如果你使用的选项值和默认值一样，你可以忽略这个选项。没有默认密码。如果你喜欢，你可以直接在命令行用-ppassword或&ndash;password=password指定密码。不推荐这种方式。</p>

<p>因为默认主机就是本地主机，你可以忽略-h（&ndash;host）选项：</p>

<pre><code>% mysql -u cbuser -p
</code></pre>

<p>假设你不想指定任何选项，你怎么让mysql知道使用什么值呢？很简单，因为MySQL支持配置文件：</p>

<ul>
<li>如果你在配置文件放入一个选项，你不需要在命令行指定它。</li>
<li>你可以混合命令行和配置文件的选项。这使你可以将最常使用的选项保存到配置文件并根据需要在命令行覆盖它们。</li>
</ul>

<blockquote>
<p><strong>MySQL中localhost的意义</strong></p>

<p>Unix下面，MySQL程序表现不一样：按照惯例，他们将主机名hostname特殊处理并尝试用一个Unix socket文件连接本地服务器。为了强制使用TCP/IP连接到本地服务器，使用IP地址127.0.0.1（或::1）而不是localhost。</p>

<p>TCP/IP连接的默认端口是3306。Unix域套接字的路径各不相同，虽然通常是/tmp/mysql.sock。使用-S file_name或&ndash;socket=file_name显示指定套接字路径。</p>
</blockquote>

<h2 id="使用配置文件指定连接参数">使用配置文件指定连接参数</h2>

<p>为了避免每次调用mysql都输入命令行选项，将它们放入配置文件，mysql会自动读取它们。配置文件是纯文本文件：</p>

<ul>
<li>在Unix下，个人配置文件在个人目录，名为.my.cnf。也有管理员可以使用的指定给所有用户的全局参数的配置文件，在/etc或etc/mysql或MySQL安装目录下的etc目录。</li>
<li>在Windows下，你可以使用的文件包括安装目录下的my.ini或my.cnf文件.</li>
</ul>

<p>下面这个例子展示了MySQL配置文件使用的格式：</p>

<pre><code># general client program connection options
[client]
host = localhost
user = cbuser
password = cbpass
# options specific to the mysql program
[mysql]
skip-auto-rehash
pager=&quot;/usr/bin/less -E&quot; # specify pager for interactive mode
</code></pre>

<p>使用刚刚展示的[client]组列出的连接参数，你可以不带参数调用mysql：</p>

<pre><code>% mysql
</code></pre>

<p>使用这个命令找出mysql程序从配置文件读取的默认参数：</p>

<pre><code>% mysql --print-defaults
</code></pre>

<p>你也可以使用my_print_defaults工具，它接受配置文件中的组名作为参数：</p>

<pre><code>% my_print_defaults client mysqldump
</code></pre>

<h2 id="组合命令行和配置文件参数">组合命令行和配置文件参数</h2>

<p>MySQL程序首先读取配置文件中连接参数，然后检查命令行中额外的参数。这意味着你可以一种方式指定某些参数，以另一种方式指定其它参数：</p>

<pre><code>% mysql -p
Enter password: ← enter your password here
</code></pre>

<p>命令行参数优先于配置文件中的参数，因此为了覆盖一个配置文件中的参数，只要在命令行指定就行：</p>

<pre><code>% mysql -u root -p
Enter password: ← enter MySQL root account password here
</code></pre>

<p>当配置文件中有一个非空的密码选项，为了显示指定“无密码”，在命令行中使用&ndash;skip-password选项：</p>

<pre><code>% mysql --skip-password
</code></pre>

<h2 id="从其他用户保护配置文件">从其他用户保护配置文件</h2>

<p>在一个多用户的操作系统比如Unix中，保护你目录下配置文件以阻止其他用户阅读并发现如何使用你的账户连接MySQL。使用chmod将文件变为私有：</p>

<pre><code>% chmod 600 .my.cnf
% chmod go-rwx .my.cnf
</code></pre>

<h1 id="1-5-交互执行sql语句">1.5. 交互执行SQL语句</h1>

<p><strong>问题</strong></p>

<p>你已经启动了mysql。现在你想要发送SQL语句到MySQL服务器执行。</p>

<p><strong>解决方法</strong></p>

<p>输入语句，让mysql知道每一句在哪里结束，或者直接在命令行指定“单行”语句。</p>

<p><strong>讨论</strong></p>

<p>分号是最常见的终结符，你也可以使用\g（“go”）作为分号的同义词。</p>

<pre><code>mysql&gt; SELECT NOW();
+---------------------+
| NOW()               |
+---------------------+
| 2016-04-05 20:20:31 |
+---------------------+
mysql&gt; SELECT
    -&gt; NOW()\g
+---------------------+
| NOW()               |
+---------------------+
| 2016-04-05 20:20:40 |
+---------------------+
</code></pre>

<p>;和\g不是语言的一部分。它们是mysql程序使用的惯例，在发送语句到MySQL服务器前，mysql识别这些终结符并从语句中去除它们。</p>

<p>某些语句产生输出的行很长以致它们占据终端一行以上，使得查询结果很难读。为了避免这个问题，使用\G产生“垂直”输出：</p>

<pre><code>mysql&gt; SHOW FULL COLUMNS FROM limbs LIKE 'thing'\G
*************************** 1. row ***************************
     Field: thing
      Type: varchar(20)
 Collation: latin1_swedish_ci
      Null: YES
       Key: 
   Default: NULL
     Extra: 
Privileges: select,insert,update,references
   Comment: 
</code></pre>

<p>为了在一个会话中所有语句执行的结果产生垂直输出，使用-E（或&ndash;vertical）选项。为了那些只超过终端宽度的结果产生垂直输出，使用&ndash;auto-vertical-output选项。</p>

<p>为了从命令行直接执行一个语句，指定-e（或&ndash;execute）选项：</p>

<pre><code>% mysql -u cbuser -p -e &quot;SELECT COUNT(*) FROM limbs&quot; cookbook
Enter password: 
+----------+
| COUNT(*) |
+----------+
|       11 |
+----------+
</code></pre>

<p>为了执行多个语句，用分号分隔它们：</p>

<pre><code>% mysql -u cbuser -p -e &quot;SELECT COUNT(*) FROM limbs; SELECT NOW()&quot; cookbook
Enter password: 
+----------+
| COUNT(*) |
+----------+
|       11 |
+----------+
+---------------------+
| NOW()               |
+---------------------+
| 2016-04-05 20:27:14 |
+---------------------+
</code></pre>

<h1 id="1-6-从文件或程序输出中执行sql语句">1.6. 从文件或程序输出中执行SQL语句</h1>

<p><strong>问题</strong></p>

<p>你想要mysql读取保存在文件中的语句而不必手动输入它们。或者你想要mysql读取其他程序的输出。</p>

<p><strong>解决方法</strong></p>

<p>为了读一个文件，重定向mysql的输入，或使用source命令。为了读取程序输出，使用管道。</p>

<p><strong>讨论</strong></p>

<p>为了创建一个mysql批量执行的SQL脚本，将你的语句放进一个文本文件。然后调用mysql并重定向输入读取那个文件：</p>

<pre><code>% mysql cookbook &lt; file_name
</code></pre>

<p>从输入文件读取的语句必须以;，\g或\G结尾。交互和批量模式的输出格式不一样。交互模式默认输出表格形式，批量模式默认以tab分隔。使用合适的命令选项可以覆盖默认行为。</p>

<p>为了在一个mysql会话中读取包含SQL语句的文件，使用source filename命令（或. filename）：</p>

<pre><code>mysql&gt; source limbs.sql;
mysql&gt; \. limbs.sql;
</code></pre>

<p>SQL脚本自己可以包含source或.命令包含其它脚本。这样更具灵活性，但是要注意避免source循环。</p>

<p>SQL脚本不需要手写，它可以是程序生成的：</p>

<pre><code>% mysqldump cookbook &gt; dump.sql
% mysql -h other-host.example.com cookbook &lt; dump.sql
</code></pre>

<p>任何程序输出产生包含正确结尾的SQL语句，都可以作为mysql的输入源：</p>

<pre><code>% mysqldump cookbook | mysql -h other-host.example.com cookbook
% generate-test-data | mysql cookbook
</code></pre>

<h1 id="1-7-控制mysql输出的目的地和格式">1.7. 控制mysql输出的目的地和格式</h1>

<p><strong>问题</strong></p>

<p>你想要mysql输出到别的地方而不是屏幕，且你不想要默认的输出格式。</p>

<p><strong>解决方法</strong></p>

<p>重定向输出到一个文件，或使用管道将输出发送给一个程序。你也可以控制mysql的输出，产生表格，tab分隔的，HTML或XML输出，去掉列头，或使mysql更加详细或更少信息。</p>

<p><strong>讨论</strong></p>

<p>使用shell的重定向能力保存mysql输出到文件：</p>

<pre><code>% mysql cookbook &gt; outputfile
% mysql cookbook &lt; inputfile &gt; outputfile
% mysql cookbook &lt; inputfile | mail paul
</code></pre>

<h2 id="产生表格或tab分隔的输出">产生表格或tab分隔的输出</h2>

<p>交互模式下，mysql默认使用表格输出：</p>

<pre><code>mysql&gt; SELECT * FROM limbs WHERE legs = 0;
+------------|------|------+
| thing      | legs | arms |
+------------|------|------+
| squid      |    0 |   10 |
| fish       |    0 |    0 |
| phonograph |    0 |    1 |
+------------|------|------+
</code></pre>

<p>非交互模式下，mysql默认使用tab分隔输出：</p>

<pre><code>% echo &quot;SELECT * FROM limbs WHERE legs = 0&quot; | mysql -u cbuser -p cookbook
Enter password: 
thing   legs    arms
squid   0   10
fish    0   0
phonograph  0   1
</code></pre>

<p>非交互模式下，使用-t（或&ndash;table）选项产生表格输出：</p>

<pre><code>% echo &quot;SELECT * FROM limbs WHERE legs = 0&quot; | mysql -u cbuser -p cookbook -t
Enter password: 
+------------|------|------+
| thing      | legs | arms |
+------------|------|------+
| squid      |    0 |   10 |
| fish       |    0 |    0 |
| phonograph |    0 |    1 |
+------------|------|------+
</code></pre>

<p>使用-B或&ndash;batch在交互模式下产生tab分隔的输出。</p>

<h2 id="产生html或xml输出">产生HTML或XML输出</h2>

<p>mysql从每一个查询结果里面产生一个HTML表，如果使用-H选项：</p>

<pre><code>% mysql -u cbuser -p -H -e &quot;SELECT * FROM limbs WHERE legs = 0&quot;  cookbook
Enter password: 
&lt;TABLE BORDER=1&gt;&lt;TR&gt;&lt;TH&gt;thing&lt;/TH&gt;&lt;TH&gt;legs&lt;/TH&gt;&lt;TH&gt;arms&lt;/TH&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;squid&lt;/TD&gt;&lt;TD&gt;0&lt;/TD&gt;&lt;TD&gt;10&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;fish&lt;/TD&gt;&lt;TD&gt;0&lt;/TD&gt;&lt;TD&gt;0&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;phonograph&lt;/TD&gt;&lt;TD&gt;0&lt;/TD&gt;&lt;TD&gt;1&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;
</code></pre>

<p>你可以将输出保存到一个文件，然后在浏览器中查看：</p>

<pre><code>% mysql -H -e &quot;SELECT * FROM limbs WHERE legs=0&quot; cookbook &gt; limbs.html
% open -a safari limbs.html
</code></pre>

<p>使用-X（或&ndash;xml）选项产生XML文件：</p>

<pre><code>% mysql -u cbuser -p -X -e &quot;SELECT * FROM limbs WHERE legs = 0&quot;  cookbook &gt; limbs.xml
</code></pre>

<p>像这样使用转换：</p>

<pre><code>% mysql -X -e &quot;SELECT * FROM limbs WHERE legs=0&quot; cookbook \
| xsltproc mysql-xml.xsl -
Query: SELECT * FROM limbs WHERE legs=0
Result set:
squid, 0, 10
fish, 0, 0
phonograph, 0, 1
</code></pre>

<p>-H，&ndash;html，-X和&ndash;xml选项只对产生结果集的语句有用，对INSERT或UPDATE无效。</p>

<h2 id="查询结果中丢弃列头">查询结果中丢弃列头</h2>

<p>使用&ndash;skip-column-names选项创建输出只包含数据值，丢弃了头：</p>

<pre><code>% mysql --skip-column-names -e &quot;SELECT arms FROM limbs&quot; cookbook | summarize
</code></pre>

<p>指定“沉默”选项（-s或&ndash;silent）2次是一样的效果：</p>

<pre><code>% mysql -ss -e &quot;SELECT arms FROM limbs&quot; cookbook | summarize
</code></pre>

<h2 id="指定输出列分隔符">指定输出列分隔符</h2>

<p>在非交互模式下，mysql使用tab分隔输出列，没有指定输出分隔符的选项。可以处理mysql输出以使用不同的分隔符：</p>

<pre><code>% mysql cookbook &lt; inputfile | sed -e &quot;s/TAB/:/g&quot; &gt; outputfile
% mysql cookbook &lt; inputfile | tr &quot;TAB&quot; &quot;:&quot; &gt; outputfile
% mysql cookbook &lt; inputfile | tr &quot;\011&quot; &quot;:&quot; &gt; outputfile
% mysql cookbook &lt; inputfile \
| sed -e 's/&quot;/&quot;&quot;/g' -e 's/TAB/&quot;,&quot;/g' -e 's/^/&quot;/' -e 's/$/&quot;/' &gt; outputfile
</code></pre>

<h2 id="控制mysql的详细级别">控制mysql的详细级别</h2>

<p>使用-v或&ndash;verbose告诉mysql变得更详细，指定选项多次可以增强详细度：</p>

<pre><code>% mysql -u cbuser -p -e &quot;SELECT NOW()&quot;
% mysql -u cbuser -p -e &quot;SELECT NOW()&quot; -v
% mysql -u cbuser -p -e &quot;SELECT NOW()&quot; -vv
% mysql -u cbuser -p -e &quot;SELECT NOW()&quot; -vvv
</code></pre>

<p>-s和&ndash;silent也有一样的效果。</p>

<h1 id="1-8-在sql语句中使用用户定义的变量">1.8. 在SQL语句中使用用户定义的变量</h1>

<p><strong>问题</strong></p>

<p>你想要在一个语句中使用之前语句产生值。</p>

<p><strong>解决方法</strong></p>

<p>保存这个值在用户定义的变量里以供以后使用。</p>

<p><strong>讨论</strong></p>

<p>用户定义的变量使你在用一个会话中其他语句中使用它。用户变量是MySQL特定的扩展，不是标准SQL。</p>

<p>使用语法@var_name := val定义用户变量，变量可以在接下来的语句中使用：</p>

<pre><code>mysql&gt; SELECT @max_limbs := MAX(arms + legs) FROM limbs;
+--------------------------------+
| @max_limbs := MAX(arms + legs) |
+--------------------------------+
|                            100 |
+--------------------------------+
mysql&gt; SELECT * FROM limbs WHERE arms + legs = @max_limbs;
+-----------|------|------+
| thing     | legs | arms |
+-----------|------|------+
| centipede |  100 |    0 |
+-----------|------|------+
</code></pre>

<p>变量的另一个用法是保存LAST_INSERT_ID()的结果在创建一个具有AUTO_INCREMENT列的表的新行后：</p>

<pre><code>mysql&gt; SELECT @last_id := LAST_INSERT_ID();
</code></pre>

<p>LAST_INSERT_ID() 返回最新的AUTO_INCREMENT值。</p>

<p>用户变量保存单一值，如果一个语句返回多行，最后一行保存到变量中：</p>

<pre><code>mysql&gt; SELECT @name := thing FROM limbs WHERE legs = 0;
+----------------+
| @name := thing |
+----------------+
| squid          |
| fish           |
| phonograph     |
+----------------+
mysql&gt; SELECT @name;
+------------+
| @name      |
+------------+
| phonograph |
+------------+
</code></pre>

<p>如果语句返回0行，赋值不会发生，且变量保存原来的值。如果变量之前没用过，则其值为NULL：</p>

<pre><code>mysql&gt; SELECT @name2 := thing FROM limbs WHERE legs &lt; 0;
Empty set (0.00 sec)
mysql&gt; SELECT @name2;
+--------+
| @name2 |
+--------+
| NULL   |
+--------+
</code></pre>

<p>为了显式设置某个值给一个变量，使用SET语句。SET语法可以使用:=或=作为赋值操作符：</p>

<pre><code>mysql&gt; SET @sum = 4 + 7;
mysql&gt; SELECT @sum;
+------+
| @sum |
+------+
|   11 |
+------+
</code></pre>

<p>你可以将SELECT结果赋值个一个变量，只要它是一个标量子查询（括号里面的只返回一个值的查询）：</p>

<pre><code>mysql&gt; SET @max_limbs = (SELECT MAX(arms+legs) FROM limbs);
</code></pre>

<p>用户变量名大小写不敏感：</p>

<pre><code>mysql&gt; SET @x = 1, @X = 2; SELECT @x, @X;
+------|------+
| @x   | @X   |
+------|------+
|    2 |    2 |
+------|------+
</code></pre>

<p>用户变量只能出现在表达式允许出现的地方，不是常量或字符标识符必须提供。变量不能用了作为表名：</p>

<pre><code>mysql&gt; SET @tbl_name = CONCAT('tmp_tbl_', CONNECTION_ID());
mysql&gt; CREATE TABLE @tbl_name (int_col INT);
ERROR 1064: You have an error in your SQL syntax near '@tbl_name
(int_col INT)'
</code></pre>

<p>SET也被用来给存储程序参数，本地变量和系统变量赋值。</p>
]]></content>
		</item>
		
		<item>
			<title>第2章 变量和基本类型</title>
			<link>https://gitop.cc/posts/cpp-primer-2/</link>
			<pubDate>Mon, 21 Mar 2016 20:27:17 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/cpp-primer-2/</guid>
			<description>2.1 基础内置类型 C++定义了一组基础类型，包括算术类型和一个特殊的void类型。算术类型表示字符，整型，布尔值和浮点数类型。void类型不关联</description>
			<content type="html"><![CDATA[

<h2 id="2-1-基础内置类型">2.1 基础内置类型</h2>

<p>C++定义了一组基础类型，包括算术类型和一个特殊的void类型。算术类型表示字符，整型，布尔值和浮点数类型。void类型不关联任何值，而且只能用在一些场合，最常见是用作函数的返回类型。</p>

<h3 id="2-1-1-算术类型">2.1.1 算术类型</h3>

<p>算术类型分为2类：整型（包含了字符和布尔值）和浮点数类型。算术类型的大小不同机器可能不一样。</p>

<table>
<thead>
<tr>
<th align="left">Type</th>
<th align="left">Meaning</th>
<th align="left">Minimum Size</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">bool</td>
<td align="left">boolean</td>
<td align="left">NA</td>
</tr>

<tr>
<td align="left">char</td>
<td align="left">character</td>
<td align="left">8 bits</td>
</tr>

<tr>
<td align="left">wchar_t</td>
<td align="left">wide character</td>
<td align="left">16 bits</td>
</tr>

<tr>
<td align="left">char16_t</td>
<td align="left">Unicode character</td>
<td align="left">16 bits</td>
</tr>

<tr>
<td align="left">char32_t</td>
<td align="left">Unicode character</td>
<td align="left">32 bits</td>
</tr>

<tr>
<td align="left">short</td>
<td align="left">short integer</td>
<td align="left">16 bits</td>
</tr>

<tr>
<td align="left">int</td>
<td align="left">integer</td>
<td align="left">16 bits</td>
</tr>

<tr>
<td align="left">long</td>
<td align="left">long integer</td>
<td align="left">32 bits</td>
</tr>

<tr>
<td align="left">long long</td>
<td align="left">long integer</td>
<td align="left">64 bits</td>
</tr>

<tr>
<td align="left">float</td>
<td align="left">single-precision floating-point</td>
<td align="left">6 significant digits</td>
</tr>

<tr>
<td align="left">double</td>
<td align="left">double-precision floating-point</td>
<td align="left">10 significant digits</td>
</tr>

<tr>
<td align="left">long double</td>
<td align="left">extended-precision floating-point</td>
<td align="left">10 significant digits</td>
</tr>
</tbody>
</table>

<p>bool类型代表了真值true和false。</p>

<p>基本的字符类型是char。一个char保证足够大来保存机器的基本字符集。也就是一个char和一个机器字节一样大。剩下的字符类型wchar_t，char16_t和char32_t用于扩展字符集。wchar_t保证可以存放机器最大扩展字符集中任意字符。char16_t和char32_t被用于Unicode字符。</p>

<p>剩下的整型表示不同大小的整数。C++保证int至少和short一样大，long至少和int一样大，long long至少和long一样大。long long类型由新标准引入。</p>

<p>浮点数类型表示单精度，双精度和扩展精度的值。标准指定了一个最小数量的有效数字。大多数编译器提供更高的精确度。典型地，float占32位，double占64位，long double占96或128位。float和double通常产生7位和16位有效数字。</p>

<p><strong>有符号和无符号类型</strong></p>

<p>除了bool和扩展的字符类型，整型可以是有符号或无符号的。有符号类型表示负值或正值（包括0），无符号的类型的值大于或等于0。</p>

<p>在整型前面加上unsigned关键字就得到相应的无符号类型。unsigned int可以简写为unsigned。</p>

<p>和其他整型不一样，有3种不一样的基本字符类型：char, signed char和unsigned char。char类型使用signed char或unsigned char其中一种表示。</p>

<p>标准没有定义signed类型如何表示，但是明确了signed类型的正值和负值范围应该一样大。</p>

<blockquote>
<p><strong>建议</strong>：决定使用哪种类型</p>
</blockquote>

<ul>
<li>当你知道值不可能是负的时，使用unsigned类型</li>
<li>使用int做整型运算。short通常太小，long通常和int一样大小。如果超过int范围，则使用long long。</li>
<li>在算术表达式中不要使用char或bool。使用char计算尤其容易出问题，因为在一些机器上char是有符号的，而在另一些机器上char是无符号的。</li>
<li>使用double做浮点计算。float通常精度不够，而且计算double的开销与float相比可以忽略。</li>
</ul>

<h3 id="2-1-2-类型转换">2.1.2 类型转换</h3>

<p>一个对象的类型定义了这个对象可能包含的数据以及它能执行的操作。在诸多类型支持的操作中的一个是转换为其他相关类型的能力。</p>

<p>类型转换自动发生在当我们使用一种类型的对象在期待另一种类型的地方。</p>

<p>当我们将一种算术类型赋值给另一种算术类型时，会发生什么取决于等号左边类型允许的值的范围：</p>

<ul>
<li>当将非bool算术类型赋值给bool对象时，如果值为0，则结果是false，否则为true。</li>
<li>当将bool赋值给其他算术类型时，如果bool为true，则结果为1，否则为0。</li>
<li>当将浮点数类型赋值给整型时，小数点后面的部分被截断。</li>
<li>当将整型值赋值给浮点数类型时，小数部分为0。如果整型有比浮点数有效数字更多数字时，可能会损失精度。</li>
<li>如果将超出范围的值赋值给无符号类型时，结果为改值和目标类型最大值的余数。</li>
<li>如果将超出范围的值赋值给有符号类型时，结果是未定义的。</li>
</ul>

<blockquote>
<p><strong>建议</strong>：避免未定义的依赖具体实现的行为</p>
</blockquote>

<p><strong>涉及无符号类型的表达式</strong></p>

<p>尽管我们不太可能有意地将一个负值赋值给一个无符号类型，但是我们非常容易写出代码隐式地这样做。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">unsigned</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">42</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// prints -84
</span><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">u</span> <span class="o">+</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// if 32-bit ints, prints 4294967264
</span></code></pre></div>

<p>不管一个或者两个操作数是无符号的，当用无符号数减去一个数时，我们必须确保结果不能是负数：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">unsigned</span> <span class="n">u1</span> <span class="o">=</span> <span class="mi">42</span><span class="p">,</span> <span class="n">u2</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">u1</span> <span class="o">-</span> <span class="n">u2</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// ok: result is 32
</span><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">u2</span> <span class="o">-</span> <span class="n">u1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// ok: but the result will wrap around
</span></code></pre></div>

<p>无符号数不可能小于0也影响我们如何写循环。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// WRONG: u can never be less than 0; the condition will always succeed
</span><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">u</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">u</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">u</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div>

<blockquote>
<p><strong>注意</strong>：不要混合使用signed和unsigned类型
需要记住signed值会自动转换为unsigned值。</p>
</blockquote>

<h3 id="2-1-3-字面值">2.1.3 字面值</h3>

<p>一个值，比如42，被称为字面值，因为它的值是不证自明的。每一个字面值都有一个类型。一个字面值的形式和值确定了它的类型。</p>

<p><strong>整型和浮点型字面值</strong></p>

<p>我们可以使用十进制，八进制或十六进制表示法来写整型字面值。八进制字面值以0开始，十六进制字面值以0x或0X开始。</p>

<p>默认地，十进制字面值是有符号的，而八进制和十六进制字面值可以使有符号或无符号的。十进制字面值类型为适合其值的最小整型，八进制字面值和十六进制字面值类型为适合其值的最小有符号或无符号整型。没有short类型的字面值。</p>

<p><em>Table 2.2 指定字面值的类型</em></p>

<table>
<thead>
<tr>
<th align="left">Prefix</th>
<th align="left">Meaning</th>
<th align="left">Type</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">u</td>
<td align="left">Unicode 16 character</td>
<td align="left">char16_t</td>
</tr>

<tr>
<td align="left">U</td>
<td align="left">Unicode 32 character</td>
<td align="left">char32_t</td>
</tr>

<tr>
<td align="left">L</td>
<td align="left">wide character</td>
<td align="left">wchar_t</td>
</tr>

<tr>
<td align="left">u8</td>
<td align="left">utf-8(string literals only)</td>
<td align="left">char</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th align="left">Suffix</th>
<th align="left">Minimum Type</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">u or U</td>
<td align="left">unsigned</td>
</tr>

<tr>
<td align="left">l or L</td>
<td align="left">long</td>
</tr>

<tr>
<td align="left">ll or LL</td>
<td align="left">long long</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th align="left">Suffix</th>
<th align="left">Type</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">f or F</td>
<td align="left">float</td>
</tr>

<tr>
<td align="left">l or L</td>
<td align="left">long double</td>
</tr>
</tbody>
</table>

<p>浮点数字面值包含小数点或指数(E或e)指定使用科学计数法。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="mf">3.14159</span>    <span class="mf">3.14159E0</span>    <span class="mf">0.</span>    <span class="mf">0e0</span>    <span class="mf">.001</span>
</code></pre></div>

<p>浮点数字面值默认为double类型。我们可以添加后缀覆盖默认行为。</p>

<p><strong>字符和字符串字面值</strong></p>

<p>一个单引号包含的字符是一个类型为char的字面值。0个或多个双引号包含的字符是字符串字面值：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="sc">&#39;a&#39;</span>  <span class="c1">// character literal
</span><span class="c1"></span><span class="s">&#34;Hello World!&#34;</span>  <span class="c1">// string literal
</span></code></pre></div>

<p>一个字符串字面值的类型是一个const char数组。编译器给每一个字符串字面值追加一个空字符(&rsquo;\0&rsquo;)。</p>

<p>两个相邻的仅仅由空白符分割的字符串字面值连接为一个字面值。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// multiline string literal
</span><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;a really, really long string literal &#34;</span>
             <span class="s">&#34;that spans two lines&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div>

<p><strong>转义序列</strong></p>

<table>
<thead>
<tr>
<th align="left">Escape Sequence</th>
<th align="left">Meaning</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">\n</td>
<td align="left">newline</td>
</tr>

<tr>
<td align="left">\t</td>
<td align="left">horizontal tab</td>
</tr>

<tr>
<td align="left">\a</td>
<td align="left">alert(bell)</td>
</tr>

<tr>
<td align="left">\v</td>
<td align="left">vertical tab</td>
</tr>

<tr>
<td align="left">\b</td>
<td align="left">backspace</td>
</tr>

<tr>
<td align="left">\&rdquo;</td>
<td align="left">double quote</td>
</tr>

<tr>
<td align="left">\<br></td>
<td align="left">backslash</td>
</tr>

<tr>
<td align="left">\?</td>
<td align="left">question mark</td>
</tr>

<tr>
<td align="left">\&rsquo;</td>
<td align="left">single quote</td>
</tr>

<tr>
<td align="left">\r</td>
<td align="left">carriage return</td>
</tr>

<tr>
<td align="left">\f</td>
<td align="left">formfeed</td>
</tr>
</tbody>
</table>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">newline</span>            <span class="err">\</span><span class="n">n</span>     <span class="n">horizontal</span> <span class="n">tab</span>      <span class="err">\</span><span class="n">t</span>     <span class="n">alert</span> <span class="p">(</span><span class="n">bell</span><span class="p">)</span>       <span class="err">\</span><span class="n">a</span>
<span class="n">vertical</span> <span class="n">tab</span>       <span class="err">\</span><span class="n">v</span>     <span class="n">backspace</span>          <span class="err">\</span><span class="n">b</span>     <span class="kt">double</span> <span class="n">quote</span>  <span class="err">\</span><span class="s">&#34;</span>
<span class="n">backslash</span>         <span class="err">\\</span>     <span class="n">question</span> <span class="n">mark</span>     <span class="err">\</span><span class="o">?</span>     <span class="n">single</span> <span class="n">quote</span>    <span class="err">\&#39;</span>
<span class="n">carriage</span> <span class="k">return</span>   <span class="err">\</span><span class="n">r</span>     <span class="n">formfeed</span>       <span class="err">\</span><span class="n">f</span><span class="s">&#34;</span>
</code></pre></div>

<p>我们也可以写通用的转义序列，即\x后跟一个或多个16进制数字或者\后跟1至3个8进制数字。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="err">\</span><span class="mi">7</span> <span class="p">(</span><span class="n">bell</span><span class="p">)</span>    <span class="err">\</span><span class="mi">12</span> <span class="p">(</span><span class="n">newline</span><span class="p">)</span>     <span class="err">\</span><span class="mi">40</span> <span class="p">(</span><span class="n">blank</span><span class="p">)</span>
<span class="err">\</span><span class="mi">0</span> <span class="p">(</span><span class="n">null</span><span class="p">)</span>    <span class="err">\</span><span class="mi">115</span> <span class="p">(</span><span class="sc">&#39;M&#39;</span><span class="p">)</span>    <span class="err">\</span><span class="n">x4d</span> <span class="p">(</span><span class="sc">&#39;M&#39;</span><span class="p">)</span>
</code></pre></div>

<p>注意如果\后面后跟3个以上8进制数字，只有前3个有效。相反\x使用所有后续16进制数字。</p>

<p><strong>指定字面值的类型</strong></p>

<p>我们可以提供前缀或后缀来覆盖整数，浮点数或字符字面值的默认类型。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="sa">L</span><span class="sc">&#39;a&#39;</span>     <span class="c1">// wide character literal, type is wchar_t
</span><span class="c1"></span><span class="sa">u8</span><span class="s">&#34;hi!&#34;</span>  <span class="c1">// utf-8 string literal (utf-8 encodes a Unicode character in 8 bits)
</span><span class="c1"></span><span class="mi">42ULL</span>    <span class="c1">// unsigned integer literal, type is unsigned long long
</span><span class="c1"></span><span class="mf">1E-3</span><span class="n">F</span>    <span class="c1">// single-precision floating-point literal, type is float
</span><span class="c1"></span><span class="mf">3.14159</span><span class="n">L</span> <span class="c1">// extended-precision floating-point literal, type is long double
</span></code></pre></div>

<blockquote>
<p><strong>最佳实践</strong>
当写一个long字面值时，使用大写的L，小写l和1容易混淆。</p>
</blockquote>

<p><strong>布尔类型和指针类型字面值</strong></p>

<p>true和false是布尔类型的字面值，nullptr是指针的字面值。</p>

<h2 id="2-2-变量">2.2 变量</h2>

<p>一个变量给我们提供了程序能够操作的命名存储空间。C++中每一个变量都有一个类型。类型决定了变量的大小和在内存种的布局，以及可以应用到变量的一组操作。</p>

<h3 id="2-2-1-变量定义">2.2.1 变量定义</h3>

<p>一个简单的变量定义由类型说明符，一个或多个由逗号分隔的变量名组成，由分号结束。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="c1">// sum, value, and units_sold have type int
</span><span class="c1"></span>    <span class="n">units_sold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// sum and units_sold have initial value 0
</span><span class="c1"></span><span class="n">Sales_item</span> <span class="n">item</span><span class="p">;</span>    <span class="c1">// item has type Sales_item (see § 1.5.1 (p. 20))
</span><span class="c1">// string is a library type, representing a variable-length sequence of characters
</span><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">book</span><span class="p">(</span><span class="s">&#34;0-201-78345-X&#34;</span><span class="p">);</span> <span class="c1">// book initialized from string literal
</span></code></pre></div>

<p><strong>初始化式</strong></p>

<p>一个被初始化的对象在它创建时获得指定的值。用来初始化一个变量的值可以是任意复杂的表达式。当一个定义语句定义多个变量时，前面定义的变量对后面的变量可见。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// ok: price is defined and initialized before it is used to initialize discount
</span><span class="c1"></span><span class="kt">double</span> <span class="n">price</span> <span class="o">=</span> <span class="mf">109.99</span><span class="p">,</span> <span class="n">discount</span> <span class="o">=</span> <span class="n">price</span> <span class="o">*</span> <span class="mf">0.16</span><span class="p">;</span>
<span class="c1">// ok: call applyDiscount and use the return value to initialize salePrice
</span><span class="c1"></span><span class="kt">double</span> <span class="n">salePrice</span> <span class="o">=</span> <span class="n">applyDiscount</span><span class="p">(</span><span class="n">price</span><span class="p">,</span> <span class="n">discount</span><span class="p">);</span>
</code></pre></div>

<blockquote>
<p><strong>警告</strong>
初始化不是赋值。初始化发生在一个变量创建时给定一个值。赋值抹掉对象当前的值并用新值替代。</p>
</blockquote>

<p><strong>列表初始化</strong></p>

<p>初始化的一个复杂主题是语言定义了几种不同形式的初始化方式。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">units_sold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">units_sold</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">units_sold</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="kt">int</span> <span class="nf">units_sold</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div>

<p>新标准引入花括号作为普遍使用的初始化方式。这种初始化方式称为列表初始化。列表初始化现在可以用在任何时候初始化一个对象以及某些情况下赋值给一个对象。</p>

<p>当使用内置类型的变量时，列表初始化有一个重要的性质：编译器不允许会导致精度损失的内置类型列表初始化。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">long</span> <span class="kt">double</span> <span class="n">ld</span> <span class="o">=</span> <span class="mf">3.1415926536</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">{</span><span class="n">ld</span><span class="p">},</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="n">ld</span><span class="p">};</span> <span class="c1">// error: narrowing conversion required
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">c</span><span class="p">(</span><span class="n">ld</span><span class="p">),</span> <span class="n">d</span> <span class="o">=</span> <span class="n">ld</span><span class="p">;</span>   <span class="c1">// ok: but value will be truncated
</span></code></pre></div>

<p><strong>默认初始化</strong></p>

<p>当我们定义变量没有提供初始化式时，变量被默认初始化。这些变量被给予默认值。默认值取决于变量的类型以及在哪里定义变量。</p>

<p>内置类型对象的默认值取决于变量在哪里定义。定义在任何函数外的变量初始化为0。定义在函数内的变量未初始化。内置类型对象未初始化的值是未定义的。</p>

<p>每一个类控制如何初始化类对象。大多数类允许我们定义对象时不用显式指定初始化式。这些类为我们提供合适的默认值。</p>

<blockquote>
<p><strong>注解</strong>
定义在函数内的未初始化的内置类型对象拥有未定义的值。没有显式初始化的类对象拥有类定义好的值。</p>

<p><strong>警告</strong>
未初始化的变量会引起运行时的问题</p>

<p><strong>提示</strong>
我们建议初始化每一个内置类型对象的值。这并不总是必要的，但是它更安全。</p>
</blockquote>

<h3 id="2-2-2-变量声明与定义">2.2.2 变量声明与定义</h3>

<p>为了允许程序按不同逻辑部分来写，C++支持所谓的分离编译（separate compilation）。分离编译允许我们将程序分解为多个文件，每一个文件可以独立编译。</p>

<p>为了支持分离编译，C++区分声明和定义。一个声明使得一个名字被程序知道。一个定义创建关联的实体。</p>

<p>为了获得一个声明而不是定义，可以添加extern关键字且不需要提供初始化式：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">extern</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>   <span class="c1">// declares but does not define i
</span><span class="c1"></span><span class="kt">int</span> <span class="n">j</span><span class="p">;</span>          <span class="c1">// declares and defines j
</span></code></pre></div>

<p>任何包含显式初始化式的声明都是一个定义。一个有初始化式的extern是一个定义：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">extern</span> <span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.1416</span><span class="p">;</span> <span class="c1">// definition
</span></code></pre></div>

<p>在函数内给extern提供初始化式是错误的。</p>

<blockquote>
<p><strong>注解</strong>
变量必须仅定义一次但是可以声明多次。</p>
</blockquote>

<h3 id="2-2-3-标识符">2.2.3 标识符</h3>

<p>C++中标识符由字母，数字和下划线组成。语言没有限制标识符的长度。标识符必须以字母或下划线开始。标识符是区分大小写的。</p>

<p>C++预留了一组名字给语言本身用，这些名字不能用作标识符。</p>

<p><em>C++关键字</em></p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">alignas</span>          <span class="k">continue</span>         <span class="k">friend</span>           <span class="k">register</span>         <span class="nb">true</span>
<span class="k">alignof</span>          <span class="k">decltype</span>         <span class="k">goto</span>             <span class="k">reinterpret_cast</span> <span class="k">try</span>
<span class="k">asm</span>              <span class="k">default</span>          <span class="k">if</span>               <span class="k">return</span>           <span class="k">typedef</span>
<span class="k">auto</span>             <span class="k">delete</span>           <span class="kr">inline</span>           <span class="kt">short</span>            <span class="k">typeid</span>
<span class="kt">bool</span>             <span class="k">do</span>               <span class="kt">int</span>              <span class="kt">signed</span>           <span class="k">typename</span>
<span class="k">break</span>            <span class="kt">double</span>           <span class="kt">long</span>             <span class="k">sizeof</span>           <span class="k">union</span>
<span class="nc">case</span>             <span class="k">dynamic_cast</span>     <span class="k">mutable</span>          <span class="k">static</span>           <span class="kt">unsigned</span>
<span class="k">catch</span>            <span class="k">else</span>             <span class="k">namespace</span>        <span class="k">static_assert</span>    <span class="k">using</span>
<span class="kt">char</span>             <span class="k">enum</span>             <span class="nc">new</span>              <span class="k">static_cast</span>      <span class="k">virtual</span>
<span class="kt">char16_t</span>         <span class="k">explicit</span>         <span class="k">noexcept</span>         <span class="k">struct</span>           <span class="nc">void</span>
<span class="kt">char32_t</span>         <span class="k">export</span>           <span class="k">nullptr</span>          <span class="k">switch</span>           <span class="k">volatile</span>
<span class="k">class</span>            <span class="nc">extern</span>           <span class="k">operator</span>         <span class="k">template</span>         <span class="kt">wchar_t</span>
<span class="k">const</span>            <span class="nb">false</span>            <span class="k">private</span>          <span class="k">this</span>             <span class="k">while</span>
<span class="k">constexpr</span>        <span class="kt">float</span>            <span class="k">protected</span>        <span class="k">thread_local</span>
<span class="k">const_cast</span>       <span class="k">for</span>              <span class="k">public</span>           <span class="k">throw</span>
</code></pre></div>

<p><em>C++可选操作符名字</em></p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">and</span>    <span class="n">bitand</span> <span class="n">compl</span> <span class="n">not_eq</span> <span class="n">or_eq</span> <span class="n">xor_eq</span>
<span class="n">and_eq</span> <span class="n">bitor</span>  <span class="n">not</span>   <span class="n">or</span>     <span class="n">xor</span>
</code></pre></div>

<p>标准也同样保留了一组名字用于标准库。我们自己的程序最好不要使用两个连续的下划线或一个下划线紧跟一个大写字母开头的标识符。此外定义在函数外的标识符不要以下划线开头。</p>

<p><strong>变量名的约定</strong></p>

<p>有一些大家都接收的变量名约定，遵循这些约定可以提高程序的可读性。</p>

<ul>
<li>标识符应该给它的含义一些提示。</li>
<li>变量名通常是小写的。</li>
<li>类名通常以大写字母开头，比如Sales_item。</li>
<li>多个单词组成的标识符应该能在视觉上区分每一个单词，比如student_loan或studentLoan。</li>
</ul>

<blockquote>
<p><strong>最佳实践</strong>
当一致遵循的时候，命名约定最有用。</p>
</blockquote>

<h3 id="2-2-4-名字的作用域">2.2.4 名字的作用域</h3>

<p>一个作用域是程序的一部分，在其中一个名字有特定的意义。C++种大多数作用域由花括号分隔。相同的名字可以引用不同作用域中的不同实体。名字从声明的地方开始可见，直到离开这个作用域。</p>

<blockquote>
<p><strong>建议：在第一次使用的地方定义变量</strong></p>
</blockquote>

<p><strong>嵌套作用域</strong></p>

<p>作用域可以包含其他作用域。被包含的作用域称为内部作用域，包含的作用域称为外部作用域。外部作用域的名字对内部作用域可见。当名字相同时，内部作用域中的名字隐藏外部作用域的名字。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">reused</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>  <span class="c1">// reused has global scope
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">reused</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// global reused
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">reused</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// local reused hides global one
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">reused</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">::</span><span class="n">reused</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// explicitly requests the global reused
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<blockquote>
<p><strong>警告</strong>
定义一个与全局变量同名的局部变量几乎总是坏想法。</p>
</blockquote>

<h2 id="2-3-复合类型">2.3 复合类型</h2>

<p>复合类型是依据其它类型定义的类型。C++有多种复合类型，指针和引用就是其中2种。</p>

<h3 id="2-3-1-引用">2.3.1 引用</h3>

<p>引用定义了对象的一个别名。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">ival</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">refVal</span> <span class="o">=</span> <span class="n">ival</span><span class="p">;</span>  <span class="c1">// refVal refers to (is another name for) ival
</span><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">refVal2</span><span class="p">;</span>        <span class="c1">// error: a reference must be initialized
</span></code></pre></div>

<p>当定义一个引用时，我们将引用绑定到初始化对象上。引用一旦初始化后，就不能绑定到其他对象了。因此，引用必须初始化。</p>

<p><strong>引用是一个别名</strong></p>

<p>引用不是一个对象，它仅仅是一个已经存在的对象的另一个名字。当引用被定义后，所有对引用的操作实际上是操作引用绑定的对象。因为引用不是一个对象，我们不能定义一个引用的引用。</p>

<p><strong>引用定义</strong></p>

<p>我们可以在一个定义里面定义多个引用。每一个标识符前面必须是&amp;。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">i2</span> <span class="o">=</span> <span class="mi">2048</span><span class="p">;</span>  <span class="c1">// i and i2 are both ints
</span><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">i2</span><span class="p">;</span>      <span class="c1">// r is a reference bound to i; r2 is an int
</span><span class="c1"></span><span class="kt">int</span> <span class="n">i3</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ri</span> <span class="o">=</span> <span class="n">i3</span><span class="p">;</span>  <span class="c1">// i3 is an int; ri is a reference bound to i3
</span><span class="c1"></span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">r3</span> <span class="o">=</span> <span class="n">i3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r4</span> <span class="o">=</span> <span class="n">i2</span><span class="p">;</span>   <span class="c1">// both r3 and r4 are references
</span></code></pre></div>

<p>除了2个例外，引用的类型和它绑定对象的类型必须完全一致。而且引用只能绑定到一个对象，不能绑定到字面值或表达式的结果上。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="o">&amp;</span><span class="n">refVal4</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>   <span class="c1">// error: initializer must be an object
</span><span class="c1"></span><span class="kt">double</span> <span class="n">dval</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">refVal5</span> <span class="o">=</span> <span class="n">dval</span><span class="p">;</span> <span class="c1">// error: initializer must be an int object
</span></code></pre></div>

<h3 id="2-3-2-指针">2.3.2 指针</h3>

<p>指针是一个指向其他类型的复合类型。和引用一样，指针也是用来间接访问其他对象。和引用不一样的是，指针本身是一个对象。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="o">*</span><span class="n">ip1</span><span class="p">,</span> <span class="o">*</span><span class="n">ip2</span><span class="p">;</span>  <span class="c1">// both ip1 and ip2 are pointers to int
</span><span class="c1"></span><span class="kt">double</span> <span class="n">dp</span><span class="p">,</span> <span class="o">*</span><span class="n">dp2</span><span class="p">;</span> <span class="c1">// dp2 is a pointer to double; dp is a double
</span></code></pre></div>

<p><strong>获取对象的地址</strong></p>

<p>指针保存了另一个对象的地址。我们使用取地址符获得一个对象的地址：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">ival</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ival</span><span class="p">;</span> <span class="c1">// p holds the address of ival; p is a pointer to ival
</span></code></pre></div>

<p>因为引用不是对象，它们没有地址。因此不能定义指向引用的指针。</p>

<p>除了2个例外，指针的类型和它指向的对象的类型必须匹配：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">double</span> <span class="n">dval</span><span class="p">;</span>
<span class="kt">double</span> <span class="o">*</span><span class="n">pd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dval</span><span class="p">;</span>  <span class="c1">// ok: initializer is the address of a double
</span><span class="c1"></span><span class="kt">double</span> <span class="o">*</span><span class="n">pd2</span> <span class="o">=</span> <span class="n">pd</span><span class="p">;</span>    <span class="c1">// ok: initializer is a pointer to double
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="n">pd</span><span class="p">;</span>  <span class="c1">// error: types of pi and pd differ
</span><span class="c1"></span><span class="n">pi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dval</span><span class="p">;</span>    <span class="c1">// error: assigning the address of a double to a pointer to int
</span></code></pre></div>

<p><strong>指针值</strong></p>

<p>存储在指针里面的值可以是以下4种状态种的一个：
1. 它可以指向一个对象。
2. 它可以指向紧跟一个对象后面的空间。
3. 它可以是空指针，指示它没有绑定到任何对象。
4. 它可以是非法的。除了上面3种值，其他值都是非法的。</p>

<p><strong>使用指针访问一个对象</strong></p>

<p>我们可以使用一个解引用操作符访问指针指向的对象：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">ival</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ival</span><span class="p">;</span> <span class="c1">// p holds the address of ival; p is a pointer to ival
</span><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>     <span class="c1">// * yields the object to which p points; prints 42
</span></code></pre></div>

<blockquote>
<p><strong>注解</strong>
我们只能解引用一个合法的指针。</p>
</blockquote>

<p><strong>空指针</strong></p>

<p>空指针不指向任何对象。在使用指针之前，代码可以检查指针是不是空指针。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="c1">// equivalent to int *p1 = 0;
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>       <span class="c1">// directly initializes p2 from the literal constant 0
</span><span class="c1">// must #include cstdlib
</span><span class="c1"></span><span class="kt">int</span> <span class="o">*</span><span class="n">p3</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>    <span class="c1">// equivalent to int *p3 = 0;
</span></code></pre></div>

<p>将一个整数变量赋值给指针是非法的，即使这个变量碰巧值为0。</p>

<blockquote>
<p><strong>建议：初始化所有指针</strong></p>
</blockquote>

<p><strong>赋值和指针</strong></p>

<p>当赋值给指针时，我们给指针本身一个新值。赋值使得指针指向一个不同的对象。</p>

<p><strong>其他指针操作</strong></p>

<p>常量表达式是一个值不能改变且能在编译期间计算出值的表达式。</p>

<p>constexpr变量
由constexpr声明的变量隐式为const并且必须由常量表达式初始化。</p>

<p>指针和constexpr</p>

<p>当我们在constexpr声明中定义一个指针时，constexpr指示符应用到指针，而不是指针指向的对象。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>     <span class="c1">// p is a pointer to a const int
</span><span class="c1"></span><span class="k">constexpr</span> <span class="kt">int</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="c1">// q is a const pointer to int
</span></code></pre></div>

<p>constexpr产生一个top-level const。</p>

<h1 id="2-5-处理类型">2.5 处理类型</h1>

<h2 id="2-5-1-类型别名">2.5.1 类型别名</h2>

<p>传统上我们使用typedef定义类型别名</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>     <span class="c1">// p is a pointer to a const int
</span><span class="c1"></span><span class="k">constexpr</span> <span class="kt">int</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="c1">// q is a const pointer to int
</span></code></pre></div>

<p>C++11引入另一种定义类型别名的方法。别名声明。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">using</span> <span class="n">SI</span> <span class="o">=</span> <span class="n">Sales_item</span><span class="p">;</span>  <span class="c1">// SI is a synonym for Sales_item
</span><span class="c1"></span>
<span class="k">typedef</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pstring</span><span class="p">;</span>
<span class="k">const</span> <span class="n">pstring</span> <span class="n">cstr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// cstr is a constant pointer to char
</span><span class="c1"></span><span class="k">const</span> <span class="n">pstring</span> <span class="o">*</span><span class="n">ps</span><span class="p">;</span>      <span class="c1">// ps is a pointer to a constant pointer to char
</span></code></pre></div>

<h2 id="2-5-2-auto类型限定符">2.5.2 auto类型限定符</h2>

<p>auto告诉编译器从初始值推导出类型。这暗示了使用auto的变量必须有一个初始值。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="n">item</span> <span class="o">=</span> <span class="n">val1</span> <span class="o">+</span> <span class="n">val2</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>      <span class="c1">// ok: i is int and p is a pointer to int
</span><span class="c1"></span><span class="k">auto</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>   <span class="c1">// error: inconsistent types for sz and pi
</span></code></pre></div>

<h3 id="复合类型-const和auto">复合类型，const和auto</h3>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>  <span class="c1">// a is an int (r is an alias for i, which has type int)
</span></code></pre></div>

<p>auto一般忽略top-level const。low-level const保留。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="kt">int</span> <span class="n">ci</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cr</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>  <span class="c1">// b is an int (top-level const in ci is dropped)
</span><span class="c1"></span><span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cr</span><span class="p">;</span>  <span class="c1">// c is an int (cr is an alias for ci whose const is top-level)
</span><span class="c1"></span><span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>  <span class="c1">// d is an int*(&amp; of an int object is int*)
</span><span class="c1"></span><span class="k">auto</span> <span class="n">e</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="p">;</span> <span class="c1">// e is const int*(&amp; of a const object is low-level const)
</span></code></pre></div>

<p>如果想要推导的类型有top-level const，必须显式指定</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span> <span class="c1">// deduced type of ci is int; f has type const int
</span></code></pre></div>

<p>我们也可以指定自动推导的类型为引用。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="o">&amp;</span><span class="n">g</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>       <span class="c1">// g is a const int&amp; that is bound to ci
</span><span class="c1"></span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">h</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>       <span class="c1">// error: we can&#39;t bind a plain reference to a literal
</span><span class="c1"></span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">j</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">// ok: we can bind a const reference to a literal
</span><span class="c1"></span>
<span class="k">auto</span> <span class="n">k</span> <span class="o">=</span> <span class="n">ci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>    <span class="c1">// k is int; l is int&amp;
</span><span class="c1"></span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">m</span> <span class="o">=</span> <span class="n">ci</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="p">;</span> <span class="c1">// m is a const int&amp;;p is a pointer to const int
</span><span class="c1">// error: type deduced from i is int; type deduced from &amp;ci is const int
</span><span class="c1"></span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">n</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ci</span><span class="p">;</span>
</code></pre></div>

<h2 id="2-5-3-decltype类型说明符">2.5.3 decltype类型说明符</h2>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">decltype</span><span class="p">(</span><span class="n">f</span><span class="p">())</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// sum has whatever type f returns
</span></code></pre></div>

<p>decltype处理top-level const和引用的方式和auto有着微妙的区别。当给变量应用
decltype时，decltype返回这个变量的类型，包括top-level const和引用。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="kt">int</span> <span class="n">ci</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cj</span> <span class="o">=</span> <span class="n">ci</span><span class="p">;</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">ci</span><span class="p">)</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// x has type const int
</span><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="n">cj</span><span class="p">)</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// y has type const int&amp; and is bound to x
</span><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="n">cj</span><span class="p">)</span> <span class="n">z</span><span class="p">;</span>     <span class="c1">// error: z is a reference and must be initialized
</span></code></pre></div>

<h3 id="decltype和引用">decltype和引用</h3>

<p>当我们应用decltype到非变量的表达式时，我们得到表达式产生的类型。decltype返回一个引用当表达式产生可以作为左值的对象时。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span> <span class="n">b</span><span class="p">;</span>  <span class="c1">// ok: addition yields an int; b is an (uninitialized) int
</span><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="n">c</span><span class="p">;</span>     <span class="c1">// error: c is int&amp; and must be initialized
</span><span class="c1"></span>
<span class="c1">// decltype of a parenthesized variable is always a reference
</span><span class="c1"></span><span class="k">decltype</span><span class="p">((</span><span class="n">i</span><span class="p">))</span> <span class="n">d</span><span class="p">;</span>    <span class="c1">// error: d is int&amp; and must be initialized
</span><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="n">e</span><span class="p">;</span>      <span class="c1">// ok: e is an (uninitialized) int
</span></code></pre></div>

<p>类内初始值 被限制于只能用在花括号里面或等号后面，不能使用圆括号。
头文件通常包含在任意文件里面只能定义一次的实体，比如类定义，const和constexpr变量。</p>
]]></content>
		</item>
		
		<item>
			<title>Boost.Asio网络编程 第2章</title>
			<link>https://gitop.cc/posts/asio-network-programming-2/</link>
			<pubDate>Thu, 17 Mar 2016 10:55:52 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/asio-network-programming-2/</guid>
			<description>Boost.Asio命名空间 Boost.Asio所有东西都放在boost::asio命名空间或者子命名空间： boost::asio：核心类和</description>
			<content type="html"><![CDATA[

<h2 id="boost-asio命名空间">Boost.Asio命名空间</h2>

<p>Boost.Asio所有东西都放在boost::asio命名空间或者子命名空间：</p>

<ul>
<li>boost::asio：核心类和函数放在这里。重要的类有io_service和streambuf。重要的自由函数，比如read，read_at，read_util，它们相应的异步版本，以及同步写和异步写函数。</li>
<li>boost::asio::ip：网络部分属于这里。重要的类有address，endpoint，tcp，udp，icmp。重要的自由函数connect和async_connect。注意boost::asio::ip::tcp::socket只是一个boost::asio::ip::tcp中的typedef。</li>
<li>boost::asio::error：包含调用I/O例程的错误码。</li>
<li>boost::asio::ssl：包含处理SSL的类。</li>
<li>boost::asio::local：包含POSIX相关的类。</li>
<li>boost::asio::windows：包含Windows相关的类。</li>
</ul>

<h2 id="ip地址">IP地址</h2>

<p>为了处理IP地址，Boost.Asio提供ip::address，ip::address_v4和ip::address_v6类。以下是一些最重要的函数：</p>

<ul>
<li>ip::address(v4_or_v6_address)：这个函数转换一个v4或v6地址为ip::address。</li>
<li>ip::address::from_string(str)：从一个IPv4或IPv6地址字符串创建地址。</li>
<li>ip::address::to_string()：返回一个友好可读的地址字符串。</li>
<li>ip::address_v4::broadcast([addr, mask])：创建一个广播地址。</li>
<li>ip::address_v4::any()：返回一个代表任何地址的地址。</li>
<li>ip::address_v4::loopback()，ip_address_v6::loopback()：返回回路地址</li>
<li>ip::host_name()：返回当前主机名。</li>
</ul>

<p>你可能最常用到ip::address::from_string：
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">ip</span><span class="o">::</span><span class="n">address</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">ip</span><span class="o">::</span><span class="n">from_string</span><span class="p">(</span><span class="s">&#34;127.0.0.1&#34;</span><span class="p">);</span>
</code></pre></div></p>

<h2 id="端点">端点</h2>

<p>端点是你要连接的地址和端口。不同类型有自己的endpoint类，比如ip::tcp::endpoint，ip::udp::endpoint和ip::icmp::endpoint。</p>

<p>如果你想连接本机80端口，这样：
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">ip</span><span class="o">::</span><span class="n">endpoint</span> <span class="n">ep</span><span class="p">(</span><span class="n">ip</span><span class="o">::</span><span class="n">from_string</span><span class="p">(</span><span class="s">&#34;127.0.0.1&#34;</span><span class="p">),</span> <span class="mi">80</span><span class="p">);</span>
</code></pre></div></p>

<p>创建端点有3种方法：</p>

<ul>
<li>endpoint()：默认构造函数，有时候可以用于UDP/ICMP套接字。</li>
<li>endpoint(protocol, port)：通常用于服务端套接字接受新连接。</li>
<li>endpoint(addr, port)：创建一个指定地址和端口的端点。</li>
</ul>

<p>下面是例子：
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">ip</span><span class="o">::</span><span class="n">endpoint</span> <span class="n">ep1</span><span class="p">;</span>
<span class="n">ip</span><span class="o">::</span><span class="n">endpoint</span> <span class="n">ep2</span><span class="p">(</span><span class="n">ip</span><span class="o">::</span><span class="n">v4</span><span class="p">(),</span> <span class="mi">80</span><span class="p">);</span>
<span class="n">ip</span><span class="o">::</span><span class="n">endpoint</span> <span class="n">ep3</span><span class="p">(</span><span class="n">ip</span><span class="o">::</span><span class="n">from_string</span><span class="p">(</span><span class="s">&#34;127.0.0.1&#34;</span><span class="p">),</span> <span class="mi">80</span><span class="p">);</span>
</code></pre></div></p>

<p>如果想要连接到一个主机名，可以这样做：
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// outputs &#34;87.248.122.122&#34;
</span><span class="c1"></span><span class="n">io_service</span> <span class="n">service</span><span class="p">;</span>
<span class="n">ip</span><span class="o">::</span><span class="n">resolver</span> <span class="n">resolver</span><span class="p">(</span><span class="n">service</span><span class="p">);</span>
<span class="n">ip</span><span class="o">::</span><span class="n">query</span> <span class="n">query</span><span class="p">(</span><span class="s">&#34;www.yahoo.com&#34;</span><span class="p">,</span> <span class="s">&#34;80&#34;</span><span class="p">);</span>
<span class="n">ip</span><span class="o">::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">resolver</span><span class="p">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">query</span><span class="p">);</span>
<span class="n">ip</span><span class="o">::</span><span class="n">endpoint</span> <span class="n">ep</span> <span class="o">=</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ep</span><span class="p">.</span><span class="n">address</span><span class="p">().</span><span class="n">to_string</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div></p>

<p>如果resolve()函数成功，它将返回至少一个入口。你可以使用第一个，也可以遍历所有的。</p>

<h2 id="套接字">套接字</h2>

<p>Boost.Asio有3中socket类：ip::tcp，ip::udp和ip::icmp，并且可以扩展。你可以创建自己的socket类。</p>

<p>你可以认为ip::tcp，ip::udp和ip::icmp类是占位符，它们提供其他类和函数的简便访问：</p>

<ul>
<li>ip::tcp::socket, ip::tcp::acceptor, ip::tcp::endpoint, ip::tcp::resolver, ip::tcp::iostream</li>
<li>ip::udp::socket, ip::udp::endpoint, ip::udp::resolver</li>
<li>ip::icmp::socket, ip::icmp::endpoint, ip::icmp::resolver</li>
</ul>

<p>socket类创建相应的套接字，创建时需要传递io_service实例：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">io_service</span> <span class="n">service</span><span class="p">;</span>
<span class="n">ip</span><span class="o">::</span><span class="n">socket</span> <span class="n">sock</span><span class="p">(</span><span class="n">service</span><span class="p">)</span>
<span class="n">sock</span><span class="p">.</span><span class="n">set_option</span><span class="p">(</span><span class="n">ip</span><span class="o">::</span><span class="n">reuse_address</span><span class="p">(</span><span class="nb">true</span><span class="p">));</span>
</code></pre></div>

<p>每一个socket名字是一个typedef：</p>

<ul>
<li>ip::tcp::socket = basic_stream_socket&lt;tcp&gt;</li>
<li>ip::udp::socket = basic_datagram_socket&lt;udp&gt;</li>
<li>ip::icmp::socket = basic_raw_socket&lt;icmp&gt;</li>
</ul>

<h3 id="同步错误码">同步错误码</h3>

<p>所有的同步函数重载了抛出异常或返回错误码的版本，像下面的例子：
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">sync_func</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span> <span class="p">...</span> <span class="n">argN</span><span class="p">);</span> <span class="c1">// throws
</span><span class="c1"></span><span class="n">boost</span><span class="o">::</span><span class="n">error_code</span> <span class="n">ec</span><span class="p">;</span>
<span class="n">sync_func</span><span class="p">(</span><span class="n">arg1</span> <span class="n">arg2</span><span class="p">,</span> <span class="p">...,</span> <span class="n">argN</span><span class="p">,</span> <span class="n">ec</span><span class="p">);</span> <span class="c1">// returns error code
</span></code></pre></div></p>

<h3 id="socket成员函数">Socket成员函数</h3>

<p>不是所有的函数对每一种类型的socket都可用。注意所有的异步函数立刻返回，同步函数只有在操作完成才会返回。</p>

<h4 id="连接相关的函数">连接相关的函数</h4>

<ul>
<li>assign(protocol, socket)：这个函数将一个原始套接字赋给一个socket实例。使用它处理遗留代码。</li>
<li>open(protocol)：这个函数使用指定IP协议（v4或v6）打开一个socket。这个函数主要用于UDP/ICMP套接字，或者服务器套接字。</li>
<li>bind(endpoint)：绑定到指定端点。</li>
<li>connect(endpoint)：同步连接到指定端点。</li>
<li>async_connect(endpoint)：异步连接到指定端点。</li>
<li>is_open()：如果socket已打开返回true。</li>
<li>close()：关闭套接字。此套接字任何异步操作立刻取消并以error::operation_aborted错误码结束。</li>
<li>shutdown(type_of_shutdown)：从现在开始禁止send，receive操作。</li>
<li>cancel()：取消此套接字所有异步操作。所有异步操作立刻以error::operation_aborted错误码结束。</li>
</ul>

<p>例子如下：
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">ip</span><span class="o">::</span><span class="n">endpoint</span> <span class="n">ep</span><span class="p">(</span><span class="n">ip</span><span class="o">::</span><span class="n">from_string</span><span class="p">(</span><span class="s">&#34;127.0.0.1&#34;</span><span class="p">),</span> <span class="mi">80</span><span class="p">);</span>
<span class="n">ip</span><span class="o">::</span><span class="n">socket</span> <span class="n">sock</span><span class="p">(</span><span class="n">service</span><span class="p">);</span>
<span class="n">sock</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">ip</span><span class="o">::</span><span class="n">v4</span><span class="p">());</span>
<span class="n">sock</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
<span class="n">sock</span><span class="p">.</span><span class="n">write_some</span><span class="p">(</span><span class="n">buffer</span><span class="p">(</span><span class="s">&#34;GET /index.html</span><span class="se">\r\n</span><span class="s">&#34;</span><span class="p">));</span>
<span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span> <span class="n">sock</span><span class="p">.</span><span class="n">read_some</span><span class="p">(</span><span class="n">buffer</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span><span class="mi">1024</span><span class="p">));</span>
<span class="n">sock</span><span class="p">.</span><span class="n">shutdown</span><span class="p">(</span><span class="n">ip</span><span class="o">::</span><span class="n">shutdown_receive</span><span class="p">);</span>
<span class="n">sock</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
</code></pre></div></p>

<h4 id="读写函数">读写函数</h4>

<p>对于所有异步读写函数，其处理函数的签名为：
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">handler</span><span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">error_code</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">bytes</span><span class="p">)</span>
</code></pre></div></p>

<ul>
<li>async_receive(buffer, [flags,] handler)：从套接字开始异步receive操作。</li>
<li>async_read_some(buffer, handler)：等价于async_receive(buffer, handler)。</li>
<li>async_receive_from(buffer, endpoint[, flags], handler)：从指定端点开始异步receive操作。</li>
<li>async_send(buffer[, flags], handler)：开始异步发送buffer中的数据。</li>
<li>async_write_some(buffer, handler)：等价于async_send(buffer, handler)。</li>
<li>async_send_to(buffer, endpoint, handler)：开始异步发送buffer中的数据到指定端点。</li>
<li>receive(buffer[, flags])：同步读取数据到指定buffer。这个函数阻塞知道收到数据或一个错误发生。</li>
<li>read_some(buffer)：等价于receive(buffer)。</li>
<li>receive_from(buffer, endpoint[, flags])：同步地从指定端点读取数据到指定buffer。这个函数阻塞直到受到数据或错误发生。</li>
<li>send(buffer[,  flags])：同步发送buffer中的数据。函数阻塞直到受到数据或发生错误。</li>
<li>write_some(buffer)：等价于send(buffer)。</li>
<li>send_to(buffer, endpoint[, flags])：同步发送buffer中的数据到指定端点。函数阻塞直到受到数据或发生错误。</li>
<li>avaliable()：返回可以同步读取的字节数，不用阻塞。</li>
</ul>

<p>flags的默认值是0，但可以是下列的组合：</p>

<ul>
<li>ip::socket_type::socket::message_peek：这个标志只是偷看消息。它返回这个消息，但是下一次调用会重读这个消息。</li>
<li>ip::socket_type::socket::message_out_of_band：这个标志处理out-of-band（OOB）数据。OOB数据是标记为比普通数据更重要的数据。</li>
<li>ip::socket_type::socket::message_do_not_route：这个标志指定消息应该不使用路由表发送。</li>
<li>ip::socket_type::socket::message_end_of_record：这个标志指示数据标志一个记录的结尾。在Windows下不支持。</li>
</ul>

<p>如果你使用下面这段代码，你最可能使用message_peek：
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
<span class="n">sock</span><span class="p">.</span><span class="n">receive</span><span class="p">(</span><span class="n">buffer</span><span class="p">(</span><span class="n">buff</span><span class="p">),</span> <span class="n">ip</span><span class="o">::</span><span class="n">message_peek</span><span class="p">);</span>
<span class="n">memset</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">// re-reads what was previously read
</span><span class="c1"></span><span class="n">sock</span><span class="p">.</span><span class="n">receive</span><span class="p">(</span><span class="n">buffer</span><span class="p">(</span><span class="n">buff</span><span class="p">));</span>
</code></pre></div></p>

<p>同步读写一个TCP套接字：
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">ip</span><span class="o">::</span><span class="n">endpoint</span> <span class="n">ep</span><span class="p">(</span> <span class="n">ip</span><span class="o">::</span><span class="n">from_string</span><span class="p">(</span><span class="s">&#34;127.0.0.1&#34;</span><span class="p">),</span> <span class="mi">80</span><span class="p">);</span>
<span class="n">ip</span><span class="o">::</span><span class="n">socket</span> <span class="n">sock</span><span class="p">(</span><span class="n">service</span><span class="p">);</span>
<span class="n">sock</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
<span class="n">sock</span><span class="p">.</span><span class="n">write_some</span><span class="p">(</span><span class="n">buffer</span><span class="p">(</span><span class="s">&#34;GET /index.html</span><span class="se">\r\n</span><span class="s">&#34;</span><span class="p">));</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;bytes available &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">sock</span><span class="p">.</span><span class="n">available</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="n">size_t</span> <span class="n">read</span> <span class="o">=</span> <span class="n">sock</span><span class="p">.</span><span class="n">read_some</span><span class="p">(</span><span class="n">buffer</span><span class="p">(</span><span class="n">buff</span><span class="p">));</span>
</code></pre></div></p>

<p>同步读写一个UDP套接字：
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">ip</span><span class="o">::</span><span class="n">socket</span> <span class="n">sock</span><span class="p">(</span><span class="n">service</span><span class="p">);</span>
<span class="n">sock</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">ip</span><span class="o">::</span><span class="n">v4</span><span class="p">());</span>
<span class="n">ip</span><span class="o">::</span><span class="n">endpoint</span> <span class="n">receiver_ep</span><span class="p">(</span><span class="s">&#34;87.248.112.181&#34;</span><span class="p">,</span> <span class="mi">80</span><span class="p">);</span>
<span class="n">sock</span><span class="p">.</span><span class="n">send_to</span><span class="p">(</span><span class="n">buffer</span><span class="p">(</span><span class="s">&#34;testing</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">),</span> <span class="n">receiver_ep</span><span class="p">);</span>
<span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="n">ip</span><span class="o">::</span><span class="n">endpoint</span> <span class="n">sender_ep</span><span class="p">;</span>
<span class="n">sock</span><span class="p">.</span><span class="n">receive_from</span><span class="p">(</span><span class="n">buffer</span><span class="p">(</span><span class="n">buff</span><span class="p">),</span> <span class="n">sender_ep</span><span class="p">);</span>
</code></pre></div></p>

<p>注意为了使用receive_from从一个UDP套接字读取数据，你需要一个默认构造的端点。</p>

<p>异步读取一个UDP服务器套接字：
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="p">;</span>
<span class="n">io_service</span> <span class="n">service</span><span class="p">;</span>
<span class="n">ip</span><span class="o">::</span><span class="n">socket</span> <span class="n">sock</span><span class="p">(</span><span class="n">service</span><span class="p">);</span>
<span class="n">boost</span><span class="o">::</span><span class="n">endpoint</span> <span class="n">sender_ep</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="kt">void</span> <span class="nf">on_read</span><span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">error_code</span> <span class="o">&amp;</span> <span class="n">err</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">read_bytes</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;read &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">read_bytes</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">sock</span><span class="p">.</span><span class="n">async_receive_from</span><span class="p">(</span><span class="n">buffer</span><span class="p">(</span><span class="n">buff</span><span class="p">),</span> <span class="n">sender_ep</span><span class="p">,</span> <span class="n">on_read</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">ip</span><span class="o">::</span><span class="n">endpoint</span> <span class="n">ep</span><span class="p">(</span><span class="n">ip</span><span class="o">::</span><span class="n">from_string</span><span class="p">(</span><span class="s">&#34;127.0.0.1&#34;</span><span class="p">),</span> <span class="mi">8001</span><span class="p">);</span>
    <span class="n">sock</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">ep</span><span class="p">.</span><span class="n">protocol</span><span class="p">());</span>
    <span class="n">sock</span><span class="p">.</span><span class="n">set_option</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">reuse_address</span><span class="p">(</span><span class="nb">true</span><span class="p">));</span>
    <span class="n">sock</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
    <span class="n">sock</span><span class="p">.</span><span class="n">async_receive_from</span><span class="p">(</span><span class="n">buffer</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span><span class="mi">512</span><span class="p">),</span> <span class="n">sender_ep</span><span class="p">,</span> <span class="n">on_read</span><span class="p">);</span>
    <span class="n">service</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></p>

<h4 id="套接字控制">套接字控制</h4>

<p>这些函数处理高级套接字选项：</p>

<ul>
<li>get_io_service()：返回构造时传递的io_service实例。</li>
<li>get_option(option)：返回一个套接字选项。</li>
<li>set_option(option)：设置套接字选项</li>
<li>io_control(cmd)：在套接字上执行一个I/O命令。</li>
</ul>

<p>以下是你可以读取或设置的套接字选项：</p>

<table>
<thead>
<tr>
<th>名字</th>
<th>描述</th>
<th>类型</th>
</tr>
</thead>

<tbody>
<tr>
<td>broadcast</td>
<td>如果真，允许广播消息</td>
<td>bool</td>
</tr>

<tr>
<td>debug</td>
<td>如果真，使socket-level调试生效</td>
<td>bool</td>
</tr>

<tr>
<td>enable_connection_aborted</td>
<td>如果真，报告在accept()时连接被中止</td>
<td>bool</td>
</tr>

<tr>
<td>receive_buffer_size</td>
<td>套接字的接收缓冲区大小</td>
<td>int</td>
</tr>

<tr>
<td>receive_low_watermark</td>
<td>提供处理套接字输入的最小字节数</td>
<td>int</td>
</tr>

<tr>
<td>reuse_address</td>
<td>如果真，套接字可以绑定一个已经在使用的地址</td>
<td>bool</td>
</tr>

<tr>
<td>send_buffer_size</td>
<td>套接字发送缓冲区大小</td>
<td>int</td>
</tr>

<tr>
<td>send_low_watermark</td>
<td>提供处理套接字输出的最小字节数</td>
<td>int</td>
</tr>

<tr>
<td>ip::v6_only</td>
<td>如果真，只允许IPv6通信</td>
<td>bool</td>
</tr>
</tbody>
</table>

<p>每一个名字代表内部socket的一个typedef或一个类。以下是例子：
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">ip</span><span class="o">::</span><span class="n">endpoint</span> <span class="n">ep</span><span class="p">(</span><span class="n">ip</span><span class="o">::</span><span class="n">from_string</span><span class="p">(</span><span class="s">&#34;127.0.0.1&#34;</span><span class="p">),</span> <span class="mi">80</span><span class="p">);</span>
<span class="n">ip</span><span class="o">::</span><span class="n">socket</span> <span class="n">sock</span><span class="p">(</span><span class="n">service</span><span class="p">);</span>
<span class="n">sock</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
<span class="c1">// TCP socket can reuse address
</span><span class="c1"></span><span class="n">ip</span><span class="o">::</span><span class="n">reuse_address</span> <span class="n">ra</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="n">sock</span><span class="p">.</span><span class="n">set_option</span><span class="p">(</span><span class="n">ra</span><span class="p">);</span>
<span class="c1">// get sock receive buffer size
</span><span class="c1"></span><span class="n">ip</span><span class="o">::</span><span class="n">receive_buffer_size</span> <span class="n">rbs</span><span class="p">;</span>
<span class="n">sock</span><span class="p">.</span><span class="n">get_option</span><span class="p">(</span><span class="n">rbs</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">rbs</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="c1">// set sock&#39;s buffer size to 8192
</span><span class="c1"></span><span class="n">ip</span><span class="o">::</span><span class="n">send_buffer_size</span> <span class="n">sbs</span><span class="p">(</span><span class="mi">8192</span><span class="p">);</span>
<span class="n">sock</span><span class="p">.</span><span class="n">set_option</span><span class="p">(</span><span class="n">sbs</span><span class="p">);</span>
</code></pre></div></p>

<p>v#### TCP vs UDP vs ICMP ####</p>

<p>如果一个成员函数不在下表，说明它对所有socket类可用：</p>

<table>
<thead>
<tr>
<th>名字</th>
<th>TCP</th>
<th>UDP</th>
<th>ICMP</th>
</tr>
</thead>

<tbody>
<tr>
<td>async_read_some</td>
<td>Yes</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<td>async_receive_from</td>
<td>-</td>
<td>Yes</td>
<td>Yes</td>
</tr>

<tr>
<td>async_write_some</td>
<td>Yes</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<td>async_send_to</td>
<td>-</td>
<td>Yes</td>
<td>Yes</td>
</tr>

<tr>
<td>read_some</td>
<td>Yes</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<td>receive_from</td>
<td>-</td>
<td>Yes</td>
<td>Yes</td>
</tr>

<tr>
<td>write_some</td>
<td>Yes</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<td>send_to</td>
<td>-</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody>
</table>

<h4 id="其它函数">其它函数</h4>

<ul>
<li>local_endpoint()：返回本地地址。</li>
<li>remote_endpoint()：返回远程地址。</li>
<li>native_handle()：返回原始套接字的句柄。你只有在想要调用原始套接字API的时候需要这个函数。</li>
<li>non_blocking()：如果套接字非阻塞返回true，否则false。</li>
<li>native_non_blocking()：和non_blocking一样，但是它在原始套接字上调用原始的套接字API。</li>
<li>at_mark()：如果套接字即将读取OOB数据，返回true。很少使用。</li>
</ul>

<h3 id="其它考虑">其它考虑</h3>

<p>最后需要注意的是，一个套接字实例不能被复制，因为复制构造函数和赋值操作符无法访问。如果你想要创建拷贝，使用共享指针：
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ip</span><span class="o">::</span><span class="n">socket</span><span class="o">&gt;</span> <span class="n">socket_ptr</span><span class="p">;</span>
<span class="n">socket_ptr</span> <span class="nf">sock1</span><span class="p">(</span><span class="k">new</span> <span class="n">ip</span><span class="o">::</span><span class="n">socket</span><span class="p">(</span><span class="n">service</span><span class="p">));</span>
<span class="n">socket_ptr</span> <span class="nf">sock2</span><span class="p">(</span><span class="n">sock1</span><span class="p">);</span> <span class="c1">// ok
</span><span class="c1"></span><span class="n">socket_ptr</span> <span class="n">sock3</span><span class="p">;</span>
<span class="n">sock3</span> <span class="o">=</span> <span class="n">sock1</span><span class="p">;</span> <span class="c1">// ok
</span></code></pre></div></p>

<h4 id="socket缓冲区">Socket缓冲区</h4>

<p>当读取或写入一个套接字，需要一个缓冲区，它将保存进来和流出的数据。缓冲区的内存必须比I/O操作更长久。你必须保证I/O操作持续期间它不被释放或超出范围。</p>

<p>这个问题有下面几种解决方法：</p>

<ul>
<li>使用全局缓冲区。</li>
<li>创建一个缓冲区，当操作完成时销毁它。</li>
<li>使用一个连接对象维护套接字和额外的数据，比如缓冲区。</li>
</ul>

<h4 id="缓存包装器函数">缓存包装器函数</h4>

<p>任何时候我们需要一个缓冲区用于读写操作时，用buffer()函数包装真实的缓冲区对象。它包装任何缓冲区为一个类，允许Boost.Asio函数迭代访问缓冲区。比如你使用下面的代码：
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">sock</span><span class="p">.</span><span class="n">async_receive</span><span class="p">(</span><span class="n">some_buffer</span><span class="p">,</span> <span class="n">on_read</span><span class="p">);</span>
</code></pre></div></p>

<p>some_buffer实例需要满足一些条件，即ConstBufferSequence或MutableBufferSequence。使用buffer()函数就可以满足这些条件。</p>

<p>简单地说，你可以用buffer()函数包装下面的对象：</p>

<ul>
<li>char[] const数组</li>
<li>void*指针和大小</li>
<li>std::string</li>
<li>POD[] const数组（POD代表plain old data，即构造函数和析构函数不用做任何事）</li>
<li>std::vector&lt;POD&gt;</li>
<li>boost::array&lt;POD&gt;</li>
<li>std::array&lt;POD&gt;</li>
</ul>

<h2 id="读-写-连接自由函数">读/写/连接自由函数</h2>

<p>Boost.Asio提供自由函数处理I/O。</p>

<h3 id="连接函数">连接函数</h3>

<p>连接socket到一个端点：</p>

<ul>
<li>connect(socket, begin[, end][, condition])：同步连接，尝试begin和end之间每一个端点。begin迭代器是socket_type::resolver::query调用返回的结果。你可以提供一个条件函数在每次连接尝试前调用。它的签名是Iterator connect_condition(const boost::system::error_code &amp;ec, Iterator next)。</li>
<li>async_connect(socket, begin[, end][, condition], handler)：执行异步连接，最后调用完成处理函数。处理函数的签名是void handler(const boost::system::error_code &amp;ec, Iterator iterator)。</li>
</ul>

<p>示例如下：
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">ip</span><span class="p">;</span>
<span class="n">tcp</span><span class="o">::</span><span class="n">resolver</span> <span class="n">resolver</span><span class="p">(</span><span class="n">service</span><span class="p">);</span>
<span class="n">tcp</span><span class="o">::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">resolver</span><span class="p">.</span><span class="n">resolve</span><span class="p">(</span>
	<span class="n">tcp</span><span class="o">::</span><span class="n">query</span><span class="p">(</span><span class="s">&#34;www.yahoo.com&#34;</span><span class="p">,</span>
	<span class="s">&#34;80&#34;</span><span class="p">));</span>
<span class="n">tcp</span><span class="o">::</span><span class="n">socket</span> <span class="n">sock</span><span class="p">(</span><span class="n">service</span><span class="p">);</span>
<span class="n">connect</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span>
</code></pre></div></p>

<p>一个主机名可以解析为多个地址，因此connect和async_connect将你从尝试每一个地址的负担中释放出来。</p>

<h3 id="读-写函数">读/写函数</h3>

<ul>
<li>async_read(stream, buffer[, completion], handler)：从stream异步读取数据。完成后调用处理函数，其签名为void handler(const boost::system::error_code &amp;ec, size_t bytes)。你可以指定一个完成函数。每一次成功读后都调用一次完成函数，并告诉Boost.Asio异步读操作是否完成，如果没有继续读。完成函数的签名为size_t completion(const boost::system::error_code &amp;ec, size_t bytes_transfered)。当完成函数返回0时，我们认为读操作完成。如果返回非0值，它指示下一次async_read_some操作读取的最大字节数。</li>
<li>async_write(stream, buffer[, completion], handler)：异步写数据到stream。参数的意义和async_read类似。</li>
<li>read(stream, buffer[, completion])：从stream同步读取数据。参数的意义和async_read类似。</li>
<li>write(stream, buffer[, completion])：同步写数据到stream。参数的意义和async_read类似。</li>
</ul>

<p>每一个读或写操作在下面这些条件发生时结束：</p>

<ul>
<li>提供的缓冲区已满（对于读）或在缓冲区的数据都被写完（对于写）</li>
<li>完成函数返回0，如果你提供了这样一个函数</li>
<li>一个错误发生</li>
</ul>

<p>下面的代码会异步读知道发现&rsquo;\n&rsquo;：
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">io_service</span> <span class="n">service</span><span class="p">;</span>
<span class="n">ip</span><span class="o">::</span><span class="n">socket</span> <span class="n">sock</span><span class="p">(</span><span class="n">service</span><span class="p">);</span>
<span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">size_t</span> <span class="nf">up_to_enter</span><span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">error_code</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">bytes</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bytes</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">offset</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">on_read</span><span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">error_code</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">size_t</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">...</span>
<span class="n">async_read</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">buffer</span><span class="p">(</span><span class="n">buff</span><span class="p">),</span> <span class="n">up_to_enter</span><span class="p">,</span> <span class="n">on_read</span><span class="p">);</span>
</code></pre></div></p>

<p>Boost.Asio提供一些助手完成函数：</p>

<ul>
<li>transfer_at_least(n)</li>
<li>transfer_exactly(n)</li>
<li>transfer_all()</li>
</ul>

<p>例子如下：
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">char</span> <span class="n">buff</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="kt">void</span> <span class="nf">on_read</span><span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">error_code</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">size_t</span><span class="p">)</span> <span class="p">{}</span>
<span class="c1">// read exactly 32 bytes
</span><span class="c1"></span><span class="n">async_read</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">buffer</span><span class="p">(</span><span class="n">buff</span><span class="p">),</span> <span class="n">transfer_exactly</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="n">on_read</span><span class="p">);</span>
</code></pre></div></p>

<p>最后4个函数，使用继承std::streambuf的stream_buffer函数而不是通常的buffer。STL stream和stream_buffer非常灵活。
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">io_service</span> <span class="n">service</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">on_read</span><span class="p">(</span><span class="n">streambuf</span><span class="o">&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">error_code</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">size_t</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">istream</span> <span class="n">in</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">line</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;first line: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">line</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">file</span> <span class="o">=</span> <span class="o">::</span><span class="n">CreateFile</span><span class="p">(</span><span class="s">&#34;readme.txt&#34;</span><span class="p">,</span> <span class="n">GENERIC_READ</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">OPEN_ALWAYS</span><span class="p">,</span> <span class="n">FILE_ATTRIBUTE_NORMAL</span> <span class="o">|</span> <span class="n">FILE_FLAG_OVERLAPPED</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">windows</span><span class="o">::</span><span class="n">stream_handle</span> <span class="n">h</span><span class="p">(</span><span class="n">service</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
    <span class="n">streambuf</span> <span class="n">buf</span><span class="p">;</span>
    <span class="n">async_read</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">transfer_exactly</span><span class="p">(</span><span class="mi">256</span><span class="p">),</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">on_read</span><span class="p">,</span><span class="n">boost</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span><span class="n">_1</span><span class="p">,</span><span class="n">_2</span><span class="p">));</span>
    <span class="n">service</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></p>

<h4 id="read-until-async-read-util函数">read_until/async_read_util函数</h4>

<p>这些函数一直读直到一个条件满足：</p>

<ul>
<li>async_read_until(stream, stream_buffer, delim, handler)：开始一个异步读操作。当遇到一个delim时，读操作停止。delim可以是任意一个字符，std::string或boost::regex。处理函数的签名为void handler(const boost::system::error_code &amp;ec, size_t bytes)。</li>
<li>async_read_until(stream, stream_buffer, completion, handler)：这个函数和前一个一样，只是将delim替换为完成函数，其签名是pair&lt;iterator, bool&gt; completion(iterator begin, iterator end)。迭代器参数是buffers_iterator&lt;streambuf::const_buffers_type&gt;。你需要记住的是迭代器类型是随机访问迭代器。返回true说明读操作应该停止。</li>
<li>read_until(stream, stream_buffer, delim)：同步读，参数意义与async_read_until一样。</li>
<li>read_until(stream, stream_buffer, completion)：同步读，参数意义与async_read_until一样。</li>
</ul>

<p>下面的代码将读到一个标点符号为止：
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="n">buffers_iterator</span><span class="o">&lt;</span><span class="n">streambuf</span><span class="o">::</span><span class="n">const_buffers_type</span><span class="o">&gt;</span> <span class="n">iterator</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">match_punct</span><span class="p">(</span><span class="n">iterator</span> <span class="n">begin</span><span class="p">,</span> <span class="n">iterator</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">begin</span> <span class="o">!=</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ispunct</span><span class="p">(</span><span class="o">*</span><span class="n">begin</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">end</span><span class="p">,</span><span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">on_read</span><span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">error_code</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">size_t</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">...</span>
<span class="n">streambuf</span> <span class="n">buf</span><span class="p">;</span>
<span class="n">async_read_until</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">match_punct</span><span class="p">,</span> <span class="n">on_read</span><span class="p">);</span>
</code></pre></div></p>

<p>如果想读到一个空格，修改最后一行：
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">async_read_until</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="n">on_read</span><span class="p">);</span>
</code></pre></div></p>

<h4 id="at函数">*_at函数</h4>

<p>这些函数在一个stream上做随机读写操作。你指定读写操作从哪开始（offset）：</p>

<ul>
<li>async_read_at(stream, offset, buffer[, completion], handler)：在指定流上从offset开始异步读操作。处理函数的签名是void handler(const boost::system::error_code &amp;ec, size_t bytes)。缓冲区可以是通常的buffer()包装器或一个streambuf函数。如果指定了一个完成函数，它在每次成功读操作后被调用，并告诉Boost.Asio操作async_read_at是否完成，其签名为size_t completion(const boost::system::error_code &amp;ec, size_t bytes)。当完成函数返回0时，我们认为读操作完成；如果返回非0值，它指示下一次async_read_some_at调用要读取的最大字节数。</li>
<li>async_write_at(stream, offset, buffer[, completion], handler)：开始一个异步写操作。参数的意思和async_read_at一样。</li>
<li>read_at(stream, offset, buffer[, completion])：同步读，参数的意思和async_read_at一样。</li>
<li>write_at(stream, offset, buffer[, completion])：同步读，参数的意思和async_read_at一样。</li>
</ul>

<p>这些函数不处理socket，它们处理随机访问流。
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">io_service</span> <span class="n">service</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">file</span> <span class="o">=</span> <span class="o">::</span><span class="n">CreateFile</span><span class="p">(</span><span class="s">&#34;readme.txt&#34;</span><span class="p">,</span> <span class="n">GENERIC_READ</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">OPEN_ALWAYS</span><span class="p">,</span> <span class="n">FILE_ATTRIBUTE_NORMAL</span> <span class="o">|</span> <span class="n">FILE_FLAG_OVERLAPPED</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">);</span>
    <span class="n">windows</span><span class="o">::</span><span class="n">random_access_handle</span> <span class="n">h</span><span class="p">(</span><span class="n">service</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
    <span class="n">streambuf</span> <span class="n">buf</span><span class="p">;</span>
    <span class="n">read_at</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">transfer_exactly</span><span class="p">(</span><span class="mi">128</span><span class="p">));</span>
    <span class="n">std</span><span class="o">::</span><span class="n">istream</span> <span class="n">in</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">line</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;first line: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">line</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>

<h1 id="异步编程">异步编程</h1>

<p>这部分将深入钻研进行异步编程会碰到的一些问题。</p>

<h2 id="异步的需求">异步的需求</h2>

<p>尽管异步编程更难，你可能还是会选择它。比如说编写需要处理非常多并行客户端的服务器。并行客户端越多，异步编程比同步编程越容易。</p>

<h2 id="异步run-run-one-poll-poll-one">异步run()，run_one()，poll()，poll_one()</h2>

<p>为了实现监听循环，io_service类提供4个函数，run()，run_one()，poll()和poll_one()。</p>

<h3 id="永久运行">永久运行</h3>

<p>run()会一直运行，只要有追加的操作执行或者你手动调用io_service::stop()。为了保持io_service实例运行，通常添加一个或多个异步操作，并当它们执行时，保持继续添加异步操作：
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="p">;</span>
<span class="n">io_service</span> <span class="n">service</span><span class="p">;</span>
<span class="n">ip</span><span class="o">::</span><span class="n">socket</span> <span class="n">sock</span><span class="p">(</span><span class="n">service</span><span class="p">);</span>
<span class="kt">char</span> <span class="n">buff_read</span><span class="p">[</span><span class="mi">1024</span><span class="p">],</span> <span class="n">buff_write</span><span class="p">[</span><span class="mi">1024</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;ok&#34;</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">on_read</span><span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">error_code</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">;</span>
<span class="kt">void</span> <span class="nf">on_write</span><span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">error_code</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">sock</span><span class="p">.</span><span class="n">async_read_some</span><span class="p">(</span><span class="n">buffer</span><span class="p">(</span><span class="n">buff_read</span><span class="p">),</span> <span class="n">on_read</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">on_read</span><span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">error_code</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ... process the read ...
</span><span class="c1"></span>    <span class="n">sock</span><span class="p">.</span><span class="n">async_write_some</span><span class="p">(</span><span class="n">buffer</span><span class="p">(</span><span class="n">buff_write</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">on_write</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">on_connect</span><span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">error_code</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sock</span><span class="p">.</span><span class="n">async_read_some</span><span class="p">(</span><span class="n">buffer</span><span class="p">(</span><span class="n">buff_read</span><span class="p">),</span> <span class="n">on_read</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">ip</span><span class="o">::</span><span class="n">endpoint</span> <span class="n">ep</span><span class="p">(</span><span class="n">ip</span><span class="o">::</span><span class="n">from_string</span><span class="p">(</span><span class="s">&#34;127.0.0.1&#34;</span><span class="p">),</span> <span class="mi">2001</span><span class="p">);</span>
    <span class="n">sock</span><span class="p">.</span><span class="n">async_connect</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">on_connect</span><span class="p">);</span>
    <span class="n">service</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></p>

<h3 id="run-one-poll-poll-one-函数">run_one()，poll()，poll_one()函数</h3>

<p>run_one()函数会执行和分配最多一个异步操作：</p>

<ul>
<li>如果没有追加操作，函数立刻返回0</li>
<li>如果有追加操作，函数阻塞知道第一个操作执行，并返回1</li>
</ul>

<p>考虑下述等价代码：
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">io_service</span> <span class="n">service</span><span class="p">;</span>
<span class="n">service</span><span class="p">.</span><span class="n">run</span><span class="p">();</span> <span class="c1">// OR
</span><span class="c1"></span><span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">service</span><span class="p">.</span><span class="n">stopped</span><span class="p">())</span> <span class="n">service</span><span class="p">.</span><span class="n">run_once</span><span class="p">();</span>
</code></pre></div></p>

<p>你可以使用run_once()开始一个异步操作，然后等待它完成：
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">io_service</span> <span class="n">service</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">write_complete</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">on_write</span><span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">error_code</span> <span class="o">&amp;</span> <span class="n">err</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span> <span class="n">write_complete</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
<span class="p">...</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">data</span> <span class="o">=</span> <span class="s">&#34;login ok&#34;</span><span class="p">;</span>
<span class="n">write_complete</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="n">async_write</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">buffer</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">on_write</span><span class="p">);</span>
<span class="k">do</span> <span class="n">service</span><span class="p">.</span><span class="n">run_once</span><span class="p">()</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">write_complete</span><span class="p">);</span>
</code></pre></div></p>

<p>poll_one函数运行最多一次准备运行的追加操作，非阻塞：</p>

<ul>
<li>如果有至少一个准备运行的非阻塞追加操作，poll_one运行它并返回1</li>
<li>否则，立刻返回0</li>
</ul>

<p>准备运行的非阻塞追加操作，通常意味着任何：</p>

<ul>
<li>一个定时器超时了，且它的async_wait回调函数需要被调用。</li>
<li>一个I/O操作完成了（比如async_read），且其回调函数需要被调用。</li>
<li>一个之前添加到io_services队列的自定义的回调函数。</li>
</ul>

<p>poll()函数运行所有添加的操作，不用阻塞。下面代码等价：
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">io_service</span> <span class="n">service</span><span class="p">;</span>
<span class="n">service</span><span class="p">.</span><span class="n">poll</span><span class="p">();</span> <span class="c1">// OR
</span><span class="c1"></span><span class="k">while</span> <span class="p">(</span><span class="n">service</span><span class="p">.</span><span class="n">poll_one</span><span class="p">());</span>
</code></pre></div></p>

<p>所有之前的函数失败时抛出boost::system::system_error异常。这不应该发生，这里抛出的错误通常是致命的。每一个函数也有不抛异常而返回错误码的重载版本。
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">io_service</span> <span class="n">service</span><span class="p">;</span>
<span class="n">boost</span><span class="o">::</span><span class="n">error_code</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">service</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Error &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">err</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div></p>

<h2 id="异步工作">异步工作</h2>

<p>异步工作不仅仅是异步接受客户端连接，异步读取或写到套接字。它包含任何可以异步执行的操作。</p>

<p>默认情况下，你不知道异步处理函数的调用顺序。你可以使用service.post()抛出自定义的函数使其可以异步调用：
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="p">;</span>
<span class="n">io_service</span> <span class="n">service</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;func called, i= &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">worker_thread</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">service</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">service</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">thread_group</span> <span class="n">threads</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">threads</span><span class="p">.</span><span class="n">create_thread</span><span class="p">(</span><span class="n">worker_thread</span><span class="p">);</span>
    <span class="c1">// wait for all threads to be created
</span><span class="c1"></span>    <span class="n">boost</span><span class="o">::</span><span class="n">sleep</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">millisec</span><span class="p">(</span><span class="mi">500</span><span class="p">));</span>
    <span class="n">threads</span><span class="p">.</span><span class="n">join_all</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></p>

<p>有的时候你想要某些异步处理函数按顺序调用。你可以使用io_service::strand，它将顺序调用你的异步处理函数。
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;func called, i= &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;/&#34;</span>
    <span class="o">&lt;&lt;</span> <span class="n">boost</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">worker_thread</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">service</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">io_service</span><span class="o">::</span><span class="n">strand</span> <span class="n">strand_one</span><span class="p">(</span><span class="n">service</span><span class="p">),</span> <span class="n">strand_two</span><span class="p">(</span><span class="n">service</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">service</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="n">strand_one</span><span class="p">.</span><span class="n">wrap</span><span class="p">(</span> <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">i</span><span class="p">)));</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">service</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="n">strand_two</span><span class="p">.</span><span class="n">wrap</span><span class="p">(</span> <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">i</span><span class="p">)));</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">thread_group</span> <span class="n">threads</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">threads</span><span class="p">.</span><span class="n">create_thread</span><span class="p">(</span><span class="n">worker_thread</span><span class="p">);</span>
    <span class="c1">// wait for all threads to be created
</span><span class="c1"></span>    <span class="n">boost</span><span class="o">::</span><span class="n">sleep</span><span class="p">(</span> <span class="n">boost</span><span class="o">::</span><span class="n">millisec</span><span class="p">(</span><span class="mi">500</span><span class="p">));</span>
    <span class="n">threads</span><span class="p">.</span><span class="n">join_all</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></p>

<h2 id="异步post-vs-dispatch-vs-wrap">异步post() vs dispatch() vs wrap()</h2>

<p>Boost.Asio提供3种方法添加你的函数异步调用：</p>

<ul>
<li>service.post(handler)：这个函数保证在请求io_service添加处理函数后立刻返回。处理函数会在之后被某个调用了service.run()的线程调用。</li>
<li>service.dispatch(handler)：请求io_service调用指定的处理函数，同时如果当前线程调用了service.run()，它可以在函数内执行处理函数。</li>
<li>service.wrap(handler)：这个函数创建一个包装函数。当包装函数被调用时，会调用service.dispatch(handler)。</li>
</ul>

<p>看看dispatch如何影响输出：
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;func called, i= &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">run_dispatch_and_post</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">service</span><span class="p">.</span><span class="n">dispatch</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
        <span class="n">service</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">service</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="n">run_dispatch_and_post</span><span class="p">);</span>
    <span class="n">service</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></p>

<p>wrap()函数返回一个函数对象，以供将来使用：
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">dispatched_func_1</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;dispatched 1&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">dispatched_func_2</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;dispatched 2&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">test</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">func</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;test&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">service</span><span class="p">.</span><span class="n">dispatch</span><span class="p">(</span><span class="n">dispatched_func_1</span><span class="p">);</span>
    <span class="n">func</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">service_run</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">service</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">test</span><span class="p">(</span><span class="n">service</span><span class="p">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">dispatched_func_2</span><span class="p">));</span>
    <span class="n">boost</span><span class="o">::</span><span class="kr">thread</span> <span class="n">th</span><span class="p">(</span><span class="n">service_run</span><span class="p">);</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">sleep</span><span class="p">(</span> <span class="n">boost</span><span class="o">::</span><span class="n">millisec</span><span class="p">(</span><span class="mi">500</span><span class="p">));</span>
    <span class="n">th</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></p>

<p>io_service::strand类也包含成员函数poll()，dispatch()和wrap()。其意义和io_service的一样。然而大多数时间你只会使用io_service::strand::wrap()作为io_service::poll()或io_service::dispatch()的参数。</p>

<h1 id="保持活着">保持活着</h1>

<p>当使用套接字缓冲区时，你可以用一个buffer实例度过一个异步调用。我们可以使用同样的原理创建一个类，内部保存套接字和读/写缓冲区。然后对于所有异步调用，传递一个共享指针给boost::bind函数：
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">connection</span> <span class="o">:</span> <span class="n">boost</span><span class="o">::</span><span class="n">enable_shared_from_this</span><span class="o">&lt;</span><span class="n">connection</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">error_code</span> <span class="n">error_code</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">connection</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">;</span>
    <span class="n">connection</span><span class="p">()</span> <span class="o">:</span> <span class="n">sock_</span><span class="p">(</span><span class="n">service</span><span class="p">),</span> <span class="n">started_</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">void</span> <span class="nf">start</span><span class="p">(</span><span class="n">ip</span><span class="o">::</span><span class="n">endpoint</span> <span class="n">ep</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sock_</span><span class="p">.</span><span class="n">async_connect</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span>
                            <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">connection</span><span class="o">::</span><span class="n">on_connect</span><span class="p">,</span> <span class="n">shared_from_this</span><span class="p">(),</span>
                                        <span class="n">_1</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">stop</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">started_</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="n">started_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">sock_</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="nf">started</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">started_</span><span class="p">;</span> <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">on_connect</span><span class="p">(</span><span class="k">const</span> <span class="n">error_code</span> <span class="o">&amp;</span> <span class="n">err</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// here you decide what to do with the connection: read or write
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="n">do_read</span><span class="p">();</span>
        <span class="k">else</span> <span class="nf">stop</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">on_read</span><span class="p">(</span><span class="k">const</span> <span class="n">error_code</span> <span class="o">&amp;</span> <span class="n">err</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">bytes</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">started</span><span class="p">())</span> <span class="k">return</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">msg</span><span class="p">(</span><span class="n">read_buffer_</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">msg</span> <span class="o">==</span> <span class="s">&#34;can_login&#34;</span><span class="p">)</span> <span class="n">do_write</span><span class="p">(</span><span class="s">&#34;access_data&#34;</span><span class="p">);</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">&#34;data &#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">process_data</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">msg</span> <span class="o">==</span> <span class="s">&#34;login_fail&#34;</span><span class="p">)</span> <span class="n">stop</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">on_write</span><span class="p">(</span><span class="k">const</span> <span class="n">error_code</span> <span class="o">&amp;</span> <span class="n">err</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">bytes</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">do_read</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">do_read</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">sock_</span><span class="p">.</span><span class="n">async_read_some</span><span class="p">(</span><span class="n">buffer</span><span class="p">(</span><span class="n">read_buffer_</span><span class="p">),</span>
                              <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">connection</span><span class="o">::</span><span class="n">on_read</span><span class="p">,</span> <span class="n">shared_from_this</span><span class="p">(),</span>
                                          <span class="n">_1</span><span class="p">,</span> <span class="n">_2</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">do_write</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">started</span><span class="p">()</span> <span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="c1">// note: in case you want to send several messages before
</span><span class="c1"></span>        <span class="c1">// doing another async_read, you&#39;ll need several write buffers!
</span><span class="c1"></span>        <span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">msg</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">write_buffer_</span><span class="p">);</span>
        <span class="n">sock_</span><span class="p">.</span><span class="n">async_write_some</span><span class="p">(</span><span class="n">buffer</span><span class="p">(</span><span class="n">write_buffer_</span><span class="p">,</span> <span class="n">msg</span><span class="p">.</span><span class="n">size</span><span class="p">()),</span>
                               <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">connection</span><span class="o">::</span><span class="n">on_write</span><span class="p">,</span> <span class="n">shared_from_this</span><span class="p">(),</span>
                                           <span class="n">_1</span><span class="p">,</span> <span class="n">_2</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">process_data</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// process what comes from server, and then perform another write
</span><span class="c1"></span>    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">ip</span><span class="o">::</span><span class="n">socket</span> <span class="n">sock_</span><span class="p">;</span>
    <span class="k">enum</span> <span class="p">{</span> <span class="n">max_msg</span> <span class="o">=</span> <span class="mi">1024</span> <span class="p">};</span>
    <span class="kt">char</span> <span class="n">read_buffer_</span><span class="p">[</span><span class="n">max_msg</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">write_buffer_</span><span class="p">[</span><span class="n">max_msg</span><span class="p">];</span>
    <span class="kt">bool</span> <span class="n">started_</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">ip</span><span class="o">::</span><span class="n">endpoint</span> <span class="n">ep</span><span class="p">(</span><span class="n">ip</span><span class="o">::</span><span class="n">from_string</span><span class="p">(</span><span class="s">&#34;127.0.0.1&#34;</span><span class="p">),</span>
                          <span class="mi">8001</span><span class="p">);</span>
    <span class="n">connection</span><span class="o">::</span><span class="n">ptr</span><span class="p">(</span><span class="k">new</span> <span class="n">connection</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></p>

<p>在所有的异步调用中，我们传递一个boost::bind函数对象作为参数。这个函数对象内部保存一个共享指针指向connection实例。只要还有追加的异步操作，Boost.Asio将保存一个boost::bind函数对象，它又保存一个共享指针指向connection实例，因此保持连接活着。</p>
]]></content>
		</item>
		
		<item>
			<title>Boost.Asio网络编程 第1章</title>
			<link>https://gitop.cc/posts/asio-network-programming-1/</link>
			<pubDate>Sun, 13 Mar 2016 10:55:46 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/asio-network-programming-1/</guid>
			<description>什么是Boost.Asio 简单来说，Boost.Asio是一个跨平台的C++库，主要是为了网络编程和一些其它低级输入/输出编程。 Boost.</description>
			<content type="html"><![CDATA[

<h1 id="什么是boost-asio">什么是Boost.Asio</h1>

<p>简单来说，Boost.Asio是一个跨平台的C++库，主要是为了网络编程和一些其它低级输入/输出编程。</p>

<p>Boost.Asio成功地抽象出输入和输出的概念，不仅仅是网络，还有COM串行端口，文件等。在此之上，你可以同步或异步进行输入或输出编程：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">read</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">buffer</span> <span class="p">[,</span> <span class="n">extra</span> <span class="n">options</span><span class="p">])</span>
<span class="n">async_read</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">buffer</span> <span class="p">[,</span> <span class="n">extra</span> <span class="n">options</span><span class="p">],</span> <span class="n">handler</span><span class="p">)</span>
<span class="n">write</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">buffer</span> <span class="p">[,</span> <span class="n">extra</span> <span class="n">options</span><span class="p">])</span>
<span class="n">async_write</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">buffer</span> <span class="p">[,</span> <span class="n">extra</span> <span class="n">options</span><span class="p">],</span> <span class="n">handler</span><span class="p">)</span>
</code></pre></div>

<p>正如你在上一个代码片段看到，这些函数接受一个stream实例，它可以是任何东西（不仅仅是socket，只要我们能够读取或写入它）。</p>

<h1 id="依赖">依赖</h1>

<p>Boost.Asio依赖以下库：</p>

<ul>
<li>Boost.System：这个库为Boost库提供操作系统支持。</li>
<li>Boost.Regex：可选，如果你使用带有boost::regex参数的read_until()或async_read_until()的重载版本。</li>
<li>Boost.DateTime：可选，如果你使用Boost.Asio计时器。</li>
<li>OpenSSL：可选，如果你决定使用Boost.Asio提供的SSL支持。</li>
</ul>

<h1 id="编译boost-asio">编译Boost.Asio</h1>

<p>Boost.Asio是只有头文件的库。然而，取决于你的编译器和程序的大小，你可以选择作为源文件嵌入Boost.Asio。可以使用下述方式减少编译次数：</p>

<ul>
<li>只在一个文件#include <boost/asio/impl/src.hpp>（如果使用SSL，也要包含<boost/asio/ssl/impl/src.hpp>）</li>
<li>在所有文件中使用#define BOOST_ASIO_SEPARATE_COMPILATION</li>
</ul>

<h2 id="重要的宏">重要的宏</h2>

<p>BOOST_ASIO_DISABLE_THREADS如果被定义，它会禁止Boost.Asio中线程支持，不管Boost是否编译了线程支持。</p>

<h1 id="同步vs异步">同步VS异步</h1>

<p>首先，异步编程与同步编程非常不同。在同步编程中，顺序执行操作，比如从socket读取请求，然后把回复写到socket。每一个操作都是阻塞的。因为操作是阻塞的，为了在读或写一个socket时不打断主程序，通常需要创建一个或多个线程处理socket的输入/输出。因此同步server/client通常是多线程的。</p>

<p>相反，异步编程是事件驱动的。你开始一个操作，但是不知道它什么时候结束；你提供一个回调函数，它会在操作结束时被API调用，连同操作结果。因此，在异步编程中，你没必要需要一个线程以上。</p>

<p>以下是一个基本的同步客户端例子：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">using</span> <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="p">;</span>
<span class="n">io_service</span> <span class="n">service</span><span class="p">;</span>
<span class="n">ip</span><span class="o">::</span><span class="n">endpoint</span> <span class="n">ep</span><span class="p">(</span><span class="n">ip</span><span class="o">::</span><span class="n">from_string</span><span class="p">(</span><span class="s">&#34;127.0.0.1&#34;</span><span class="p">),</span> <span class="mi">2001</span><span class="p">);</span>
<span class="n">ip</span><span class="o">::</span><span class="n">socket</span> <span class="n">sock</span><span class="p">(</span><span class="n">service</span><span class="p">);</span>
<span class="n">sock</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span>
</code></pre></div>

<p>首先，程序需要至少一个io_service实例。Boost.Asio使用io_service与操作系统输入/输出服务对话。通常一个io_service实例就足够了。</p>

<p>以下是一个简单的同步服务器例子：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ip</span><span class="o">::</span><span class="n">socket</span><span class="o">&gt;</span> <span class="n">socket_ptr</span><span class="p">;</span>
<span class="n">io_service</span> <span class="n">service</span><span class="p">;</span>
<span class="n">ip</span><span class="o">::</span><span class="n">endpoint</span> <span class="n">ep</span><span class="p">(</span><span class="n">ip</span><span class="o">::</span><span class="n">v4</span><span class="p">(),</span> <span class="mi">2001</span><span class="p">));</span> <span class="c1">// listen on 2001
</span><span class="c1"></span><span class="n">ip</span><span class="o">::</span><span class="n">acceptor</span> <span class="n">acc</span><span class="p">(</span><span class="n">service</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">socket_ptr</span> <span class="nf">sock</span><span class="p">(</span><span class="k">new</span> <span class="n">ip</span><span class="o">::</span><span class="n">socket</span><span class="p">(</span><span class="n">service</span><span class="p">));</span>
    <span class="n">acc</span><span class="p">.</span><span class="n">accept</span><span class="p">(</span><span class="o">*</span><span class="n">sock</span><span class="p">);</span>
    <span class="n">boost</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">client_session</span><span class="p">,</span> <span class="n">sock</span><span class="p">));</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">client_session</span><span class="p">(</span><span class="n">socket_ptr</span> <span class="n">sock</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
        <span class="n">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">read_some</span><span class="p">(</span><span class="n">buffer</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">write</span><span class="p">(</span><span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="n">buffer</span><span class="p">(</span><span class="s">&#34;ok&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>创建一个异步客户端，类似下面这样：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">using</span> <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="p">;</span>
<span class="n">io_service</span> <span class="n">service</span><span class="p">;</span>
<span class="n">ip</span><span class="o">::</span><span class="n">endpoint</span> <span class="n">ep</span><span class="p">(</span><span class="n">ip</span><span class="o">::</span><span class="n">from_string</span><span class="p">(</span><span class="s">&#34;127.0.0.1&#34;</span><span class="p">),</span> <span class="mi">2001</span><span class="p">);</span>
<span class="n">ip</span><span class="o">::</span><span class="n">socket</span> <span class="n">sock</span><span class="p">(</span><span class="n">service</span><span class="p">);</span>
<span class="n">sock</span><span class="p">.</span><span class="n">async_connect</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">connect_handler</span><span class="p">);</span>
<span class="n">service</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">connect_handler</span><span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">error_code</span> <span class="o">&amp;</span> <span class="n">ec</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// here we know we connected successfully
</span><span class="c1"></span>    <span class="c1">// if ec indicates success
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<p>注意service.run()循环会一直运行，只要还有异步操作加入。在前一个例子中，只有一个async_connect异步操作。在此之后，service.run()退出。</p>

<p>每一个异步操作都有一个完成处理器，一个在操作完成时被调用的函数。</p>

<p>以下是一个基本异步服务器：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">using</span> <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ip</span><span class="o">::</span><span class="n">socket</span><span class="o">&gt;</span> <span class="n">socket_ptr</span><span class="p">;</span>
<span class="n">io_service</span> <span class="n">service</span><span class="p">;</span>
<span class="n">ip</span><span class="o">::</span><span class="n">endpoint</span> <span class="n">ep</span><span class="p">(</span><span class="n">ip</span><span class="o">::</span><span class="n">v4</span><span class="p">(),</span> <span class="mi">2001</span><span class="p">));</span> <span class="c1">// listen on 2001
</span><span class="c1"></span><span class="n">ip</span><span class="o">::</span><span class="n">acceptor</span> <span class="n">acc</span><span class="p">(</span><span class="n">service</span><span class="p">,</span> <span class="n">ep</span><span class="p">);</span>
<span class="n">socket_ptr</span> <span class="nf">sock</span><span class="p">(</span><span class="k">new</span> <span class="n">ip</span><span class="o">::</span><span class="n">socket</span><span class="p">(</span><span class="n">service</span><span class="p">));</span>
<span class="n">start_accept</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
<span class="n">service</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">start_accept</span><span class="p">(</span><span class="n">socket_ptr</span> <span class="n">sock</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">acc</span><span class="p">.</span><span class="n">async_accept</span><span class="p">(</span><span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">handle_accept</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">_1</span><span class="p">));</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">handle_accept</span><span class="p">(</span><span class="n">socket_ptr</span> <span class="n">sock</span><span class="p">,</span> <span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">error_code</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="c1">// at this point, you can read/write to the socket
</span><span class="c1"></span>    <span class="n">socket_ptr</span> <span class="n">sock</span><span class="p">(</span><span class="k">new</span> <span class="n">ip</span><span class="o">::</span><span class="n">socket</span><span class="p">(</span><span class="n">service</span><span class="p">));</span>
    <span class="n">start_accept</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>handle_accept里面，在socket使用后，创建一个新的socket，并再次调用start_accept()，它添加另一个async_accept操作，保持service.run()忙碌下去。</p>

<h1 id="异常vs错误码">异常VS错误码</h1>

<p>Boost.Asio允许异常或错误码。所有同步函数重载了抛出异常或返回错误码的版本。这些函数抛出boost::system::system_error错误。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">using</span> <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="p">;</span>
<span class="n">ip</span><span class="o">::</span><span class="n">endpoint</span> <span class="n">ep</span><span class="p">;</span>
<span class="n">ip</span><span class="o">::</span><span class="n">socket</span> <span class="n">sock</span><span class="p">(</span><span class="n">service</span><span class="p">);</span>
<span class="n">sock</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">ep</span><span class="p">);</span> <span class="c1">// Line 1
</span><span class="c1"></span><span class="n">boost</span><span class="o">::</span><span class="n">error_code</span> <span class="n">err</span><span class="p">;</span>
<span class="n">sock</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span> <span class="c1">// Line 2
</span></code></pre></div>

<p>在前面的代码中，sock.connect(ep)在发生错误时抛出异常，而sock.connect(ep, err)返回错误码。</p>

<p>所有异步函数返回一个错误码，你可以在回调中检查它。异步函数从不抛出异常，因为这不合理，谁来捕捉异常？</p>

<p>所有Boost.Asio错误码在命名空间boost::asio::error。</p>

<h1 id="boost-asio中的线程">Boost.Asio中的线程</h1>

<p>当提到Boost.Asio中的线程，我们会讨论：</p>

<ul>
<li>io_service：io_service类是线程安全的。多个线程可以调用io_service::run()。大多数时候你可能从单个线程调用io_service::run()，它一直阻塞直到所有异步操作完成。然而你可以从多个线程里面调用io_service::run()，这会阻塞所有调用了io_service::run()的线程。所有回调都将在线程自己的上下文环境中被调用。</li>
<li>socket：socket类不是线程安全的。因此你应该避免在一个线程中读，然后写到另一个线程中去。</li>
<li>utility：utility类不是线程安全的，通常在多个线程中使用它不合理。它们中的大多数都是短时间使用，然后被回收。</li>
</ul>

<p>Boost.Asio库自己可以使用多个非用户的线程，它保证在这些线程里面不会调用任何你的代码。这意味着回调只会被调用了io_service::run()的线程调用。</p>

<h1 id="不仅仅是网络">不仅仅是网络</h1>

<p>除了网络，Boost.Asio提供其他输入/输出设施。</p>

<p>Boost.Asio允许等待信号，比如SIGTERM，SIGINT，SIGSEGV等：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">signal_handler</span><span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">error_code</span> <span class="o">&amp;</span> <span class="n">err</span><span class="p">,</span> <span class="kt">int</span> <span class="n">signal</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// log this, and terminate application
</span><span class="c1"></span><span class="p">}</span>
<span class="n">boost</span><span class="o">::</span><span class="n">signal_set</span> <span class="n">sig</span><span class="p">(</span><span class="n">service</span><span class="p">,</span> <span class="n">SIGINT</span><span class="p">,</span> <span class="n">SIGTERM</span><span class="p">);</span>
<span class="n">sig</span><span class="p">.</span><span class="n">async_wait</span><span class="p">(</span><span class="n">signal_handler</span><span class="p">);</span>
</code></pre></div>

<p>使用Boost.Asio可以很容易地连接串行端口：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">io_service</span> <span class="n">service</span><span class="p">;</span>
<span class="n">serial_port</span> <span class="nf">sp</span><span class="p">(</span><span class="n">service</span><span class="p">,</span> <span class="s">&#34;COM7&#34;</span><span class="p">);</span>
<span class="c1">// serial_port sp(service, &#34;/dev/ttyS0&#34;);
</span><span class="c1"></span><span class="n">serial_port</span><span class="o">::</span><span class="n">baud_rate</span> <span class="n">rate</span><span class="p">(</span><span class="mi">9600</span><span class="p">);</span>
<span class="n">sp</span><span class="p">.</span><span class="n">set_option</span><span class="p">(</span><span class="n">rate</span><span class="p">);</span>
<span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="n">read</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">buffer</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">512</span><span class="p">));</span>
</code></pre></div>

<p>Boost.Asio也允许连接Windows文件：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">HANDLE</span> <span class="n">h</span> <span class="o">=</span> <span class="o">::</span><span class="n">OpenFile</span><span class="p">(...);</span>
<span class="n">windows</span><span class="o">::</span><span class="n">stream_handle</span> <span class="n">sh</span><span class="p">(</span><span class="n">service</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
<span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="n">read</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">buffer</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">512</span><span class="p">));</span>
</code></pre></div>

<p>你可以同样操作POSIX文件描述符，比如管道，标准I/O，各种设备：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">posix</span><span class="o">::</span><span class="n">stream_descriptor</span> <span class="n">sd_in</span><span class="p">(</span><span class="n">service</span><span class="p">,</span> <span class="o">::</span><span class="n">dup</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">));</span>
<span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="n">read</span><span class="p">(</span><span class="n">sd_in</span><span class="p">,</span> <span class="n">buffer</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">512</span><span class="p">));</span>
</code></pre></div>

<h1 id="计时器">计时器</h1>

<p>一些I/O操作可以有一个完成的最后期限，这个概念只能用到异步操作。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">bool</span> <span class="n">read</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">deadline_handler</span><span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">error_code</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">read</span> <span class="o">?</span> <span class="s">&#34;read successfully&#34;</span> <span class="o">:</span> <span class="s">&#34;read failed&#34;</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">read_handler</span><span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">error_code</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">read</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">ip</span><span class="o">::</span><span class="n">socket</span> <span class="n">sock</span><span class="p">(</span><span class="n">service</span><span class="p">);</span>
<span class="err">…</span>
<span class="n">read</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="n">sock</span><span class="p">.</span><span class="n">async_read_some</span><span class="p">(</span><span class="n">buffer</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">512</span><span class="p">));</span>
<span class="n">deadline_timer</span> <span class="nf">t</span><span class="p">(</span><span class="n">service</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
<span class="n">t</span><span class="p">.</span><span class="n">async_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">deadline_handler</span><span class="p">);</span>
<span class="n">service</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>
</code></pre></div>

<p>Boost.Asio同样允许同步计时器，但它们通常等价于sleep操作。以下2个等价：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">boost</span><span class="o">::</span><span class="n">sleep</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
<span class="n">deadline_timer</span> <span class="nf">t</span><span class="p">(</span><span class="n">service</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">500</span><span class="p">));</span>
<span class="n">t</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
</code></pre></div>

<h1 id="io-service类">io_service类</h1>

<p>io_service是Boost.Asio最重要的类，它跟操作系统打交道，等待一个异步操作结束并调用相应的回调函数。</p>

<p>你可以以几种方式使用io_service：</p>

<ul>
<li>单线程，1个io_service和单处理线程：
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">io_service</span> <span class="n">service_</span><span class="p">;</span>
<span class="c1">// all the socket operations are handled by service_
</span><span class="c1"></span><span class="n">ip</span><span class="o">::</span><span class="n">socket</span> <span class="n">sock1</span><span class="p">(</span><span class="n">service_</span><span class="p">);</span>
<span class="c1">// all the socket operations are handled by service_
</span><span class="c1"></span><span class="n">ip</span><span class="o">::</span><span class="n">socket</span> <span class="n">sock2</span><span class="p">(</span><span class="n">service_</span><span class="p">);</span>
<span class="n">sock1</span><span class="p">.</span><span class="n">async_connect</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">connect_handler</span><span class="p">);</span>
<span class="n">sock2</span><span class="p">.</span><span class="n">async_connect</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">connect_handler</span><span class="p">);</span>
<span class="n">deadline_timer</span> <span class="nf">t</span><span class="p">(</span><span class="n">service_</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
<span class="n">t</span><span class="p">.</span><span class="n">async_wait</span><span class="p">(</span><span class="n">timeout_handler</span><span class="p">);</span>
<span class="n">service_</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>
</code></pre></div></li>
<li>多线程，单个io_service和多个处理线程：
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">io_service</span> <span class="n">service_</span><span class="p">;</span>
<span class="n">ip</span><span class="o">::</span><span class="n">socket</span> <span class="n">sock1</span><span class="p">(</span><span class="n">service_</span><span class="p">);</span>
<span class="n">ip</span><span class="o">::</span><span class="n">socket</span> <span class="n">sock2</span><span class="p">(</span><span class="n">service_</span><span class="p">);</span>
<span class="n">sock1</span><span class="p">.</span><span class="n">async_connect</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">connect_handler</span><span class="p">);</span>
<span class="n">sock2</span><span class="p">.</span><span class="n">async_connect</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">connect_handler</span><span class="p">);</span>
<span class="n">deadline_timer</span> <span class="nf">t</span><span class="p">(</span><span class="n">service_</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
<span class="n">t</span><span class="p">.</span><span class="n">async_wait</span><span class="p">(</span><span class="n">timeout_handler</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">boost</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">run_service</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">run_service</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">service_</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></li>
<li>多个线程，多个io_service和多个处理线程：
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">io_service</span> <span class="n">service_</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">ip</span><span class="o">::</span><span class="n">socket</span> <span class="n">sock1</span><span class="p">(</span><span class="n">service_</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">ip</span><span class="o">::</span><span class="n">socket</span> <span class="n">sock2</span><span class="p">(</span><span class="n">service_</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="n">sock1</span><span class="p">.</span><span class="n">async_connect</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">connect_handler</span><span class="p">);</span>
<span class="n">sock2</span><span class="p">.</span><span class="n">async_connect</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span> <span class="n">connect_handler</span><span class="p">);</span>
<span class="n">deadline_timer</span> <span class="nf">t</span><span class="p">(</span><span class="n">service_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">boost</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
<span class="n">t</span><span class="p">.</span><span class="n">async_wait</span><span class="p">(</span><span class="n">timeout_handler</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">boost</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">run_service</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
<span class="kt">void</span> <span class="nf">run_service</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">service_</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">run</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></li>
</ul>

<p>首先，需要注意在一个线程里面不能有多个io_service实例。以下代码毫无意义：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">service_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">run</span><span class="p">();</span>
</code></pre></div>

<p>以下是从前面例子中你应该学到的：</p>

<ul>
<li>第一种情况对最基本的程序有用。如果多个处理函数需要同时调用，将遇到瓶颈，因为它们以顺序方式被调用。如果一个处理函数花太长时间结束，所有后续处理函数都将等待。</li>
<li>第二种情况适用于大多数程序。如果多个处理函数被同时调用，它们会在自己的线程被调用。唯一的瓶颈是如果所有处理线程都在忙碌，而新的处理函数被调用。</li>
<li>第三种情况最复杂最灵活。你应该在第二种情况不够的时候使用它。你可以认为每一个处理线程（运行io_service::run()的线程）有自己的select/epoll循环。</li>
</ul>

<p>最后记住如果没有更多的操作需要处理，run()将会终止。如果想要run()继续运行，你必须把更多工作给它。一种方法是在处理函数中开始另一个异步操作。另一种方法是模拟一些工作给它：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">io_service</span><span class="o">::</span><span class="n">work</span><span class="o">&gt;</span> <span class="n">work_ptr</span><span class="p">;</span>
<span class="n">work_ptr</span> <span class="nf">dummy_work</span><span class="p">(</span><span class="k">new</span> <span class="n">io_service</span><span class="o">::</span><span class="n">work</span><span class="p">(</span><span class="n">service_</span><span class="p">));</span>
</code></pre></div>

<p>上述代码将使得service<em>.run()不会停止除非你使用service</em>.stop()或dummy_work.reset(0)销毁dummy_work。</p>
]]></content>
		</item>
		
		<item>
			<title>Python核心编程 第3章</title>
			<link>https://gitop.cc/posts/core-python-3/</link>
			<pubDate>Fri, 25 Dec 2015 13:28:23 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/core-python-3/</guid>
			<description>3.1 语句和语法 关于Python语句的一些规则和符号： * 井号（#）指示Python注释。 * 换行（\n）是标准行分隔符（一个语句一行） * 反斜杠（\</description>
			<content type="html"><![CDATA[

<h2 id="3-1-语句和语法">3.1 语句和语法</h2>

<p>关于Python语句的一些规则和符号：
* 井号（#）指示Python注释。
* 换行（\n）是标准行分隔符（一个语句一行）
* 反斜杠（\）延续一行
* 分号（;）将2个语句连接在一行
* 冒号（:）分隔标题行和其单元
* 单元通过缩进界定
* Python文件组织成模块</p>

<h3 id="3-1-1-注释">3.1.1 注释（#）</h3>

<p>Python注释以井号开始。一个注释可以在一行的任何地方开始，所有跟在井号后面直到行尾的字符被解释器忽略。明智审慎地使用它们。</p>

<h3 id="3-1-2-延续">3.1.2 延续（\）</h3>

<p>Python语句通常由换行界定，意思是一个语句一行。单一语句可以通过反斜杠分成多行。反斜杠可以放在换行符前面使当前语句延续到下一行。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># check conditions</span>
<span class="k">if</span> <span class="p">(</span><span class="n">weather_is_hot</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> \
   <span class="p">(</span><span class="n">shark_warnings</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
    <span class="n">send_goto_beach_mesg_to_pager</span><span class="p">()</span></code></pre></div>

<p>有两种例外可以不使用反斜杠延续到下一行。被括号，方括号或花括号包围的单一语句和包围在三重引号的字符串。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># display a string with triple quotes</span>
<span class="k">print</span> <span class="s1">&#39;&#39;&#39;hi there, this is a long message for you
</span><span class="s1">that goes over multiple lines... you will find
</span><span class="s1">out soon that triple quotes in Python allows
</span><span class="s1">this kind of fun! it is like a day on the beach!&#39;&#39;&#39;</span>
<span class="c1"># set some variables</span>
<span class="n">go_surf</span><span class="p">,</span> <span class="n">get_a_tan_while</span><span class="p">,</span> <span class="n">boat_size</span><span class="p">,</span> <span class="n">toll_money</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span>
    <span class="s1">&#39;windsurfing&#39;</span><span class="p">,</span> <span class="mf">40.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.00</span><span class="p">)</span></code></pre></div>

<h3 id="3-1-3-多个语句组成程序组">3.1.3 多个语句组成程序组（:）</h3>

<p>多个语句组成一个代码块在Python中称为程序组（suites）。复合语句如if，while，def和class都需要一个标题行和一个程序组。标题行以关键字开始一行语句并以冒号结尾。</p>

<h3 id="3-1-4-通过缩进界定程序组">3.1.4 通过缩进界定程序组</h3>

<p>Python利用缩进作为一种界定代码块的方法。内层的代码通过空格或制表符缩进。一个程序组的所有代码行必须处在同样的缩进级别上。</p>

<blockquote>
<p><strong>核心风格：使用4个空格缩进并避免使用制表符</strong></p>
</blockquote>

<p>当缩进的数量增加时，一个新的代码块被识别。而一个代码块的结束由缩进的数量减少并匹配上一层的缩进。没有缩进的代码（最高层的代码）被认为是脚本的主要部分。</p>

<h3 id="3-1-5-多个语句在一行">3.1.5 多个语句在一行（;）</h3>

<p>分号（;）允许多个语句在一行，这些语句都不开始一个新的代码块。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">sys</span><span class="p">;</span> <span class="n">x</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span></code></pre></div>

<p>不要多行语句放在一行，因为它使得代码更难阅读。</p>

<h3 id="3-1-6-模块">3.1.6 模块</h3>

<p>每一个Python脚本都是一个模块。模块物理表现为硬盘文件。当一个模块变得足够大时，将一些代码移到另一个模块更合理。</p>

<h2 id="3-2-变量赋值">3.2 变量赋值</h2>

<h3 id="赋值操作符">赋值操作符</h3>

<p>等号是Python主要的赋值操作符，其它的是增量赋值操作符。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">anInt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">12</span>
<span class="n">aString</span> <span class="o">=</span> <span class="s1">&#39;cart&#39;</span>
<span class="n">aFloat</span> <span class="o">=</span> <span class="o">-</span><span class="mf">3.1415</span> <span class="o">*</span> <span class="p">(</span><span class="mf">5.0</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">anotherString</span> <span class="o">=</span> <span class="s1">&#39;shop&#39;</span> <span class="o">+</span> <span class="s1">&#39;ping&#39;</span>
<span class="n">aList</span> <span class="o">=</span> <span class="p">[</span><span class="mf">3.14e10</span><span class="p">,</span> <span class="s1">&#39;2nd elmt of a list&#39;</span><span class="p">,</span> <span class="mf">8.82</span><span class="o">-</span><span class="mf">4.371j</span><span class="p">]</span></code></pre></div>

<p>注意赋值并没有显式将一个值赋给一个变量。在Python中，对象都是被引用的。因此当赋值时，一个对象的引用被赋值给变量，不管对象是刚刚创建还是已经存在。</p>

<p>如果你熟悉C，赋值被当做表达式。Python中不是这样，下面这样的语句在Python中非法：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># assignments not expressions!</span>
  <span class="n">File</span> <span class="s2">&#34;&lt;stdin&gt;&#34;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
           <span class="o">^</span>
<span class="ne">SyntaxError</span><span class="p">:</span> <span class="n">invalid</span> <span class="n">syntax</span></code></pre></div>

<p>赋值可以链接在一起：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span></code></pre></div>

<h3 id="增量赋值操作符">增量赋值操作符</h3>

<p>从Python 2.0开始，等号可以和算术操作符一起使用，且产生的结果再赋值给原来的变量。比如：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=&gt;</span> <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span></code></pre></div>

<p>增量赋值操作符有，<strong>+=</strong>，<strong>-=</strong>，*<strong>=</strong>，<strong>/=</strong>，<strong>%=</strong>，<strong>**=</strong>，<strong>&lt;&lt;=</strong>，<strong>&gt;&gt;=</strong>，<strong>&amp;=</strong>，<strong>^=</strong>，<strong>|=</strong>。</p>

<p>除了明显的语法改变，最显著的不同是第一个对象只被检查一次。可变对象在原地改变，而不可变对象和可变对象有一样的效果（一个新对象被分配）。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">12</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span> <span class="o">%=</span> <span class="mi">7</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span>
<span class="mi">5</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span> <span class="o">**=</span> <span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span>
<span class="mi">25</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">aList</span> <span class="o">=</span> <span class="p">[</span><span class="mi">123</span><span class="p">,</span> <span class="s1">&#39;xyz&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">aList</span> <span class="o">+=</span> <span class="p">[</span><span class="mf">45.6e7</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">aList</span>
<span class="p">[</span><span class="mi">123</span><span class="p">,</span> <span class="s1">&#39;xyz&#39;</span><span class="p">,</span> <span class="mf">456000000.0</span></code></pre></div>

<p>Python不支持前/后自增操作符，也不支持前/后自减操作符。</p>

<h3 id="多个赋值">多个赋值</h3>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">=</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">1</span></code></pre></div>

<p>上面这个例子中，一个整形对象被创建，且x，y，z都引用到这个整形对象。Python也可以将多个对象赋值给多个变量。</p>

<h3 id="元组赋值">元组赋值</h3>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a string&#39;</span></code></pre></div>

<p>上面这个例子中，2个整形对象和一个字符串对象被赋值给x，y，z。尽管括号是可选的，我们建议在任何使代码容易阅读的地方使用括号：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;a string&#39;</span><span class="p">)</span></code></pre></div>

<p>Python元组赋值的一个有趣副作用是我们不再需要一个临时变量来交换2个变量的值：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span></code></pre></div>

<p>显然，Python在赋值前执行计算。</p>

<h2 id="3-3-标识符">3.3 标识符</h2>

<p>标识符是一组合法的允许作为计算机语言里的名字的字符串。从这个包罗万象的列表中，我们分离出一些形成语言结构的关键字。这些标识符是不应该用作其它意图的保留字，否则将发生语法错误。</p>

<p>Python也有一组额外的标识符集被称为built-ins。尽管它们不是保留字，不推荐使用这些特殊名字。</p>

<h3 id="3-3-1-合法python标识符">3.3.1 合法Python标识符</h3>

<p>Python标识符的规则和其它来自C世界的高级语言一样：
* 第一个字符必须是字母或是下划线（_）。
* 任何其它的字符可以是字母，数字或下划线。
* 大小写敏感。</p>

<h3 id="3-3-2-关键字">3.3.2 关键字</h3>

<p><strong>keyword</strong>模块包含关键字列表和一个<strong>iskeyword()</strong>函数。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">keyword</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">keyword</span><span class="o">.</span><span class="n">kwlist</span>
<span class="p">[</span><span class="s1">&#39;and&#39;</span><span class="p">,</span> <span class="s1">&#39;as&#39;</span><span class="p">,</span> <span class="s1">&#39;assert&#39;</span><span class="p">,</span> <span class="s1">&#39;break&#39;</span><span class="p">,</span> <span class="s1">&#39;class&#39;</span><span class="p">,</span> <span class="s1">&#39;continue&#39;</span><span class="p">,</span> <span class="s1">&#39;def&#39;</span><span class="p">,</span> <span class="s1">&#39;del&#39;</span><span class="p">,</span>
 <span class="s1">&#39;elif&#39;</span><span class="p">,</span> <span class="s1">&#39;else&#39;</span><span class="p">,</span> <span class="s1">&#39;except&#39;</span><span class="p">,</span> <span class="s1">&#39;exec&#39;</span><span class="p">,</span> <span class="s1">&#39;finally&#39;</span><span class="p">,</span> <span class="s1">&#39;for&#39;</span><span class="p">,</span> <span class="s1">&#39;from&#39;</span><span class="p">,</span> <span class="s1">&#39;global&#39;</span><span class="p">,</span>
 <span class="s1">&#39;if&#39;</span><span class="p">,</span> <span class="s1">&#39;import&#39;</span><span class="p">,</span> <span class="s1">&#39;in&#39;</span><span class="p">,</span> <span class="s1">&#39;is&#39;</span><span class="p">,</span> <span class="s1">&#39;lambda&#39;</span><span class="p">,</span> <span class="s1">&#39;not&#39;</span><span class="p">,</span> <span class="s1">&#39;or&#39;</span><span class="p">,</span> <span class="s1">&#39;pass&#39;</span><span class="p">,</span> <span class="s1">&#39;print&#39;</span><span class="p">,</span>
 <span class="s1">&#39;raise&#39;</span><span class="p">,</span> <span class="s1">&#39;return&#39;</span><span class="p">,</span> <span class="s1">&#39;try&#39;</span><span class="p">,</span> <span class="s1">&#39;while&#39;</span><span class="p">,</span> <span class="s1">&#39;with&#39;</span><span class="p">,</span> <span class="s1">&#39;yield&#39;</span><span class="p">]</span></code></pre></div>

<h3 id="3-3-3-built-ins">3.3.3 Built-ins</h3>

<p>除了关键字，Python还有一组内置名字集合。尽管不是关键字，内置名字应该被当做留给系统的，不应该用作任何其它意图。</p>

<p>内置名字都是<strong><strong>builtins</strong></strong>模块的成员，这个模块在程序开始前由解释器自动导入。</p>
]]></content>
		</item>
		
		<item>
			<title>Python核心编程 第2章</title>
			<link>https://gitop.cc/posts/core-python-2/</link>
			<pubDate>Thu, 24 Dec 2015 09:46:13 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/core-python-2/</guid>
			<description>命令行选项 -d 提供调试输出 -O 生成优化字节码（产生.pyo文件） -S 启动时不要运行导入地址查询Python路径 -v 详细输出（详细追踪import语句</description>
			<content type="html"><![CDATA[

<h1 id="命令行选项">命令行选项</h1>

<p>-d      提供调试输出
-O      生成优化字节码（产生.pyo文件）
-S      启动时不要运行导入地址查询Python路径
-v      详细输出（详细追踪import语句）
-m      mod 将模块当脚本运行
-Q      opt 除法选项
-c      cmd 将cmd字符串当Python脚本执行
file    从指定文件运行Python脚本</p>

<h1 id="2-1-程序输出-print语句和-hello-world">2.1 程序输出，print语句和&rdquo;Hello World!&rdquo;</h1>

<p>Python的<strong>print</strong>语句（2.x）或函数（3.x）给用户显示程序输出的工具，类似C语言的<strong>printf()</strong>和shell脚本的<strong>echo</strong>。实际上，它也支持<strong>printf()</strong>风格的字符串替换用法：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="s2">&#34;</span><span class="si">%s</span><span class="s2"> is number </span><span class="si">%d</span><span class="s2">!&#34;</span> <span class="o">%</span> <span class="p">(</span><span class="s2">&#34;Python&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">Python</span> <span class="ow">is</span> <span class="n">number</span> <span class="mi">1</span><span class="err">!</span></code></pre></div>

<blockquote>
<p><strong>核心笔记：在交互解释器中打印变量内容</strong>
在交互解释器中，你可以提供变量的名字直接打印变量的内容。print语句使用str()打印内容，而交互解释器调用repr()显示对象。下划线（_）在交互解释器中也有特殊含义：上一个计算过的表达式。</p>
</blockquote>

<p><strong>print</strong>语句也可以将输出重定向到文件。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">sys</span>
<span class="k">print</span> <span class="o">&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="s1">&#39;Fatal error: invalid input!&#39;</span>

<span class="n">logfile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/tmp/mylog.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="o">&gt;&gt;</span> <span class="n">logfile</span><span class="p">,</span> <span class="s1">&#39;Fatal error: invalid input!&#39;</span>
<span class="n">logfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></code></pre></div>

<p><strong>print</strong>在Python 3.0变成了函数[print()]。从Python 2.6开始，你可以通过添加这句特殊的import语句使用print函数：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span></code></pre></div>

<p>新函数的语法是：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">print</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s1">&#39;Fatal error: invalid input!&#39;</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span></code></pre></div>

<h1 id="2-2-程序输入和内置raw-input-函数">2.2 程序输入和内置raw_input()函数</h1>

<p>从命令行获取用户输入最简单的方法是使用内置的<strong>raw_input()</strong>函数。它从标准输入读取输入并将字符串赋值给你指定的变量。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">user</span> <span class="o">=</span> <span class="nb">raw_input</span><span class="p">(</span><span class="s1">&#39;Enter login name: &#39;</span><span class="p">)</span>
<span class="n">Enter</span> <span class="n">login</span> <span class="n">name</span><span class="p">:</span> <span class="n">root</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="s1">&#39;Your login is:&#39;</span><span class="p">,</span> <span class="n">user</span>
<span class="n">Your</span> <span class="n">login</span> <span class="ow">is</span><span class="p">:</span> <span class="n">root</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">num</span> <span class="o">=</span> <span class="nb">raw_input</span><span class="p">(</span><span class="s1">&#39;Now enter a number: &#39;</span><span class="p">)</span>
<span class="n">Now</span> <span class="n">enter</span> <span class="n">a</span> <span class="n">number</span><span class="p">:</span> <span class="mi">1024</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="s1">&#39;Doubling your number: </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">Doubling</span> <span class="n">your</span> <span class="n">number</span><span class="p">:</span> <span class="mi">2048</span></code></pre></div>

<p>内置的<strong>int()</strong>函数将字符串转换成整数。</p>

<blockquote>
<p><strong>核心笔记：在交互解释器中寻求帮助</strong>
在学习Python的过程中，如果需要对一个你不熟悉的新函数的帮助文档，你可以调用help()内置函数寻求帮助，比如help(raw_input)。
<strong>核心风格：用户交互放在函数外面</strong>
我们建议函数应该保持干净，意思是函数应该只用来接收参数并返回值。</p>
</blockquote>

<h1 id="2-3-注释">2.3 注释</h1>

<p>和大多数脚本语言一样，井号（#）表示一个注释开始并持续到一行结尾。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="c1"># one comment</span>
<span class="o">...</span> <span class="k">print</span> <span class="s1">&#39;Hello World!&#39;</span> <span class="c1"># another comment</span>
<span class="n">Hello</span> <span class="n">World</span><span class="err">!</span></code></pre></div>

<p>有一种特殊的注释被称为文档字符串。在一个模块，类或函数开头独立的字符串就是文档字符串。文档字符串可以在运行时访问并用来自动生成文档。可以使用object.<strong>doc</strong>访问注释文档。</p>

<h1 id="2-4-操作符">2.4 操作符</h1>

<p>你熟知的标准数学操作符在Python里面跟其它大多数语言一样工作。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">+</span>   <span class="o">-</span>   <span class="o">*</span>   <span class="o">/</span>   <span class="o">//</span>  <span class="o">%</span>   <span class="o">**</span></code></pre></div>

<p>Python有2个除法操作符，一个斜杠用来做经典除法而2个斜杠用来做截断除法。经典除法的意思是如果操作数都是整数，则执行截断除法，而对于浮点型执行真实除法。如果真实除法生效，则除法操作符总是执行真实除法，不管操作数类型。两个星号（**）是指数操作符。</p>

<p>Python也提供了标准比较操作符，这些操作符返回布尔值：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&lt;</span>   <span class="o">&lt;=</span>  <span class="o">&gt;</span>   <span class="o">&gt;=</span>  <span class="o">==</span>  <span class="o">!=</span>  <span class="o">&lt;&gt;</span></code></pre></div>

<p>Python当前支持两种不等操作符，!=和&lt;&gt;。后面这个正逐渐被淘汰，推荐使用前面的。</p>

<p>Python也提供表达式连接操作符：<strong>and</strong>，<strong>or</strong>，<strong>not</strong>。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="mi">3</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="o">&lt;</span> <span class="mi">5</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">3</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="ow">and</span> <span class="mi">4</span> <span class="o">&lt;</span> <span class="mi">5</span>
<span class="bp">True</span></code></pre></div>

<blockquote>
<p>核心风格：使用括号澄清
很多情况下，使用括号是个好主意。比如如果没有它们代码很难阅读，或如果没有它们容易造成混淆。</p>
</blockquote>

<h1 id="2-5-变量和赋值">2.5 变量和赋值</h1>

<p>Python中变量的规则和大多数其它高级语言一样。它们仅仅是以字母开头的标识符。Python是大小写敏感的。</p>

<p>Python是动态类型的，意味着变量类型的预先声明是不必要的。类型和值在赋值时初始化，使用等号进行赋值。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">miles</span> <span class="o">=</span> <span class="mf">1000.0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Bob&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">kilometers</span> <span class="o">=</span> <span class="mf">1.609</span> <span class="o">*</span> <span class="n">miles</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="s1">&#39;</span><span class="si">%f</span><span class="s1"> miles is the same as </span><span class="si">%f</span><span class="s1"> km&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">miles</span><span class="p">,</span> <span class="n">kilometers</span><span class="p">)</span>
<span class="mf">1000.000000</span> <span class="n">miles</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">same</span> <span class="k">as</span> <span class="mf">1609.000000</span> <span class="n">km</span></code></pre></div>

<p>Python支持增量赋值，比如n *= 10。Python不支持自增和自减操作符。</p>

<h1 id="2-6-数字">2.6 数字</h1>

<p>Python支持五种基本数字类型，其中三种是整形。
* <strong>int</strong>（有符号整数）
    * <strong>long</strong>（long整形）
    * <strong>bool</strong>（Boolean值）
* <strong>float</strong>（浮点型实数）
* <strong>complex</strong>（复数）</p>

<p>Python的long型没有范围限制，它只局限于系统的内存。如果你熟悉Java，Python的long型类似于BigInteger类型。未来int和long将被统一进一种整形。从2.3开始，溢出错误不再报告，其结果将自动转为long。Python 3中，int和long被统一为一个整形，且&rdquo;L&rdquo;不再是合法的Python语法。</p>

<p>Boolean值是整形的一个特殊情况。尽管由常量<strong>True</strong>和<strong>False</strong>表示，如果放进数值环境比如与其它数作加法，<strong>True</strong>被看作数字1，而<strong>False</strong>为0。</p>

<p>还有一种数值类型，decimal，代表十进制浮点数。但是它不是内置类型。你必须导入decimal模块才能使用。</p>

<h1 id="2-7-字符串">2.7 字符串</h1>

<p>字符串在Python中被表示为引号之间的一组连续的字符。Python允许使用一对单引号或一对双引号。三重引号（三个连续的单引号或双引号）可以用来转义特殊字符。可以使用下标（[]）和切片（[:]）获取子字符串。加号（+）是字符串连接操作符，星号（*）是重复操作符。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">pystr</span> <span class="o">=</span> <span class="s1">&#39;Python&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">iscool</span> <span class="o">=</span> <span class="s1">&#39;is cool!&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pystr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="s1">&#39;P&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pystr</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="s1">&#39;tho&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">iscool</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
<span class="s1">&#39;is&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">iscool</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>
<span class="s1">&#39;cool!&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">iscool</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="s1">&#39;!&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pystr</span> <span class="o">+</span> <span class="n">iscool</span>
<span class="s1">&#39;Pythonis cool!&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pystr</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">iscool</span>
<span class="s1">&#39;Python is cool!&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pystr</span> <span class="o">*</span> <span class="mi">2</span>
<span class="s1">&#39;PythonPython&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="s1">&#39;-&#39;</span> <span class="o">*</span> <span class="mi">20</span>
<span class="s1">&#39;--------------------&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pystr</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;python
</span><span class="s1">... is cool&#39;&#39;&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pystr</span>
<span class="s1">&#39;python</span><span class="se">\n</span><span class="s1">is cool&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">pystr</span>
<span class="n">python</span>
<span class="ow">is</span> <span class="n">cool</span>
<span class="o">&gt;&gt;&gt;</span></code></pre></div>

<h1 id="2-8-列表和元组">2.8 列表和元组</h1>

<p>列表和元组可以被认为是通用“数组”，使用它可以存放任意数量的任意Python对象，其元素顺序存放并通过下标访问。</p>

<p>列表和元组有一些主要的区别。列表由中括号（[]）括起来，其元素和大小可以改变。元组由括号（()）括起来且不能更新。元组可以认为是“只读”列表。像字符串一样可以使用切片操作符（[]和[:]）获取子集。</p>

<h1 id="2-9-字典">2.9 字典</h1>

<p>字典是Python的映射类型，像Perl里面的关联数组或哈希一样工作，它由键值对组成。键可以是几乎任何Python类型，但是通常是数字或字符串。另一方面，值可以是任意Python对象。字典由花括号（{}）括起来。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">aDict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;host&#39;</span><span class="p">:</span> <span class="s1">&#39;earth&#39;</span><span class="p">}</span> <span class="c1"># create dict</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">aDict</span><span class="p">[</span><span class="s1">&#39;port&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">80</span> <span class="c1"># add to dict</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">aDict</span>
<span class="p">{</span><span class="s1">&#39;host&#39;</span><span class="p">:</span> <span class="s1">&#39;earth&#39;</span><span class="p">,</span> <span class="s1">&#39;port&#39;</span><span class="p">:</span> <span class="mi">80</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">aDict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="p">[</span><span class="s1">&#39;host&#39;</span><span class="p">,</span> <span class="s1">&#39;port&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">aDict</span><span class="p">[</span><span class="s1">&#39;host&#39;</span><span class="p">]</span>
<span class="s1">&#39;earth&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">aDict</span><span class="p">:</span>
<span class="o">...</span> <span class="k">print</span> <span class="n">key</span><span class="p">,</span> <span class="n">aDict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
<span class="o">...</span>
<span class="n">host</span> <span class="n">earth</span>
<span class="n">port</span> <span class="mi">80</span></code></pre></div>

<h1 id="2-10-代码块使用缩进">2.10 代码块使用缩进</h1>

<p>代码块由缩进指定而不是用像花括号这样的符号。没有额外的符号，程序更容易阅读。同样，缩进清晰地指出代码属于哪一个代码块。当然代码块可以由单个语句组成。</p>

<h1 id="2-11-if语句">2.11 if语句</h1>

<p>标准<strong>if</strong>条件语句遵循下面语法：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">if</span> <span class="n">expression</span><span class="p">:</span>
    <span class="n">if_suite</span></code></pre></div>

<p>如果表达式非0或True，则if_suite被执行。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="o">.</span><span class="mi">0</span><span class="p">:</span>
    <span class="k">print</span> <span class="s1">&#39;”x” must be at least 0!&#39;</span></code></pre></div>

<p>Python支持<strong>else</strong>语句，和<strong>if</strong>一起使用：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">if</span> <span class="n">expression</span><span class="p">:</span>
    <span class="n">if_suite</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">else_suite</span></code></pre></div>

<p>Python有一个“else-if”书写为<strong>elif</strong>使用下面的语法：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">if</span> <span class="n">expression1</span><span class="p">:</span>
    <span class="n">if_suite</span>
<span class="k">elif</span> <span class="n">expression2</span><span class="p">:</span>
    <span class="n">elif_suite</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">else_suite</span></code></pre></div>

<h1 id="2-12-while循环">2.12 while循环</h1>

<p>标准while条件循环语句类似<strong>if</strong>，语法如下：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">while</span> <span class="n">expression</span><span class="p">:</span>
    <span class="n">while_suite</span></code></pre></div>

<p>while_suite语句在循环里面一直被执行直到expression变为0或False。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">while</span> <span class="n">counter</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
<span class="o">...</span>     <span class="k">print</span> <span class="s1">&#39;loop #</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">counter</span><span class="p">)</span>
<span class="o">...</span>     <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">loop</span> <span class="c1">#0</span>
<span class="n">loop</span> <span class="c1">#1</span>
<span class="n">loop</span> <span class="c1">#2</span></code></pre></div>

<h1 id="2-13-for循环和range-内置函数">2.13 for循环和range()内置函数</h1>

<p>Python中的for循环更像一个脚本语言中foreach迭代类型循环。Python的for接受一个iterable并遍历每一个元素。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;e-mail&#39;</span><span class="p">,</span> <span class="s1">&#39;net-surfing&#39;</span><span class="p">,</span> <span class="s1">&#39;homework&#39;</span><span class="p">,</span>
<span class="s1">&#39;chat&#39;</span><span class="p">]:</span>
<span class="o">...</span>     <span class="k">print</span> <span class="n">item</span>
<span class="n">e</span><span class="o">-</span><span class="n">mail</span>
<span class="n">net</span><span class="o">-</span><span class="n">surfing</span>
<span class="n">homework</span>
<span class="n">chat</span></code></pre></div>

<p><strong>print</strong>语句默认在每一行结尾添加一个换行符。可以在<strong>print</strong>语句后面加一个逗号抑制这个默认行为。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">print</span> <span class="s1">&#39;I like to use the Internet for:&#39;</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;e-mail&#39;</span><span class="p">,</span> <span class="s1">&#39;net-surfing&#39;</span><span class="p">,</span> <span class="s1">&#39;homework&#39;</span><span class="p">,</span> <span class="s1">&#39;chat&#39;</span><span class="p">]:</span>
    <span class="k">print</span> <span class="n">item</span><span class="p">,</span>
<span class="k">print</span></code></pre></div>

<p><strong>print</strong>语句中逗号分隔的元素当它们被显示时会自动包含一个分隔的空格。</p>

<p>Python提供<strong>range()</strong>内置函数为我们生成一个列表。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">eachNum</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
<span class="o">...</span>     <span class="k">print</span> <span class="n">eachNum</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="s1">&#39;abc&#39;</span><span class="p">:</span>
<span class="o">...</span>     <span class="k">print</span> <span class="n">c</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">)):</span>
<span class="o">...</span>     <span class="k">print</span> <span class="n">foo</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s1">&#39;(</span><span class="si">%d</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">i</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">foo</span><span class="p">):</span><span class="n">s</span>
<span class="o">...</span>     <span class="k">print</span> <span class="n">ch</span><span class="p">,</span> <span class="s1">&#39;(</span><span class="si">%d</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">i</span></code></pre></div>

<h1 id="2-14-列表推导式">2.14 列表推导式</h1>

<p>列表推导式使用一个for循环生成一个列表：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">squared</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">squared</span><span class="p">:</span>
<span class="o">...</span>     <span class="k">print</span> <span class="n">i</span></code></pre></div>

<p>列表推导式甚至可以选择性的包含什么进新列表：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">sqdEvens</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span><span class="p">]</span></code></pre></div>

<h1 id="2-15-文件和open-file-内置函数">2.15 文件和open()，file()内置函数</h1>

<p>如何打开一个文件：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">handle</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">access_mode</span> <span class="o">=</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span></code></pre></div>

<p>file_name变量包含字符串类型的文件名，access_mode可以是读（r），写（w），追加（a）。其它标志包括读写（+），二进制访问（b）。</p>

<p>如果open()成功，一个文件对象被返回。所有后续文件访问必须通过这个文件对象。</p>

<blockquote>
<p><strong>核心笔记：什么是属性？</strong>
属性是关联到一块数据的项。属性可以是简单数据值或可执行对象比如函数或方法。通过点号访问属性：object.attribute。</p>
</blockquote>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">filename</span> <span class="o">=</span> <span class="nb">raw_input</span><span class="p">(</span><span class="s1">&#39;Enter file name: &#39;</span><span class="p">)</span>
<span class="n">fobj</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">fobj</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
<span class="n">fobj</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="k">for</span> <span class="n">eachLine</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">eachLine</span><span class="p">,</span></code></pre></div>

<p><strong>file()</strong>内置函数最近才添加进Python。它和<strong>open()</strong>是相同的，但是这种命名指示它是一个工厂函数（生产文件对象），类似于<strong>int()</strong>生产整数对象和<strong>dict()</strong>生产字典对象。</p>

<h1 id="2-16-错误和异常">2.16 错误和异常</h1>

<p>语法错误在编译时检查，但是Python也允许程序运行期间发现错误。当一个错误被检测，Python解释器抛出一个异常。使用<strong>try-except</strong>语句添加错误检测或异常处理到你的代码。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">try</span><span class="p">:</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="nb">raw_input</span><span class="p">(</span><span class="s1">&#39;Enter file name: &#39;</span><span class="p">)</span>
    <span class="n">fobj</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">eachLine</span> <span class="ow">in</span> <span class="n">fobj</span><span class="p">:</span>
        <span class="k">print</span> <span class="n">eachLine</span><span class="p">,</span>
    <span class="n">fobj</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="k">except</span> <span class="ne">IOError</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span> <span class="s1">&#39;file open error:&#39;</span><span class="p">,</span> <span class="n">e</span></code></pre></div>

<p>程序员可以显式使用<strong>raise</strong>抛出一个异常。</p>

<h1 id="2-17-函数">2.17 函数</h1>

<p>和其它语言一样，Python中的函数使用函数操作符（()）调用，函数必须在调用前声明。不需要声明函数返回类型或显式返回值，如果没有返回值，Python返回<strong>None</strong>。</p>

<p>Python可以被认为是“引用调用”。这意味着函数内任何对函数参数的改变会影响到原来的对象。然而在Python中，这实际上取决于传递的对象类型。如果这个对象允许更新，则它表现为我们预期的“引用调用”，但是如果对象的值不能改变，则它表现为“传值调用”。</p>

<h2 id="如何定义函数">如何定义函数</h2>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">function_name</span><span class="p">([</span><span class="n">arguments</span><span class="p">]):</span>
    <span class="s2">&#34;optional documentation string&#34;</span>
    <span class="n">function_suite</span></code></pre></div>

<p>声明一个函数的语法由<strong>def</strong>关键字，跟着函数名和任意数量函数可能接收的参数组成。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">addMe2Me</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="s1">&#39;apply + operation to argument&#39;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span></code></pre></div>

<h1 id="默认实参">默认实参</h1>

<p>函数可以有具有默认值的参数。如果参数的值没有提供，将会使用默认值：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">debug</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
<span class="o">...</span>     <span class="s1">&#39;determine if in debug mode with default argument&#39;</span>
<span class="o">...</span>     <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
<span class="o">...</span>         <span class="k">print</span> <span class="s1">&#39;in debug mode&#39;</span>
<span class="o">...</span>     <span class="k">print</span> <span class="s1">&#39;done&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">foo</span><span class="p">()</span>
<span class="ow">in</span> <span class="n">debug</span> <span class="n">mode</span>
<span class="n">done</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">foo</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="n">done</span></code></pre></div>

<h1 id="2-18-类">2.18 类</h1>

<p>类是面向对象编程的核心部分，并作为一个“容器”服务相关的数据和逻辑。</p>

<h2 id="如何定义类">如何定义类</h2>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">ClassName</span><span class="p">(</span><span class="n">base_class</span><span class="p">[</span><span class="n">es</span><span class="p">]):</span>
    <span class="s2">&#34;optional documentation string&#34;</span>
    <span class="n">static_member_declarations</span>
    <span class="n">method_declarations</span></code></pre></div>

<p>类使用<strong>class</strong>关键字声明。基类或父类可选，如果没有，使用object作为基类。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">FooClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="s2">&#34;&#34;&#34;my very first class: FooClass&#34;&#34;&#34;</span>
    <span class="n">version</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="c1"># class (data) attribute</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nm</span><span class="o">=</span><span class="s1">&#39;John Doe&#39;</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;constructor&#34;&#34;&#34;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">nm</span> <span class="c1"># class instance (data) attribute</span>
        <span class="k">print</span> <span class="s1">&#39;Created a class instance for&#39;</span><span class="p">,</span> <span class="n">nm</span>

    <span class="k">def</span> <span class="nf">showname</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;display instance attribute and class name&#34;&#34;&#34;</span>
        <span class="k">print</span> <span class="s1">&#39;Your name is&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">print</span> <span class="s1">&#39;My name is&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="k">def</span> <span class="nf">showver</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;display class(static) attribute&#34;&#34;&#34;</span>
        <span class="k">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">version</span> <span class="c1"># references FooClass.version</span>

    <span class="k">def</span> <span class="nf">addMe2Me</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span> <span class="c1"># does not use &#39;self&#39;</span>
        <span class="s2">&#34;&#34;&#34;apply + operation to argument&#34;&#34;&#34;</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span></code></pre></div>

<p><strong><strong>init</strong>()</strong>方法一个默认提供的函数，当类实例创建的时候被调用，类似一个构造器并在对象实例化后被调用。<strong>self</strong>基本上是实例自己本身的句柄，其它面向对象语言通常使用<strong>this</strong>。</p>

<h2 id="如何创建实例">如何创建实例</h2>

<p>创建实例看起来像调用一个函数，并拥有一样的语法。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="n">foo1</span> <span class="o">=</span> <span class="n">FooClass</span><span class="p">()</span>
<span class="n">Created</span> <span class="n">a</span> <span class="k">class</span> <span class="nc">instance</span> <span class="k">for</span> <span class="n">John</span> <span class="n">Doe</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">foo1</span><span class="o">.</span><span class="n">showname</span><span class="p">()</span>
<span class="n">Your</span> <span class="n">name</span> <span class="ow">is</span> <span class="n">John</span> <span class="n">Doe</span>
<span class="n">My</span> <span class="n">name</span> <span class="ow">is</span> <span class="n">FooClass</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">foo1</span><span class="o">.</span><span class="n">showver</span><span class="p">()</span>
<span class="mf">0.1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">foo1</span><span class="o">.</span><span class="n">addMe2Me</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="mi">10</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">foo1</span><span class="o">.</span><span class="n">addMe2Me</span><span class="p">(</span><span class="s1">&#39;xyz&#39;</span><span class="p">)</span>
<span class="n">xyzxyz</span></code></pre></div>

<h1 id="2-19-模块">2.19 模块</h1>

<p>一个模块是物理组织和区分相关的Python代码到独立文件的逻辑方式。一个模块可以包含可执行代码，函数，类或所有任何以上的。</p>

<p>当你创建了一个Python源文件，模块名和文件名去除扩展名一样。一旦一个模块创建了，你可以使用<strong>import</strong>语句导入模块。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">module_name</span></code></pre></div>

<p>一旦导入模块，模块的属性（函数和变量等）可以用点号访问：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">module</span><span class="o">.</span><span class="n">function</span><span class="p">()</span>
<span class="n">module</span><span class="o">.</span><span class="n">variable</span>

<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">sys</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;Hello World!</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">Hello</span> <span class="n">World</span><span class="err">!</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span>
<span class="s1">&#39;win32&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">version</span>
<span class="s1">&#39;2.4.2 (#67, Sep 28 2005, 1012) [MSC v.1310 32 bit</span>
<span class="p">(</span><span class="n">Intel</span><span class="p">)]</span><span class="s1">&#39;</span></code></pre></div>

<blockquote>
<p><strong>核心笔记：PEP是什么？</strong>
PEP是Python Enhancement Proposal。它是新特性被引进到未来版本的Python的一种方式。<a href="http://python.org/dev/peps">PEP链接</a></p>
</blockquote>

<h1 id="2-20-有用的函数">2.20 有用的函数</h1>

<table>
<thead>
<tr>
<th>函数</th>
<th align="left">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>dir([obj])</td>
<td align="left">显示obj的属性或全局变量的名字如果参数未提供</td>
</tr>

<tr>
<td>help([obj])</td>
<td align="left">显示obj的帮助文档或进入交互帮助界面如果参数未提供</td>
</tr>

<tr>
<td>int(obj)</td>
<td align="left">将obj转换为整形</td>
</tr>

<tr>
<td>len(obj)</td>
<td align="left">返回obj的长度</td>
</tr>

<tr>
<td>open(fn, mode)</td>
<td align="left">用mode打开文件fn（&rsquo;r&rsquo;读，&rsquo;w&rsquo;写）</td>
</tr>

<tr>
<td>range([start,]stop[,step])</td>
<td align="left">返回一个整形列表，从start开始到stop（不包括stop），每次增量step；start默认为0，step默认为1</td>
</tr>

<tr>
<td>raw_input(str)</td>
<td align="left">等待用户输入，str可选</td>
</tr>

<tr>
<td>str(obj)</td>
<td align="left">将obj转换为字符串</td>
</tr>

<tr>
<td>type(obj)</td>
<td align="left">返回obj的类型（本身是一个type对象）</td>
</tr>
</tbody>
</table>
]]></content>
		</item>
		
		<item>
			<title>21世纪C语言 第2章 调试，测试，文档</title>
			<link>https://gitop.cc/posts/21st-c-2/</link>
			<pubDate>Fri, 18 Dec 2015 15:48:18 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/21st-c-2/</guid>
			<description>使用调试器 关于调试器的第一个简明提示：总是使用调试器。 一个调试侦探故事 调试代码： #include &amp;lt;math.h&amp;gt;#include &amp;lt;stdio.h&amp;gt; //size_t typedef struct meanvar {double mean, var;} meanvar; meanvar mean_and_var(const double *data){ long double avg = 0, avg2 = 0; long double ratio; size_t count= 0; for(size_t</description>
			<content type="html"><![CDATA[

<h1 id="使用调试器">使用调试器</h1>

<p>关于调试器的第一个简明提示：总是使用调试器。</p>

<h2 id="一个调试侦探故事">一个调试侦探故事</h2>

<p>调试代码：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;math.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt; //size_t</span><span class="cp">
</span><span class="cp"></span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">meanvar</span> <span class="p">{</span><span class="kt">double</span> <span class="n">mean</span><span class="p">,</span> <span class="n">var</span><span class="p">;}</span> <span class="n">meanvar</span><span class="p">;</span>

<span class="n">meanvar</span> <span class="nf">mean_and_var</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">data</span><span class="p">){</span>
    <span class="kt">long</span> <span class="kt">double</span> <span class="n">avg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
          <span class="n">avg2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">double</span> <span class="n">ratio</span><span class="p">;</span>
    <span class="n">size_t</span> <span class="n">count</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>  <span class="o">!</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">ratio</span> <span class="o">=</span> <span class="n">count</span><span class="o">/</span><span class="p">(</span><span class="n">count</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">count</span> <span class="o">++</span><span class="p">;</span>
        <span class="n">avg</span>   <span class="o">*=</span> <span class="n">ratio</span><span class="p">;</span>
        <span class="n">avg2</span>  <span class="o">*=</span> <span class="n">ratio</span><span class="p">;</span>
        <span class="n">avg</span>   <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">count</span> <span class="o">+</span><span class="mf">0.0</span><span class="p">);</span>
        <span class="n">avg2</span>  <span class="o">+=</span> <span class="n">pow</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">count</span> <span class="o">+</span><span class="mf">0.0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">meanvar</span><span class="p">){.</span><span class="n">mean</span> <span class="o">=</span> <span class="n">avg</span><span class="p">,</span>
                    <span class="p">.</span><span class="n">var</span> <span class="o">=</span> <span class="n">avg2</span> <span class="o">-</span> <span class="n">pow</span><span class="p">(</span><span class="n">avg</span><span class="p">,</span> <span class="mi">2</span><span class="p">)};</span> <span class="c1">//E[x^2] - E^2[x]
</span><span class="c1"></span><span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">double</span> <span class="n">d</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">34124.75</span><span class="p">,</span> <span class="mf">34124.48</span><span class="p">,</span>
                   <span class="mf">34124.90</span><span class="p">,</span> <span class="mf">34125.31</span><span class="p">,</span>
                   <span class="mf">34125.05</span><span class="p">,</span> <span class="mf">34124.98</span><span class="p">,</span> <span class="n">NAN</span><span class="p">};</span>

    <span class="n">meanvar</span> <span class="n">mv</span> <span class="o">=</span> <span class="n">mean_and_var</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;mean: %.10g var: %.10g</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">mv</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">mv</span><span class="p">.</span><span class="n">var</span><span class="o">*</span><span class="mi">6</span><span class="o">/</span><span class="mf">5.</span><span class="p">);</span>

    <span class="kt">double</span> <span class="n">d2</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">4.75</span><span class="p">,</span> <span class="mf">4.48</span><span class="p">,</span>
                    <span class="mf">4.90</span><span class="p">,</span> <span class="mf">5.31</span><span class="p">,</span>
                    <span class="mf">5.05</span><span class="p">,</span> <span class="mf">4.98</span><span class="p">,</span> <span class="n">NAN</span><span class="p">};</span>

    <span class="n">mv</span> <span class="o">=</span> <span class="n">mean_and_var</span><span class="p">(</span><span class="n">d2</span><span class="p">);</span>
    <span class="n">mv</span><span class="p">.</span><span class="n">var</span> <span class="o">*=</span> <span class="mf">6.</span><span class="o">/</span><span class="mi">5</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;mean: %.10g var: %.10g</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">mv</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">mv</span><span class="p">.</span><span class="n">var</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>使用<strong>CFLAGS=&ldquo;-g -Wall -std=gnu11 -O3&rdquo; make stddev</strong>编译代码，<strong>gdb stddev_bugged</strong>调试代码。</p>

<p><strong>Q: 这个程序是做什么的？</strong>
A: <strong>run</strong>命令运行程序。</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">r</span>
<span class="nl">mean</span><span class="p">:</span> <span class="mf">5687.496667</span> <span class="nl">var</span><span class="p">:</span> <span class="mi">194085710</span>
<span class="nl">mean</span><span class="p">:</span> <span class="mf">0.83</span> <span class="nl">var</span><span class="p">:</span> <span class="mf">4.1334</span>
<span class="p">[</span><span class="n">Inferior</span> <span class="mi">1</span> <span class="p">(</span><span class="n">process</span> <span class="mi">22734</span><span class="p">)</span> <span class="n">exited</span> <span class="n">normally</span><span class="p">]</span></code></pre></div>

<p><strong>Q: main函数中的代码符合我们的输出吗？</strong>
A: <strong>list</strong>命令显示源代码</p>

<p><strong>Q: 我们如何查看mean_and_var发生了什么？</strong>
A: 我们想要程序在mean_and_var暂停，因此我们在那里设置一个断点：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">b</span> <span class="n">mean_and_var</span>
<span class="n">Breakpoint</span> <span class="mi">1</span> <span class="n">at</span> <span class="mh">0x400820</span><span class="o">:</span> <span class="n">file</span> <span class="n">stddev_bugged</span><span class="p">.</span><span class="n">c</span><span class="p">,</span> <span class="n">line</span> <span class="mf">16.</span></code></pre></div>

<p><strong>Q: data是我们想的那样吗？</strong>
A: 我们可以通过print简写为p查看data：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">p</span> <span class="o">*</span><span class="n">data</span>
<span class="err">$</span><span class="mi">2</span> <span class="o">=</span> <span class="mf">34124.75</span></code></pre></div>

<p>我们只得到第一个元素，但GDB有一个特殊的@语法打印数组元素。打印10个元素[LLDB: mem read -tdouble -c10 data]：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">p</span> <span class="o">*</span><span class="n">data</span><span class="err">@</span><span class="mi">10</span>
<span class="err">$</span><span class="mi">3</span> <span class="o">=</span> <span class="p">{</span><span class="mf">34124.75</span><span class="p">,</span> <span class="mf">34124.480000000003</span><span class="p">,</span> <span class="mf">34124.900000000001</span><span class="p">,</span> <span class="mf">34125.309999999998</span><span class="p">,</span> 
  <span class="mf">34125.050000000003</span><span class="p">,</span> <span class="mf">34124.980000000003</span><span class="p">,</span> <span class="n">nan</span><span class="p">(</span><span class="mh">0x8000000000000</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> 
  <span class="mf">4.9406564584124654e-324</span><span class="p">,</span> <span class="mf">2.0732560687596022e-317</span><span class="p">}</span></code></pre></div>

<p>注意表达式前面的星号，没有它，我们会得到10个地址。</p>

<p><strong>Q: 这和main发送的匹配吗？</strong>
A: 我们可以通过bt回溯：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">bt</span>
<span class="cp">#0  mean_and_var (data=data@entry=0x7fffffffdd50) at stddev_bugged.c:16
</span><span class="cp">#1  0x0000000000400520 in main () at stddev_bugged.c:38</span></code></pre></div>

<p>让我们看看data在frame 1是什么，首先切换到frame 1：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">f</span> <span class="mi">1</span>
<span class="cp">#1  0x0000000000400520 in main () at stddev_bugged.c:38
</span><span class="cp"></span><span class="mi">38</span>      <span class="n">meanvar</span> <span class="n">mv</span> <span class="o">=</span> <span class="n">mean_and_var</span><span class="p">(</span><span class="n">d</span><span class="p">);</span></code></pre></div>

<p>在这一层，data数组叫d：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">p</span> <span class="o">*</span><span class="n">d</span><span class="err">@</span><span class="mi">7</span>
<span class="err">$</span><span class="mi">5</span> <span class="o">=</span> <span class="p">{</span><span class="mf">34124.75</span><span class="p">,</span> <span class="mf">34124.480000000003</span><span class="p">,</span> <span class="mf">34124.900000000001</span><span class="p">,</span> <span class="mf">34125.309999999998</span><span class="p">,</span> 
  <span class="mf">34125.050000000003</span><span class="p">,</span> <span class="mf">34124.980000000003</span><span class="p">,</span> <span class="n">nan</span><span class="p">(</span><span class="mh">0x8000000000000</span><span class="p">)}</span></code></pre></div>

<p>我们可以返回frame 0通过f 0或与栈关联的移动：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">down</span>
<span class="cp">#0  mean_and_var (data=data@entry=0x7fffffffdd50) at stddev_bugged.c:16
</span><span class="cp"></span><span class="mi">16</span>  <span class="n">meanvar</span> <span class="n">mean_and_var</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">data</span><span class="p">){</span></code></pre></div>

<p>注意up和down参考数字顺序。由bt产生的列表，数字最小的层在最上面，up走向数字大的层，down走向数字小的层。</p>

<p><strong>Q: 这是线程的问题吗？</strong>
A: 我们可以得到一个线程列表通过info threads[LLDB: thread list]：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">info</span> <span class="n">threads</span>
  <span class="n">Id</span>   <span class="n">Target</span> <span class="n">Id</span>         <span class="n">Frame</span> 
<span class="o">*</span> <span class="mi">1</span>    <span class="n">process</span> <span class="mi">6125</span> <span class="s">&#34;stddev_bugged&#34;</span> <span class="n">mean_and_var</span> <span class="p">(</span>
    <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="err">@</span><span class="n">entry</span><span class="o">=</span><span class="mh">0x7fffffffdd50</span><span class="p">)</span> <span class="n">at</span> <span class="n">stddev_bugged</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">16</span></code></pre></div>

<p>如果有多个线程，我们可以使用thread num（GDB）或thread select num（LLDB）切换过去。GDB用户可以在.gdbinit添加set print thread-events off关闭每一个线程烦人的通知。</p>

<p><strong>Q: mean_and_var在做什么？</strong>
A: 我们可以重复步进程序的下一行：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">n</span>
<span class="mi">18</span>            <span class="n">avg2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">n</span>
<span class="mi">16</span>  <span class="n">meanvar</span> <span class="n">mean_and_var</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="o">*</span><span class="n">data</span><span class="p">){</span></code></pre></div>

<p>没有输入敲击回车重复上一个命令。还有其他的步进选项（snuc）。使用步进调试代码将会花费很多时间。且函数中有个循环，我们可以在循环中间设置一个断点：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">b</span> <span class="mi">25</span>
<span class="n">Breakpoint</span> <span class="mi">2</span> <span class="n">at</span> <span class="mh">0x400715</span><span class="o">:</span> <span class="n">file</span> <span class="n">stddev_bugged</span><span class="p">.</span><span class="n">c</span><span class="p">,</span> <span class="n">line</span> <span class="mf">25.</span></code></pre></div>

<p>现在我们有2个断点，可以使用info break查看断点列表。</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">info</span> <span class="n">b</span>
<span class="n">Num</span>     <span class="n">Type</span>           <span class="n">Disp</span> <span class="n">Enb</span> <span class="n">Address</span>            <span class="n">What</span>
<span class="mi">1</span>       <span class="n">breakpoint</span>     <span class="n">keep</span> <span class="n">y</span>   <span class="mh">0x00000000004006c0</span> <span class="n">in</span> <span class="n">mean_and_var</span> 
                                                   <span class="n">at</span> <span class="n">stddev_bugged</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">16</span>
    <span class="n">breakpoint</span> <span class="n">already</span> <span class="n">hit</span> <span class="mi">1</span> <span class="n">time</span>
<span class="mi">2</span>       <span class="n">breakpoint</span>     <span class="n">keep</span> <span class="n">y</span>   <span class="mh">0x0000000000400715</span> <span class="n">in</span> <span class="n">mean_and_var</span> 
                                                   <span class="n">at</span> <span class="n">stddev_bugged</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">25</span></code></pre></div>

<p>不再需要mean_and_var头部的断点了，可以禁止它[LLDB: break dis 1]：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">dis</span> <span class="mi">1</span></code></pre></div>

<p>你可以重新激活一个断点enable 1（GDB）或break enable 1（LLDB）。如果你不再需要一个断点可以删除它，del 1（GDB）或break del 1（LLDB）。</p>
]]></content>
		</item>
		
		<item>
			<title>21世纪C语言 第1章 便利编译配置</title>
			<link>https://gitop.cc/posts/21st-c-1/</link>
			<pubDate>Tue, 15 Dec 2015 19:55:08 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/21st-c-1/</guid>
			<description>使用包管理器 必须获取的包： * 编译器。必须安装gcc；clang可能也有用。 * gdb，调试器 * Valgrind，测试C内存使用错误。 * gpro</description>
			<content type="html"><![CDATA[

<h1 id="使用包管理器">使用包管理器</h1>

<p>必须获取的包：
* 编译器。必须安装<strong>gcc</strong>；<strong>clang</strong>可能也有用。
* <strong>gdb</strong>，调试器
* <strong>Valgrind</strong>，测试C内存使用错误。
* <strong>gprof</strong>，一个分析工具
* <strong>make</strong>，你永远不需要直接调用编译器
* <strong>pkg-config</strong>，查找库
* <strong>Doxygen</strong>，文档生成
* 文本编辑器。<strong>Emacs</strong>或<strong>vim</strong>。
* 自动工具：<strong>Autoconf</strong>，<strong>Automake</strong>，<strong>libtool</strong>。
* <strong>Git</strong>
* Shell替换品，比如Z shell。</p>

<p>一些省去重复造轮子的C库：
* <strong>libcURL</strong>
* <strong>libGLib</strong>
* <strong>libGSL</strong>
* <strong>libSQLite3</strong>
* <strong>libXML2</strong></p>

<h1 id="通向库的路径">通向库的路径</h1>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;math.h&gt;  //erf, sqrt</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt; //printf</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;The integral of a Normal(0, 1) distribution &#34;</span>
           <span class="s">&#34;between -1.96 and 1.96 is: %g</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">erf</span><span class="p">(</span><span class="mf">1.96</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mf">2.</span><span class="p">)));</span>
<span class="p">}</span></code></pre></div>

<p>编译器会将math.h和stdio.h文件内容粘贴进代码文件。math.h中的声明并没有说明erf函数做了什么。链接器负责找到erf，你需要告诉链接器-lm找到math库。-l指示一个库需要链接进来。你可以免费使用printf，因为链接器会用隐式的-lc将标准库libc链接进来。</p>

<p>如果使用gcc编译器，完整的命令包括一些额外的标志就像这样：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">gcc</span> <span class="n">erf</span><span class="p">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">erf</span> <span class="o">-</span><span class="n">lm</span> <span class="o">-</span><span class="n">g</span> <span class="o">-</span><span class="n">Wall</span> <span class="o">-</span><span class="n">O3</span> <span class="o">-</span><span class="n">std</span><span class="o">=</span><span class="n">gnu11</span></code></pre></div>

<h2 id="一些出名的标志">一些出名的标志</h2>

<p>推荐使用这些编译标志：</p>

<ul>
<li><strong>-g</strong>，为调试添加符号。</li>
<li><strong>-std=gnu11</strong>，clang-和gcc-特定，指示编译器允许遵守C11和POSIX标准的代码。POSIX标准指定系统中要有c99程序。</li>
<li><strong>-o3</strong>，指示优化等级3，会尝试任何手段编译更快的代码。如果不需要太多优化，也可以使用<strong>-o0</strong>。</li>
<li><strong>-Wall</strong>，添加编译器警告。也可以使用<strong>-w1</strong>，只显示编译器警告，没有附注。<strong>-Werror</strong>，编译器将会把警告视为错误。</li>
</ul>

<h2 id="路径">路径</h2>

<p>在一个典型配置中，库至少会安装在三个地方：
* 操作系统供应商可能会定义1到2个标准目录来安装库。
* 本地系统管理员可能有一个目录安装不想被供应商覆盖的包。
* 用户在自己主目录可能有库目录。</p>

<p>假设你有一个叫libuseful的库安装在/usr/local目录。你已经把#include <useful.h>写进代码，现在你需要使用下面的命令编译代码：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">gcc</span> <span class="o">-</span><span class="n">I</span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">include</span> <span class="n">use_useful</span><span class="p">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">use_useful</span> <span class="o">-</span><span class="n">L</span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">lib</span> <span class="o">-</span><span class="n">luseful</span></code></pre></div>

<ul>
<li><strong>-I</strong>将指定路径添加进头文件搜索路径，编译器在搜索路径搜索你包含的头文件。</li>
<li><strong>-L</strong>添加库搜索路径。</li>
<li>链接的顺序有关系。如果你有一个名字为specific.o的文件，依赖libbroad库，且libbroad库依赖libgeneral库，那么你需要，gcc specific.o -lbroad -lgeneral。任何其它的顺序都可能会失败。</li>
</ul>

<p><strong>pkg-config</strong>返回已安装库的维护信息。</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">pkg</span><span class="o">-</span><span class="n">config</span> <span class="o">--</span><span class="n">libs</span> <span class="n">gsl</span> <span class="n">libxml</span><span class="o">-</span><span class="mf">2.0</span>
<span class="n">pkg</span><span class="o">-</span><span class="n">config</span> <span class="o">--</span><span class="n">cflags</span> <span class="n">gsl</span> <span class="n">libxml</span><span class="o">-</span><span class="mf">2.0</span>

<span class="o">-</span><span class="n">lgsl</span> <span class="o">-</span><span class="n">lgslcblas</span> <span class="o">-</span><span class="n">lm</span> <span class="o">-</span><span class="n">lxml2</span>
<span class="o">-</span><span class="n">I</span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">include</span><span class="o">/</span><span class="n">libxml2</span></code></pre></div>

<p>回到前面那个命令，当你使用反撇号包含一个命令时，shell会使用其输出替换该命令。</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">gcc</span> <span class="err">`</span><span class="n">pkg</span><span class="o">-</span><span class="n">config</span> <span class="o">--</span><span class="n">cflags</span> <span class="o">--</span><span class="n">libs</span> <span class="n">gsl</span> <span class="n">libxml</span><span class="o">-</span><span class="mf">2.0</span><span class="err">`</span> <span class="o">-</span><span class="n">o</span> <span class="n">specific</span> <span class="n">specific</span><span class="p">.</span><span class="n">c</span></code></pre></div>

<p>等价于：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">gcc</span> <span class="o">-</span><span class="n">I</span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">include</span><span class="o">/</span><span class="n">libxml2</span> <span class="o">-</span><span class="n">lgsl</span> <span class="o">-</span><span class="n">lgslcblas</span> <span class="o">-</span><span class="n">lm</span> <span class="o">-</span><span class="n">lxml2</span> <span class="o">-</span><span class="n">o</span> <span class="n">specific</span> <span class="n">specific</span><span class="p">.</span><span class="n">c</span></code></pre></div>

<h2 id="运行时链接">运行时链接</h2>

<p>静态库由编译器通过拷贝库内容链接进可执行程序。共享库在运行时链接进程序，意味着和编译时一样存在库的查找问题。如果是一个在常见位置的库，运行时系统将没有查找库的问题。如果库不在标准路径，则你需要找到一种修改运行时路径查找的方法。
* 如果使用Autotools打包程序，libtool知道如何添加正确的标志，你不需要担心它。
* 当使用gcc，clang或icc基于libpath的库编译程序时，添加： LDADD=-Llibpath -Wl, -Rlibpath到makefile里面。-L标志告诉编译器去哪里查找库以确定符号；-Wl标志传递标志给链接器，链接器将指定-R标志的库嵌入运行时库的查找路径。pkg-config通常不知道运行时路径，因此需要手动输入。
* 运行时，链接器将使用另一个路径查找不在常见位置也没有-Wl,R&hellip;指定的库。这个路径在shell的启动脚本里面设置：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">export</span> <span class="n">LD_LIBRARY_PATH</span><span class="o">=</span><span class="nl">libpath</span><span class="p">:</span><span class="err">$</span><span class="n">LD_LIBRARY_PATH</span>     <span class="err">#</span><span class="n">Linux</span><span class="p">,</span> <span class="n">Cygwin</span>
<span class="n">export</span> <span class="n">DYLD_LIBRARY_PATH</span><span class="o">=</span><span class="nl">libpath</span><span class="p">:</span><span class="err">$</span><span class="n">DYLD_LIBRARY_PATH</span>    <span class="err">#</span><span class="n">OS</span> <span class="n">X</span></code></pre></div>

<h1 id="使用makefile">使用Makefile</h1>

<p><strong>makefile</strong>提供了所有这些无止境的调整的一种解决方案。它基本上是组织的一组变量和单行shell脚本的序列。POSIX标准的<strong>make</strong>程序读取<strong>makefile</strong>里面的指令和变量，并将长且单调的命令行组合给我们。</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">P</span><span class="o">=</span><span class="n">program_name</span>
<span class="n">OBJECTS</span><span class="o">=</span>
<span class="n">CFLAGS</span> <span class="o">=</span> <span class="o">-</span><span class="n">g</span> <span class="o">-</span><span class="n">Wall</span> <span class="o">-</span><span class="n">O3</span>
<span class="n">LDLIBS</span><span class="o">=</span>
<span class="n">CC</span><span class="o">=</span><span class="n">c99</span>
<span class="err">$</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">:</span> <span class="err">$</span><span class="p">(</span><span class="n">OBJECTS</span><span class="p">)</span></code></pre></div>

<p>用法：
* 一次就好：将这几行保存在.c文件同一个目录，并命名为Makefile（GNU Make）。在第一行设置你的程序名，没有.c后缀。
* 每次需要重新编译：输入<strong>make</strong>。</p>

<h2 id="设置变量">设置变量</h2>

<p><strong>shell</strong>和<strong>make</strong>使用<strong>$</strong>指示变量的值。<strong>shell</strong>使用<strong>$var</strong>，而<strong>make</strong>需要任何变量名长度大于1个字符的变量包含在括号中：<strong>$(var)</strong>。</p>

<p>有几种方法告诉<strong>make</strong>变量：
* 调用<strong>make</strong>之前设置变量并<strong>export</strong>这个变量。POSIX标准命令行设置CFLAGS变量：<strong>export CFLAGS=&lsquo;-g -Wall -O3&rsquo;</strong>
* 你可以将这些<strong>export</strong>命令放进<strong>shell</strong>启动脚本，比如.bashrc或.zshrc。
* 你可以在命令之前赋值设置一个变量。<strong>PANTS=kakhi env | grep PANTS</strong>。等号两边不能有空格，因为空格是用来区分命令和赋值的。
* 早期的<strong>makefile</strong>可以在文件头设置变量。在<strong>makefile</strong>文件里面，等号两边可以有空格。
* <strong>make</strong>允许在命令行设置变量，独立于<strong>shell</strong>。</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">make</span> <span class="n">CFLAGS</span><span class="o">=</span><span class="s">&#34;-g -Wall&#34;</span>  <span class="err">#</span> <span class="n">Set</span> <span class="n">a</span> <span class="n">makefile</span> <span class="n">variable</span><span class="p">.</span>
<span class="n">CFLAGS</span><span class="o">=</span><span class="s">&#34;-g -Wall&#34;</span> <span class="n">make</span>  <span class="err">#</span> <span class="n">Set</span> <span class="n">an</span> <span class="n">environment</span> <span class="n">variable</span> <span class="n">visible</span> <span class="n">to</span> <span class="n">make</span> <span class="n">and</span> <span class="n">its</span> <span class="n">children</span><span class="p">.</span></code></pre></div>

<h3 id="c语言中的环境变量">C语言中的环境变量</h3>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt; //getenv, atoi</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt; //printf</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">repstext</span> <span class="o">=</span> <span class="n">getenv</span><span class="p">(</span><span class="s">&#34;reps&#34;</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">reps</span> <span class="o">=</span> <span class="n">repstext</span> <span class="o">?</span> <span class="n">atoi</span><span class="p">(</span><span class="n">repstext</span><span class="p">)</span> <span class="o">:</span> <span class="mi">10</span><span class="p">;</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="n">getenv</span><span class="p">(</span><span class="s">&#34;msg&#34;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">msg</span><span class="p">)</span> <span class="n">msg</span> <span class="o">=</span> <span class="s">&#34;Hello.&#34;</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">reps</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">reps</span><span class="o">=</span><span class="mi">10</span> <span class="n">msg</span><span class="o">=</span><span class="s">&#34;Ha&#34;</span> <span class="p">.</span><span class="o">/</span><span class="n">getenv</span>
<span class="n">msg</span><span class="o">=</span><span class="s">&#34;Ha&#34;</span> <span class="p">.</span><span class="o">/</span><span class="n">getenv</span>
<span class="n">reps</span><span class="o">=</span><span class="mi">20</span> <span class="n">msg</span><span class="o">=</span><span class="s">&#34; &#34;</span> <span class="p">.</span><span class="o">/</span><span class="n">getenv</span></code></pre></div>

<p><strong>make</strong>也提供一些内置变量：
* <strong>$@</strong> 所有的目标文件。目标文件是源文件编译完生成的中间文件（.o文件）。
* <strong>$</strong>* 去掉后缀的目标文件。如果目标文件是prog.o，则<strong>$</strong>*是prog，且<strong>$</strong>*.c就是prog.c
* <strong>$&lt;</strong> 引起目标被触发并编译的文件名。如果我们编译prog.o，可能因为prog.c最近被修改了，所以<strong>$&lt;</strong>就是prog.c。</p>

<h2 id="规则">规则</h2>

<p>除了设置变量，<strong>makefile</strong>的片段具有以下形式：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="nl">target</span><span class="p">:</span> <span class="n">dependencies</span>
        <span class="n">script</span></code></pre></div>

<p>如果通过命令<strong>make target</strong>目标被调用，则依赖被检查。如果目标是一个文件，依赖也全部是文件，且目标比依赖新，则文件是最新的，没有什么事要做。否则，目标的处理被暂停，依赖被运行或生成，可能通过另一个目标，当依赖的脚本都完成了，目标的脚本开始运行。</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="nl">all</span><span class="p">:</span> <span class="n">html</span> <span class="n">doc</span> <span class="n">publish</span>
<span class="nl">doc</span><span class="p">:</span>
    <span class="n">pdflatex</span> <span class="err">$</span><span class="p">(</span><span class="n">f</span><span class="p">).</span><span class="n">tex</span>
<span class="nl">html</span><span class="p">:</span>
    <span class="n">latex</span> <span class="o">-</span><span class="n">interaction</span> <span class="n">batchmode</span> <span class="err">$</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">latex2html</span> <span class="err">$</span><span class="p">(</span><span class="n">f</span><span class="p">).</span><span class="n">tex</span>
<span class="nl">publish</span><span class="p">:</span>
    <span class="n">scp</span> <span class="err">$</span><span class="p">(</span><span class="n">f</span><span class="p">).</span><span class="n">pdf</span> <span class="err">$</span><span class="p">(</span><span class="n">Blogserver</span><span class="p">)</span></code></pre></div>

<p>在前面简单的makefile里面，我们只有一个目标/依赖/脚本组合。比如：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">P</span><span class="o">=</span><span class="n">domath</span>
<span class="n">OBJECTS</span><span class="o">=</span><span class="n">addition</span><span class="p">.</span><span class="n">o</span> <span class="n">subtraction</span><span class="p">.</span><span class="n">o</span>
<span class="err">$</span><span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">:</span> <span class="err">$</span><span class="p">(</span><span class="n">OBJECTS</span><span class="p">)</span></code></pre></div>

<p>P=domath是需要编译的程序，它依赖对象文件addition.o和substration.o。因为addition.o没有作为目标列出来，<strong>make</strong>使用隐式规则将.c文件编译成.o文件。同样的操作处理substraction.o和domath.o（GNU make隐式假定domath依赖domath.o）。当所有对象被编译时，我们没有脚本规则建立$(P)目标，GNU make填写默认脚本，链接.o文件成可执行程序。</p>

<p>POSIX标准<strong>make</strong>将.c文件编译成.o文件的默认规则：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="err">$</span><span class="p">(</span><span class="n">CC</span><span class="p">)</span> <span class="err">$</span><span class="p">(</span><span class="n">CFLAGS</span><span class="p">)</span> <span class="err">$</span><span class="p">(</span><span class="n">LDFLAGS</span><span class="p">)</span> <span class="o">-</span><span class="n">o</span> <span class="err">$@</span> <span class="err">$</span><span class="o">*</span><span class="p">.</span><span class="n">c</span></code></pre></div>

<p>$(CC)变量代表你的C编译器；POSIX标准指定默认CC=c99。$(CFLAGS)设置为之前的标志。$(LDFLAGS)没有设置因此为空。</p>

<p>GNU make将目标文件编译成可执行程序的默认规则：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="err">$</span><span class="p">(</span><span class="n">CC</span><span class="p">)</span> <span class="err">$</span><span class="p">(</span><span class="n">LDFLAGS</span><span class="p">)</span> <span class="err">$@</span> <span class="err">$</span><span class="p">(</span><span class="n">LDLIBS</span><span class="p">)</span></code></pre></div>

<p>回忆一下链接的顺序很重要，因此我们需要两个链接器变量。</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">cc</span> <span class="n">specific</span><span class="p">.</span><span class="n">o</span> <span class="o">-</span><span class="n">lbroad</span> <span class="o">-</span><span class="n">lgeneral</span>
<span class="n">LDLIBS</span><span class="o">=-</span><span class="n">lbroad</span> <span class="o">-</span><span class="n">lgeneral</span></code></pre></div>

<blockquote>
<p>如果想要看完整的make默认规则和内置变量，试一试：make -p &gt; default_rules</p>
</blockquote>

<p>这就是游戏规则：查找正确的变量并在makefile里面设置。</p>

<ul>
<li><strong>CFLAGS</strong>变量是一个根深蒂固的习俗，但是为链接器设置的变量在每个系统都不一样。甚至<strong>LDLIBS</strong>也不是POSIX标准，它只是GNU make使用。</li>
<li><strong>CFLAGS</strong>和<strong>LDLIBS</strong>变量是我们指定所有编译器标志并查找和指定库。如果你有<strong>pkg-config</strong>，使用反撇号调用。</li>
</ul>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">CFLAGS</span><span class="o">=</span><span class="err">`</span><span class="n">pkg</span><span class="o">-</span><span class="n">config</span> <span class="o">--</span><span class="n">cflags</span> <span class="n">apophenia</span> <span class="n">glib</span><span class="o">-</span><span class="mf">2.0</span><span class="err">`</span> <span class="o">-</span><span class="n">g</span> <span class="o">-</span><span class="n">Wall</span> <span class="o">-</span><span class="n">std</span><span class="o">=</span><span class="n">gnu11</span> <span class="o">-</span><span class="n">O3</span>
<span class="n">LDLIBS</span><span class="o">=</span><span class="err">`</span><span class="n">pkg</span><span class="o">-</span><span class="n">config</span> <span class="o">--</span><span class="n">libs</span> <span class="n">apophenia</span> <span class="n">glib</span><span class="o">-</span><span class="mf">2.0</span><span class="err">`</span></code></pre></div>

<p>或者手动指定<strong>-I</strong>，<strong>-L</strong>和<strong>-l</strong>标志：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">CFLAGS</span><span class="o">=-</span><span class="n">I</span><span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">b</span><span class="o">/</span><span class="n">root</span><span class="o">/</span><span class="n">include</span> <span class="o">-</span><span class="n">g</span> <span class="o">-</span><span class="n">Wall</span> <span class="o">-</span><span class="n">O3</span>
<span class="n">LDLIBS</span><span class="o">=-</span><span class="n">L</span><span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">b</span><span class="o">/</span><span class="n">root</span><span class="o">/</span><span class="n">lib</span> <span class="o">-</span><span class="n">lweirdlib</span></code></pre></div>

<ul>
<li>在你将一个库和其路径添加进<strong>LDLIBS</strong>和<strong>CFLAGS</strong>后，没有理由再去除它。你不会在意最终的可执行程序可能大一点。而且这样也可以makefile在各个工程里面不太需要修改。</li>
<li>如果你的程序需要更多C文件，在makefile中添加name.o到OBJECTS。</li>
<li>如果你的程序只有一个.c文件，你可能根本不需要makefile。你可以使用下面的方法使用make：</li>
</ul>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">export</span> <span class="n">CFLAGS</span><span class="o">=</span><span class="err">&#39;</span><span class="o">-</span><span class="n">g</span> <span class="o">-</span><span class="n">Wall</span> <span class="o">-</span><span class="n">O3</span> <span class="o">-</span><span class="n">std</span><span class="o">=</span><span class="n">gnu11</span><span class="err">&#39;</span>
<span class="n">export</span> <span class="n">LDLIBS</span><span class="o">=</span><span class="err">&#39;</span><span class="o">-</span><span class="n">lm</span><span class="err">&#39;</span>
<span class="n">make</span> <span class="n">erf</span></code></pre></div>

<h1 id="从源文件使用库">从源文件使用库</h1>

<p>可以通过编译源代码来安装库。下面用GSL（GNU Scientific Library）库作为例子。假设你有<strong>root</strong>权限：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">wget</span> <span class="nl">ftp</span><span class="p">:</span><span class="c1">//ftp.gnu.org/gnu/gsl/gsl-2.1.tar.gz
</span><span class="c1"></span><span class="n">tar</span> <span class="n">xvzf</span> <span class="n">gsl</span><span class="o">-</span><span class="mf">2.1</span><span class="p">.</span><span class="n">tar</span><span class="p">.</span><span class="n">gz</span>
<span class="n">cd</span> <span class="n">gsl</span><span class="o">-</span><span class="mf">2.1</span>
<span class="p">.</span><span class="o">/</span><span class="n">configure</span>
<span class="n">make</span>
<span class="n">sudo</span> <span class="n">make</span> <span class="n">install</span></code></pre></div>

<p>如果没有出错的话，GSL就已经安装好了。下面是一个简单的使用gsl库的程序：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;gsl/gsl_cdf.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">double</span> <span class="n">bottom_tail</span> <span class="o">=</span> <span class="n">gsl_cdf_gaussian_P</span><span class="p">(</span><span class="o">-</span><span class="mf">1.96</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Area between [-1.96, 1.96]: %g</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">bottom_tail</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>要使用你安装的库，你需要修改你的makefile，取决与你是否有<strong>pkg-config</strong>，你可以使用其中一个：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">LDLIBS</span><span class="o">=</span><span class="err">`</span><span class="n">pkg</span><span class="o">-</span><span class="n">config</span> <span class="o">--</span><span class="n">libs</span> <span class="n">gsl</span><span class="err">`</span></code></pre></div>

<p>或：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">LDLIBS</span><span class="o">=-</span><span class="n">lgsl</span> <span class="o">-</span><span class="n">lgslcblas</span> <span class="o">-</span><span class="n">lm</span></code></pre></div>

<p>如果你没有安装在标准位置且没有<strong>pkg-config</strong>，你需要添加路径：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">CFLAGS</span><span class="o">=-</span><span class="n">I</span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">include</span>
<span class="n">LDLIBS</span><span class="o">=-</span><span class="n">L</span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">lib</span> <span class="o">-</span><span class="n">Wl</span><span class="p">,</span><span class="o">-</span><span class="n">R</span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">local</span><span class="o">/</span><span class="n">lib</span></code></pre></div>

<h1 id="从源文件使用库-即使你的系统管理员不允许">从源文件使用库（即使你的系统管理员不允许）</h1>

<p>首先创建一个目录，比如：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">mkdir</span> <span class="o">~/</span><span class="n">root</span></code></pre></div>

<p>接着添加路径：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">PATH</span><span class="o">=~/</span><span class="n">root</span><span class="o">/</span><span class="nl">bin</span><span class="p">:</span><span class="err">$</span><span class="n">PATH</span></code></pre></div>

<p>在makefile中添加新路径：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">LDLIBS</span><span class="o">=-</span><span class="n">L</span><span class="err">$</span><span class="p">(</span><span class="n">HOME</span><span class="p">)</span><span class="o">/</span><span class="n">root</span><span class="o">/</span><span class="n">lib</span> <span class="p">(</span><span class="n">plus</span> <span class="n">the</span> <span class="n">other</span> <span class="n">flags</span><span class="p">,</span> <span class="n">like</span> <span class="o">-</span><span class="n">lgsl</span> <span class="o">-</span><span class="n">lm</span> <span class="p">...)</span>
<span class="n">CFLAGS</span><span class="o">=-</span><span class="n">I</span><span class="err">$</span><span class="p">(</span><span class="n">HOME</span><span class="p">)</span><span class="o">/</span><span class="n">root</span><span class="o">/</span><span class="n">include</span> <span class="p">(</span><span class="n">plus</span> <span class="o">-</span><span class="n">g</span> <span class="o">-</span><span class="n">Wall</span> <span class="o">-</span><span class="n">O3</span> <span class="p">...)</span></code></pre></div>

<p>将所要的库安装到指定路径：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="p">.</span><span class="o">/</span><span class="n">configure</span> <span class="o">--</span><span class="n">prefix</span><span class="o">=</span><span class="err">$</span><span class="n">HOME</span><span class="o">/</span><span class="n">root</span> <span class="o">&amp;&amp;</span> <span class="n">make</span> <span class="o">&amp;&amp;</span> <span class="n">make</span> <span class="n">install</span></code></pre></div>

<h1 id="通过嵌入文档编译c程序">通过嵌入文档编译C程序</h1>

<p>你已经看过编译的模式很多次了：</p>

<ol>
<li>设置一个变量代表编译的标志</li>
<li>设置一个变量代表链接的标志，每一个你使用的库包括一个-l标志</li>
<li>使用<strong>make</strong>或IDE将变量转换为完整的编译和链接命令。</li>
</ol>

<h2 id="从命令行包含头文件">从命令行包含头文件</h2>

<p><strong>gcc</strong>和<strong>clang</strong>有一个方便的标志包含头文件，比如：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">gcc</span> <span class="o">-</span><span class="n">include</span> <span class="n">stdio</span><span class="p">.</span><span class="n">h</span></code></pre></div>

<p>和这句一样：</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span></code></pre></div>

<p><strong>-include</strong>是编译器特定的。</p>

<h2 id="统一的头文件">统一的头文件</h2>

<p>为了有用，头文件必须包含<strong>typedefs</strong>，宏定义和函数声明，且不应该包含没有不会使用的定义或声明。而现在的趋势是节省用户时间，将多个头文件包含进一个头文件。</p>

<h2 id="嵌入文档">嵌入文档</h2>

<p>嵌入文档是一个POSIX标准shell的特性，你可以用在C，Python，Perl或其他。</p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">python</span> <span class="o">-</span> <span class="o">&lt;&lt;</span><span class="s">&#34;XXXX&#34;</span>
<span class="n">lines</span><span class="o">=</span><span class="mi">2</span>
<span class="n">print</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">This script is %i lines long.</span><span class="se">\n</span><span class="s">&#34;</span> <span class="o">%</span><span class="p">(</span><span class="n">lines</span><span class="p">,)</span>
<span class="n">XXXX</span></code></pre></div>

<ul>
<li>嵌入文档是shell的标准特性，因此它应该能在任何POSIX系统上工作。</li>
<li>&ldquo;XXXX&rdquo;是任意你喜欢的字符串；&rdquo;EOF&rdquo;很流行，&rdquo;&mdash;&ndash;&ldquo;看起来不错只要顶部和底部的破折号数量相同既可以。当shell看到你选择的字符串为独立的一行，它将停止发送脚本到程序stdin。</li>
<li>有一个变体以&lt;&lt;-开始，它会删除没一行开头的所有tab字符。</li>
<li>作为另一个变体，&lt;&lt;XXXX和&lt;&lt;&ldquo;XXXX&rdquo;不同。前面那个可以插入$shell_variable。</li>
</ul>

<h2 id="从标准输入编译">从标准输入编译</h2>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="n">go_libs</span><span class="o">=</span><span class="s">&#34;-lm&#34;</span>
<span class="n">go_flags</span><span class="o">=</span><span class="s">&#34;-g -Wall -include allheads.h -O3&#34;</span>
<span class="n">alias</span> <span class="n">go_c</span><span class="o">=</span><span class="s">&#34;c99 -xc - $go_libs $go_flags&#34;</span>
<span class="n">go_c</span> <span class="o">&lt;&lt;</span> <span class="err">&#39;</span><span class="o">---</span><span class="err">&#39;</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span><span class="n">printf</span><span class="p">(</span><span class="s">&#34;Hello from the command line.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);}</span>
<span class="o">---</span>
<span class="p">.</span><span class="o">/</span><span class="n">a</span><span class="p">.</span><span class="n">out</span></code></pre></div>
]]></content>
		</item>
		
		<item>
			<title>第16章 模板和泛型编程</title>
			<link>https://gitop.cc/posts/cpp-primer-16/</link>
			<pubDate>Mon, 14 Dec 2015 10:34:42 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/cpp-primer-16/</guid>
			<description>面向对象编程和泛型编程都是处理程序编写时类型未知的情况。两者的区别是面向对象编程直到运行时类型才能知道，而泛型编程类型在编译期间知道。 容器，</description>
			<content type="html"><![CDATA[

<p>面向对象编程和泛型编程都是处理程序编写时类型未知的情况。两者的区别是面向对象编程直到运行时类型才能知道，而泛型编程类型在编译期间知道。</p>

<p>容器，迭代器和算法都是泛型编程的例子。当编写一个泛型程序，我们用一种独立于任何类型的方式编写代码。当使用一个泛型程序，我们提供程序的实例将操作的类型或值。</p>

<p>模板是C++中泛型编程的基础。模板是一个创建类或函数的公式或蓝图。当我们使用一个泛型类型，我们提供将蓝图转换为指定类或函数所需的信息。这个转换发生在编译期间。</p>

<h1 id="16-1-定义一个模板">16.1 定义一个模板</h1>

<p>想象我们要写一个函数比较两个值的大小。实际中，我们要定义多个这样的函数，每一个比较指定类型的值。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// returns 0 if the values are equal, -1 if v1 is smaller, 1 if v2 is smaller
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v1</span> <span class="o">&lt;</span> <span class="n">v2</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v2</span> <span class="o">&lt;</span> <span class="n">v1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v1</span> <span class="o">&lt;</span> <span class="n">v2</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v2</span> <span class="o">&lt;</span> <span class="n">v1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>这样的函数几乎相同：唯一不同是参数的类型不同，每一个函数体都相同。</p>

<h2 id="16-1-1-函数模板">16.1.1 函数模板</h2>

<p>我们定义一个函数模板而不是为每一种类型定义一个新函数。一个函数模板是一个公式，从这个公式我们能够生成指定类型的函数。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v1</span> <span class="o">&lt;</span> <span class="n">v2</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v2</span> <span class="o">&lt;</span> <span class="n">v1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>模板定义开始于关键字<strong>template</strong>后面跟着模板参数列表。模板参数列表由&lt;&gt;括起来，逗号分隔的一个或多个模板参数组成。</p>

<blockquote>
<p><strong>注释</strong>
在模板定义中，模板参数列表不能为空。</p>
</blockquote>

<p>模板参数列表的行为非常像函数的参数列表。模板参数表示用在类或函数定义中的类型或值。当我们使用一个模板，我们指定一个（隐式或显式）模板实参绑定到模板参数。</p>

<h3 id="实例化函数模板">实例化函数模板</h3>

<p>当我们调用一个函数模板，编译器使用函数调用的实参为我们推导模板实参。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">compare</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>       <span class="c1">// T is int
</span></code></pre></div>

<p>编译器使用推导的模板参数来为我们实例化指定版本的函数。当编译器实例化一个模板，它使用实际的模板实参创建一个新的模板实例代替相应的模板参数。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// instantiates int compare(const int&amp;, const int&amp;)
</span><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">compare</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>       <span class="c1">// T is int
</span><span class="c1">// instantiates int compare(const vector&lt;int&gt;&amp;, const vector&lt;int&gt;&amp;)
</span><span class="c1"></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec1</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="n">vec2</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">compare</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// T is vector&lt;int&gt;
</span></code></pre></div>

<h3 id="模板类型参数">模板类型参数</h3>

<p>一般而言，我们可以和使用内置类型或类类型一样的方式使用类型参数作为类型说明符。特别地，类型参数可以用来命名一个返回类型，函数参数类型，变量声明或函数内类型转换。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// ok: same type used for the return type and parameter
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">foo</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="c1">// tmp will have the type to which p points
</span><span class="c1"></span>    <span class="c1">// ...
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>每一个类型参数之前必须有<strong>class</strong>或<strong>typename</strong>关键字。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// error: must precede U with either typename or class
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">calc</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">U</span><span class="o">&amp;</span><span class="p">);</span>
</code></pre></div>

<p>使用关键字<strong>typename</strong>指定模板类型参数比<strong>class</strong>似乎更直观。毕竟我们可以使用内置（非类类型）类型作为模板的类型实参。而且<strong>typename</strong>更加清晰地指示了跟在它后面的名字是一个类型名。但是，<strong>typename</strong>是在模板广泛使用之后才被加入C++的。</p>

<h3 id="非类型模板参数">非类型模板参数</h3>

<p>除了定义类型参数，我们还能定义非类型的模板参数。一个非类型参数代表一个值而不是类型。非类型参数由一个指定的类型名指定而不是<strong>class</strong>或<strong>typename</strong>关键字。</p>

<p>当模板实例化时，非类型参数被用户提供的或编译器推导的一个值替换。这些值必须是常量表达式，以允许编译器在编译期间实例化模板。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="n">N</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">M</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">p1</span><span class="p">)[</span><span class="n">N</span><span class="p">],</span> <span class="k">const</span> <span class="kt">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">p2</span><span class="p">)[</span><span class="n">M</span><span class="p">])</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nf">strcmp</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">compare</span><span class="p">(</span><span class="s">&#34;hi&#34;</span><span class="p">,</span> <span class="s">&#34;mom&#34;</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">p1</span><span class="p">)[</span><span class="mi">3</span><span class="p">],</span> <span class="k">const</span> <span class="kt">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">p2</span><span class="p">)[</span><span class="mi">4</span><span class="p">])</span>
</code></pre></div>

<p>一个非类型参数可能是整型，对象或函数的指针或（左值）引用。绑定到非类型的整型参数的实参必须是常量表达式。绑定到指针或引用的非类型参数必须拥有静态生命周期。不能使用普通（非静态）局部对象或动态分配的对象作为模板实参传给指针或引用的非类型模板参数。指针参数也能用<strong>nullptr</strong>或0值常量表达式初始化。</p>

<blockquote>
<p><strong>注释</strong>
用于非类型模板参数的模板实参必须是常量表达式。</p>
</blockquote>

<h3 id="inline和constexpr函数模板">inline和constexpr函数模板</h3>

<p>和非模板函数一样，函数模板可以被声明为<strong>inline</strong>或<strong>constexpr</strong>。<strong>inline</strong>或<strong>constexpr</strong>限定符跟在模板参数列表之后，函数返回类型之前。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// ok: inline specifier follows the template parameter list
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kr">inline</span> <span class="n">T</span> <span class="n">min</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
<span class="c1">// error: incorrect placement of the inline specifier
</span><span class="c1"></span><span class="kr">inline</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">min</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
</code></pre></div>

<h3 id="编写类型独立的代码">编写类型独立的代码</h3>

<p>尽管简单，compare函数展示了编写泛型代码的两个重要原则：
* 模板中的函数参数是const引用
* 函数体中的比较只使用&lt;</p>

<p>只使用&lt;运算符，我们降低了对使用compare函数的类型的要求。这些类型只需要支持&lt;，没有必要支持&gt;。实际上，如果我们真正关心类型独立和可移植性，我们可能应该使用<strong>less</strong>定义函数。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// version of compare that will be correct even if used on pointers; see § 14.8.2 (p.
</span><span class="c1"></span><span class="mi">575</span><span class="p">)</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">less</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">))</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">less</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v1</span><span class="p">))</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<blockquote>
<p><strong>最佳实践</strong>
模板程序应该尽量减少作用在参数类型的要求的数量。</p>
</blockquote>

<h3 id="模板编译">模板编译</h3>

<p>当编译器看到模板的定义，并没有生成代码。只有当实例化一个指定的模板实例的时候生成代码。只有使用模板时生成代码的事实影响我们如何组织源代码和如何检测错误。</p>

<p>通常当我们调用一个函数，编译器只需要看到函数的声明。类似地，当我们使用类对象，类定义必须可用，但是成员函数的定义不需要提供。因此，我们把类定义和函数声明放在头文件而普通函数和成员函数放在源文件。</p>

<p>模板不一样：为了生成一个模板实例，编译器需要定义函数模板或类模板成员函数的代码。因此不像非模板代码，模板头文件既包含了定义也包含了声明。</p>

<blockquote>
<p><strong>注释</strong>
函数模板和类模板成员函数的定义通常放进头文件。</p>

<p><strong>关键概念：模板和头文件</strong>
模板包含两种名字：
* 那些不依赖模板参数的名字
* 那些依赖模板参数的名字</p>

<p>由模板的提供者保证当模板使用时所有不依赖模板参数的名字可见。而且，模板的提供者必须保证当模板实例化的时候模板的定义，包括类模板成员的定义可见。由模板的用户保证用来实例化模板所有的函数，类型和类型相关的操作符可见。
模板的作者应该提供一个头文件，包含模板定义，连同所有类模板或成员定义中使用的名字的声明。模板用户必须包含模板头文件和任意用来实例化模板的类型。</p>
</blockquote>

<h3 id="实例化期间最常报的编译错误">实例化期间最常报的编译错误</h3>

<p>第一个阶段是编译模板自己的时候。编译器在这个阶段通常不能找到很多错误。编译器能查找出语法错误，比如忘记标点或变量拼写错误。</p>

<p>第二个阶段是编译器看到模板的使用的时候。这个阶段也没有很多需要检查。对于一个函数模板调用，编译器只是检查参数的个数是否合适。也可以检查两个类型应该一样的参数是否真的相同。对于类模板，编译器能检查正确的模板参数个数。</p>

<p>第三个阶段是实例化的时候。只有这个时候类型相关的错误才能被发现。取决于编译器如何处理实例化，这些错误可能会在链接时报告。</p>

<blockquote>
<p><strong>警告</strong>
由调用者保证传递给模板的参数支持模板使用到的任意操作，且这些操作在模板使用的上下文环境表现正确。</p>
</blockquote>

<h2 id="16-1-2-类模板">16.1.2 类模板</h2>

<p>类模板是产生类的蓝图。和函数模板不同，编译器不能为类模板推导模板参数。因此为了使用类模板，我们必须在模板名字后面的尖括号里面提供额外的信息。这些信息就是用来代替模板参数的模板实参列表。</p>

<h3 id="定义一个类模板">定义一个类模板</h3>

<p>和函数模板一样，类模板以<strong>template</strong>关键字开头，后跟一个模板参数列表。在类模板（和它的成员）的定义中，我们使用模板参数作为当模板使用时提供的类型或值的替身。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Blob</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">typedef</span> <span class="n">T</span> <span class="n">value_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">size_type</span> <span class="n">size_type</span><span class="p">;</span>
    <span class="c1">// constructors
</span><span class="c1"></span>    <span class="n">Blob</span><span class="p">();</span>
    <span class="n">Blob</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span>
    <span class="c1">// number of elements in the Blob
</span><span class="c1"></span>    <span class="n">size_type</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">();</span> <span class="p">}</span>
    <span class="c1">// add and remove elements
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">t</span><span class="p">);}</span>
    <span class="c1">// move version; see § 13.6.3 (p. 548)
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t</span><span class="p">));</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">pop_back</span><span class="p">();</span>
    <span class="c1">// element access
</span><span class="c1"></span>    <span class="n">T</span><span class="o">&amp;</span> <span class="n">back</span><span class="p">();</span>
    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">size_type</span> <span class="n">i</span><span class="p">);</span> <span class="c1">// defined in § 14.5 (p. 566)
</span><span class="c1"></span><span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">data</span><span class="p">;</span>
    <span class="c1">// throws msg if data[i] isn&#39;t valid
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">check</span><span class="p">(</span><span class="n">size_type</span> <span class="n">i</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="实例化一个类模板">实例化一个类模板</h3>

<p>当我们使用一个类模板时，必须提供额外的信息。这些额外的信息是显式模板实参列表。编译器使用这些模板实参来实例化一个指定类。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Blob</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ia</span><span class="p">;</span>                <span class="c1">// empty Blob&lt;int&gt;
</span><span class="c1"></span><span class="n">Blob</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ia2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span> <span class="c1">// Blob&lt;int&gt; with five elements
</span><span class="c1"></span>
<span class="k">template</span> <span class="o">&lt;&gt;</span> <span class="k">class</span> <span class="nc">Blob</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">size_type</span> <span class="n">size_type</span><span class="p">;</span>
    <span class="n">Blob</span><span class="p">();</span>
    <span class="n">Blob</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="kt">int</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">size_type</span> <span class="n">i</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">data</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">check</span><span class="p">(</span><span class="n">size_type</span> <span class="n">i</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>当编译器从Blob模板实例化一个类时，它重写了Blob模板，用int替换掉每一个模板参数T。编译器为每一个我们指定的类型生成一个不同的类。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// these definitions instantiate two distinct Blob types
</span><span class="c1"></span><span class="n">Blob</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">names</span><span class="p">;</span> <span class="c1">// Blob that holds strings
</span><span class="c1"></span><span class="n">Blob</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">prices</span><span class="p">;</span><span class="c1">// different element type
</span></code></pre></div>

<blockquote>
<p><strong>注释</strong>
每一个类模板的实例化构成了一个独立的类。类型Blob<string>和任何其它的Blob类型没有关系，也没有任何特殊权限访问其它Blob类型的成员。</p>
</blockquote>

<h3 id="模板作用域中模板类型的引用">模板作用域中模板类型的引用</h3>

<p>类模板用来实例化一个类型，且被实例化的类型总是包含模板实参。类模板中的代码通常不使用实际类型（或值）的名字作为模板实参。相反，我们经常使用模板自己的参数作为模板实参。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">data</span><span class="p">;</span>
<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span>
</code></pre></div>

<h3 id="类模板成员函数">类模板成员函数</h3>

<p>和任意其它类一样，我们能够在类里面或外面定义类模板的成员函数。定义在类里面的成员函数默认为<strong>inline</strong>。类模板成员函数本身是个普通函数。但是类模板每一个实例都拥有自己版本的成员。因此类模板的成员函数拥有和类模板相同的模板参数。所以定义在类模板外面的成员函数以关键字<strong>template</strong>开头，后接类模板参数列表。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">ret</span><span class="o">-</span><span class="n">type</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">member</span><span class="o">-</span><span class="n">name</span><span class="p">(</span><span class="n">parm</span><span class="o">-</span><span class="n">list</span><span class="p">)</span>
</code></pre></div>

<h3 id="check和元素访问成员">check和元素访问成员</h3>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">check</span><span class="p">(</span><span class="n">size_type</span> <span class="n">i</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">())</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="o">&amp;</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">back</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">check</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&#34;back on empty Blob&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="o">&amp;</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">operator</span><span class="p">[](</span><span class="n">size_type</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// if i is too big, check will throw, preventing access to a nonexistent element
</span><span class="c1"></span>    <span class="n">check</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s">&#34;subscript out of range&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> 
<span class="kt">void</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">pop_back</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">check</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&#34;pop_back on empty Blob&#34;</span><span class="p">);</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">pop_back</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="blob构造函数">Blob构造函数</h3>

<p>和其它定义在类模板外面的成员函数一样，构造函数以声明模板参数开始。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Blob</span><span class="p">()</span><span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">())</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Blob</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">)</span><span class="o">:</span>
              <span class="n">data</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">il</span><span class="p">))</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div>

<h3 id="类模板成员函数实例化">类模板成员函数实例化</h3>

<p>默认地，类模板的成员函数只有在程序使用这个函数时实例化。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// instantiates Blob&lt;int&gt; and the initializer_list&lt;int&gt; constructor
</span><span class="c1"></span><span class="n">Blob</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">squares</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span>
<span class="c1">// instantiates Blob&lt;int&gt;::size() const
</span><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">squares</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">squares</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">;</span> <span class="c1">// instantiates Blob&lt;int&gt;::operator[](size_t)
</span></code></pre></div>

<p>成员只有在使用时实例化这个事实使我们可以用一个可能不满足某些模板操作要求的类型实例化一个类。</p>

<blockquote>
<p><strong>注释</strong>
默认地，一个实例化的类模板的成员只有当成员使用时才实例化。</p>
</blockquote>

<h3 id="类代码里面简化模板类名的使用">类代码里面简化模板类名的使用</h3>

<p>使用一个类模板类型必须提供一个模板实参有一个例外，在类模板作用域里面，我们可以不带模板实参使用模板名字。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// BlobPtr throws an exception on attempts to access a nonexistent element
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">BlobPtr</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">BlobPtr</span><span class="p">()</span><span class="o">:</span> <span class="n">curr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="n">BlobPtr</span><span class="p">(</span><span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span>
            <span class="n">wptr</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">data</span><span class="p">),</span> <span class="n">curr</span><span class="p">(</span><span class="n">sz</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span> <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">check</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="s">&#34;dereference past end&#34;</span><span class="p">);</span>
      <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="n">curr</span><span class="p">];</span>  <span class="c1">// (*p) is the vector to which this object points
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="c1">// increment and decrement
</span><span class="c1"></span>    <span class="n">BlobPtr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">();</span>        <span class="c1">// prefix operators
</span><span class="c1"></span>    <span class="n">BlobPtr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">--</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="c1">// check returns a shared_ptr to the vector if the check succeeds
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
        <span class="n">check</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">// store a weak_ptr, which means the underlying vector might be destroyed
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">wptr</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">curr</span><span class="p">;</span>      <span class="c1">// current position within the array
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div>

<h3 id="在类模板外面使用类模板名字">在类模板外面使用类模板名字</h3>

<p>当我们在类模板外面定义成员时，必须记住我们不在类的作用域直到类名被看见。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// postfix: increment/decrement the object but return the unchanged value
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">BlobPtr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">BlobPtr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// no check needed here; the call to prefix increment will do the check
</span><span class="c1"></span>    <span class="n">BlobPtr</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>  <span class="c1">// save the current value
</span><span class="c1"></span>    <span class="o">++*</span><span class="k">this</span><span class="p">;</span>    <span class="c1">// advance one element; prefix ++ checks the increment
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>  <span class="c1">// return the saved state
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<p>当我们没有提供模板实参，编译器假设我们使用成员实例化一样的类型。因此，ret的定义就好像：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">BlobPtr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</code></pre></div>

<blockquote>
<p><strong>注释</strong>
在类模板作用域里面，我们可以使用模板，而不指定模板实参。</p>
</blockquote>

<h3 id="类模板和友元">类模板和友元</h3>

<p>当一个类包含友元声明时，类和友元各自可以是模板或非模板。一个有非模板的友元的类模板授予其友元访问模板所有实例。当友元本身也是模板时，授予友元关系的类控制友元模板所有实例或指定实例友元关系。</p>

<h3 id="一对一友元关系">一对一友元关系</h3>

<p>从一个类模板到另一个模板（类模板或函数模板）建立相应实例之间的友元关系是最常见友元关系形式。为了引用一个指定的模板实例（类模板或函数模板），我们必须先声明模板。一个模板声明包含模板参数列表。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// forward declarations needed for friend declarations in Blob
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">BlobPtr</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Blob</span><span class="p">;</span> <span class="c1">// needed for parameters in operator==
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Blob</span> <span class="p">{</span>
    <span class="c1">// each instantiation of Blob grants access to the version of
</span><span class="c1"></span>    <span class="c1">// BlobPtr and the equality operator instantiated with the same type
</span><span class="c1"></span>    <span class="k">friend</span> <span class="k">class</span> <span class="nc">BlobPtr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==&lt;</span><span class="n">T</span><span class="o">&gt;</span>
           <span class="p">(</span><span class="k">const</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span><span class="p">);</span>
    <span class="c1">// other members as in § 12.1.1 (p. 456)
</span><span class="c1"></span><span class="p">};</span>

<span class="n">Blob</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">ca</span><span class="p">;</span> <span class="c1">// BlobPtr&lt;char&gt; and operator==&lt;char&gt; are friends
</span><span class="c1"></span><span class="n">Blob</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ia</span><span class="p">;</span>  <span class="c1">// BlobPtr&lt;int&gt; and operator==&lt;int&gt; are friends
</span></code></pre></div>

<h3 id="通用和指定模板友元">通用和指定模板友元</h3>

<p>一个类也可以指定另一个模板的每一个实例为友元，或限制指定实例为友元：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// forward declaration necessary to befriend a specific instantiation of a template
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Pal</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>  <span class="c1">//  C is an ordinary, nontemplate class
</span><span class="c1"></span>    <span class="k">friend</span> <span class="k">class</span> <span class="nc">Pal</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">// Pal instantiated with class C is a friend to C
</span><span class="c1"></span>    <span class="c1">// all instances of Pal2 are friends to C;
</span><span class="c1"></span>    <span class="c1">// no forward declaration required when we befriend all instantiations
</span><span class="c1"></span>    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">friend</span> <span class="k">class</span> <span class="nc">Pal2</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">C2</span> <span class="p">{</span> <span class="c1">// C2 is itself a class template
</span><span class="c1"></span>    <span class="c1">// each instantiation of C2 has the same instance of Pal as a friend
</span><span class="c1"></span>    <span class="k">friend</span> <span class="k">class</span> <span class="nc">Pal</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">// a template declaration for Pal must be in scope
</span><span class="c1"></span>    <span class="c1">// all instances of Pal2 are friends of each instance of C2, prior declaration needed
</span><span class="c1"></span>    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">X</span><span class="o">&gt;</span> <span class="k">friend</span> <span class="k">class</span> <span class="nc">Pal2</span><span class="p">;</span>
    <span class="c1">// Pal3 is a nontemplate class that is a friend of every instance of C2
</span><span class="c1"></span>    <span class="k">friend</span> <span class="k">class</span> <span class="nc">Pal3</span><span class="p">;</span>    <span class="c1">// prior declaration for Pal3 not needed
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div>

<p>为了允许所有的实例都是友元，友元声明必须使用跟类不一样的模板参数。</p>

<h3 id="模板类型参数作为友元">模板类型参数作为友元</h3>

<p>在新标准下，我们可以将模板类型参数作为友元：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Bar</span> <span class="p">{</span>
<span class="k">friend</span> <span class="n">Type</span><span class="p">;</span> <span class="c1">// grants access to the type used to instantiate Bar
</span><span class="c1"></span>    <span class="c1">//  ...
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div>

<p>值得注意的是尽管友元通常必须是一个类或函数，用内置类型实例化类Bar也可以，因此友元为内置类型在这种情况也允许。</p>

<h3 id="模板类型别名">模板类型别名</h3>

<p>类模板的一个实例定义了一个类类型，和其它类类型一样，我们可以使用<strong>typedef</strong>引用它：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="n">Blob</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">StrBlob</span><span class="p">;</span>
</code></pre></div>

<p>因为模板不是一个类型，我们不能使用<strong>typedef</strong>引用一个模板，即没有办法用<strong>typedef</strong>引用Blob<T>。但是新标准允许我们为类模板定义一个类型别名：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">using</span> <span class="n">twin</span> <span class="o">=</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">twin</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">authors</span><span class="p">;</span> <span class="c1">// authors is a pair&lt;string, string&gt;
</span></code></pre></div>

<p>模板类型别名是一个类家庭的同义词：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">twin</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">win_loss</span><span class="p">;</span>  <span class="c1">// win_loss is a pair&lt;int, int&gt;
</span><span class="c1"></span><span class="n">twin</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">area</span><span class="p">;</span>   <span class="c1">// area is a pair&lt;double, double&gt;
</span></code></pre></div>

<p>当我们定义一个模板类型别名，我们可以固定一个或多个模板参数：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">using</span> <span class="n">partNo</span> <span class="o">=</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">unsigned</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">partNo</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">books</span><span class="p">;</span>  <span class="c1">// books is a pair&lt;string, unsigned&gt;
</span><span class="c1"></span><span class="n">partNo</span><span class="o">&lt;</span><span class="n">Vehicle</span><span class="o">&gt;</span> <span class="n">cars</span><span class="p">;</span>  <span class="c1">// cars is a pair&lt;Vehicle, unsigned&gt;
</span><span class="c1"></span><span class="n">partNo</span><span class="o">&lt;</span><span class="n">Student</span><span class="o">&gt;</span> <span class="n">kids</span><span class="p">;</span>  <span class="c1">// kids is a pair&lt;Student, unsigned&gt;
</span></code></pre></div>

<h3 id="类模板的静态成员">类模板的静态成员</h3>

<p>和其它类一样，类模板可以声明静态成员：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">count</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ctr</span><span class="p">;</span> <span class="p">}</span>
   <span class="c1">// other interface members
</span><span class="c1"></span><span class="k">private</span><span class="o">:</span>
   <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">ctr</span><span class="p">;</span>
   <span class="c1">// other implementation members
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div>

<p>每一个Foo的实例都有自己静态成员。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// instantiates static members Foo&lt;string&gt;::ctr and Foo&lt;string&gt;::count
</span><span class="c1"></span><span class="n">Foo</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">fs</span><span class="p">;</span>
<span class="c1">// all three objects share the same Foo&lt;int&gt;::ctr and Foo&lt;int&gt;::count members
</span><span class="c1"></span><span class="n">Foo</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">fi</span><span class="p">,</span> <span class="n">fi2</span><span class="p">,</span> <span class="n">fi3</span><span class="p">;</span>
</code></pre></div>

<p>和其它静态数据成员一样，类模板的每一个静态数据成员必须只有一个定义。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">size_t</span> <span class="n">Foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">ctr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// define and initialize ctr
</span></code></pre></div>

<p>必须引用指定的实例来访问静态成员。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Foo</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">fi</span><span class="p">;</span>                 <span class="c1">// instantiates Foo&lt;int&gt; class
</span><span class="c1"></span>                             <span class="c1">// and the static data member ctr
</span><span class="c1"></span><span class="k">auto</span> <span class="n">ct</span> <span class="o">=</span> <span class="n">Foo</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">count</span><span class="p">();</span> <span class="c1">// instantiates Foo&lt;int&gt;::count
</span><span class="c1"></span><span class="n">ct</span> <span class="o">=</span> <span class="n">fi</span><span class="p">.</span><span class="n">count</span><span class="p">();</span>             <span class="c1">// uses Foo&lt;int&gt;::count
</span><span class="c1"></span><span class="n">ct</span> <span class="o">=</span> <span class="n">Foo</span><span class="o">::</span><span class="n">count</span><span class="p">();</span>           <span class="c1">// error: which template instantiation?
</span></code></pre></div>

<p>和其它成员函数一样，静态成员函数只有在程序中使用时才实例化。</p>

<h2 id="16-1-3-模板参数">16.1.3 模板参数</h2>

<p>和函数参数的名字一样，模板参数的名字没有实质意义。我们通常命名类型参数为T，也可以使用人用名字：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Foo</span><span class="o">&gt;</span> <span class="n">Foo</span> <span class="n">calc</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Foo</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// tmp has the same type as the parameters and return type
</span><span class="c1"></span>    <span class="c1">// ...
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>  <span class="c1">// return type and parameters have the same type
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<h3 id="模板参数和作用域">模板参数和作用域</h3>

<p>模板参数遵循正常的作用域规则。模板参数的名字在声明之后直到模板声明或定义结束之前都能使用。和其它名字一样，模板参数名隐藏任何外围声明的名字。但是一个被用来作为模板参数的名字在模板内不能被重复使用。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="kt">double</span> <span class="n">A</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">B</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">A</span> <span class="n">a</span><span class="p">,</span> <span class="n">B</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">A</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// tmp has same type as the template parameter A, not double
</span><span class="c1"></span>    <span class="kt">double</span> <span class="n">B</span><span class="p">;</span>  <span class="c1">// error: redeclares template parameter B
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<p>因为模板参数名不能重复使用，模板参数列表中的每一个模板参数名只能出现一次：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// error: illegal reuse of template parameter name V
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">V</span><span class="p">,</span> <span class="k">typename</span> <span class="n">V</span><span class="o">&gt;</span> <span class="c1">// ...
</span></code></pre></div>

<h3 id="模板声明">模板声明</h3>

<p>模板声明必须包含模板参数：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// declares but does not define compare and Blob
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Blob</span><span class="p">;</span>
</code></pre></div>

<p>和函数参数一样，模板参数名不需要和定义中的模板参数名一样：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// all three uses of calc refer to the same function template
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">calc</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// declaration
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span> <span class="n">U</span> <span class="n">calc</span><span class="p">(</span><span class="k">const</span> <span class="n">U</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">U</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// declaration
</span><span class="c1">// definition of the template
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="o">&gt;</span>
<span class="n">Type</span> <span class="n">calc</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* . . . */</span> <span class="p">}</span>
</code></pre></div>

<p>当然，模板的每一个声明和定义参数的数量和种类（类型或非类型）必须一样。</p>

<blockquote>
<p><strong>最佳实践</strong>
一个文件需要的所有模板的声明通常应该一起出现在文件开头，在任何代码使用这些名字之前。</p>
</blockquote>

<h3 id="使用为类型的类成员">使用为类型的类成员</h3>

<p>我们可以使用作用域操作符（::）访问<strong>static</strong>成员和类型成员。假设T是一个模板类型参数，当编译器看到T::mem时，在实例化前它不知道mem是一个类型还是静态数据成员。但是为了处理模板，编译器必须知道一个名字是否代表类型。比如下面这个例子：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">T</span><span class="o">::</span><span class="n">size_type</span> <span class="o">*</span> <span class="n">p</span><span class="p">;</span>
</code></pre></div>

<p>编译器需要知道这是定义一个变量p还是静态数据成员与p相乘。语言默认假设通过作用域操作符访问的名字不是一个类型。因此如果我们想要使用模板类型参数的类型成员，我们必须显式告诉编译器这个名字是一个类型。我们使用关键字<strong>typename</strong>来做这件事：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span> <span class="n">top</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">value_type</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<blockquote>
<p><strong>注释</strong>
当我们通知编译器一个名字代表类型时，必须使用关键字<strong>typename</strong>，而不是<strong>class</strong>。</p>
</blockquote>

<h3 id="默认模板实参">默认模板实参</h3>

<p>就像我们能够给函数参数提供默认实参，我们也能提供默认模板实参。新标准下，我们能给函数模板和类模板提供默认实参。早先的版本只允许类模板有默认实参。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// compare has a default template argument, less&lt;T&gt;
</span><span class="c1">// and a default function argument, F()
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">F</span> <span class="o">=</span> <span class="n">less</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
<span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">v2</span><span class="p">,</span> <span class="n">F</span> <span class="n">f</span> <span class="o">=</span> <span class="n">F</span><span class="p">())</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">))</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v1</span><span class="p">))</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">i</span> <span class="o">=</span> <span class="n">compare</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span> <span class="c1">// uses less; i is -1
</span><span class="c1">// result depends on the isbns in item1 and item2
</span><span class="c1"></span><span class="n">Sales_data</span> <span class="nf">item1</span><span class="p">(</span><span class="n">cin</span><span class="p">),</span> <span class="n">item2</span><span class="p">(</span><span class="n">cin</span><span class="p">);</span>
<span class="kt">bool</span> <span class="n">j</span> <span class="o">=</span> <span class="n">compare</span><span class="p">(</span><span class="n">item1</span><span class="p">,</span> <span class="n">item2</span><span class="p">,</span> <span class="n">compareIsbn</span><span class="p">);</span>
</code></pre></div>

<h3 id="模板默认实参和类模板">模板默认实参和类模板</h3>

<p>不管什么时候使用类模板，我们必须在模板名后面跟尖括号。尖括号指示类必须从模板实例化。特别地，如果一个类模板为所有模板参数提供了默认实参，且我们使用这些默认值，我们必须在模板名后面放一对空的尖括号：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span> <span class="o">=</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Numbers</span> <span class="p">{</span>   <span class="c1">// by default T is int
</span><span class="c1"></span><span class="k">public</span><span class="o">:</span>
    <span class="n">Numbers</span><span class="p">(</span><span class="n">T</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="c1">// various operations on numbers
</span><span class="c1"></span><span class="k">private</span><span class="o">:</span>
    <span class="n">T</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">Numbers</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">lots_of_precision</span><span class="p">;</span>
<span class="n">Numbers</span><span class="o">&lt;&gt;</span> <span class="n">average_precision</span><span class="p">;</span> <span class="c1">// empty &lt;&gt; says we want the default type
</span></code></pre></div>

<h2 id="16-1-4-成员模板">16.1.4 成员模板</h2>

<p>一个类（不管是普通类还是类模板）可能有本身是模板的成员函数。这种成员被称为成员模板。成员模板不能是虚函数。</p>

<h3 id="普通类的成员模板">普通类的成员模板</h3>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// function-object class that calls delete on a given pointer
</span><span class="c1"></span><span class="k">class</span> <span class="nc">DebugDelete</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">DebugDelete</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">s</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="p">)</span><span class="o">:</span> <span class="n">os</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="c1">// as with any function template, the type of T is deduced by the compiler
</span><span class="c1"></span>    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">T</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="k">const</span>
      <span class="p">{</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;deleting unique_ptr&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>和其他模板一样，一个成员模板以它自己的模板参数列表开始。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">double</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">;</span>
<span class="n">DebugDelete</span> <span class="n">d</span><span class="p">;</span>    <span class="c1">// an object that can act like a delete expression
</span><span class="c1"></span><span class="n">d</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// calls DebugDelete::operator()(double*), which deletes p
</span><span class="c1"></span><span class="kt">int</span><span class="o">*</span> <span class="n">ip</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span>
<span class="c1">// calls operator()(int*) on a temporary DebugDelete object
</span><span class="c1"></span><span class="n">DebugDelete</span><span class="p">()(</span><span class="n">ip</span><span class="p">);</span>

<span class="c1">// destroying the the object to which p points
</span><span class="c1">// instantiates DebugDelete::operator()&lt;int&gt;(int *)
</span><span class="c1"></span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">DebugDelete</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">,</span> <span class="n">DebugDelete</span><span class="p">());</span>
<span class="c1">// destroying the the object to which sp points
</span><span class="c1">// instantiates DebugDelete::operator()&lt;string&gt;(string*)
</span><span class="c1"></span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="n">DebugDelete</span><span class="o">&gt;</span> <span class="n">sp</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">,</span> <span class="n">DebugDelete</span><span class="p">());</span>
</code></pre></div>

<p><strong>unique_ptr</strong>的析构函数会调用DebugDelete的调用操作符。因此，当<strong>unique_ptr</strong>析构函数实例化时，DebugDelete的调用操作符也会实例化。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// sample instantiations for member templates of DebugDelete
</span><span class="c1"></span><span class="kt">void</span> <span class="n">DebugDelete</span><span class="o">::</span><span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">p</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">DebugDelete</span><span class="o">::</span><span class="k">operator</span><span class="p">()(</span><span class="n">string</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">p</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div>

<h3 id="类模板的成员模板">类模板的成员模板</h3>

<p>我们也可以定义一个类模板的成员模板。这种情况下，类和成员都有它们自己的独立的模板参数。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Blob</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">It</span><span class="o">&gt;</span> <span class="n">Blob</span><span class="p">(</span><span class="n">It</span> <span class="n">b</span><span class="p">,</span> <span class="n">It</span> <span class="n">e</span><span class="p">);</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div>

<p>不同于类模板的普通函数成员，成员模板是函数模板。当我们在类模板外面定义一个成员模板，我们必须为类模板和函数模板提供模板参数列表。类模板参数列表在前，后面跟成员模板参数列表：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>     <span class="c1">// type parameter for the class
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">It</span><span class="o">&gt;</span>    <span class="c1">// type parameter for the constructor
</span><span class="c1"></span>    <span class="n">Blob</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Blob</span><span class="p">(</span><span class="n">It</span> <span class="n">b</span><span class="p">,</span> <span class="n">It</span> <span class="n">e</span><span class="p">)</span><span class="o">:</span>
              <span class="n">data</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="成员模板的实例化">成员模板的实例化</h3>

<p>为了实例化一个类模板的成员模板，我们必须为类模板和成员模板的模板参数提供实参。和以前一样，类模板参数的实参由调用成员模板的对象类型决定。同样，编译器通过传递给成员模板的实参推导出成员模板参数的实参。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">ia</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span> <span class="n">vi</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span>
<span class="n">list</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span> <span class="n">w</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;now&#34;</span><span class="p">,</span> <span class="s">&#34;is&#34;</span><span class="p">,</span> <span class="s">&#34;the&#34;</span><span class="p">,</span> <span class="s">&#34;time&#34;</span><span class="p">};</span>
<span class="c1">// instantiates the Blob&lt;int&gt; class
</span><span class="c1">// and the Blob&lt;int&gt; constructor that has two int* parameters
</span><span class="c1"></span><span class="n">Blob</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a1</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">ia</span><span class="p">));</span>
<span class="c1">// instantiates the Blob&lt;int&gt; constructor that has
</span><span class="c1">// two vector&lt;long&gt;::iterator parameters
</span><span class="c1"></span><span class="n">Blob</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a2</span><span class="p">(</span><span class="n">vi</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vi</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="c1">// instantiates the Blob&lt;string&gt; class and the Blob&lt;string&gt;
</span><span class="c1">// constructor that has two (list&lt;const char*&gt;::iterator parameters
</span><span class="c1"></span><span class="n">Blob</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">a3</span><span class="p">(</span><span class="n">w</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">w</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</code></pre></div>

<h2 id="16-1-5-控制实例化">16.1.5 控制实例化</h2>

<p>当模板被使用时才生成实例意味着同一个实例可能出现在多个对象文件。当两个或更多单独编译的源文件用相同的模板实参使用同一个模板时，在每一个文件中有一个模板实例。</p>

<p>在大型系统中，在多个文件中实例化同一个模板的开销将变得非常明显。在新标准下，我们可以使用显式实例化避免这种开销。显式实例化具有形式：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">extern</span> <span class="k">template</span> <span class="n">declaration</span><span class="p">;</span> <span class="c1">// instantiation declaration
</span><span class="c1"></span><span class="k">template</span> <span class="n">declaration</span><span class="p">;</span>        <span class="c1">// instantiation definition
</span></code></pre></div>

<p>declaration是一个类或函数声明，其模板参数被模板实参替换。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// instantion declaration and definition
</span><span class="c1"></span><span class="k">extern</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">Blob</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">;</span>             <span class="c1">// declaration
</span><span class="c1"></span><span class="k">template</span> <span class="kt">int</span> <span class="nf">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">);</span>   <span class="c1">// definition
</span></code></pre></div>

<p>当编译器看到一个<strong>extern</strong>模板声明，它不会在那个文件生成实例化代码。将一个模板实例声明为<strong>extern</strong>承诺程序的其它地方存在一个<strong>nonextern</strong>的实例。对于一个指定的实例可以有多个<strong>extern</strong>声明但是只能存在一个实例的定义。</p>

<p>因为编译器使用模板时自动实例化，<strong>extern</strong>声明必须出现在任何使用实例的代码之前：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// Application.cc
</span><span class="c1">// these template types must be instantiated elsewhere in the program
</span><span class="c1"></span><span class="k">extern</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">Blob</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">template</span> <span class="kt">int</span> <span class="nf">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">);</span>
<span class="n">Blob</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">sa1</span><span class="p">,</span> <span class="n">sa2</span><span class="p">;</span> <span class="c1">// instantiation will appear elsewhere
</span><span class="c1">// Blob&lt;int&gt; and its initializer_list constructor instantiated in this file
</span><span class="c1"></span><span class="n">Blob</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span>
<span class="n">Blob</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a2</span><span class="p">(</span><span class="n">a1</span><span class="p">);</span>  <span class="c1">// copy constructor instantiated in this file
</span><span class="c1"></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">compare</span><span class="p">(</span><span class="n">a1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a2</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// instantiation will appear elsewhere定义
</span></code></pre></div>

<blockquote>
<p><strong>警告</strong>
对于每一个实例声明，在程序的其它地方必须有一个显式实例定义。</p>
</blockquote>

<h3 id="实例定义实例化所有成员">实例定义实例化所有成员</h3>

<p>一个类模板的实例定义实例化其所有成员包括内联成员函数。当编译器看到一个实例定义，它不知道哪一个成员函数会被用到，因此编译器实例化所有成员。</p>

<blockquote>
<p><strong>注释</strong>
实例定义只能用在类模板所有成员函数都能使用的类型。</p>
</blockquote>

<h2 id="16-1-6-效率和灵活性">16.1.6 效率和灵活性</h2>

<p>标准库的智能指针提供了一个关于模板设计者面临的设计选择的很好说明。</p>

<h1 id="16-2-模板实参推导">16.2 模板实参推导</h1>

<p>在模板实参推导期间，编译器使用实参的类型查找模板参数并生成最符合的函数。</p>

<h2 id="16-2-1-转换和模板类型参数">16.2.1 转换和模板类型参数</h2>

<p>使用模板类型参数的函数参数具有特殊的初始化规则。只有非常有限数量的转换被自动应用到这种参数。编译器生成一个新的实例而不是转换实参。</p>

<p>和以往一样，不管是形参还是实参的上层const都被忽略。在一个函数模板调用中执行的唯一其它转换有：
* const转换：引用（或指针）const对象的函数参数可以传递引用（或指针）非const对象。
* 数组到指针或函数到指针的转换：如果函数参数不是引用类型，则普通指针转换将被应用到参数为数组或函数类型上。数组参数被转换为指向第一个元素的指针。类似地，函数参数被转换为指向函数类型的指针。</p>

<p>其它转换比如算术转换，派生类到基类转换和用户自定义的转换都不会执行。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">fobj</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span> <span class="c1">// arguments are copied
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">fref</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// references
</span><span class="c1"></span><span class="n">string</span> <span class="nf">s1</span><span class="p">(</span><span class="s">&#34;a value&#34;</span><span class="p">);</span>
<span class="k">const</span> <span class="n">string</span> <span class="nf">s2</span><span class="p">(</span><span class="s">&#34;another value&#34;</span><span class="p">);</span>
<span class="n">fobj</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">);</span> <span class="c1">// calls fobj(string, string); const is ignored
</span><span class="c1"></span><span class="n">fref</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">);</span> <span class="c1">// calls fref(const string&amp;, const string&amp;)
</span><span class="c1"></span>              <span class="c1">// uses premissible conversion to const on s1
</span><span class="c1"></span><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">42</span><span class="p">];</span>
<span class="n">fobj</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// calls f(int*, int*)
</span><span class="c1"></span><span class="n">fref</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// error: array types don&#39;t match
</span></code></pre></div>

<blockquote>
<p><strong>注释</strong>
const转换和数组或函数到指针的转换是模板类型唯一的实参到形参自动转换。</p>
</blockquote>

<h3 id="使用相同模板参数类型的函数参数">使用相同模板参数类型的函数参数</h3>

<p>一个模板类型参数可以被多个函数参数使用。因为转换非常有限，这种参数的实参必须具有一样的类型。如果推导的参数类型不匹配，那么调用出错。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">long</span> <span class="n">lng</span><span class="p">;</span>
<span class="n">compare</span><span class="p">(</span><span class="n">lng</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span> <span class="c1">// error: cannot instantiate compare(long, int)
</span><span class="c1"></span>
<span class="c1">// argument types can differ but must be compatible
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">B</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">flexibleCompare</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">v1</span><span class="p">,</span> <span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">v2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v1</span> <span class="o">&lt;</span> <span class="n">v2</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v2</span> <span class="o">&lt;</span> <span class="n">v1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">long</span> <span class="n">lng</span><span class="p">;</span>
<span class="n">flexibleCompare</span><span class="p">(</span><span class="n">lng</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span> <span class="c1">// ok: calls flexibleCompare(long, int)
</span></code></pre></div>

<h3 id="应用到普通实参的正常转换">应用到普通实参的正常转换</h3>

<p>函数模板可以有普通类型的参数，就是与模板类型参数无关的参数。这些参数不需要特殊处理，它们的转换规则和以前一样。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">ostream</span> <span class="o">&amp;</span><span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span>
<span class="o">&amp;</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">print</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span> <span class="c1">// instantiates print(ostream&amp;, int)
</span><span class="c1"></span><span class="n">ofstream</span> <span class="nf">f</span><span class="p">(</span><span class="s">&#34;output&#34;</span><span class="p">);</span>
<span class="n">print</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>    <span class="c1">// uses print(ostream&amp;, int); converts f to ostream&amp;
</span></code></pre></div>

<h2 id="16-2-2-函数模板显式参数">16.2.2 函数模板显式参数</h2>

<p>在某些情况下，编译器不可能推导出模板参数的类型。另一些情况，我们想要允许用户控制模板实例化。当一个函数返回类型不同于参数列表中的类型时，这两种情况经常出现。</p>

<h3 id="指定一个显式模板参数">指定一个显式模板参数</h3>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// T1 cannot be deduced: it doesn&#39;t appear in the function parameter list
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T3</span><span class="o">&gt;</span>
<span class="n">T1</span> <span class="n">sum</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">T3</span><span class="p">);</span>
</code></pre></div>

<p>这个例子中，没有用来推导T1类型的实参，调用者必须提供一个显式模板实参。我们可以像定义类模板实例那样，给一个函数调用提供显式模板实参。显式模板实参在尖括号中指定，在函数名之后，参数列表之前：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// T1 is explicitly specified; T2 and T3 are inferred from the argument types
</span><span class="c1"></span><span class="k">auto</span> <span class="n">val3</span> <span class="o">=</span> <span class="n">sum</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">lng</span><span class="p">);</span> <span class="c1">// long long sum(int, long)
</span></code></pre></div>

<p>显式模板实参从左到右匹配相应的模板参数，</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// poor design: users must explicitly specify all three template parameters
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T3</span><span class="o">&gt;</span>
<span class="n">T3</span> <span class="n">alternative_sum</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">T1</span><span class="p">);</span>

<span class="c1">// error: can&#39;t infer initial template parameters
</span><span class="c1"></span><span class="k">auto</span> <span class="n">val3</span> <span class="o">=</span> <span class="n">alternative_sum</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">lng</span><span class="p">);</span>
<span class="c1">// ok: all three parameters are explicitly specified
</span><span class="c1"></span><span class="k">auto</span> <span class="n">val2</span> <span class="o">=</span> <span class="n">alternative_sum</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">lng</span><span class="p">);</span>
</code></pre></div>

<h3 id="显式指定参数应用普通转换">显式指定参数应用普通转换</h3>

<p>和普通类型参数允许普通转换的原因一样，显式指定参数也可以应用其实参的普通转换：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">long</span> <span class="n">lng</span><span class="p">;</span>
<span class="n">compare</span><span class="p">(</span><span class="n">lng</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>       <span class="c1">// error: template parameters don&#39;t match
</span><span class="c1"></span><span class="n">compare</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lng</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span> <span class="c1">// ok: instantiates compare(long, long)
</span><span class="c1"></span><span class="n">compare</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lng</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>  <span class="c1">// ok: instantiates compare(int, int)
</span></code></pre></div>

<h2 id="16-2-3-尾返回类型和类型转换">16.2.3 尾返回类型和类型转换</h2>

<p>使用显式模板参数来表示模板函数的返回类型工作得很好。另外一些情况下，需要有一个显式模板参数给用户强加了负担。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">It</span><span class="o">&gt;</span>
<span class="o">???</span> <span class="o">&amp;</span><span class="n">fcn</span><span class="p">(</span><span class="n">It</span> <span class="n">beg</span><span class="p">,</span> <span class="n">It</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// process the range
</span><span class="c1"></span>    <span class="k">return</span> <span class="o">*</span><span class="n">beg</span><span class="p">;</span>  <span class="c1">// return a reference to an element from the range
</span><span class="c1"></span><span class="p">}</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vi</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
<span class="n">Blob</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">ca</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&#34;hi&#34;</span><span class="p">,</span> <span class="s">&#34;bye&#34;</span> <span class="p">};</span>
<span class="k">auto</span> <span class="o">&amp;</span><span class="n">i</span> <span class="o">=</span> <span class="n">fcn</span><span class="p">(</span><span class="n">vi</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vi</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">// fcn should return int&amp;
</span><span class="c1"></span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">s</span> <span class="o">=</span> <span class="n">fcn</span><span class="p">(</span><span class="n">ca</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ca</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">// fcn should return string&amp;
</span><span class="c1"></span>
<span class="c1">// a trailing return lets us declare the return type after the parameter list is seen
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">It</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">fcn</span><span class="p">(</span><span class="n">It</span> <span class="n">beg</span><span class="p">,</span> <span class="n">It</span> <span class="n">end</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">beg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// process the range
</span><span class="c1"></span>    <span class="k">return</span> <span class="o">*</span><span class="n">beg</span><span class="p">;</span>  <span class="c1">// return a reference to an element from the range
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<h3 id="类型转换标准库模板类">类型转换标准库模板类</h3>

<p>有时候我们不能直接访问到我们需要的类型。比如我们可能想要写一个类似fcn的函数返回一个元素的值而不是引用。编写这样的函数我们面临的问题是我们几乎不了解我们传递的参数类型。为了获取元素类型，我们可以使用库类型转换模板。这些模板定义在<strong>type_traits</strong>头文件。通常头文件<strong>type_traits</strong>中的类被用来所谓的元编程。</p>

<table>
<thead>
<tr>
<th>For Mod&lt;T&gt;, Mod is</th>
<th align="left">If T is</th>
<th align="left">Then Mod&lt;T&gt;::type is</th>
</tr>
</thead>

<tbody>
<tr>
<td>remove_reference</td>
<td align="left">X&amp; or X&amp;&amp;<br>otherwise</td>
<td align="left">X<br>T</td>
</tr>

<tr>
<td>add_const</td>
<td align="left">X&amp;, const X, or function<br>otherwise</td>
<td align="left">T<br>const T</td>
</tr>

<tr>
<td>add_lvalue_reference</td>
<td align="left">X&amp;<br>X&amp;&amp;<br>otherwise</td>
<td align="left">T<br>X&amp;<br>T&amp;</td>
</tr>

<tr>
<td>add_rvalue_reference</td>
<td align="left">X&amp; or X&amp;&amp;<br>otherwise</td>
<td align="left">T<br>T&amp;&amp;</td>
</tr>

<tr>
<td>remove_pointer</td>
<td align="left">X*<br>otherwise</td>
<td align="left">X<br>const T</td>
</tr>

<tr>
<td>add_pointer</td>
<td align="left">X&amp; or X&amp;&amp;<br>otherwise</td>
<td align="left">X*<br>T*</td>
</tr>

<tr>
<td>make_signed</td>
<td align="left">unsigned X<br>otherwise</td>
<td align="left">X<br>T</td>
</tr>

<tr>
<td>make_unsigned</td>
<td align="left">signed type<br>otherwise</td>
<td align="left">unsigned T<br>T</td>
</tr>

<tr>
<td>remove_extent</td>
<td align="left">X[n]<br>otherwise</td>
<td align="left">X<br>T</td>
</tr>

<tr>
<td>remove_all_extents</td>
<td align="left">X[n1][n2]&hellip;<br>otherwise</td>
<td align="left">X<br>T</td>
</tr>
</tbody>
</table>

<p>在这个例子中，我们可以使用<strong>remove_reference</strong>获取元素类型。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">remove_reference</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">beg</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span>

<span class="c1">// must use typename to use a type member of a template parameter; see § 16.1.3 (p.
</span><span class="c1"></span><span class="mi">670</span><span class="p">)</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">It</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">fcn2</span><span class="p">(</span><span class="n">It</span> <span class="n">beg</span><span class="p">,</span> <span class="n">It</span> <span class="n">end</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">beg</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span>
<span class="p">{</span>
    <span class="c1">// process the range
</span><span class="c1"></span>    <span class="k">return</span> <span class="o">*</span><span class="n">beg</span><span class="p">;</span>  <span class="c1">// return a copy of an element from the range
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<p>注意type是一个依赖模板参数的类成员。因此我们必须在返回类型的声明中使用<strong>typename</strong>来告诉编译器type代表一个类型。</p>

<p>每一个上表中描述的类型转换模板和<strong>remove_reference</strong>类似工作。每一个模板都有一个公开的type成员代表一个类型。如果不可能（或没必要）转换一个模板参数，则type成员就是模板参数本身。</p>

<h2 id="16-2-4-函数指针和实参推导">16.2.4 函数指针和实参推导</h2>

<p>当我们从一个函数模板初始化或赋值一个函数指针时，编译器使用函数指针的类型推导模板实参。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
<span class="c1">// pf1 points to the instantiation int compare(const int&amp;, const int&amp;)
</span><span class="c1"></span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pf1</span><span class="p">)(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="n">compare</span><span class="p">;</span>
</code></pre></div>

<p>如果从函数指针类型不能决定模板实参则出错：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// overloaded versions of func; each takes a different function pointer type
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">));</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">));</span>
<span class="n">func</span><span class="p">(</span><span class="n">compare</span><span class="p">);</span> <span class="c1">// error: which instantiation of compare?
</span></code></pre></div>

<p>我们可以使用显式模板实参使得调用无二义性：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// ok: explicitly specify which version of compare to instantiate
</span><span class="c1"></span><span class="n">func</span><span class="p">(</span><span class="n">compare</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">);</span>  <span class="c1">// passing compare(const int&amp;, const int&amp;)
</span></code></pre></div>

<blockquote>
<p><strong>注释</strong>
当一个函数模板实例的地址被使用时，其应用环境必须是只允许唯一类型或值可以确定每一个模板参数。</p>
</blockquote>

<h2 id="16-2-5-模板实参推导和引用">16.2.5 模板实参推导和引用</h2>

<p>为了理解下例函数类型推导，需要记住两点，一是正常的引用绑定规则，二是const是低层次不是高层次的。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
</code></pre></div>

<h3 id="左值引用函数参数类型推导">左值引用函数参数类型推导</h3>

<p>当一个函数参数是普通的左值引用模板参数，我们只能传递左值给它。如果实参是const，则T被推导为一个const类型。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f1</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>  <span class="c1">// argument must be an lvalue
</span><span class="c1">// calls to f1 use the referred-to type of the argument as the template parameter type
</span><span class="c1"></span><span class="n">f1</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>   <span class="c1">//  i is an int; template parameter T is int
</span><span class="c1"></span><span class="n">f1</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span>  <span class="c1">//  ci is a const int; template parameter T is const int
</span><span class="c1"></span><span class="n">f1</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>   <span class="c1">//  error: argument to a &amp; parameter must be an lvalue
</span></code></pre></div>

<p>如果一个函数参数是const T&amp;，则可以传递任何种类给它。如果实参是const，则T被推导为普通类型。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f2</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// can take an rvalue
</span><span class="c1">// parameter in f2 is const &amp;; const in the argument is irrelevant
</span><span class="c1">// in each of these three calls, f2&#39;s function parameter is inferred as const int&amp;
</span><span class="c1"></span><span class="n">f2</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>  <span class="c1">// i is an int; template parameter T is int
</span><span class="c1"></span><span class="n">f2</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span> <span class="c1">// ci is a const int, but template parameter T is int
</span><span class="c1"></span><span class="n">f2</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>  <span class="c1">// a const &amp; parameter can be bound to an rvalue; T is int)
</span></code></pre></div>

<h3 id="右值引用函数参数类型推导">右值引用函数参数类型推导</h3>

<p>当一个函数参数是右值引用，正常绑定规则告诉我们可以传递一个右值给函数参数。类型推导的行为和普通左值引用类似。被推导的类型T是右值的类型。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f3</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">);</span>
<span class="n">f3</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="c1">// argument is an rvalue of type int; template parameter T is int
</span></code></pre></div>

<h3 id="引用折叠和右值引用参数">引用折叠和右值引用参数</h3>

<p>C++在正常绑定规则上定义了2种特例，允许将右值引用绑定到左值上。</p>

<p>第一种特例是关于右值引用如何推导的。当传递一个左值给右值引用模板参数，编译器推导模板参数类型为实参的左值引用。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">f3</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>  <span class="c1">// argument is an lvalue; template parameter T is int&amp;
</span><span class="c1"></span><span class="n">f3</span><span class="p">(</span><span class="n">ci</span><span class="p">);</span> <span class="c1">// argument is an lvalue; template parameter T is const int&amp;
</span></code></pre></div>

<p>第二种特例是如果我们间接地创建了一个引用的引用，则这些引用“折叠”。
对于一个给定类型X：
* X&amp; &amp;, X&amp; &amp;&amp;和X&amp;&amp; &amp;折叠为X&amp;
* X&amp;&amp; &amp;&amp;折叠为X&amp;&amp;</p>

<blockquote>
<p><strong>注释</strong>
引用折叠仅仅应用在间接创建了一个引用的引用，比如通过类型别名或模板参数。</p>
</blockquote>

<p>这两个特例产生两个重要结果：
* 一个是右值引用的函数模板参数可以绑定到左值上
* 如果实参是一个左值，则模板实参类型被推导为左值引用，且函数参数被实例化为左值引用参数</p>

<p>这也意味着可以传递任意类型给T&amp;&amp;函数参数。</p>

<h3 id="编写右值引用参数模板函数">编写右值引用参数模板函数</h3>

<p>模板参数可以被推导为引用类型这个事实，对于在模板内编写代码有惊人的冲击：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f3</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">t</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>  <span class="c1">// copy or binding a reference?
</span><span class="c1"></span>    <span class="n">t</span> <span class="o">=</span> <span class="n">fcn</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="c1">// does the assignment change only t or val and t?
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span> <span class="c1">// always true if T is a reference type
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<p>实际上，右值引用参数被用在2个场景，一个是模板转发它的实参，另一个是模板重载。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">);</span>      <span class="c1">// binds to nonconst
</span><span class="c1"></span><span class="n">rvalues</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// lvalues and const
</span><span class="c1"></span><span class="n">rvalues</span>
</code></pre></div>

<h2 id="16-2-6-理解std-move">16.2.6 理解std::move</h2>

<p>库函数move是一个展示右值引用模板参数的好例子。</p>

<h3 id="std-move是如何定义的">std::move是如何定义的</h3>

<p>标准库定义move如下：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// for the use of typename in the return type and the cast see § 16.1.3 (p. 670)
</span><span class="c1">// remove_reference is covered in § 16.2.3 (p. 684)
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;&amp;</span> <span class="n">move</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// static_cast covered in § 4.11.3 (p. 163)
</span><span class="c1"></span>    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="std-move是如何工作的">std::move是如何工作的</h3>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">string</span> <span class="nf">s1</span><span class="p">(</span><span class="s">&#34;hi!&#34;</span><span class="p">),</span> <span class="n">s2</span><span class="p">;</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="s">&#34;bye!&#34;</span><span class="p">));</span> <span class="c1">// ok: moving from an rvalue
</span><span class="c1"></span><span class="n">s2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span>  <span class="c1">// ok: but after the assigment s1 has indeterminate value
</span></code></pre></div>

<p>第一个赋值，传递给move的实参是一个右值：
* T推导的类型为string
* remove_reference<string>::type是string
* move的返回类型是string&amp;&amp;
* move的函数参数t类型为string&amp;&amp;
因此这个调用实例化的move是string&amp;&amp; move(string&amp;&amp; t)</p>

<p>第二个赋值，传递给move的实参是一个左值：
* T推导的类型为string&amp;
* remove_reference<string&>::type是string
* move的返回类型是string&amp;&amp;
* move的函数参数t类型为string&amp; &amp;&amp;，折叠为string&amp;
因此这个调用实例化的move是string&amp;&amp; move(string&amp; t)</p>

<h4 id="static-cast一个左值引用为右值引用是允许的">static_cast一个左值引用为右值引用是允许的</h4>

<p>不能隐式将左值引用转换为右值引用，必须使用static_cast。</p>

<h2 id="16-2-7-转发">16.2.7 转发</h2>

<p>有些函数需要转发一个或多个参数给其他函数。这种情况下，我们需要保存被转发参数的所有信息。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// template that takes a callable and two parameters
</span><span class="c1">// and calls the given callable with the parameters &#39;&#39;flipped&#39;&#39;
</span><span class="c1">// flip1 is an incomplete implementation: top-level const and references are lost
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">flip1</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">,</span> <span class="n">T1</span> <span class="n">t1</span><span class="p">,</span> <span class="n">T2</span> <span class="n">t2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">t1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>这个模板工作得很好直到调用一个有引用参数的函数：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">v1</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">v2</span><span class="p">)</span> <span class="c1">// note v2 is a reference
</span><span class="c1"></span><span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v1</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="o">++</span><span class="n">v2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>f改变了v2的值，但是如果通过flip1调用f，则f做的改变不影响原来的实参：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">f</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>        <span class="c1">// f changes its argument i
</span><span class="c1"></span><span class="n">flip1</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span> <span class="c1">// f called through flip1 leaves j unchanged
</span></code></pre></div>

<h3 id="定义保留类型信息的函数参数">定义保留类型信息的函数参数</h3>

<p>我们可以定义函数参数为模板类型的右值引用保留实参的所有类型信息。使用引用参数可以保存const属性，通过引用折叠可以保存左值或右值属性。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">flip2</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">,</span> <span class="n">T1</span><span class="o">&amp;&amp;</span> <span class="n">t1</span><span class="p">,</span> <span class="n">T2</span><span class="o">&amp;&amp;</span> <span class="n">t2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">t1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<blockquote>
<p><strong>注解</strong>
函数的一个右值引用的模板类型参数保留实参的const属性和左值或右值属性。</p>
</blockquote>

<p>flip2函数只解决了一半问题。flip2函数当函数参数为左值引用时工作很好，但是不能调用有右值引用参数的函数，比如：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="n">i</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">j</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">flip2</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span> <span class="c1">// error: can&#39;t initialize int&amp;&amp; from an lvalue
</span></code></pre></div>

<p>函数参数和任何其他变量一样，是一个左值表达式。结果flip2中的g调用传递一个左值给g的右值引用参数。</p>

<h3 id="使用std-forward在函数调用种保留类型信息">使用std::forward在函数调用种保留类型信息</h3>

<p>我们可以使用一个新的库工具forward传递给flip2的函数参数并保留类型信息。和move一样，forward定义在utility头文件。与move不一样的是，forward调用时必须显示指定模板实参。forward返回其模板实参的右值引用，即forward<T>返回类型为T&amp;&amp;</p>

<p>通常我们使用forward来传递定义为右值引用模板类型的函数参数。通过返回类型的引用折叠，forward保留了指定实参的类型：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="o">&gt;</span> <span class="n">intermediary</span><span class="p">(</span><span class="n">Type</span><span class="o">&amp;&amp;</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">finalFcn</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg</span><span class="p">));</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<blockquote>
<p><em>注解</em>
当使用函数参数为右值引用模板类型时，forward保留实参类型的所有信息</p>
</blockquote>

<p>使用forward，我们可以重写flip函数为：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">flip</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">,</span> <span class="n">T1</span><span class="o">&amp;&amp;</span> <span class="n">t1</span><span class="p">,</span> <span class="n">T2</span><span class="o">&amp;&amp;</span> <span class="n">t2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t2</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t1</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>

<blockquote>
<p><em>注解</em>
和std::move一样，不提供using声明使用std::forward是个好主意</p>
</blockquote>

<h2 id="16-3-重载和模板">16.3 重载和模板</h2>

<p>函数模板可以被其他模板或普通的非模板函数重载。和以往一样，同名函数的参数个数或类型必须不一样。</p>

<p>函数匹配受函数模板的影响，表现为下面几点：
* 候选函数包含任何成功实例化的模板函数。
* 候选函数模板总是可行的，因为模板实参会去除任何不可行的模板。
* 和以往一样，可行函数（模板和非模板）通过转换评级。
* 如果仅有一个函数比其他更匹配，则这个函数被选中。如果有多个函数匹配，则：
1. 如果只有一个非模板函数，则该函数被选中。
2. 如果没有非模板函数，且其中某个比其他更特例，则该函数被选中。
3. 调用有歧义。</p>

<blockquote>
<p><strong>警告</strong>
正确定义一组重载函数模板需要很好地理解类型之间的关系和函数模板参数转换的限制。</p>
</blockquote>

<h3 id="编写重载模板">编写重载模板</h3>

<p>作为一个例子，我们将定义一组调试时有用的函数</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// print any type we don&#39;t otherwise handle
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">string</span> <span class="n">debug_rep</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ostringstream</span> <span class="n">ret</span><span class="p">;</span> <span class="c1">// see § 8.3 (p. 321)
</span><span class="c1"></span>    <span class="n">ret</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">;</span> <span class="c1">// uses T&#39;s output operator to print a representation of t
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">ret</span><span class="p">.</span><span class="n">str</span><span class="p">();</span> <span class="c1">// return a copy of the string to which ret is bound
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<p>这个函数可以用来生成任何具有输出操作符类型的字符串表示。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// print pointers as their pointer value, followed by the object to which the pointer points
</span><span class="c1">// NB: this function will not work properly with char*; see § 16.3 (p. 698)
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">string</span> <span class="n">debug_rep</span><span class="p">(</span><span class="n">T</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ostringstream</span> <span class="n">ret</span><span class="p">;</span>
    <span class="n">ret</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;pointer: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">;</span>         <span class="c1">// print the pointer&#39;s own value
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">debug_rep</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span> <span class="c1">// print the value to which p points
</span><span class="c1"></span>    <span class="k">else</span>
        <span class="n">ret</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; null pointer&#34;</span><span class="p">;</span>      <span class="c1">// or indicate that the p is null
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">ret</span><span class="p">.</span><span class="n">str</span><span class="p">();</span> <span class="c1">// return a copy of the string to which ret is bound
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<p>这是一个指针版本。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">string</span> <span class="nf">s</span><span class="p">(</span><span class="s">&#34;hi&#34;</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">debug_rep</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></div>

<p>对于这个调用，只有第一个版本可行。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">debug_rep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></div>

<p>对于这个调用，两个函数都可行：
* debug_rep(const string* &amp;)，第一个函数实例化，T推导为string*
* debug_rep(string*)，第二个函数实例化，T推导为string</p>

<p>第二个版本实例化对于这个调用完全匹配，第一个版本需要将普通指针转换为const。</p>

<h3 id="多个可行模板">多个可行模板</h3>

<p>作为另一个例子，考虑以下调用：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="n">string</span><span class="o">*</span> <span class="n">sp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">debug_rep</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></div>

<p>这里2个模板都可行且都完全匹配：
* debug_rep(const string* &amp;)，T推导为const string*
* debug_rep(const string*)，T推导为const string</p>

<p>这种情况下，普通函数匹配不能区分这2个调用。然而由于重载函数模板的特殊规则，这个调用确认为debug_rep(T*)，即这个更特殊的模板。理由是，如果没有这个规则，将没有办法调用指针版本的debug_rep。</p>

<blockquote>
<p><strong>注解</strong>
当有多个重载模板对于一个调用提供同样好的匹配时，更特殊的模板版本被选择。</p>
</blockquote>

<h3 id="非模板和模板重载">非模板和模板重载</h3>

<p>我们定义一个普通的非模板版本的debug_rep：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// print strings inside double quotes
</span><span class="c1"></span><span class="n">string</span> <span class="nf">debug_rep</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="sc">&#39;&#34;&#39;</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="sc">&#39;&#34;&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>当我们使用string调用debug_rep时：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">string</span> <span class="nf">s</span><span class="p">(</span><span class="s">&#34;hi&#34;</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">debug_rep</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></div>

<p>有两个可行的函数：
* debug_rep<string>(const string&amp;)，第一个模板T绑定到string
* debug_rep(const string&amp;)，普通的非模板函数</p>

<p>这种情况下，普通的非模板函数被选择。出于同样的原因，同样好的匹配的函数，更特殊的被选择。</p>

<blockquote>
<p><strong>注解</strong>
当一个非模板函数对于一个调用提供和函数模板一样好的匹配时，非模板函数被选择。</p>
</blockquote>

<h3 id="重载模板和转换">重载模板和转换</h3>

<p>有一种情况还没有谈到，指向C风格字符串的指针和字符串字面值。考虑下面这个调用：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">debug_rep</span><span class="p">(</span><span class="s">&#34;hi world!&#34;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// calls debug_rep(T*)
</span></code></pre></div>

<p>有3个debug_rep函数可行：
* debug_rep(const T&amp;)，T绑定到char[10]
* debug_rep(T*)，T绑定到const char
* debug_rep(const string&amp;)，需要将const char*转换到string</p>

<p>2个模板版本的函数提供完全匹配，非函数模板需要用户定义的转换，因此更特殊的模板版本被选择。</p>

<p>如果像将字符指针处理为string，可以再定义2个非模板重载函数：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// convert the character pointers to string and call the string version of debug_rep
</span><span class="c1"></span><span class="n">string</span> <span class="nf">debug_rep</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">debug_rep</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">string</span> <span class="nf">debug_rep</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">debug_rep</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="缺失声明可导致程序表现异常">缺失声明可导致程序表现异常</h3>

<p>值得注意的是为了char*版本的debug_rep正常工作，当char*版本函数定义时，debug_rep(const stirng&amp;)声明必须在作用域内。否则模板版本将被调用：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">string</span> <span class="n">debug_rep</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">string</span> <span class="n">debug_rep</span><span class="p">(</span><span class="n">T</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
<span class="c1">// the following declaration must be in scope
</span><span class="c1">// for the definition of debug_rep(char*) to do the right thing
</span><span class="c1"></span><span class="n">string</span> <span class="nf">debug_rep</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="n">string</span> <span class="nf">debug_rep</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// if the declaration for the version that takes a const string&amp; is not in scope
</span><span class="c1"></span>    <span class="c1">// the return will call debug_rep(const T&amp;) with T instantiated to string
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">debug_rep</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>

<blockquote>
<p><strong>提示</strong>
定义任何函数之前声明重载集中每一个函数。这样就不用担心编译器看到你想用的函数之前实例化一个函数。</p>
</blockquote>

<h2 id="16-4-变长模板">16.4 变长模板</h2>

<p><strong>C++ 11:</strong> 变长模板是一个模板函数或类拥有可变数量的参数。可变参数被称为参数包。有两种参数包，模板参数包表示0个或多个模板参数，函数参数包表示0个或多个函数参数。</p>

<p>我们使用&hellip;表示模板或函数参数包。在模板参数列表中，class&hellip;或typename&hellip;指示接下来的参数表示0个或多个类型；类型名后面跟&hellip;表示0个或多个非类型参数列表。在函数参数列表中，类型为模板参数包的参数是一个函数参数包：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// Args is a template parameter pack; rest is a function parameter pack
</span><span class="c1">// Args represents zero or more template type parameters
</span><span class="c1">// rest represents zero or more function parameters
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span> <span class="p">...</span> <span class="n">rest</span><span class="p">);</span>
</code></pre></div>

<p>通常，编译器从函数实参中推导模板参数类型。对于一个变长模板，编译器同样推导出参数包中的参数个数：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span> <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&#34;how now brown cow&#34;</span><span class="p">;</span>
<span class="n">foo</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>    <span class="c1">// three parameters in the pack
</span><span class="c1"></span><span class="n">foo</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="s">&#34;hi&#34;</span><span class="p">);</span>    <span class="c1">// two parameters in the pack
</span><span class="c1"></span><span class="n">foo</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>           <span class="c1">// one parameter in the pack
</span><span class="c1"></span><span class="n">foo</span><span class="p">(</span><span class="s">&#34;hi&#34;</span><span class="p">);</span>           <span class="c1">// empty pack
</span></code></pre></div>

<p>编译器将实例化4个不同的foo：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span>
<span class="kt">double</span><span class="o">&amp;</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">&amp;</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">&amp;</span><span class="p">);</span>
</code></pre></div>

<h3 id="sizeof-操作符">sizeof&hellip;操作符</h3>

<p><strong>C++ 11:</strong> 当我们想要直到参数包中有多少个元素时，可以使用sizeof&hellip;操作符。和sizeof一样，sizeof&hellip;返回一个常量，而且不会计算实参：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">g</span><span class="p">(</span><span class="n">Args</span> <span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">Args</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">// number of type parameters
</span><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">args</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">// number of function parameters
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<h3 id="编写变长函数模板">编写变长函数模板</h3>

<p>我们定义一个变长函数print，打印实参列表的值。变长函数通常是递归的，第一个调用处理参数包中第一个参数，然后用剩下的参数调用自己。为了终止递归，我们需要定义一个非变长的print函数：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// function to end the recursion and print the last element
</span><span class="c1">// this function must be declared before the variadic version of print is defined
</span><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">ostream</span> <span class="o">&amp;</span><span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">;</span> <span class="c1">// no separator after the last element in the pack
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">// this version of print will be called for all but the last element in the pack
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="n">ostream</span> <span class="o">&amp;</span><span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">rest</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, &#34;</span><span class="p">;</span>           <span class="c1">// print the first argument
</span><span class="c1"></span>    <span class="k">return</span> <span class="nf">print</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">rest</span><span class="p">...);</span> <span class="c1">// recursive call; print the other arguments
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<blockquote>
<p><strong>警告</strong>
当print的变长版本定义时，print的非变长版本必须在作用域中，否则变长函数将无限递归。</p>
</blockquote>

<h3 id="包展开">包展开</h3>

<p>除了获取包的大小，对参数包可以做的唯一的另外一件事就是包展开。当我们展开一个包时，我们也可以提供一个模式用在每一个被展开的元素。将&hellip;放在模式右边触发包展开。</p>

<p>例如，print函数包含2个展开：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="n">ostream</span><span class="o">&amp;</span> <span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">rest</span><span class="p">)</span><span class="c1">// expand Args
</span><span class="c1"></span><span class="p">{</span>
    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, &#34;</span><span class="p">;</span>
    <span class="k">return</span> <span class="nf">print</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">rest</span><span class="p">...);</span> <span class="c1">// expand rest
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<p>Args的展开应用模式const Args&amp;到每一个元素。第二个展开应用模式函数参数包的名字。</p>

<h3 id="理解包展开">理解包展开</h3>

<p>print的函数参数包展开仅仅是将包展开为它的组成部分。更复杂的模式也是可能的，比如：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// call debug_rep on each argument in the call to print
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="n">ostream</span> <span class="o">&amp;</span><span class="n">errorMsg</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">rest</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// print(os, debug_rep(a1), debug_rep(a2), ..., debug_rep(an)
</span><span class="c1"></span>    <span class="k">return</span> <span class="nf">print</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="n">debug_rep</span><span class="p">(</span><span class="n">rest</span><span class="p">)...);</span>
<span class="p">}</span>
</code></pre></div>

<p>print的调用中使用模式debug_rep(rest)。这个模式对函数参数包的每一个元素调用debug_rep。</p>

<blockquote>
<p><strong>注解</strong>
展开的模式单独地作用于包中的每一个元素</p>
</blockquote>

<h3 id="转发参数包">转发参数包</h3>

<p>在新标准下，我们可以使用变长模板和forward一起编写函数，将实参不变地传递给其他函数。作为展示，我们将添加一个emplace_back成员函数到StrVec类。标准库容器的emplace_back成员是一个变长的模板成员函数，它使用其实参在容器的内存空间直接构造元素。</p>

<p>我们知道，保存类型信息有2个步骤。第一，为了保存实参的类型信息，必须定义函数参数为右值模板参数。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">StrVec</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Args</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">emplace_back</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...);</span>
    <span class="c1">// remaining members as in § 13.5 (p. 526)
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div>

<p>第二，当emplace_back将实参传递给构造函数时，必须使用forward保存实参的原有类型</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="err">... </span><span class="nc">Args</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">StrVec</span><span class="o">::</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">chk_n_alloc</span><span class="p">();</span> <span class="c1">// reallocates the StrVec if necessary
</span><span class="c1"></span>    <span class="n">alloc</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">first_free</span><span class="o">++</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="p">}</span>
</code></pre></div>

<blockquote>
<p><strong>建议: 转发和变长模板</strong>
变长函数通常转发它们的参数给其他函数。这种函数一般具有和emplace_back函数类似的形式：</p>
</blockquote>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// fun has zero or more parameters each of which is
</span><span class="c1">// an rvalue reference to a template parameter type
</span><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">fun</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="c1">// expands Args as a list of rvalue references
</span><span class="c1"></span><span class="p">{</span>
    <span class="c1">// the argument to work expands both Args and args
</span><span class="c1"></span>    <span class="n">work</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="16-5-模板特化">16.5 模板特化</h2>

<p>一个模板并不总是适合每一个模板实参。某些情况下，通用的模板定义对于一个类型是错的，可能不能编译或做的事情是错的。有时候我们可能想利用一些特有的知识来写比模板实例化更有效的代码。当我们不能（或不想）使用模板版本时，我们可以模板的特殊版本。</p>

<p>compare函数是一个通用函数模板定义不能满足特定类型的很好例子。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// first version; can compare any two types
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
<span class="c1">// second version to handle string literals
</span><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="n">size_t</span> <span class="n">N</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">M</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="p">)[</span><span class="n">N</span><span class="p">],</span> <span class="k">const</span> <span class="kt">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="p">)[</span><span class="n">M</span><span class="p">]);</span>
</code></pre></div>

<p>带非类型模板参数版本的compare只会被字符串字面值或字符数组调用，如果使用字符指针调用compare，则第一个版本被调用：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="s">&#34;hi&#34;</span><span class="p">,</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="s">&#34;mom&#34;</span><span class="p">;</span>
<span class="n">compare</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span>      <span class="c1">// calls the first template
</span><span class="c1"></span><span class="n">compare</span><span class="p">(</span><span class="s">&#34;hi&#34;</span><span class="p">,</span> <span class="s">&#34;mom&#34;</span><span class="p">);</span> <span class="c1">// calls the template with two nontype parameters
</span></code></pre></div>

<p>为了处理字符指针，我们可以定义第一个compare版本的一个模板特化。模板特化是模板的一个独立定义，它的一个或多个模板参数被指定为特定类型。</p>

<h3 id="定义函数模板特化">定义函数模板特化</h3>

<p>当我们特化一个函数模板时，必须提供原模板中每个模板参数的实参类型。我们使用template &lt;&gt;表示模板特化。空&lt;&gt;指示将提供所有模板参数的实参：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// special version of compare to handle pointers to character arrays
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="kt">int</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">p1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nf">strcmp</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>当我们定义一个特化时，函数模板参数类型必须匹配之前声明的模板。</p>

<h3 id="函数重载vs模板特化">函数重载VS模板特化</h3>

<p>当我们定义一个函数模板特化时，本质上我们接管了编译器的工作。特化是一个实例，它不是函数名的重载。</p>

<blockquote>
<p><strong>注解</strong>
特化实例化一个模板，而不是重载函数。因此特化不影响函数匹配。</p>

<p><strong>关键概念: 普通作用域规则适用于特化</strong>
为了特化一个模板，原模板的声明在作用域中必须可见。而且，特化的声明必须在任何使用该模板实例的代码作用域之前可见。</p>

<p><strong>最佳实践</strong>
模板和它的特化应该在同一个头文件中声明。模板通用声明应该先出现，后跟任意模板特化。</p>
</blockquote>

<h3 id="类模板特化">类模板特化</h3>

<p>除了特化函数模板，我们也可以特化类模板。作为一个例子，我们定义库hash模板的一个特化，使得可以将Sales_data对象存到一个unordered容器。特化的hash类必须定义：
* 一个重载调用操作符，接收容器的键类型对象并返回size_t
* 2个类型成员，result_type和argument_type，它们是调用操作符的返回类型和实参类型。
* 默认构造函数和赋值操作符，可被隐式定义。</p>

<p>定义hash特化唯一复杂之处是，当我们特化一个模板时，必须和原有模板在同一个命名空间。因此我们必须先打开命名空间：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// open the std namespace so we can specialize std::hash
</span><span class="c1"></span><span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
<span class="p">}</span>  <span class="c1">// close the std namespace; note: no semicolon after the close curly
</span></code></pre></div>

<p>任何在花括号之间的定义将成为命名空间std的一部分。下面定义对于Sales_data类型hash的一个特化：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// open the std namespace so we can specialize std::hash
</span><span class="c1"></span><span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;&gt;</span>  <span class="c1">// we&#39;re defining a specialization with
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">hash</span><span class="o">&lt;</span><span class="n">Sales_data</span><span class="o">&gt;</span> <span class="c1">// the template parameter of Sales_data
</span><span class="c1"></span><span class="p">{</span>
    <span class="c1">// the type used to hash an unordered container must define these types
</span><span class="c1"></span>    <span class="k">typedef</span> <span class="n">size_t</span> <span class="n">result_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">Sales_data</span> <span class="n">argument_type</span><span class="p">;</span> <span class="c1">// by default, this type needs ==
</span><span class="c1"></span>    <span class="n">size_t</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Sales_data</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">// our class uses synthesized copy control and default constructor
</span><span class="c1"></span><span class="p">};</span>
<span class="n">size_t</span>
<span class="n">hash</span><span class="o">&lt;</span><span class="n">Sales_data</span><span class="o">&gt;::</span><span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Sales_data</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">s</span><span class="p">.</span><span class="n">bookNo</span><span class="p">)</span> <span class="o">^</span>
        <span class="n">hash</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">s</span><span class="p">.</span><span class="n">units_sold</span><span class="p">)</span> <span class="o">^</span>
        <span class="n">hash</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">s</span><span class="p">.</span><span class="n">revenue</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span> <span class="c1">// close the std namespace; note: no semicolon after the close curly
</span></code></pre></div>

<p>hash<Sales_data>定义以template&lt;&gt;开始，它指示我们定义一个完全特化的模板。</p>

<blockquote>
<p><strong>注解</strong>
为了使Sales_data的用户可以使用hash的特例，我们应该在Sales_data的头文件中定义这个特化。</p>
</blockquote>

<h3 id="类模板偏特化">类模板偏特化</h3>

<p>和函数模板不同的是，类模板特化可以不必提供每一个模板参数的实参。我们可以指定一部分而不是全部。一个类模板偏特化本身是一个模板。用户必须提供那些没有固定在特化中的模板参数。</p>

<blockquote>
<p><strong>注解</strong>
我们只能部分特化一个类模板，不能部分特化一个函数模板。</p>
</blockquote>

<p>标准库remove_reference类型就是通过一系列特化工作的：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// original, most general template
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">remove_reference</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="n">T</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// partial specializations that will be used for lvalue and rvalue references
</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&gt;</span>  <span class="c1">// lvalue references
</span><span class="c1"></span><span class="p">{</span> <span class="k">typedef</span> <span class="n">T</span> <span class="n">type</span><span class="p">;</span> <span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span> <span class="c1">// rvalue references
</span><span class="c1"></span><span class="p">{</span> <span class="k">typedef</span> <span class="n">T</span> <span class="n">type</span><span class="p">;</span> <span class="p">};</span>
</code></pre></div>

<p>因为模板偏特化是一个模板，我们还是以定义模板参数开始。模板偏特化的参数列表和原模板是一样的。在类名后，我们指定特化模板的实参。这些实参包括在&lt;&gt;之中，且和圆模板的参数位置对应。</p>

<p>模板偏特化的参数列表是原模板的一个子集。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="c1">// decltype(42) is int, uses the original template
</span><span class="c1"></span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">a</span><span class="p">;</span>
<span class="c1">// decltype(i) is int&amp;, uses first (T&amp;) partial specialization
</span><span class="c1"></span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">b</span><span class="p">;</span>
<span class="c1">// decltype(std::move(i)) is int&amp;&amp;, uses second (i.e., T&amp;&amp;) partial specialization
</span><span class="c1"></span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">c</span><span class="p">;</span>
</code></pre></div>

<h3 id="特化成员而不是类">特化成员而不是类</h3>

<p>我们可以仅仅特化指定的成员函数，而不是特化整个类模板。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="n">Foo</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">t</span> <span class="o">=</span> <span class="n">T</span><span class="p">())</span><span class="o">:</span> <span class="n">mem</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">Bar</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
    <span class="n">T</span> <span class="n">mem</span><span class="p">;</span>
    <span class="c1">// other members of Foo
</span><span class="c1"></span><span class="p">};</span>
<span class="k">template</span><span class="o">&lt;&gt;</span>           <span class="c1">// we&#39;re specializing a template
</span><span class="c1"></span><span class="kt">void</span> <span class="n">Foo</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">Bar</span><span class="p">()</span> <span class="c1">// we&#39;re specializing the Bar member of Foo&lt;int&gt;
</span><span class="c1"></span><span class="p">{</span>
    <span class="c1">// do whatever specialized processing that applies to ints
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<p>这里我们仅仅特化Foo<int>类的一个成员，其他成员由Foo模板提供：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Foo</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">fs</span><span class="p">;</span>  <span class="c1">// instantiates Foo&lt;string&gt;::Foo()
</span><span class="c1"></span><span class="n">fs</span><span class="p">.</span><span class="n">Bar</span><span class="p">();</span>        <span class="c1">// instantiates Foo&lt;string&gt;::Bar()
</span><span class="c1"></span><span class="n">Foo</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">fi</span><span class="p">;</span>     <span class="c1">// instantiates Foo&lt;int&gt;::Foo()
</span><span class="c1"></span><span class="n">fi</span><span class="p">.</span><span class="n">Bar</span><span class="p">();</span>        <span class="c1">// uses our specialization of Foo&lt;int&gt;::Bar()
</span></code></pre></div>
]]></content>
		</item>
		
		<item>
			<title>Pygame第6章 接受用户输入</title>
			<link>https://gitop.cc/posts/pygame-6/</link>
			<pubDate>Mon, 16 Nov 2015 16:39:23 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/pygame-6/</guid>
			<description>用户可以有很多种方式与游戏交互，这一章详细讲解多种输入设备。除了从设备获取信息，我们也要探索如何将用户所做的事情翻译成游戏中有意义的事件。容</description>
			<content type="html"><![CDATA[

<p>用户可以有很多种方式与游戏交互，这一章详细讲解多种输入设备。除了从设备获取信息，我们也要探索如何将用户所做的事情翻译成游戏中有意义的事件。容易交互对任何游戏都至关重要，不管你有多好的外观和声音。</p>

<h1 id="控制游戏">控制游戏</h1>

<p>玩过游戏的都知道鼠标和键盘是游戏不可或缺的输入设备。键盘可以控制有限的方向和诸多的命令操作，而鼠标更是提供了全方位的方向和位置操作。不过这两个设备并不是为游戏而生，专业的游戏手柄给玩家提供了更好的操作感，加上力反馈等技术，应该说游戏设备越来越丰富，玩家们也是越来越幸福。</p>

<h1 id="理解键盘控制">理解键盘控制</h1>

<p>现在大多数键盘都是qwerty键盘。我们可以使用<strong>pygame.key</strong>模块检测所有的键。</p>

<h3 id="检测键盘按下">检测键盘按下</h3>

<p>在Pygame里面有两种方式检测键盘按下。一种方式是处理<strong>KEYDOWN</strong>事件和<strong>KEYUP</strong>事件，分别对应键盘按下和键盘松开。当我们使用键盘输入代表移动时，我们只需知道键是否被按下，这种情况可以直接使用<strong>pygame.key</strong>模块。</p>

<p>每一个键盘上的键都有一个常量键值关联它。每一个常量以<strong>K_</strong>开头，比如字母是K_a到K_z，数字是K_0到K_9，其它的如K_F1，K_LEFT，K_RETURN等。完整列表参考(<a href="http://www.pygame.org/docs/ref/key.html">http://www.pygame.org/docs/ref/key.html</a>)。没有大写字母对应的键值，因为大写字母是小写字母和其它键的组合。</p>

<p>我们可以使用<strong>pygame.key.get_pressed</strong>函数检查一个键是否被按下。它返回一个布尔值列表，每一个布尔值对应一个键值常量。要查询某一个键，使用其键值常量作为列表下标。比如查看空格是否被按下：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">pressed_keys</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">key</span><span class="o">.</span><span class="n">get_pressed</span><span class="p">()</span>
<span class="k">if</span> <span class="n">pressed_keys</span><span class="p">[</span><span class="n">K_SPACE</span><span class="p">]:</span>
    <span class="c1"># Space key has been pressed</span>
    <span class="n">fire</span><span class="p">()</span></code></pre></div>

<blockquote>
<p><strong>注意</strong> 由于硬件的限制，有些键组合不能被检测。原因请看<a href="http://www.sjbaker.org/steve/omniv/keyboards_are_evil.html">http://www.sjbaker.org/steve/omniv/keyboards_are_evil.html</a></p>
</blockquote>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">pygame</span>
<span class="kn">from</span> <span class="nn">pygame.locals</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="nb">exit</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="n">font</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">font</span><span class="o">.</span><span class="n">SysFont</span><span class="p">(</span><span class="s1">&#39;arial&#39;</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="n">font_height</span> <span class="o">=</span> <span class="n">font</span><span class="o">.</span><span class="n">get_linesize</span><span class="p">()</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">QUIT</span><span class="p">:</span>
            <span class="nb">exit</span><span class="p">()</span>

    <span class="n">screen</span><span class="o">.</span><span class="n">fill</span><span class="p">((</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>

    <span class="n">pressed_key_text</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pressed_keys</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">key</span><span class="o">.</span><span class="n">get_pressed</span><span class="p">()</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">font_height</span>

    <span class="k">for</span> <span class="n">key_constant</span><span class="p">,</span> <span class="n">pressed</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pressed_keys</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pressed</span><span class="p">:</span>
            <span class="n">key_name</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">key</span><span class="o">.</span><span class="n">name</span><span class="p">(</span><span class="n">key_constant</span><span class="p">)</span>
            <span class="n">text_surface</span> <span class="o">=</span> <span class="n">font</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">key_name</span> <span class="o">+</span> <span class="s1">&#39; pressed&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">text_surface</span><span class="p">,</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
            <span class="n">y</span> <span class="o">+=</span> <span class="n">font_height</span>

    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></code></pre></div>

<p>让我们更详细地复习<strong>pygame.key</strong>：
* <strong>pygame.key.get_focused</strong> - Pygame窗口只有获得焦点后才会接受键事件。如果窗口获得焦点，<strong>get_focused</strong>函数返回真，否则返回假。全屏模式，总是返回真。
* <strong>pygame.key.get_pressed</strong> - 返回一个包含每一个键的布尔值列表。如果值为True，则对应键被按下。
* <strong>pygame.key.get_mods</strong> - 返回一个值，指示哪一个修饰键被按下。要检查哪一个修饰键被按下，可以对KMOD_常量使用位与操作。比如检查左shift键被按下，pygame.key.get_mods() &amp; KMOD_LSHIFT。
* <strong>pygame.key.set_mods</strong> - 可以设置修饰键模拟组合键按下的效果。要设置一个或多个修饰键，对KMOD_常量使用位或操作。比如设置shift和alt键，可以使用pygame.key.set_mods(KMOD_SHIFT | KMOD_ALT)。
* <strong>pygame.key.set_repeat</strong> - 可以使用<strong>set_repeat</strong>函数重复<strong>KEY_DOWN</strong>事件，它接受一个初始延迟时间和重复事件延迟时间，单位为毫秒。<strong>set_repeat</strong>不带参数禁用重复按键事件。
* <strong>pygame.key.name</strong> - 接受一个KEY_常量返回一个描述该键的字符串。</p>

<h3 id="使用键盘控制方向">使用键盘控制方向</h3>

<p>四个基本方向向量：</p>

<table>
<thead>
<tr>
<th>方向</th>
<th align="left">向量</th>
</tr>
</thead>

<tbody>
<tr>
<td>Left</td>
<td align="left">(-1.0, 0.0)</td>
</tr>

<tr>
<td>Right</td>
<td align="left">(1.0, 0.0)</td>
</tr>

<tr>
<td>Up</td>
<td align="left">(0.0, –1.0)</td>
</tr>

<tr>
<td>Down</td>
<td align="left">(0.0, 1.0)</td>
</tr>
</tbody>
</table>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">background_image_filename</span> <span class="o">=</span> <span class="s1">&#39;sushiplate.jpg&#39;</span>
<span class="n">sprite_iamge_filename</span> <span class="o">=</span> <span class="s1">&#39;fugu.png&#39;</span>

<span class="kn">import</span> <span class="nn">pygame</span>
<span class="kn">from</span> <span class="nn">pygame.locals</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="nb">exit</span>
<span class="kn">from</span> <span class="nn">gameobjects.vector2</span> <span class="kn">import</span> <span class="n">Vector2</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">background_image_filename</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">sprite</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">sprite_iamge_filename</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>

<span class="n">clock</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">Clock</span><span class="p">()</span>

<span class="n">sprite_pos</span> <span class="o">=</span> <span class="n">Vector2</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">150</span><span class="p">)</span>
<span class="n">sprite_speed</span> <span class="o">=</span> <span class="mf">300.</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">QUIT</span><span class="p">:</span>
            <span class="nb">exit</span><span class="p">()</span>

    <span class="n">pressed_keys</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">key</span><span class="o">.</span><span class="n">get_pressed</span><span class="p">()</span>
    <span class="n">key_direction</span> <span class="o">=</span> <span class="n">Vector2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">pressed_keys</span><span class="p">[</span><span class="n">K_LEFT</span><span class="p">]:</span>
        <span class="n">key_direction</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">elif</span> <span class="n">pressed_keys</span><span class="p">[</span><span class="n">K_RIGHT</span><span class="p">]:</span>
        <span class="n">key_direction</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="o">+</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">pressed_keys</span><span class="p">[</span><span class="n">K_UP</span><span class="p">]:</span>
        <span class="n">key_direction</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">elif</span> <span class="n">pressed_keys</span><span class="p">[</span><span class="n">K_DOWN</span><span class="p">]:</span>
        <span class="n">key_direction</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="o">+</span><span class="mi">1</span>

    <span class="n">key_direction</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>

    <span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="n">sprite_pos</span><span class="p">)</span>

    <span class="n">time_passed</span> <span class="o">=</span> <span class="n">clock</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
    <span class="n">time_passed_seconds</span> <span class="o">=</span> <span class="n">time_passed</span> <span class="o">/</span> <span class="mf">1000.0</span>

    <span class="n">sprite_pos</span> <span class="o">+=</span> <span class="n">key_direction</span> <span class="o">*</span> <span class="n">sprite_speed</span> <span class="o">*</span> <span class="n">time_passed_seconds</span>

    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></code></pre></div>

<h3 id="键盘旋转移动">键盘旋转移动</h3>

<p>往八个方向移动有点像人造的，现实中很少看到这样移动的，大多数东西都能自由转向。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">background_image_filename</span> <span class="o">=</span> <span class="s1">&#39;sushiplate.jpg&#39;</span>
<span class="n">sprite_image_filename</span> <span class="o">=</span> <span class="s1">&#39;fugu.png&#39;</span>

<span class="kn">import</span> <span class="nn">pygame</span>
<span class="kn">from</span> <span class="nn">pygame.locals</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="nb">exit</span>
<span class="kn">from</span> <span class="nn">gameobjects.vector2</span> <span class="kn">import</span> <span class="n">Vector2</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">background_image_filename</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">sprite</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">sprite_image_filename</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>

<span class="n">clock</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">Clock</span><span class="p">()</span>

<span class="n">sprite_pos</span> <span class="o">=</span> <span class="n">Vector2</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">150</span><span class="p">)</span>
<span class="n">sprite_speed</span> <span class="o">=</span> <span class="mf">300.</span>
<span class="n">sprite_rotation</span> <span class="o">=</span> <span class="mf">0.</span>
<span class="n">sprite_rotation_speed</span> <span class="o">=</span> <span class="mf">360.</span> <span class="c1"># Degrees per second</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">QUIT</span><span class="p">:</span>
            <span class="nb">exit</span><span class="p">()</span>

    <span class="n">pressed_keys</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">key</span><span class="o">.</span><span class="n">get_pressed</span><span class="p">()</span>

    <span class="n">rotation_direction</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">movement_direction</span> <span class="o">=</span> <span class="mf">0.</span>

    <span class="k">if</span> <span class="n">pressed_keys</span><span class="p">[</span><span class="n">K_LEFT</span><span class="p">]:</span>
        <span class="n">rotation_direction</span> <span class="o">=</span> <span class="o">+</span><span class="mf">1.0</span>
    <span class="k">if</span> <span class="n">pressed_keys</span><span class="p">[</span><span class="n">K_RIGHT</span><span class="p">]:</span>
        <span class="n">rotation_direction</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
    <span class="k">if</span> <span class="n">pressed_keys</span><span class="p">[</span><span class="n">K_UP</span><span class="p">]:</span>
        <span class="n">movement_direction</span> <span class="o">=</span> <span class="o">+</span><span class="mf">1.0</span>
    <span class="k">if</span> <span class="n">pressed_keys</span><span class="p">[</span><span class="n">K_DOWN</span><span class="p">]:</span>
        <span class="n">movement_direction</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>

    <span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="n">rotated_sprite</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="n">sprite_rotation</span><span class="p">)</span>
    <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">rotated_sprite</span><span class="o">.</span><span class="n">get_size</span><span class="p">()</span>
    <span class="n">sprite_draw_pos</span> <span class="o">=</span> <span class="n">Vector2</span><span class="p">(</span><span class="n">sprite_pos</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">w</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">sprite_pos</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">h</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">rotated_sprite</span><span class="p">,</span> <span class="n">sprite_draw_pos</span><span class="p">)</span>

    <span class="n">time_passed</span> <span class="o">=</span> <span class="n">clock</span><span class="o">.</span><span class="n">tick</span><span class="p">()</span>
    <span class="n">time_passed_seconds</span> <span class="o">=</span> <span class="n">time_passed</span> <span class="o">/</span> <span class="mf">1000.0</span>

    <span class="n">sprite_rotation</span> <span class="o">+=</span> <span class="n">rotation_direction</span> <span class="o">*</span> <span class="n">sprite_rotation_speed</span> <span class="o">*</span> <span class="n">time_passed_seconds</span>

    <span class="n">heading_x</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">sprite_rotation</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span><span class="p">)</span>
    <span class="n">heading_y</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">sprite_rotation</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">/</span> <span class="mf">180.0</span><span class="p">)</span>
    <span class="n">heading</span> <span class="o">=</span> <span class="n">Vector2</span><span class="p">(</span><span class="n">heading_x</span><span class="p">,</span> <span class="n">heading_y</span><span class="p">)</span>
    <span class="n">heading</span> <span class="o">*=</span> <span class="n">movement_direction</span>

    <span class="n">sprite_pos</span> <span class="o">+=</span> <span class="n">heading</span> <span class="o">*</span> <span class="n">sprite_speed</span> <span class="o">*</span> <span class="n">time_passed_seconds</span>

    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></code></pre></div>
]]></content>
		</item>
		
		<item>
			<title>Pygame第5章 让画面动起来</title>
			<link>https://gitop.cc/posts/pygame-5/</link>
			<pubDate>Tue, 10 Nov 2015 20:21:33 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/pygame-5/</guid>
			<description>这一章描述如何以一种可以预测的方式在屏幕上移动对象，和如何使运动在其他人电脑里面一致。 理解帧率 我们需要知道计算机游戏中关于运动的第一件事情就</description>
			<content type="html"><![CDATA[

<p>这一章描述如何以一种可以预测的方式在屏幕上移动对象，和如何使运动在其他人电脑里面一致。</p>

<h1 id="理解帧率">理解帧率</h1>

<p>我们需要知道计算机游戏中关于运动的第一件事情就是<strong>没有什么东西真正在移动</strong>。电脑屏幕或电视机展示给我们一系列图片，当两张图片间隔时间够短时，我们的大脑将这些图片混合在一起从而制造了流畅运动的假象。一张图片称为一帧，FPS(Frame Per Second)是每秒的帧数，也就是帧率。产生流畅运动需要的帧数，因人而异。</p>

<p>游戏的帧率也受限于显示设备的刷新速度。比如，显示器的刷新速度为60HZ，也就是每秒刷新60次。产生帧的速度比刷新速度快会导致“tearing”现象，即下一个帧混进前一个帧。电脑要做的事情越多，帧率就会越慢。好消息是现在的桌面电脑已经足以产生你想要的视觉效果。</p>

<p>只需记住几个常量：一般的电视画面是24FPS；30FPS基本可以给玩家提供流畅的体验了；60FPS是LCD常用的刷新率，所以你的游戏的帧率再高也没什么意义了；在70FPS以上，很少有人能察觉任何提升了！</p>

<h1 id="直线运动">直线运动</h1>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">background_image_filename</span> <span class="o">=</span> <span class="s1">&#39;sushiplate.jpg&#39;</span>
<span class="n">sprite_image_filename</span> <span class="o">=</span> <span class="s1">&#39;fugu.png&#39;</span>

<span class="kn">import</span> <span class="nn">pygame</span>
<span class="kn">from</span> <span class="nn">pygame.locals</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="nb">exit</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">background_image_filename</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">sprite</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">sprite_image_filename</span><span class="p">)</span>

<span class="c1"># The x coordinate of our sprite</span>
<span class="n">x</span> <span class="o">=</span> <span class="mf">0.</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">QUIT</span><span class="p">:</span>
            <span class="nb">exit</span><span class="p">()</span>

    <span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
    <span class="n">x</span> <span class="o">+=</span> <span class="mf">10.</span>

    <span class="c1"># If the image goes off the end of the screen, move it back</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mf">640.</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">-=</span> <span class="mf">640.</span>

    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></code></pre></div>

<p>这段代码有两个问题，第一个是我们不能精确知道画一张图片到屏幕需要多长时间，另一个问题是这个精灵在配置差的机器上移动慢，在配置好的机器上移动更快。</p>

<h3 id="关于时间">关于时间</h3>

<p>解决第一个问题的技巧是使运动基于时间。我们需要知道距离上一个帧已经过去多长时间，据此我们能相应地在屏幕上放置任何物体。<strong>pygame.time</strong>模块有一个Clock对象可以用来跟踪时间。使用<strong>pygame.time.Clock()</strong>创建clock对象。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">clock</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">Clock</span><span class="p">()</span></code></pre></div>

<p>一旦创建了clock对象，你应该每一帧调用一次<strong>tick</strong>函数，返回上次调用该函数已过去的时间，单位毫秒。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">time_passed</span> <span class="o">=</span> <span class="n">clock</span><span class="o">.</span><span class="n">tick</span><span class="p">()</span></code></pre></div>

<p><strong>tick</strong>函数也接收一个可选参数表示最大帧率。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="c1"># Game will run at a maximum 30 frames per second</span>
<span class="n">time_passed</span> <span class="o">=</span> <span class="n">clock</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="n">time_passed_seconds</span> <span class="o">=</span> <span class="n">time_passed</span> <span class="o">/</span> <span class="mf">1000.0</span></code></pre></div>

<p>我们要怎样使用这个time_passed_seconds来移动精灵呢？需要做的第一件事就是选择一个精灵移动的速度。接下来只要用这个速度乘于时间就能得出精灵该移动多远。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">background_image_filename</span> <span class="o">=</span> <span class="s1">&#39;sushiplate.jpg&#39;</span>
<span class="n">sprite_image_filename</span> <span class="o">=</span> <span class="s1">&#39;fugu.png&#39;</span>

<span class="kn">import</span> <span class="nn">pygame</span>
<span class="kn">from</span> <span class="nn">pygame.locals</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="nb">exit</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">background_image_filename</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">sprite</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">sprite_image_filename</span><span class="p">)</span>

<span class="c1"># Our clock object</span>
<span class="n">clock</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">Clock</span><span class="p">()</span>

<span class="c1"># X coordinate of our sprite</span>
<span class="n">x</span> <span class="o">=</span> <span class="mf">0.</span>
<span class="c1"># Speed in pixels per second</span>
<span class="n">speed</span> <span class="o">=</span> <span class="mf">250.</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">QUIT</span><span class="p">:</span>
            <span class="nb">exit</span><span class="p">()</span>

    <span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>

    <span class="n">time_passed</span> <span class="o">=</span> <span class="n">clock</span><span class="o">.</span><span class="n">tick</span><span class="p">()</span>
    <span class="n">time_passed_seconds</span> <span class="o">=</span> <span class="n">time_passed</span> <span class="o">/</span> <span class="mf">1000.0</span>

    <span class="n">distance_moved</span> <span class="o">=</span> <span class="n">time_passed_seconds</span> <span class="o">*</span> <span class="n">speed</span>
    <span class="n">x</span> <span class="o">+=</span> <span class="n">distance_moved</span>

    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mf">640.</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">-=</span> <span class="mf">640.</span>

    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></code></pre></div>

<p>理解帧率和精灵移动速度的不同很重要。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">background_image_filename</span> <span class="o">=</span> <span class="s1">&#39;sushiplate.jpg&#39;</span>
<span class="n">sprite_image_filename</span> <span class="o">=</span> <span class="s1">&#39;fugu.png&#39;</span>

<span class="kn">import</span> <span class="nn">pygame</span>
<span class="kn">from</span> <span class="nn">pygame.locals</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="nb">exit</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">background_image_filename</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">sprite</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">sprite_image_filename</span><span class="p">)</span>

<span class="c1"># Our clock object</span>
<span class="n">clock</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">Clock</span><span class="p">()</span>

<span class="n">x1</span> <span class="o">=</span> <span class="mf">0.</span>
<span class="n">x2</span> <span class="o">=</span> <span class="mf">0.</span>
<span class="c1"># Speed in pixels per second</span>
<span class="n">speed</span> <span class="o">=</span> <span class="mf">250.</span>

<span class="n">frame_no</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">QUIT</span><span class="p">:</span>
            <span class="nb">exit</span><span class="p">()</span>

    <span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
    <span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="mi">250</span><span class="p">))</span>

    <span class="n">time_passed</span> <span class="o">=</span> <span class="n">clock</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
    <span class="n">time_passed_seconds</span> <span class="o">=</span> <span class="n">time_passed</span> <span class="o">/</span> <span class="mf">1000.0</span>

    <span class="n">distance_moved</span> <span class="o">=</span> <span class="n">time_passed_seconds</span> <span class="o">*</span> <span class="n">speed</span>
    <span class="n">x1</span> <span class="o">+=</span> <span class="n">distance_moved</span>

    <span class="k">if</span> <span class="n">frame_no</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">distance_moved</span> <span class="o">=</span> <span class="n">time_passed_seconds</span> <span class="o">*</span> <span class="n">speed</span>
        <span class="n">x2</span> <span class="o">+=</span> <span class="n">distance_moved</span> <span class="o">*</span> <span class="mi">5</span>

    <span class="c1"># If the image goes off the end of the screen, move it back</span>
    <span class="k">if</span> <span class="n">x1</span> <span class="o">&gt;</span> <span class="mf">640.</span><span class="p">:</span>
        <span class="n">x1</span> <span class="o">-=</span> <span class="mf">640.</span>
    <span class="k">if</span> <span class="n">x2</span> <span class="o">&gt;</span> <span class="mf">640.</span><span class="p">:</span>
        <span class="n">x2</span> <span class="o">-=</span> <span class="mf">640.</span>

    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
    <span class="n">frame_no</span> <span class="o">+=</span> <span class="mi">1</span></code></pre></div>

<h3 id="斜线运动">斜线运动</h3>

<p>直线运动很有用，但是一个游戏如果所有物体都水平或垂直移动看起来就很笨。我们需要能够在任何方向移动精灵。可以通过调整每个帧的x和y坐标做到。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">background_image_filename</span> <span class="o">=</span> <span class="s1">&#39;sushiplate.jpg&#39;</span>
<span class="n">sprite_image_filename</span> <span class="o">=</span> <span class="s1">&#39;fugu.png&#39;</span>

<span class="kn">import</span> <span class="nn">pygame</span>
<span class="kn">from</span> <span class="nn">pygame.locals</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="nb">exit</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">background_image_filename</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">sprite</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">sprite_image_filename</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>

<span class="n">clock</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">Clock</span><span class="p">()</span>

<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">100.</span><span class="p">,</span> <span class="mf">100.</span>
<span class="n">speed_x</span><span class="p">,</span> <span class="n">speed_y</span> <span class="o">=</span> <span class="mf">133.</span><span class="p">,</span> <span class="mf">170.</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">QUIT</span><span class="p">:</span>
            <span class="nb">exit</span><span class="p">()</span>

    <span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

    <span class="n">time_passed</span> <span class="o">=</span> <span class="n">clock</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
    <span class="n">time_passed_seconds</span> <span class="o">=</span> <span class="n">time_passed</span> <span class="o">/</span> <span class="mf">1000.0</span>

    <span class="n">x</span> <span class="o">+=</span> <span class="n">speed_x</span> <span class="o">*</span> <span class="n">time_passed_seconds</span>
    <span class="n">y</span> <span class="o">+=</span> <span class="n">speed_y</span> <span class="o">*</span> <span class="n">time_passed_seconds</span>

    <span class="c1"># If the sprite goes off the edge of the screen,</span>
    <span class="c1"># make it move in the opposite direction</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">640</span> <span class="o">-</span> <span class="n">sprite</span><span class="o">.</span><span class="n">get_width</span><span class="p">():</span>
        <span class="n">speed_x</span> <span class="o">=</span> <span class="o">-</span><span class="n">speed_x</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">640</span> <span class="o">-</span> <span class="n">sprite</span><span class="o">.</span><span class="n">get_width</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">speed_x</span> <span class="o">=</span> <span class="o">-</span><span class="n">speed_x</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">480</span> <span class="o">-</span> <span class="n">sprite</span><span class="o">.</span><span class="n">get_height</span><span class="p">():</span>
        <span class="n">speed_y</span> <span class="o">=</span> <span class="o">-</span><span class="n">speed_y</span>
        <span class="n">y</span> <span class="o">=</span> <span class="mi">480</span> <span class="o">-</span> <span class="n">sprite</span><span class="o">.</span><span class="n">get_height</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">speed_y</span> <span class="o">=</span> <span class="o">-</span><span class="n">speed_y</span>
        <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></code></pre></div>

<p>为了达到反弹的效果，我们首先必须检查是否撞击到边缘。在坐标上做点简单的算术就行。如果x坐标小于0，则我们超过了屏幕的左边缘。如果x加上精灵的宽度比屏幕的宽度大，则精灵的右边缘超过屏幕的宽度。y坐标的判断类似，只是使用高度而不是宽度。</p>

<h1 id="探索向量">探索向量</h1>

<p>游戏开发者从数学借来向量并用到很多领域，比如2D和3D游戏。向量和点类似，它们都有x和y值(在2D中)，但是用途不一样。一个点的坐标(10, 20)在屏幕上总是同一个位置，而一个向量(10, 20)意思是从当前位置x坐标加上10，y坐标加上20。因此你可以认为一个点的坐标就是从原点(0, 0)到该点的向量。</p>

<h3 id="创建向量">创建向量</h3>

<p>你可以从任意2个点计算向量，只要用第二个点坐标减去第一个点坐标。比如点A(10, 20)，点B(30, 35)，则向量AB就是(20, 15)。这个向量告诉我们从A到B需要在x方向移动20个单位，在y方向移动15个单位。</p>

<h3 id="存储向量">存储向量</h3>

<p>在Python里面没有内置的向量类型，但是你可以将向量存入list，或者自己定义向量类。方便起见，我们选择定义自己的向量类。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Vector2</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;(</span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_points</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">P1</span><span class="p">,</span> <span class="n">P2</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">P2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">P1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">P2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">P1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></code></pre></div>

<p><strong>@classmethod</strong>装饰使函数from_points变成一个类方法。类方法是通过类调用的，不是通过类实例调用，比如Vector2.from_points(P1, P2)。将from_points定义为一个类方法是因为它创建一个新的Vector2对象，而不是修改已经存在的对象。</p>

<h3 id="向量大小">向量大小</h3>

<p>从A到B的向量大小就是2个点之间的距离。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">get_magnitude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span></code></pre></div>

<h3 id="单位向量">单位向量</h3>

<p>向量实际描述了两件事情：大小和方向。通常这两个信息绑定在一个向量里面，但有时候你只需其中一个。有一种特殊的向量叫单位向量，它的大小总是为1。我们可以把任意向量缩放到一个单位向量，这叫向量的规格化。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">magnitude</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_magnitude</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">/=</span> <span class="n">magnitude</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">/=</span> <span class="n">magnitude</span></code></pre></div>

<h3 id="向量加法">向量加法</h3>

<p>向量加法是将两个向量组合产生一个向量，它有两个向量组合的效果。也就是AC=AB+BC。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Vector2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">rhs</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">rhs</span><span class="o">.</span><span class="n">y</span><span class="p">)</span></code></pre></div>

<h3 id="向量减法">向量减法</h3>

<p>向量减法和加法类似。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Vector2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">rhs</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">rhs</span><span class="o">.</span><span class="n">y</span><span class="p">)</span></code></pre></div>

<h3 id="否定向量">否定向量</h3>

<p>如果想要改变向量的方向，使向量AB变成向量BA，需要将向量每个元素都改变符号。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Vector2</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span></code></pre></div>

<h3 id="向量乘法和除法">向量乘法和除法</h3>

<p>将一个向量乘于或除于一个系数(数字)，效果是改变向量的大小。如果向量乘于一个整数，则产生同一方向的向量，如果乘于一个负数，则产生相反方向的向量。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scalar</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Vector2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">scalar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">scalar</span><span class="p">)</span>

<span class="k">def</span> <span class="fm">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scalar</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Vector2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">scalar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">/</span> <span class="n">scalar</span><span class="p">)</span></code></pre></div>

<blockquote>
<p><strong>注意</strong> 向量乘于向量也是可以的，但是在游戏中不常用，你可能永远都不需要它。</p>
</blockquote>

<p>向量乘法如何使用呢？基于时间把向量分解为很多步，向量乘法很有用。如果我们知道从A到B需要10秒，我们可以计算出每一秒我们到达的坐标。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="mf">30.0</span><span class="p">,</span> <span class="mf">35.0</span><span class="p">)</span>
<span class="n">AB</span> <span class="o">=</span> <span class="n">Vector2</span><span class="o">.</span><span class="n">from_points</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="n">step</span> <span class="o">=</span> <span class="n">AB</span> <span class="o">*</span> <span class="o">.</span><span class="mi">1</span>
<span class="n">position</span> <span class="o">=</span> <span class="n">Vector2</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">position</span> <span class="o">+=</span> <span class="n">step</span>
    <span class="k">print</span> <span class="n">position</span></code></pre></div>

<p>当在两个点之间移动，计算中间位置是基本的。你还可以用向量计算在重力，外部作用力和摩擦力作用下很多现实的运动。</p>

<h3 id="游戏对象向量类">游戏对象向量类</h3>

<p>作者已经写了一个二维向量类作为游戏对象的一部分。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">gameobjects.vector2</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="mf">30.0</span><span class="p">,</span> <span class="mf">35.0</span><span class="p">)</span>
<span class="n">AB</span> <span class="o">=</span> <span class="n">Vector2</span><span class="o">.</span><span class="n">from_points</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="k">print</span> <span class="s2">&#34;Vector AB is&#34;</span><span class="p">,</span> <span class="n">AB</span>
<span class="k">print</span> <span class="s2">&#34;AB * 2 is&#34;</span><span class="p">,</span> <span class="n">AB</span> <span class="o">*</span> <span class="mi">2</span>
<span class="k">print</span> <span class="s2">&#34;AB / 2 is&#34;</span><span class="p">,</span> <span class="n">AB</span> <span class="o">/</span> <span class="mi">2</span>
<span class="k">print</span> <span class="s2">&#34;AB + (-10, 5) is&#34;</span><span class="p">,</span> <span class="n">AB</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="k">print</span> <span class="s2">&#34;Magnitude of AB is&#34;</span><span class="p">,</span> <span class="n">AB</span><span class="o">.</span><span class="n">get_magnitude</span><span class="p">()</span>
<span class="k">print</span> <span class="s2">&#34;AB normalized is&#34;</span><span class="p">,</span> <span class="n">AB</span><span class="o">.</span><span class="n">get_normalized</span><span class="p">()</span></code></pre></div>

<h1 id="使用向量创建运动">使用向量创建运动</h1>

<p>既然我们了解了向量，我们可以使用它以多种方式移动游戏角色，而且可以实现简单的，基于力学的物理现象，使得游戏更加可信。</p>

<h3 id="斜线运动-1">斜线运动</h3>

<p>让我们使用向量创建更加精确的斜线运动。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">background_image_filename</span> <span class="o">=</span> <span class="s1">&#39;sushiplate.jpg&#39;</span>
<span class="n">sprite_image_filename</span> <span class="o">=</span> <span class="s1">&#39;fugu.png&#39;</span>

<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="nb">exit</span>
<span class="kn">import</span> <span class="nn">pygame</span>
<span class="kn">from</span> <span class="nn">pygame.locals</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">gameobjects.vector2</span> <span class="kn">import</span> <span class="n">Vector2</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">background_image_filename</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">sprite</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">sprite_image_filename</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>

<span class="n">clock</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">Clock</span><span class="p">()</span>

<span class="n">position</span> <span class="o">=</span> <span class="n">Vector2</span><span class="p">(</span><span class="mf">100.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">)</span>
<span class="n">speed</span> <span class="o">=</span> <span class="mi">250</span>
<span class="n">heading</span> <span class="o">=</span> <span class="n">Vector2</span><span class="p">()</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">QUIT</span><span class="p">:</span>
            <span class="nb">exit</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">MOUSEBUTTONDOWN</span><span class="p">:</span>
            <span class="n">destination</span> <span class="o">=</span> <span class="n">Vector2</span><span class="p">(</span><span class="o">*</span><span class="n">event</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span> <span class="o">-</span> <span class="n">Vector2</span><span class="p">(</span><span class="o">*</span><span class="n">sprite</span><span class="o">.</span><span class="n">get_size</span><span class="p">())</span> <span class="o">/</span> <span class="mf">2.</span>
            <span class="n">heading</span> <span class="o">=</span> <span class="n">Vector2</span><span class="o">.</span><span class="n">from_points</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span>
            <span class="n">heading</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>

        <span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>

        <span class="n">time_passed</span> <span class="o">=</span> <span class="n">clock</span><span class="o">.</span><span class="n">tick</span><span class="p">()</span>
        <span class="n">time_passed_seconds</span> <span class="o">=</span> <span class="n">time_passed</span> <span class="o">/</span> <span class="mf">1000.0</span>

        <span class="n">distance_moved</span> <span class="o">=</span> <span class="n">time_passed_seconds</span> <span class="o">*</span> <span class="n">speed</span>
        <span class="n">position</span> <span class="o">+=</span> <span class="n">heading</span> <span class="o">*</span> <span class="n">distance_moved</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></code></pre></div>

<p>目的坐标的计算需要解释一下。星号(<code>*</code>)用在函数的参数时，扩展为一个元组或列表。因此Vector2(*event.pos)相当于Vector2(event.pos[0], event.pos[1])。</p>
]]></content>
		</item>
		
		<item>
			<title>整理代码片段</title>
			<link>https://gitop.cc/posts/baiyu/</link>
			<pubDate>Tue, 10 Nov 2015 11:18:10 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/baiyu/</guid>
			<description>根据pid获取进程名 void get_process_name_by_pid(int pid, char *name) { char buf[256] = {0}; char path[256] = {0}; sprintf(buf, &amp;#34;/proc/%d/exe&amp;#34;, pid); readlink(buf, path, sizeof(path)); char *filename = basename(path); strcpy(name, filename); } C语言变长数组 C99标准才有的特性 void test_vla(const char *str) { int len = strlen(str); char a[len + 1]; memset(a, 0, sizeof(a));</description>
			<content type="html"><![CDATA[

<h1 id="根据pid获取进程名">根据pid获取进程名</h1>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">get_process_name_by_pid</span><span class="p">(</span><span class="kt">int</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="kt">char</span> <span class="n">path</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&#34;/proc/%d/exe&#34;</span><span class="p">,</span> <span class="n">pid</span><span class="p">);</span>
    <span class="n">readlink</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">path</span><span class="p">));</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span> <span class="o">=</span> <span class="n">basename</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<h1 id="c语言变长数组">C语言变长数组</h1>

<p><strong>C99标准才有的特性</strong></p>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">test_vla</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>

    <span class="kt">char</span> <span class="n">a</span><span class="p">[</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>

    <span class="n">strcpy</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<h1 id="确保路径存在">确保路径存在</h1>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">bool</span> <span class="nf">besure_path</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">pathname</span><span class="p">);</span>

    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>

    <span class="n">strcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">pathname</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">access</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">F_OK</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">mkdir</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mo">0755</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;/&#39;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<h1 id="计算一个数字二进制格式1的个数">计算一个数字二进制格式1的个数</h1>

<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">count_bit</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">count</span><span class="p">;</span>
        <span class="n">n</span> <span class="o">&amp;=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>
]]></content>
		</item>
		
		<item>
			<title>Pygame第4章 创建视觉</title>
			<link>https://gitop.cc/posts/pygame-4/</link>
			<pubDate>Sat, 07 Nov 2015 21:28:44 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/pygame-4/</guid>
			<description>电脑游戏倾向于视觉上很自然，游戏开发者花费很多精力在处理图像和提升视觉效果来创建最令人愉快的体验上。 像素的威力 显示器里的一个独立的点称为一个</description>
			<content type="html"><![CDATA[

<p>电脑游戏倾向于视觉上很自然，游戏开发者花费很多精力在处理图像和提升视觉效果来创建最令人愉快的体验上。</p>

<h1 id="像素的威力">像素的威力</h1>

<p>显示器里的一个独立的点称为一个图像单元或像素。如果一个显示器分辨率为1280x1024，则像素总数为1310720。一个屏幕上像素越多，则图片的质量越好。典型的家用电脑可以显示的颜色数量最高为16.7百万个。如果你想显示每一种颜色，你需要一个分辨率4096x4096的显示器。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">))</span>

<span class="n">all_colors</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Surface</span><span class="p">((</span><span class="mi">4096</span><span class="p">,</span> <span class="mi">4096</span><span class="p">),</span> <span class="n">depth</span><span class="o">=</span><span class="mi">24</span><span class="p">)</span>

<span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">256</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;out of 256&#39;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">)</span> <span class="o">*</span> <span class="mi">256</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="mi">256</span>
    <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">256</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">256</span><span class="p">):</span>
            <span class="n">all_colors</span><span class="o">.</span><span class="n">set_at</span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">g</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">b</span><span class="p">),</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">all_colors</span><span class="p">,</span> <span class="s1">&#39;allcolors.bmp&#39;</span><span class="p">)</span></code></pre></div>

<p>上面程序用到的类或方法：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Surface</span><span class="p">(</span><span class="n">__builtin__</span><span class="o">.</span><span class="n">object</span><span class="p">)</span>
 <span class="o">|</span>  <span class="n">pygame</span><span class="o">.</span><span class="n">Surface</span><span class="p">((</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">),</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">masks</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span> <span class="k">return</span> <span class="n">Surface</span>
 <span class="o">|</span>  <span class="n">pygame</span><span class="o">.</span><span class="n">Surface</span><span class="p">((</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">),</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Surface</span><span class="p">):</span> <span class="k">return</span> <span class="n">Surface</span>
 <span class="o">|</span>  <span class="n">pygame</span> <span class="nb">object</span> <span class="k">for</span> <span class="n">representing</span> <span class="n">images</span>

<span class="n">set_at</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">Surface</span><span class="o">.</span><span class="n">set_at</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">Color</span><span class="p">):</span> <span class="k">return</span> <span class="bp">None</span>
    <span class="nb">set</span> <span class="n">the</span> <span class="n">color</span> <span class="n">value</span> <span class="k">for</span> <span class="n">a</span> <span class="n">single</span> <span class="n">pixel</span>

<span class="n">save</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">Surface</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span> <span class="k">return</span> <span class="bp">None</span>
    <span class="n">save</span> <span class="n">an</span> <span class="n">image</span> <span class="n">to</span> <span class="n">disk</span></code></pre></div>

<h1 id="和颜色打交道">和颜色打交道</h1>

<h3 id="pygame中表示颜色">Pygame中表示颜色</h3>

<p>当Pygame需要一种颜色，你需要传进一个包含三个数字的元组，分别对应红绿蓝三种颜色，每个数值范围为[0, 255]。</p>

<table>
<thead>
<tr>
<th>颜色</th>
<th align="left">红色</th>
<th align="left">绿色</th>
<th align="left">蓝色</th>
<th align="left">元组</th>
</tr>
</thead>

<tbody>
<tr>
<td>黑(Black)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">(0, 0, 0)</td>
</tr>

<tr>
<td>蓝(Blue)</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">255</td>
<td align="left">(0, 0, 255)</td>
</tr>

<tr>
<td>绿(Green)</td>
<td align="left">0</td>
<td align="left">255</td>
<td align="left">0</td>
<td align="left">(0, 255, 0)</td>
</tr>

<tr>
<td>蓝绿(Cyan)</td>
<td align="left">0</td>
<td align="left">255</td>
<td align="left">255</td>
<td align="left">(0, 255, 255)</td>
</tr>

<tr>
<td>红(Red)</td>
<td align="left">255</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">(255, 0, 0)</td>
</tr>

<tr>
<td>洋红(Magenta)</td>
<td align="left">255</td>
<td align="left">0</td>
<td align="left">255</td>
<td align="left">(255, 0, 255)</td>
</tr>

<tr>
<td>黄(Yellow)</td>
<td align="left">255</td>
<td align="left">255</td>
<td align="left">0</td>
<td align="left">(255, 255, 0)</td>
</tr>

<tr>
<td>白(White)</td>
<td align="left">255</td>
<td align="left">255</td>
<td align="left">255</td>
<td align="left">(255, 255, 255)</td>
</tr>
</tbody>
</table>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">pygame</span>
<span class="kn">from</span> <span class="nn">pygame.locals</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="nb">exit</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="c1"># Creates images with smooth gradients</span>
<span class="k">def</span> <span class="nf">create_scales</span><span class="p">(</span><span class="n">height</span><span class="p">):</span>
    <span class="n">red_scale_surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">Surface</span><span class="p">((</span><span class="mi">640</span><span class="p">,</span> <span class="n">height</span><span class="p">))</span>
    <span class="n">green_scale_surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">Surface</span><span class="p">((</span><span class="mi">640</span><span class="p">,</span> <span class="n">height</span><span class="p">))</span>
    <span class="n">blue_scale_surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">Surface</span><span class="p">((</span><span class="mi">640</span><span class="p">,</span> <span class="n">height</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">640</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">x</span> <span class="o">/</span> <span class="mf">639.</span><span class="p">)</span> <span class="o">*</span> <span class="mf">255.</span><span class="p">)</span>
        <span class="n">red</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">green</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">blue</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="n">line_rect</span> <span class="o">=</span> <span class="n">Rect</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">rect</span><span class="p">(</span><span class="n">red_scale_surface</span><span class="p">,</span> <span class="n">red</span><span class="p">,</span> <span class="n">line_rect</span><span class="p">)</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">rect</span><span class="p">(</span><span class="n">green_scale_surface</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">line_rect</span><span class="p">)</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">rect</span><span class="p">(</span><span class="n">blue_scale_surface</span><span class="p">,</span> <span class="n">blue</span><span class="p">,</span> <span class="n">line_rect</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">red_scale_surface</span><span class="p">,</span> <span class="n">green_scale_surface</span><span class="p">,</span> <span class="n">blue_scale_surface</span>

<span class="n">red_scale</span><span class="p">,</span> <span class="n">green_scale</span><span class="p">,</span> <span class="n">blue_scale</span> <span class="o">=</span> <span class="n">create_scales</span><span class="p">(</span><span class="mi">80</span><span class="p">)</span>

<span class="n">color</span> <span class="o">=</span> <span class="p">[</span><span class="mi">127</span><span class="p">,</span> <span class="mi">127</span><span class="p">,</span> <span class="mi">127</span><span class="p">]</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">QUIT</span><span class="p">:</span>
            <span class="nb">exit</span><span class="p">()</span>

    <span class="n">screen</span><span class="o">.</span><span class="n">fill</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="c1"># Draw the scales to the screen</span>
    <span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">red_scale</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">green_scale</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
    <span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">blue_scale</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">160</span><span class="p">))</span>

    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">mouse</span><span class="o">.</span><span class="n">get_pos</span><span class="p">()</span>

    <span class="c1"># If the mouse was pressed on one of the sliders, adjust the color component</span>
    <span class="k">if</span> <span class="n">pygame</span><span class="o">.</span><span class="n">mouse</span><span class="o">.</span><span class="n">get_pressed</span><span class="p">()[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">component</span> <span class="o">*</span> <span class="mi">80</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">component</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">80</span><span class="p">:</span>
                <span class="n">color</span><span class="p">[</span><span class="n">component</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">x</span> <span class="o">/</span> <span class="mf">639.</span><span class="p">)</span> <span class="o">*</span> <span class="mf">255.</span><span class="p">)</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_caption</span><span class="p">(</span><span class="s1">&#39;Pygame Color Test - &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">color</span><span class="p">)))</span>

    <span class="c1"># Draw a circle for each slider to represent the current setting</span>
    <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">((</span><span class="n">color</span><span class="p">[</span><span class="n">component</span><span class="p">]</span> <span class="o">/</span> <span class="mf">255.</span><span class="p">)</span> <span class="o">*</span> <span class="mi">639</span><span class="p">),</span> <span class="n">component</span> <span class="o">*</span> <span class="mi">80</span> <span class="o">+</span> <span class="mi">40</span><span class="p">)</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="n">screen</span><span class="p">,</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">pos</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>

    <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">rect</span><span class="p">(</span><span class="n">screen</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">color</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">240</span><span class="p">))</span>

    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></code></pre></div>

<p>上面程序用到的类或方法：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Rect</span><span class="p">(</span><span class="n">__builtin__</span><span class="o">.</span><span class="n">object</span><span class="p">)</span>
 <span class="o">|</span>  <span class="n">pygame</span><span class="o">.</span><span class="n">Rect</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span> <span class="k">return</span> <span class="n">Rect</span>
 <span class="o">|</span>  <span class="n">pygame</span><span class="o">.</span><span class="n">Rect</span><span class="p">((</span><span class="n">left</span><span class="p">,</span> <span class="n">top</span><span class="p">),</span> <span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)):</span> <span class="k">return</span> <span class="n">Rect</span>
 <span class="o">|</span>  <span class="n">pygame</span><span class="o">.</span><span class="n">Rect</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="k">return</span> <span class="n">Rect</span>
 <span class="o">|</span>  <span class="n">pygame</span> <span class="nb">object</span> <span class="k">for</span> <span class="n">storing</span> <span class="n">rectangular</span> <span class="n">coordinates</span>

<span class="n">rect</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">rect</span><span class="p">(</span><span class="n">Surface</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">Rect</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span> <span class="k">return</span> <span class="n">Rect</span>
    <span class="n">draw</span> <span class="n">a</span> <span class="n">rectangle</span> <span class="n">shape</span>

<span class="n">get_pressed</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">mouse</span><span class="o">.</span><span class="n">get_pressed</span><span class="p">():</span> <span class="k">return</span> <span class="p">(</span><span class="n">button1</span><span class="p">,</span> <span class="n">button2</span><span class="p">,</span> <span class="n">button3</span><span class="p">)</span>
    <span class="n">get</span> <span class="n">the</span> <span class="n">state</span> <span class="n">of</span> <span class="n">the</span> <span class="n">mouse</span> <span class="n">buttons</span>

<span class="n">circle</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="n">Surface</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span> <span class="k">return</span> <span class="n">Rect</span>
    <span class="n">draw</span> <span class="n">a</span> <span class="n">circle</span> <span class="n">around</span> <span class="n">a</span> <span class="n">point</span></code></pre></div>

<h3 id="调整颜色">调整颜色</h3>

<p>要使颜色变暗，只需RGB每一个值都乘于一个0和1之间的系数。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">scale_color</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
    <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="o">=</span> <span class="n">color</span>
    <span class="n">red</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">red</span> <span class="o">*</span> <span class="n">scale</span><span class="p">)</span>
    <span class="n">green</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">green</span> <span class="o">*</span> <span class="n">scale</span><span class="p">)</span>
    <span class="n">blue</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">blue</span> <span class="o">*</span> <span class="n">scale</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span>

<span class="n">fireball_orange</span> <span class="o">=</span> <span class="p">(</span><span class="mi">221</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="k">print</span> <span class="n">fireball_orange</span>
<span class="k">print</span> <span class="n">scale_color</span><span class="p">(</span><span class="n">fireball_orange</span><span class="p">,</span> <span class="o">.</span><span class="mi">5</span><span class="p">)</span></code></pre></div>

<p>如果乘于一个大于1的数，颜色会变得更亮。但是如果颜色值大于255时，Pygame会抛出TypeError异常。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">saturate_color</span><span class="p">(</span><span class="n">color</span><span class="p">):</span>
    <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="o">=</span> <span class="n">color</span>
    <span class="n">red</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">red</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span>
    <span class="n">green</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">green</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span>
    <span class="n">blue</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">blue</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span></code></pre></div>

<p>当颜色饱和至255时，可能就失去原来的色调了，所以需要注意调整的系数。</p>

<h3 id="混合颜色">混合颜色</h3>

<p>有时候我们想要将一种颜色逐渐混入另一种颜色，比如一个僵尸在路过一个火山熔岩坑的时候，它会由绿色变成橙红色，再变为正常的绿色。我们怎样才能计算中间的颜色使得颜色转换平滑自然呢？
我们用一种叫做<strong>线性插值(linear interpolation)</strong>的方法来做这件事情。公式如下：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">lerp</span><span class="p">(</span><span class="n">value1</span><span class="p">,</span> <span class="n">value2</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">value1</span> <span class="o">+</span> <span class="p">(</span><span class="n">value2</span> <span class="o">-</span> <span class="n">value1</span><span class="p">)</span> <span class="o">*</span> <span class="n">factor</span></code></pre></div>

<p>如果逐渐改变系数因子，就会产生颜色的平滑转换。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">pygame</span>
<span class="kn">from</span> <span class="nn">pygame.locals</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="nb">exit</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="n">color1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">221</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span> <span class="c1"># 火球黄</span>
<span class="n">color2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">96</span><span class="p">,</span> <span class="mi">130</span><span class="p">,</span> <span class="mi">51</span><span class="p">)</span> <span class="c1"># 僵尸绿</span>

<span class="n">factor</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">lerp</span><span class="p">(</span><span class="n">value1</span><span class="p">,</span> <span class="n">value2</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">value1</span> <span class="o">+</span> <span class="p">(</span><span class="n">value2</span> <span class="o">-</span> <span class="n">value1</span><span class="p">)</span> <span class="o">*</span> <span class="n">factor</span>

<span class="k">def</span> <span class="nf">blend_color</span><span class="p">(</span><span class="n">color1</span><span class="p">,</span> <span class="n">color2</span><span class="p">,</span> <span class="n">blend_factor</span><span class="p">):</span>
    <span class="n">red1</span><span class="p">,</span> <span class="n">green1</span><span class="p">,</span> <span class="n">blue1</span> <span class="o">=</span> <span class="n">color1</span>
    <span class="n">red2</span><span class="p">,</span> <span class="n">green2</span><span class="p">,</span> <span class="n">blue2</span> <span class="o">=</span> <span class="n">color2</span>
    <span class="n">red</span> <span class="o">=</span> <span class="n">lerp</span><span class="p">(</span><span class="n">red1</span><span class="p">,</span> <span class="n">red2</span><span class="p">,</span> <span class="n">blend_factor</span><span class="p">)</span>
    <span class="n">green</span> <span class="o">=</span> <span class="n">lerp</span><span class="p">(</span><span class="n">green1</span><span class="p">,</span> <span class="n">green2</span><span class="p">,</span> <span class="n">blend_factor</span><span class="p">)</span>
    <span class="n">blue</span> <span class="o">=</span> <span class="n">lerp</span><span class="p">(</span><span class="n">blue1</span><span class="p">,</span> <span class="n">blue2</span><span class="p">,</span> <span class="n">blend_factor</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">red</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">green</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">blue</span><span class="p">)</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">QUIT</span><span class="p">:</span>
            <span class="nb">exit</span><span class="p">()</span>

    <span class="n">screen</span><span class="o">.</span><span class="n">fill</span><span class="p">((</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>

    <span class="n">tri</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">120</span><span class="p">),</span> <span class="p">(</span><span class="mi">639</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="p">(</span><span class="mi">639</span><span class="p">,</span> <span class="mi">140</span><span class="p">)]</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">screen</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">tri</span><span class="p">)</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="n">screen</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">factor</span> <span class="o">*</span> <span class="mf">639.</span><span class="p">),</span> <span class="mi">120</span><span class="p">),</span> <span class="mi">10</span><span class="p">)</span>

    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">mouse</span><span class="o">.</span><span class="n">get_pos</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">pygame</span><span class="o">.</span><span class="n">mouse</span><span class="o">.</span><span class="n">get_pressed</span><span class="p">()[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="mf">639.</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_caption</span><span class="p">(</span><span class="s1">&#39;Pygame Color Blend Test - </span><span class="si">%.3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">factor</span><span class="p">)</span>

    <span class="n">color</span> <span class="o">=</span> <span class="n">blend_color</span><span class="p">(</span><span class="n">color1</span><span class="p">,</span> <span class="n">color2</span><span class="p">,</span> <span class="n">factor</span><span class="p">)</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">rect</span><span class="p">(</span><span class="n">screen</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">240</span><span class="p">))</span>

    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></code></pre></div>

<p>用到的方法：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">polygon</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">Surface</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">pointlist</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span> <span class="k">return</span> <span class="n">Rect</span>
    <span class="n">draw</span> <span class="n">a</span> <span class="n">shape</span> <span class="k">with</span> <span class="nb">any</span> <span class="n">number</span> <span class="n">of</span> <span class="n">sides</span></code></pre></div>

<h1 id="使用图片">使用图片</h1>

<p>图片对大多数游戏都是一个必须的部分。电脑存储图片为颜色的网阵。除了常见的红绿蓝，有些图片还存储额外的信息(alpha通道)。颜色的alpha值通常用来表示当图片画在另一张图片上的透明度。</p>

<h3 id="存储图片">存储图片</h3>

<p>有很多方式存储图片到硬盘。多年来，多种图片格式被开发出来。最有用的两种格式是JPEG和PNG。</p>

<ul>
<li>JPEG(Joint Photographic Expert Group)-JPEG图片文件扩展名为.jpg或.jpeg。数码相机常用这种格式，因为它是特别设计来存储图片的。它使用有损压缩，会降低图片质量，但是能很好地减小文件大小。JPEG不支持透明，对拥有硬边缘的东西比如字体和图表支持不好。</li>
<li>PNG(Portable Network Graphics)-PNG可能是最全面的图片格式，因为它能保存很多种图片类型并且压缩也很好。它也支持alpha通道，对游戏开发者来说是福利。PNG使用的压缩是无损压缩，缺点就是文件比JPEG文件大。</li>
</ul>

<p>除了JPEG和PNG，Pygame支持读取下面的格式：</p>

<ul>
<li>GIF(非动态)-网上使用的很多，支持透明和动画，只是只能有256种颜色，软件和游戏中使用很少</li>
<li>BMP-Windows上的标准图像格式，无压缩，质量很高但尺寸很大，一般不使用</li>
<li>PCX</li>
<li>TGA(只限非压缩的)</li>
<li>TIF</li>
<li>LBM(和PBM)</li>
<li>PBM(和PGM，PPM)</li>
<li>XPM</li>
</ul>

<p>根据经验，对于拥有很多颜色变化的大图片文件使用JPEG，否则使用PNG。</p>

<h3 id="使用surface对象">使用Surface对象</h3>

<p>加载图片到Pygame只需一行，<strong>pygame.image.load</strong>接收一个图片文件名返回一个Surface对象，它是图片的容器。Surface对象可以表示许多种图片类型，但是Pygame隐藏了大多数细节，因此我们能够以相同的方式对待它们。你可以在Surface对象上画图，变形，或拷贝到另一个Surface。甚至屏幕也是一个Surface对象。</p>

<h3 id="创建surface对象">创建Surface对象</h3>

<p>调用<strong>pygame.image.load</strong>是一种创建Surface的方式，它会创建和图片文件相同尺寸和颜色的Surface。也可以创建任意尺寸的空白Surface。使用<strong>pygame.Surface</strong>构造函数可以创建一个空白Surface。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">blank_surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Surface</span><span class="p">((</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">))</span></code></pre></div>

<p>还有一些选项会影响图片的创建。第一个参数是flags：</p>

<ul>
<li>HWSURFACE-创建硬件外观，比非硬件外观更快。通常最好不要设置这个标志，而是留给Pygame决定是否使用硬件外观。</li>
<li>SRCALPHA-创建拥有alpha信息的外观。这个选项需要depth参数设为32。</li>
</ul>

<p>第二个参数为depth，这个参数和<strong>pygame.display.set_mode</strong>的depth参数一样。通常最好不要设置这个参数(或设置为0)，但是如果想要保留alpha信息，则必须设置为32。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">blank_alpha_surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Surface</span><span class="p">((</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">),</span> <span class="n">flags</span><span class="o">=</span><span class="n">SRCALPHA</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">32</span><span class="p">)</span></code></pre></div>

<h3 id="转换surface">转换Surface</h3>

<p>当你使用Surface对象时，你不需要担心图像信息在内存是怎么存储的，因为Pygame隐藏了这些细节，因此不管什么图片类型，你的代码都能工作。自动转换的唯一缺点是如果你使用不同格式的图片，Pygame需要做更多工作，这可能会降低游戏性能。解决的方法是使用<strong>convert</strong>方法转换所有的图片为相同的格式。</p>

<p>如果不带参数调用<strong>convert</strong>，Surface会被转换为和显示设备的Surface一样的格式。这很有用因为通常起点和终点是相同类型的话拷贝Surface非常快，而大多数图片最终会被拷贝到显示设备。调用<strong>pygame.image.load</strong>时附加<strong>.convert()</strong>是个好习惯。Pygame还提供<strong>convert_alpha</strong>方法，转换Surface并保留alpha信息。</p>

<p><strong>convert</strong>和<strong>convert_alpha</strong>可以接收另外一个Surface参数，如果提供了这个参数，则Surface会被转换为和参数一样的Surface。</p>

<h3 id="矩形对象">矩形对象</h3>

<p>当一个函数调用会影响到屏幕的某一部分时，Pygame通常需要你提供一个矩形区域。你可以使用一个4元组定义矩形区域，(left, top, width, height)。或者使用2个2元组，((left, top), (width, height))。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">my_rect1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">150</span><span class="p">)</span>
<span class="n">my_rect2</span> <span class="o">=</span> <span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">150</span><span class="p">))</span></code></pre></div>

<p>Pygame有一个Rect类存储和处理矩形对象。因为Rect对象很常使用，所以它包含在<strong>pygame.locals</strong>里面。创建Rect对象使用一样的元组参数。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">my_rect3</span> <span class="o">=</span> <span class="n">Rect</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">150</span><span class="p">)</span>
<span class="n">my_rect4</span> <span class="o">=</span> <span class="n">Rect</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">150</span><span class="p">))</span></code></pre></div>

<p>一旦创建了Rect对象，就可以使用它来调整位置和大小，检查一个点是否在其中，判断矩形是否交叉等。详细请参考<a href="http://www.pygame.org/docs/ref/rect.html">http://www.pygame.org/docs/ref/rect.html</a></p>

<h3 id="剪裁">剪裁</h3>

<p>通常创建游戏画面的时候，你可能想只绘制一部分。为了解决这个问题，Surface有一个剪裁区域，定义了屏幕的哪一部分可以被绘制。使用<strong>set_clip</strong>方法设置剪裁区域，<strong>get_clip</strong>获得当前剪裁区域。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">screen</span><span class="o">.</span><span class="n">set_clip</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">300</span><span class="p">)</span>
<span class="n">draw_map</span><span class="p">()</span>
<span class="n">screen</span><span class="o">.</span><span class="n">set_clip</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">180</span><span class="p">)</span>
<span class="n">draw_panel</span><span class="p">()</span></code></pre></div>

<h3 id="子表面-subsurface">子表面(Subsurface)</h3>

<p>一个子表面在其它Surface里面的Surface。当你在子表面上画图时，也会画在父表面上。子表面的一个用法是画图形字体。<strong>pygame.font</strong>模块可以产生漂亮的一种颜色的文字，但是游戏可能需要更丰富的表现。你可以为每一个字母保存一个文本，但是更简单的方法是保存所有字母到一张图片，然后创建26个子表面。</p>

<p>使用Surface对象的<strong>subsurface</strong>方法创建子表面，它接收一个Rect参数，表示覆盖父表面哪一部分，返回一个新的和父表面一样格式的Surface对象。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">my_font_image</span> <span class="o">=</span> <span class="n">Pygame</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&#34;font.png&#34;</span><span class="p">)</span>
<span class="n">letters</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">letters</span><span class="p">[</span><span class="s2">&#34;a&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_font_image</span><span class="o">.</span><span class="n">subsurface</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">80</span><span class="p">,</span><span class="mi">80</span><span class="p">))</span>
<span class="n">letters</span><span class="p">[</span><span class="s2">&#34;b&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_font_image</span><span class="o">.</span><span class="n">subsurface</span><span class="p">((</span><span class="mi">80</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">80</span><span class="p">,</span><span class="mi">80</span><span class="p">))</span>

<span class="n">subsurface</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">Surface</span><span class="o">.</span><span class="n">subsurface</span><span class="p">(</span><span class="n">Rect</span><span class="p">):</span> <span class="k">return</span> <span class="n">Surface</span>
    <span class="n">create</span> <span class="n">a</span> <span class="n">new</span> <span class="n">surface</span> <span class="n">that</span> <span class="n">references</span> <span class="n">its</span> <span class="n">parent</span></code></pre></div>

<p>当你使用子表面时，需要记住它们拥有自己的坐标系统。</p>

<h3 id="填充表面">填充表面</h3>

<p><strong>fill</strong>方法使用指定颜色填充Surface对象。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">screen</span><span class="o">.</span><span class="n">fill</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span></code></pre></div>

<p><strong>fill</strong>方法也可以带一个可选的Rect参数，指定填充区域。</p>

<blockquote>
<p><strong>注意</strong> 如果你使用其它方法画整个屏幕，就不必调用<strong>fill</strong>来清屏了。</p>
</blockquote>

<h3 id="设置表面像素">设置表面像素</h3>

<p>你能对表面做的一个最基本的事情就是设置单一像素，效果就是画一个非常小的点。很少需要一次画一个像素，因为有更多有效的画图方式，但是你需要处理脱机图片将会很有用。
使用<strong>set_at</strong>方法，参数为坐标和颜色，可以在表面画一个像素。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python">    <span class="kn">import</span> <span class="nn">pygame</span>
    <span class="kn">from</span> <span class="nn">pygame.locals</span> <span class="kn">import</span> <span class="o">*</span>
    <span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="nb">exit</span>
    <span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randint</span>

    <span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
    <span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">QUIT</span><span class="p">:</span>
                <span class="nb">exit</span><span class="p">()</span>

        <span class="n">rand_col</span> <span class="o">=</span> <span class="p">(</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
            <span class="n">rand_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">639</span><span class="p">),</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">479</span><span class="p">))</span>
            <span class="n">screen</span><span class="o">.</span><span class="n">set_at</span><span class="p">(</span><span class="n">rand_pos</span><span class="p">,</span> <span class="n">rand_col</span><span class="p">)</span>

        <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></code></pre></div>

<h3 id="获得表面的像素">获得表面的像素</h3>

<p>与<strong>set_at</strong>相对的是<strong>get_at</strong>，它返回给定坐标像素的颜色。获取像素有时候对于碰撞检测很必要。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">my_color</span> <span class="o">=</span> <span class="n">screen</span><span class="o">.</span><span class="n">get_at</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span></code></pre></div>

<blockquote>
<p><strong>注意</strong> <strong>get_at</strong>在读取硬件表面时很慢。显示可能是硬件表面，尤其是全屏显示的时候，所以这时应该避免使用<strong>get_at</strong>。</p>
</blockquote>

<h3 id="锁定surface">锁定Surface</h3>

<p>当Pygame在surface上画图时，surface必须先锁定。当surface被锁定时，Pygame完全控制surface，计算机其它进程只能等到surface解锁时才能使用。当你在surface上画图时，加锁和解锁自动发生。但是如果Pygame需要做太多加锁和解锁，程序会变得没有效率。我们可以通过手动加锁和解锁来减少加锁和解锁的次数，从而提高运行速度。</p>

<blockquote>
<p><strong>注意</strong> <strong>lock</strong>和<strong>unlock</strong>的次数必须一样，如果忘记了<strong>unlock</strong>一个surface，Pygame将失去响应。</p>
</blockquote>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">pygame</span>
<span class="kn">from</span> <span class="nn">pygame.locals</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="nb">exit</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randint</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">QUIT</span><span class="p">:</span>
            <span class="nb">exit</span><span class="p">()</span>

    <span class="n">rand_col</span> <span class="o">=</span> <span class="p">(</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>
    <span class="n">screen</span><span class="o">.</span><span class="n">lock</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
        <span class="n">rand_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">639</span><span class="p">),</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">479</span><span class="p">))</span>
        <span class="n">screen</span><span class="o">.</span><span class="n">set_at</span><span class="p">(</span><span class="n">rand_pos</span><span class="p">,</span> <span class="n">rand_col</span><span class="p">)</span>
    <span class="n">screen</span><span class="o">.</span><span class="n">unlock</span><span class="p">()</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></code></pre></div>

<p>不是所有的surface需要加锁。硬件surface需要(屏幕通常是硬件surface)，普通的surface不需要。Pygame提供一个<strong>mustlock</strong>方法返回True如果surface需要加锁。加锁不需要加锁的surface没有问题。</p>

<h3 id="blitting">Blitting</h3>

<p>最常用的surface对象的方法可能是<strong>blit</strong>，是位块传输(<strong>bit block transfer</strong>)的缩写。Blitting意思是从一个surface拷贝图片数据到另一个surface。你可以使用它来画背景，字体，角色和游戏中几乎所有的事。</p>

<p>为了blit一个surface，用目标surface对象调用<strong>blit</strong>，传递源surface和目的坐标。也可以只blit一部分surface。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">ogre</span><span class="p">,</span> <span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">200</span><span class="p">),</span> <span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="n">frame_no</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span></code></pre></div>

<h1 id="用pygame画图">用Pygame画图</h1>

<p>我们在之前的例子中已经使用过一些<strong>pygame.draw</strong>模块的函数了。这个模块的用途就是在屏幕上画几何图形。你可以使用它创建整个游戏而不需要加载其它图片。</p>

<p><strong>pygame.draw</strong>模块的函数前两个参数都是surface和颜色。每一个函数也会至少带一个点，也许是一个点的列表。每个点是一个包含坐标的元组。</p>

<p>画图函数返回一个Rect对象包含了绘制过的区域，对于只想绘制屏幕的一部分很有用。</p>

<table>
<thead>
<tr>
<th>函数</th>
<th align="left">用途</th>
</tr>
</thead>

<tbody>
<tr>
<td>rect</td>
<td align="left">绘制矩形</td>
</tr>

<tr>
<td>polygon</td>
<td align="left">绘制多边形(三条边或更多)</td>
</tr>

<tr>
<td>circle</td>
<td align="left">绘制圆</td>
</tr>

<tr>
<td>ellipse</td>
<td align="left">绘制椭圆</td>
</tr>

<tr>
<td>arc</td>
<td align="left">绘制圆弧</td>
</tr>

<tr>
<td>line</td>
<td align="left">绘制直线</td>
</tr>

<tr>
<td>lines</td>
<td align="left">绘制多个直线</td>
</tr>

<tr>
<td>aaline</td>
<td align="left">绘制平滑直线</td>
</tr>

<tr>
<td>aalines</td>
<td align="left">绘制多个平滑直线</td>
</tr>
</tbody>
</table>

<h3 id="pygame-draw-rect">pygame.draw.rect</h3>

<p>这个函数在surface上画一个矩形。除了目的surface和颜色，<strong>pygame.draw.rect</strong>接收一个Rect对象和width作为参数。如果width为0或忽略，则用固定颜色填充矩形，否则只画边缘。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">pygame</span>
<span class="kn">from</span> <span class="nn">pygame.locals</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="nb">exit</span>

<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">QUIT</span><span class="p">:</span>
            <span class="nb">exit</span><span class="p">()</span>

    <span class="n">screen</span><span class="o">.</span><span class="n">lock</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">random_color</span> <span class="o">=</span> <span class="p">(</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>
        <span class="n">random_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">639</span><span class="p">),</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">479</span><span class="p">))</span>
        <span class="n">random_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">639</span> <span class="o">-</span> <span class="n">randint</span><span class="p">(</span><span class="n">random_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">639</span><span class="p">),</span> <span class="mi">479</span> <span class="o">-</span>
            <span class="n">randint</span><span class="p">(</span><span class="n">random_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">479</span><span class="p">))</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">rect</span><span class="p">(</span><span class="n">screen</span><span class="p">,</span> <span class="n">random_color</span><span class="p">,</span> <span class="n">Rect</span><span class="p">(</span><span class="n">random_pos</span><span class="p">,</span> <span class="n">random_size</span><span class="p">))</span>
    <span class="n">screen</span><span class="o">.</span><span class="n">unlock</span><span class="p">()</span>

    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></code></pre></div>

<p>还有另外一个方法画填充的矩形。surface的<strong>fill</strong>方法接收一个Rect对象指定要填充的区域。<strong>fill</strong>比<strong>pygame.draw.rect</strong>要快，因为<strong>fill</strong>由显卡来执行。</p>

<h3 id="pygame-draw-polygon">pygame.draw.polygon</h3>

<p><strong>pygame.draw.polygon</strong>接收一系列点的列表并在它们之间画形状。它也有一个width参数，如果width被忽略或设置为0，则多边形被填充，否则只画边缘。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">pygame</span>
<span class="kn">from</span> <span class="nn">pygame.locals</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="nb">exit</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">QUIT</span><span class="p">:</span>
            <span class="nb">exit</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">MOUSEBUTTONDOWN</span><span class="p">:</span>
            <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>

    <span class="n">screen</span><span class="o">.</span><span class="n">fill</span><span class="p">((</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">screen</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">points</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="n">screen</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">point</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></code></pre></div>

<h3 id="pygame-draw-circle">pygame.draw.circle</h3>

<p><strong>circle</strong>函数在surface上画圆。它接收一个圆心坐标和半径作为参数。和之前一样，width参数如果为0或忽略，则圆被填充，否则只画边缘。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">pygame</span>
<span class="kn">from</span> <span class="nn">pygame.locals</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="nb">exit</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">QUIT</span><span class="p">:</span>
            <span class="nb">exit</span><span class="p">()</span>

    <span class="n">random_color</span> <span class="o">=</span> <span class="p">(</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>
    <span class="n">random_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">639</span><span class="p">),</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">479</span><span class="p">))</span>
    <span class="n">random_radius</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="n">screen</span><span class="p">,</span> <span class="n">random_color</span><span class="p">,</span> <span class="n">random_pos</span><span class="p">,</span> <span class="n">random_radius</span><span class="p">)</span>

    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></code></pre></div>

<h3 id="pygame-draw-ellipse">pygame.draw.ellipse</h3>

<p><strong>用法</strong>： pygame.draw.ellipse(Surface, color, Rect, width=0)</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">pygame</span>
<span class="kn">from</span> <span class="nn">pygame.locals</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="nb">exit</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">QUIT</span><span class="p">:</span>
            <span class="nb">exit</span><span class="p">()</span>

    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">mouse</span><span class="o">.</span><span class="n">get_pos</span><span class="p">()</span>
    <span class="n">screen</span><span class="o">.</span><span class="n">fill</span><span class="p">((</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">ellipse</span><span class="p">(</span><span class="n">screen</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></code></pre></div>

<h3 id="pygame-draw-arc">pygame.draw.arc</h3>

<p><strong>用法</strong>：pygame.draw.arc(Surface, color, Rect, start_angle, stop_angle, width=1)
<strong>arc</strong>函数仅仅画椭圆的一部分，而且只画边缘。圆弧是不封闭的，因此没有<strong>fill</strong>方法。这个函数的width参数默认为1，你也可以设置为更大的值以得到更粗的线。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
<span class="kn">import</span> <span class="nn">pygame</span>
<span class="kn">from</span> <span class="nn">pygame.locals</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="nb">exit</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">QUIT</span><span class="p">:</span>
            <span class="nb">exit</span><span class="p">()</span>

    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">mouse</span><span class="o">.</span><span class="n">get_pos</span><span class="p">()</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="mf">639.</span><span class="p">)</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="n">screen</span><span class="o">.</span><span class="n">fill</span><span class="p">((</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">arc</span><span class="p">(</span><span class="n">screen</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">639</span><span class="p">,</span> <span class="mi">479</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>

    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></code></pre></div>

<h3 id="pygame-draw-line">pygame.draw.line</h3>

<p><strong>用法</strong>：pygame.draw.line(Surface, color, start_pos, end_pos, width=1)</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">pygame</span>
<span class="kn">from</span> <span class="nn">pygame.locals</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="nb">exit</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">QUIT</span><span class="p">:</span>
            <span class="nb">exit</span><span class="p">()</span>

    <span class="n">screen</span><span class="o">.</span><span class="n">fill</span><span class="p">((</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>
    <span class="n">mouse_pos</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">mouse</span><span class="o">.</span><span class="n">get_pos</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">20</span><span class="p">):</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">screen</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">mouse_pos</span><span class="p">)</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">screen</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">479</span><span class="p">),</span> <span class="n">mouse_pos</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">480</span><span class="p">,</span> <span class="mi">20</span><span class="p">):</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">screen</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">mouse_pos</span><span class="p">)</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">screen</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">639</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">mouse_pos</span><span class="p">)</span>

    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></code></pre></div>

<h3 id="pygame-draw-lines">pygame.draw.lines</h3>

<p><strong>用法</strong>：pygame.draw.lines(Surface, color, closed, pointlist, width=1)</p>

<p>closed是一个布尔值，指明是否需要多画一条线来使这些线条闭合。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">pygame</span>
<span class="kn">from</span> <span class="nn">pygame.locals</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="nb">exit</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">QUIT</span><span class="p">:</span>
            <span class="nb">exit</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">MOUSEMOTION</span><span class="p">:</span>
            <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">screen</span><span class="o">.</span><span class="n">fill</span><span class="p">((</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">lines</span><span class="p">(</span><span class="n">screen</span><span class="p">,</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="bp">False</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></code></pre></div>

<h3 id="pygame-draw-aaline">pygame.draw.aaline</h3>

<p><strong>用法</strong>：pygame.draw.aaline(Surface, color, start_pos, end_pos, width=1)</p>

<p>你可能注意到了上一个画线函数画出的线有锯齿。这是因为一个像素对应一个坐标，而这个坐标可能没有直接在线里面，这个现象叫做锯齿。任何试图避免或减少锯齿的方法称为抗锯齿。</p>

<p><strong>pygame.draw.aaline</strong>和<strong>pygame.draw.line</strong>参数一样，但是能画出平滑的直线。缺点是它慢一点。</p>

<h3 id="pygame-draw-aalines">pygame.draw.aalines</h3>

<p><strong>用法</strong>：pygame.draw.aalines(Surface, color, closed, pointlist, width=1)</p>

<p><strong>pygame.draw.aalines</strong>和<strong>pygame.draw.lines</strong>用法一样。</p>
]]></content>
		</item>
		
		<item>
			<title>Pygame第3章 Pygame介绍</title>
			<link>https://gitop.cc/posts/pygame-3/</link>
			<pubDate>Mon, 02 Nov 2015 08:16:02 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/pygame-3/</guid>
			<description>安装Pygame Ubuntu下安装Pygame: sudo apt-get install python-pygame 装好后，查看Pygame版本: &amp;gt;&amp;gt;&amp;gt; import pygame &amp;gt;&amp;gt;&amp;gt; print pygame.ver 使用Pygame Pygame有很多模块。每</description>
			<content type="html"><![CDATA[

<h1 id="安装pygame">安装Pygame</h1>

<p>Ubuntu下安装Pygame:</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">sudo</span> <span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">install</span> <span class="n">python</span><span class="o">-</span><span class="n">pygame</span></code></pre></div>

<p>装好后，查看Pygame版本:</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">pygame</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">pygame</span><span class="o">.</span><span class="n">ver</span></code></pre></div>

<h1 id="使用pygame">使用Pygame</h1>

<p>Pygame有很多模块。每一个设备都有一个对应的模块。Pygame模块一览：</p>

<table>
<thead>
<tr>
<th>模块名</th>
<th align="left">功能</th>
</tr>
</thead>

<tbody>
<tr>
<td>pygame.cdrom</td>
<td align="left">访问和控制光驱</td>
</tr>

<tr>
<td>pygame.cursors</td>
<td align="left">加载光标图片</td>
</tr>

<tr>
<td>pygame.display</td>
<td align="left">访问显示设备</td>
</tr>

<tr>
<td>pygame.draw</td>
<td align="left">绘制形状、线和点</td>
</tr>

<tr>
<td>pygame.event</td>
<td align="left">管理事件</td>
</tr>

<tr>
<td>pygame.font</td>
<td align="left">使用字体</td>
</tr>

<tr>
<td>pygame.image</td>
<td align="left">加载和存储图片</td>
</tr>

<tr>
<td>pygame.joystick</td>
<td align="left">使用游戏手柄或者类似设备</td>
</tr>

<tr>
<td>pygame.key</td>
<td align="left">读取键盘按键</td>
</tr>

<tr>
<td>pygame.mixer</td>
<td align="left">加载和播放声音</td>
</tr>

<tr>
<td>pygame.mouse</td>
<td align="left">管理鼠标</td>
</tr>

<tr>
<td>pygame.movie</td>
<td align="left">播放视频</td>
</tr>

<tr>
<td>pygame.music</td>
<td align="left">处理音乐和音频流</td>
</tr>

<tr>
<td>pygame.overlay</td>
<td align="left">访问高级视频叠加</td>
</tr>

<tr>
<td>pygame</td>
<td align="left">包含高层Pygame函数</td>
</tr>

<tr>
<td>pygame.rect</td>
<td align="left">管理矩形区域</td>
</tr>

<tr>
<td>pygame.sndarray</td>
<td align="left">操作声音数据</td>
</tr>

<tr>
<td>pygame.sprite</td>
<td align="left">操作移动图像</td>
</tr>

<tr>
<td>pygame.surface</td>
<td align="left">管理图像和屏幕</td>
</tr>

<tr>
<td>pygame.surfarray</td>
<td align="left">管理点阵图像数据</td>
</tr>

<tr>
<td>pygame.time</td>
<td align="left">管理时间和帧信息</td>
</tr>

<tr>
<td>pygame.transform</td>
<td align="left">缩放和移动图像</td>
</tr>
</tbody>
</table>

<p>有些模块可能在某些平台上不存在，比如游戏运行的硬件驱动没有安装，这种情况下，Pygame将设置这个模块为None，可以使用None来测试。下面这段代码检测<code>pygame.font</code>是否可用：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">if</span> <span class="n">pygame</span><span class="o">.</span><span class="n">font</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
    <span class="k">print</span> <span class="s1">&#39;The font module is not available!&#39;</span>
    <span class="nb">exit</span><span class="p">()</span></code></pre></div>

<h1 id="重温hello-world">重温Hello World</h1>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">background_image_filename</span> <span class="o">=</span> <span class="s1">&#39;sushiplate.jpg&#39;</span>
<span class="n">mouse_image_filename</span> <span class="o">=</span> <span class="s1">&#39;fugu.png&#39;</span>

<span class="kn">import</span> <span class="nn">pygame</span>
<span class="kn">from</span> <span class="nn">pygame.locals</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="nb">exit</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_caption</span><span class="p">(</span><span class="s1">&#39;Hello, World!&#39;</span><span class="p">)</span>

<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">background_image_filename</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>
<span class="n">mouse_cursor</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">mouse_image_filename</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">QUIT</span><span class="p">:</span>
            <span class="nb">exit</span><span class="p">()</span>

    <span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">mouse</span><span class="o">.</span><span class="n">get_pos</span><span class="p">()</span>
    <span class="n">x</span> <span class="o">-=</span> <span class="n">mouse_cursor</span><span class="o">.</span><span class="n">get_width</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">y</span> <span class="o">-=</span> <span class="n">mouse_cursor</span><span class="o">.</span><span class="n">get_height</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">mouse_cursor</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></code></pre></div>

<p>第一行导入pygame包，使我们可以访问它的所有子模块。第二行导入一些常用函数和常量，这个不是必须的，但是更方便。</p>

<p><strong>pygame.init()</strong>非常简单，实际上却做了非常多工作。它初始化每一个Pygame的子模块。可以单独初始化某一个模块，比如<strong>pygame.sound.init()</strong>。</p>

<p><strong>pygame.display.set_mode</strong>返回一个Surface对象，代表桌面窗口。第一个参数为元祖，代表分辨率(必须)。第二个是一个标志位，具体意思见下表，如果不用什么特性，就指定0。第三个为色深，如果未提供或设置为0，Pygame将使用当前桌面的值。</p>

<table>
<thead>
<tr>
<th>标志位</th>
<th align="left">用途</th>
</tr>
</thead>

<tbody>
<tr>
<td>FULLSCREEN</td>
<td align="left">创建一个全屏窗口</td>
</tr>

<tr>
<td>DOUBLEBUF</td>
<td align="left">创建一个“双缓冲”窗口，建议在HWSURFACE或者OPENGL时使用</td>
</tr>

<tr>
<td>HWSURFACE</td>
<td align="left">创建一个硬件加速的窗口，必须和FULLSCREEN同时使用</td>
</tr>

<tr>
<td>OPENGL</td>
<td align="left">创建一个OpenGL渲染的窗口</td>
</tr>

<tr>
<td>RESIZABLE</td>
<td align="left">创建一个可变大小的窗口</td>
</tr>

<tr>
<td>NOFRAME</td>
<td align="left">创建一个没有边框的窗口</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th>色深</th>
<th align="left">颜色个数</th>
</tr>
</thead>

<tbody>
<tr>
<td>8 bits</td>
<td align="left">256种颜色</td>
</tr>

<tr>
<td>15 bits</td>
<td align="left">32768种颜色，空闲一位</td>
</tr>

<tr>
<td>16 bits</td>
<td align="left">65536种颜色</td>
</tr>

<tr>
<td>24 bits</td>
<td align="left">16.7百万种颜色</td>
</tr>

<tr>
<td>32 bits</td>
<td align="left">16.7百万种颜色，空闲8位</td>
</tr>
</tbody>
</table>

<p><strong>load</strong>函数读取一个文件并返回一个包含图片数据的Surface对象，直到画出来之前是不可见的。
<strong>convert</strong>函数是将图像数据转化为Surface对象，每次加载完图像以后就应该做这件事件(事实上因为它太常用了，如果你不写Pygame也会帮你做)；
<strong>convert_alpha</strong>相比<strong>convert</strong>，保留了Alpha通道信息(可以简单理解为透明的部分)，这样我们的光标才可以是不规则的形状。</p>

<p>游戏的主循环是一个无限循环，直到用户跳出。在这个主循环里做的事情就是不停地画背景和更新光标位置，虽然背景是不动的，我们还是需要每次都画它，否则鼠标覆盖过的位置就不能恢复正常了。
画完以后一定要<strong>update</strong>更新一下，否则画面一片漆黑。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">init</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">():</span> <span class="k">return</span> <span class="p">(</span><span class="n">numpass</span><span class="p">,</span> <span class="n">numfail</span><span class="p">)</span>
    <span class="n">initialize</span> <span class="nb">all</span> <span class="n">imported</span> <span class="n">pygame</span> <span class="n">modules</span>

<span class="n">set_mode</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">(</span><span class="n">resolution</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span> <span class="k">return</span> <span class="n">Surface</span>
    <span class="n">initialize</span> <span class="n">a</span> <span class="n">window</span> <span class="ow">or</span> <span class="n">screen</span> <span class="k">for</span> <span class="n">display</span>

<span class="n">set_caption</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_caption</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">icontitle</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span> <span class="k">return</span> <span class="bp">None</span>
    <span class="nb">set</span> <span class="n">the</span> <span class="n">current</span> <span class="n">window</span> <span class="n">caption</span>

<span class="n">load</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span> <span class="k">return</span> <span class="n">Surface</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="n">namehint</span><span class="o">=</span><span class="p">):</span> <span class="k">return</span> <span class="n">Surface</span>
    <span class="n">load</span> <span class="n">new</span> <span class="n">image</span> <span class="kn">from</span> <span class="nn">a</span> <span class="nn">file</span>

<span class="n">convert</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">Surface</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">Surface</span><span class="p">):</span> <span class="k">return</span> <span class="n">Surface</span>
    <span class="n">Surface</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span> <span class="k">return</span> <span class="n">Surface</span>
    <span class="n">Surface</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span> <span class="k">return</span> <span class="n">Surface</span>
    <span class="n">Surface</span><span class="o">.</span><span class="n">convert</span><span class="p">():</span> <span class="k">return</span> <span class="n">Surface</span>
    <span class="n">change</span> <span class="n">the</span> <span class="n">pixel</span> <span class="n">format</span> <span class="n">of</span> <span class="n">an</span> <span class="n">image</span>

<span class="n">convert_alpha</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">Surface</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">(</span><span class="n">Surface</span><span class="p">):</span> <span class="k">return</span> <span class="n">Surface</span>
    <span class="n">Surface</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">():</span> <span class="k">return</span> <span class="n">Surface</span>
    <span class="n">change</span> <span class="n">the</span> <span class="n">pixel</span> <span class="n">format</span> <span class="n">of</span> <span class="n">an</span> <span class="n">image</span> <span class="n">including</span> <span class="n">per</span> <span class="n">pixel</span> <span class="n">alphas</span>

<span class="n">get</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">():</span> <span class="k">return</span> <span class="n">Eventlist</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span> <span class="k">return</span> <span class="n">Eventlist</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">typelist</span><span class="p">):</span> <span class="k">return</span> <span class="n">Eventlist</span>
    <span class="n">get</span> <span class="n">events</span> <span class="kn">from</span> <span class="nn">the</span> <span class="nn">queue</span>

<span class="n">blit</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">Surface</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">area</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">special_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span> <span class="k">return</span> <span class="n">Rect</span>
    <span class="n">draw</span> <span class="n">one</span> <span class="n">image</span> <span class="n">onto</span> <span class="n">another</span>

<span class="n">get_pos</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">mouse</span><span class="o">.</span><span class="n">get_pos</span><span class="p">():</span> <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">get</span> <span class="n">the</span> <span class="n">mouse</span> <span class="n">cursor</span> <span class="n">position</span>

<span class="n">get_width</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">Surface</span><span class="o">.</span><span class="n">get_width</span><span class="p">():</span> <span class="k">return</span> <span class="n">width</span>
    <span class="n">get</span> <span class="n">the</span> <span class="n">width</span> <span class="n">of</span> <span class="n">the</span> <span class="n">Surface</span>

<span class="n">get_height</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">Surface</span><span class="o">.</span><span class="n">get_height</span><span class="p">():</span> <span class="k">return</span> <span class="n">height</span>
    <span class="n">get</span> <span class="n">the</span> <span class="n">height</span> <span class="n">of</span> <span class="n">the</span> <span class="n">Surface</span>

<span class="n">update</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">rectangle</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span> <span class="k">return</span> <span class="bp">None</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">rectangle_list</span><span class="p">):</span> <span class="k">return</span> <span class="bp">None</span>
    <span class="n">update</span> <span class="n">portions</span> <span class="n">of</span> <span class="n">the</span> <span class="n">screen</span> <span class="k">for</span> <span class="n">software</span> <span class="n">displays</span></code></pre></div>

<h1 id="理解事件">理解事件</h1>

<p>事件可以在任何时候产生，不管程序当前在做什么。因为你不能对发生的事件立刻做出反应，Pygame将事件存入一个队列，逐个处理。</p>

<h3 id="事件检索">事件检索</h3>

<p>上个程序中，使用<strong>pygame.event.get()</strong>来处理所有的事件，这就像打开大门让所有的人进入。如果我们使用<strong>pygame.event.wait()</strong>，Pygame就会等到一个事件发生才继续下去，就好像等在门口，直到有人来。这个函数不太常用，因为它会挂起程序直到有事情发生；而另外一个方法<strong>pygame.event.poll()</strong>就好一些，一旦调用，它会根据现在的情形返回一个真实的事件，否则返回一个类型为NOEVENT的假事件。</p>

<p>每隔一段固定的时间调用事件处理函数很有必要，这样Pygame才能在内部处理事件。如果不使用任何事件处理函数，也可以调用<strong>pygame.event.pump()</strong>替代事件循环。</p>

<p>事件对象包含一些描述事件发生的成员变量。所有事件对象都有一个事件类型。</p>

<table>
<thead>
<tr>
<th>事件</th>
<th align="left">产生途径</th>
<th align="left">参数</th>
</tr>
</thead>

<tbody>
<tr>
<td>QUIT</td>
<td align="left">用户点击关闭按钮</td>
<td align="left">none</td>
</tr>

<tr>
<td>ACTIVEEVENT</td>
<td align="left">Pygame被激活或隐藏</td>
<td align="left">gain,state</td>
</tr>

<tr>
<td>KEYDOWN</td>
<td align="left">键盘按下</td>
<td align="left">unicode,key,mod</td>
</tr>

<tr>
<td>KEYUP</td>
<td align="left">键盘松开</td>
<td align="left">key,mod</td>
</tr>

<tr>
<td>MOUSEMOTION</td>
<td align="left">鼠标移动</td>
<td align="left">pos,rel,buttons</td>
</tr>

<tr>
<td>MOUSEBUTTONDOWN</td>
<td align="left">鼠标按下</td>
<td align="left">pos,button</td>
</tr>

<tr>
<td>MOUSEBUTTONUP</td>
<td align="left">鼠标松开</td>
<td align="left">pos,button</td>
</tr>

<tr>
<td>JOYAXISMOTION</td>
<td align="left">游戏手柄(Joystick or pad)移动</td>
<td align="left">joy,axis,value</td>
</tr>

<tr>
<td>JOYBALLMOTION</td>
<td align="left">游戏球(Joy ball)移动</td>
<td align="left">joy,ball,rel</td>
</tr>

<tr>
<td>JOYHATMOTION</td>
<td align="left">游戏手柄(Joystick)移动</td>
<td align="left">joy,hat,value</td>
</tr>

<tr>
<td>JOYBUTTONDOWN</td>
<td align="left">游戏手柄按下</td>
<td align="left">joy,button</td>
</tr>

<tr>
<td>JOYBUTTONUP</td>
<td align="left">游戏手柄放开</td>
<td align="left">joy,button</td>
</tr>

<tr>
<td>VIDEORESIZE</td>
<td align="left">Pygame窗口缩放</td>
<td align="left">size,w,h</td>
</tr>

<tr>
<td>VIDEOEXPOSE</td>
<td align="left">部分或所有Pygame窗口暴露</td>
<td align="left">none</td>
</tr>

<tr>
<td>USEREVENT</td>
<td align="left">触发一个用户事件</td>
<td align="left">code</td>
</tr>
</tbody>
</table>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">pygame</span>
<span class="kn">from</span> <span class="nn">pygame.locals</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="nb">exit</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="n">SCREEN_SIZE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">)</span>
<span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">(</span><span class="n">SCREEN_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="n">font</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">font</span><span class="o">.</span><span class="n">SysFont</span><span class="p">(</span><span class="s1">&#39;arial&#39;</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">font_height</span> <span class="o">=</span> <span class="n">font</span><span class="o">.</span><span class="n">get_linesize</span><span class="p">()</span>
<span class="n">event_text</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">event</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
    <span class="n">event_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
    <span class="n">event_text</span> <span class="o">=</span> <span class="n">event_text</span><span class="p">[</span><span class="o">-</span><span class="n">SCREEN_SIZE</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">font_height</span><span class="p">:]</span>

    <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">QUIT</span><span class="p">:</span>
        <span class="nb">exit</span><span class="p">()</span>

    <span class="n">screen</span><span class="o">.</span><span class="n">fill</span><span class="p">((</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>

    <span class="n">y</span> <span class="o">=</span> <span class="n">SCREEN_SIZE</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">font_height</span>
    <span class="k">for</span> <span class="n">text</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">event_text</span><span class="p">):</span>
        <span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">font</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
        <span class="n">y</span> <span class="o">-=</span> <span class="n">font_height</span>

    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></code></pre></div>

<p><strong>pygame.font.SysFont</strong>返回一个pygame.font.Font对象。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">SysFont</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">bold</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">italic</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">font</span><span class="o">.</span><span class="n">SysFont</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">bold</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">italic</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Font</span>
    <span class="n">create</span> <span class="n">a</span> <span class="n">pygame</span> <span class="n">Font</span> <span class="kn">from</span> <span class="nn">system</span> <span class="nn">font</span> <span class="nn">resources</span>
    
    <span class="n">This</span> <span class="n">will</span> <span class="n">search</span> <span class="n">the</span> <span class="n">system</span> <span class="n">fonts</span> <span class="k">for</span> <span class="n">the</span> <span class="n">given</span> <span class="n">font</span>
    <span class="n">name</span><span class="o">.</span> <span class="n">You</span> <span class="n">can</span> <span class="n">also</span> <span class="n">enable</span> <span class="n">bold</span> <span class="ow">or</span> <span class="n">italic</span> <span class="n">styles</span><span class="p">,</span> <span class="ow">and</span>
    <span class="n">the</span> <span class="n">appropriate</span> <span class="n">system</span> <span class="n">font</span> <span class="n">will</span> <span class="n">be</span> <span class="n">selected</span> <span class="k">if</span> <span class="n">available</span><span class="o">.</span>
    
    <span class="n">This</span> <span class="n">will</span> <span class="n">always</span> <span class="k">return</span> <span class="n">a</span> <span class="n">valid</span> <span class="n">Font</span> <span class="nb">object</span><span class="p">,</span> <span class="ow">and</span> <span class="n">will</span>
    <span class="n">fallback</span> <span class="n">on</span> <span class="n">the</span> <span class="n">builtin</span> <span class="n">pygame</span> <span class="n">font</span> <span class="k">if</span> <span class="n">the</span> <span class="n">given</span> <span class="n">font</span>
    <span class="ow">is</span> <span class="ow">not</span> <span class="n">found</span><span class="o">.</span>
    
    <span class="n">Name</span> <span class="n">can</span> <span class="n">also</span> <span class="n">be</span> <span class="n">a</span> <span class="n">comma</span> <span class="n">separated</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">names</span><span class="p">,</span> <span class="ow">in</span>
    <span class="n">which</span> <span class="n">case</span> <span class="nb">set</span> <span class="n">of</span> <span class="n">names</span> <span class="n">will</span> <span class="n">be</span> <span class="n">searched</span> <span class="ow">in</span> <span class="n">order</span><span class="o">.</span> <span class="n">Pygame</span>
    <span class="n">uses</span> <span class="n">a</span> <span class="n">small</span> <span class="nb">set</span> <span class="n">of</span> <span class="n">common</span> <span class="n">font</span> <span class="n">aliases</span><span class="p">,</span> <span class="k">if</span> <span class="n">the</span> <span class="n">specific</span>
    <span class="n">font</span> <span class="n">you</span> <span class="n">ask</span> <span class="k">for</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">available</span><span class="p">,</span> <span class="n">a</span> <span class="n">reasonable</span> <span class="n">alternative</span>
    <span class="n">may</span> <span class="n">be</span> <span class="n">used</span><span class="o">.</span>

<span class="n">get_linesize</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">Font</span><span class="o">.</span><span class="n">get_linesize</span><span class="p">():</span> <span class="k">return</span> <span class="nb">int</span>
    <span class="n">get</span> <span class="n">the</span> <span class="n">line</span> <span class="n">space</span> <span class="n">of</span> <span class="n">the</span> <span class="n">font</span> <span class="n">text</span>

<span class="n">wait</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">wait</span><span class="p">():</span> <span class="k">return</span> <span class="n">Event</span>
    <span class="n">wait</span> <span class="k">for</span> <span class="n">a</span> <span class="n">single</span> <span class="n">event</span> <span class="kn">from</span> <span class="nn">the</span> <span class="nn">queue</span>

<span class="n">render</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">Font</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span> <span class="k">return</span> <span class="n">Surface</span>
    <span class="n">draw</span> <span class="n">text</span> <span class="n">on</span> <span class="n">a</span> <span class="n">new</span> <span class="n">Surface</span>

<span class="n">fill</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">Surface</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="n">rect</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">special_flags</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span> <span class="k">return</span> <span class="n">Rect</span>
    <span class="n">fill</span> <span class="n">Surface</span> <span class="k">with</span> <span class="n">a</span> <span class="n">solid</span> <span class="n">color</span>

<span class="n">pump</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">pump</span><span class="p">():</span> <span class="k">return</span> <span class="bp">None</span>
    <span class="n">internally</span> <span class="n">process</span> <span class="n">pygame</span> <span class="n">event</span> <span class="n">handlers</span></code></pre></div>

<h3 id="处理鼠标移动事件">处理鼠标移动事件</h3>

<p>当鼠标移动时，<strong>MOUSEMOTION</strong>事件发生。包含下面三个值：</p>

<ul>
<li>buttons-一个对应鼠标按钮的元组。buttons[0]是鼠标左按钮，buttons[1]是鼠标中间按钮，buttons[2]是鼠标右按钮。如果按钮被按下，则值为1，反之为0。多个按钮可以同时按下。</li>
<li>pos-一个元组，包含事件发生时鼠标所在位置。</li>
<li>rel-一个元祖，包含现在距离上次产生鼠标事件时的距离。</li>
</ul>

<h3 id="处理鼠标按钮事件">处理鼠标按钮事件</h3>

<p>除了鼠标移动事件，鼠标还能产生<strong>MOUSEBUTTONDOWN</strong>和<strong>MOUSEBUTTONUP</strong>事件。包含下面2个值：</p>

<ul>
<li>button-被按下的按钮的数字。1为鼠标左按钮，2为鼠标中间按钮，3为鼠标右按钮。</li>
<li>pos-一个元组，包含事件发生时鼠标所在位置。</li>
</ul>

<h3 id="处理键盘事件">处理键盘事件</h3>

<p>键盘和游戏手柄的事件类似。当一个键被按下<strong>KEYDOWN</strong>事件发生。当一个键松开<strong>KEYUP</strong>事件发生。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">bg_file</span> <span class="o">=</span> <span class="s1">&#39;sushiplate.jpg&#39;</span>

<span class="kn">import</span> <span class="nn">pygame</span>
<span class="kn">from</span> <span class="nn">pygame.locals</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="nb">exit</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="n">FULLSCREEN</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">bg_file</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
<span class="n">move_x</span><span class="p">,</span> <span class="n">move_y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">QUIT</span><span class="p">:</span>
            <span class="nb">exit</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">KEYDOWN</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">K_LEFT</span><span class="p">:</span>
                <span class="n">move_x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">K_RIGHT</span><span class="p">:</span>
                <span class="n">move_x</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">K_UP</span><span class="p">:</span>
                <span class="n">move_y</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">K_DOWN</span><span class="p">:</span>
                <span class="n">move_y</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">KEYUP</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">K_LEFT</span> <span class="ow">or</span> <span class="n">event</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">K_RIGHT</span><span class="p">:</span>
                <span class="n">move_x</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">event</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">K_UP</span> <span class="ow">or</span> <span class="n">event</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">K_DOWN</span><span class="p">:</span>
                <span class="n">move_y</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">x</span> <span class="o">+=</span> <span class="n">move_x</span>
    <span class="n">y</span> <span class="o">+=</span> <span class="n">move_y</span>

    <span class="n">screen</span><span class="o">.</span><span class="n">fill</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></code></pre></div>

<p><strong>KEYDOWN</strong>和<strong>KEYUP</strong>事件包含下面三个值：</p>

<ul>
<li>key-这是一个代表按下或松开的键值的数字。每一个键盘上的物理按钮都有一个以K_开头的常量。字母键为K_a到K_z，其它的如K_SPACE和K_RETURN。</li>
<li>mod-这个值代表和key组合使用的其它键，比如Shift，Alt和Ctrl。每一个组合键以KMOD_开头，比如KMOD_SHIFT，KMOD_ALT和KMOD_CTRL。如果mod &amp; KMOD_CTRL为真，则表示按下了Ctrl键。</li>
<li>unicode-这个是被按下的键的Unicode值。每一个符号都有一个Unicode值与它对应。</li>
</ul>

<h3 id="过滤事件">过滤事件</h3>

<p>一个游戏不是所有的事件都需要处理，而且通常存在其它方式获取某个事件可能提供的信息。比如，使用<strong>pygame.mouse.get_pos()</strong>就不需要响应<strong>MOUSEMOTION</strong>事件了。</p>

<p>使用<strong>pygame.event.set_blocked</strong>函数可以屏蔽事件，阻止事件进入事件队列。比如：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">set_blocked</span><span class="p">(</span><span class="n">MOUSEMOTION</span><span class="p">)</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">set_blocked</span><span class="p">([</span><span class="n">KEYDOWN</span><span class="p">,</span> <span class="n">KEYUP</span><span class="p">])</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">set_blocked</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>

<span class="n">set_blocked</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">set_blocked</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span> <span class="k">return</span> <span class="bp">None</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">set_blocked</span><span class="p">(</span><span class="n">typelist</span><span class="p">):</span> <span class="k">return</span> <span class="bp">None</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">set_blocked</span><span class="p">(</span><span class="bp">None</span><span class="p">):</span> <span class="k">return</span> <span class="bp">None</span>
    <span class="n">control</span> <span class="n">which</span> <span class="n">events</span> <span class="n">are</span> <span class="n">allowed</span> <span class="n">on</span> <span class="n">the</span> <span class="n">queue</span></code></pre></div>

<p>与之相对的，<strong>pygame.event.set_allowed</strong>设定允许的事件。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">set_allowed</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">set_allowed</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span> <span class="k">return</span> <span class="bp">None</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">set_allowed</span><span class="p">(</span><span class="n">typelist</span><span class="p">):</span> <span class="k">return</span> <span class="bp">None</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">set_allowed</span><span class="p">(</span><span class="bp">None</span><span class="p">):</span> <span class="k">return</span> <span class="bp">None</span>
    <span class="n">control</span> <span class="n">which</span> <span class="n">events</span> <span class="n">are</span> <span class="n">allowed</span> <span class="n">on</span> <span class="n">the</span> <span class="n">queue</span></code></pre></div>

<p><strong>pygame.event.get_blocked</strong>可以查询一个事件是否被屏蔽。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">get_blocked</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get_blocked</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span> <span class="k">return</span> <span class="nb">bool</span>
    <span class="n">test</span> <span class="k">if</span> <span class="n">a</span> <span class="nb">type</span> <span class="n">of</span> <span class="n">event</span> <span class="ow">is</span> <span class="n">blocked</span> <span class="kn">from</span> <span class="nn">the</span> <span class="nn">queue</span></code></pre></div>

<h3 id="产生事件">产生事件</h3>

<p>通常Pygame为你产生相应的事件，但是你也可以产生自己的事件。为了产生一个事件，必须首先使用<strong>pygame.event.Event</strong>创建一个事件对象，然后使用<strong>pygame.event.post</strong>发送到事件队列尾端。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">my_event</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">Event</span><span class="p">(</span><span class="n">KEYDOWN</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">K_SPACE</span><span class="p">,</span> <span class="n">mod</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">unicode</span><span class="o">=</span><span class="sa">u</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
<span class="n">pgame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="n">my_event</span><span class="p">)</span></code></pre></div>

<p>事件构造函数接收事件类型和事件值参数。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">Event</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">Event</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span> <span class="k">return</span> <span class="n">Event</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">Event</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="o">**</span><span class="n">attributes</span><span class="p">):</span> <span class="k">return</span> <span class="n">Event</span>
    <span class="n">create</span> <span class="n">a</span> <span class="n">new</span> <span class="n">event</span> <span class="nb">object</span>

<span class="n">post</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="n">Event</span><span class="p">):</span> <span class="k">return</span> <span class="bp">None</span>
    <span class="n">place</span> <span class="n">a</span> <span class="n">new</span> <span class="n">event</span> <span class="n">on</span> <span class="n">the</span> <span class="n">queue</span></code></pre></div>

<p>除了模拟Pygame产生的事件，也可以创建新的事件。你只需使用一个大于<strong>USEREVENT</strong>的值作为事件的值。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">CATONKEYBOARD</span> <span class="o">=</span> <span class="n">USEREVENT</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">my_event</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">Event</span><span class="p">(</span><span class="n">CATONKEYBOARD</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&#34;Bad cat!&#34;</span><span class="p">)</span>
<span class="n">pgame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="n">my_event</span><span class="p">)</span>

<span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">CATONKEYBOARD</span><span class="p">:</span>
        <span class="k">print</span> <span class="n">event</span><span class="o">.</span><span class="n">message</span></code></pre></div>

<h1 id="打开一个显示">打开一个显示</h1>

<h3 id="全屏显示">全屏显示</h3>

<p><strong>pygame.display.set_mode</strong>第二个参数设置为<strong>FULLSCREEN</strong>，就能得到一个全屏窗口了。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="n">FULLSCREEN</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span></code></pre></div>

<blockquote>
<p><strong>注意</strong>
如果在全屏模式下出问题，有时候非常难回到桌面。因此进入全屏模式前，需要先在窗口模式下测试。同时提供一个退出程序方法，因为全屏模式下关闭按钮看不到。</p>
</blockquote>

<p>当进入全屏时，你的显卡可能会切换到不同的显示模式，这将改变显示的宽度，高度和一次显示颜色的数量。显卡只支持几种大小和颜色数量的组合。如果显示的大小不支持，Pygame将选择下一个大小，并居中显示。<strong>pygame.display.list_modes</strong>可以查看显卡支持的分辨率。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">pygame</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">list_modes</span><span class="p">()</span>

<span class="n">list_modes</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">list_modes</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">pygame</span><span class="o">.</span><span class="n">FULLSCREEN</span><span class="p">):</span> <span class="k">return</span> <span class="nb">list</span>
    <span class="n">get</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">available</span> <span class="n">fullscreen</span> <span class="n">modes</span></code></pre></div>

<p>如果显卡不支持你想要的颜色数量，Pygame将自动转换以适应当前显示设备。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">background_image_filename</span> <span class="o">=</span> <span class="s1">&#39;sushiplate.jpg&#39;</span>

<span class="kn">import</span> <span class="nn">pygame</span>
<span class="kn">from</span> <span class="nn">pygame.locals</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="nb">exit</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">background_image_filename</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="n">Fullscreen</span> <span class="o">=</span> <span class="bp">False</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">QUIT</span><span class="p">:</span>
            <span class="nb">exit</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">KEYDOWN</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="n">K_f</span><span class="p">:</span>
            <span class="n">Fullscreen</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">Fullscreen</span>
            <span class="k">if</span> <span class="n">Fullscreen</span><span class="p">:</span>
                <span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="n">FULLSCREEN</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

    <span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></code></pre></div>

<h3 id="可变尺寸的pygame窗口">可变尺寸的Pygame窗口</h3>

<p>有时候用户想要能够改变窗口大小，调用<strong>pygame.display.set_mode</strong>时使用<strong>RESIZABLE</strong>标志位，可以达到这个目的。Pygame通过发送包含新宽高的<strong>VIDEORESIZE</strong>事件告诉用户窗口大小改变了。当收到这个事件时，我们应该再次调用<strong>pygame.display.set_mode</strong>。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">background_image_filename</span> <span class="o">=</span> <span class="s1">&#39;sushiplate.jpg&#39;</span>

<span class="kn">import</span> <span class="nn">pygame</span>
<span class="kn">from</span> <span class="nn">pygame.locals</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="nb">exit</span>

<span class="n">SCREEN_SIZE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">)</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">(</span><span class="n">SCREEN_SIZE</span><span class="p">,</span> <span class="n">RESIZABLE</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">background_image_filename</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">event</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">QUIT</span><span class="p">:</span>
        <span class="nb">exit</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">VIDEORESIZE</span><span class="p">:</span>
        <span class="n">SCREEN_SIZE</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">size</span>
        <span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">(</span><span class="n">SCREEN_SIZE</span><span class="p">,</span> <span class="n">RESIZABLE</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_caption</span><span class="p">(</span><span class="s1">&#39;Window resized to &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>

    <span class="n">screen_width</span><span class="p">,</span> <span class="n">screen_height</span> <span class="o">=</span> <span class="n">SCREEN_SIZE</span>
    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">screen_height</span><span class="p">,</span> <span class="n">background</span><span class="o">.</span><span class="n">get_height</span><span class="p">()):</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">screen_width</span><span class="p">,</span> <span class="n">background</span><span class="o">.</span><span class="n">get_width</span><span class="p">()):</span>
            <span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></code></pre></div>

<p><strong>VIDEORESIZE</strong>事件包含下面的值：
* size-一个元组，包含更改后窗口的尺寸。size[0]代表宽度，size[1]代表高度。
* w-宽度，和size[0]一样，但是更方便
* h-高度，和size[1]一样，但是更方便</p>

<h3 id="无边框窗口">无边框窗口</h3>

<p>当调用<strong>set_mode</strong>时使用<strong>NOFRAME</strong>标志可以设置一个无边框窗口。</p>

<h3 id="其它显示标志">其它显示标志</h3>

<p>通常最好是使用0显示窗口而使用<strong>FULLSCREEN</strong>全屏以保证程序在所有平台都能运行。其它高级标志也许会有兼容问题。
如果设置了<strong>HWSURFACE</strong>标志，将创建一个硬件显示，存储在显存里面，只能和<strong>FULLSCREEN</strong>一起使用。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">(</span><span class="n">SCREEN_SIZE</span><span class="p">,</span> <span class="n">HWSURFACE</span> <span class="o">|</span> <span class="n">FULLSCREEN</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span></code></pre></div>

<p>硬件显示比常规显示更快，因为它能够利用显卡的特性加速显示，缺点是兼容性不够好。硬件显示也能从<strong>DOUBLEBUF</strong>标志受益。这个有效地创建2个硬件显示，但是一次只能看见一个。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">(</span><span class="n">SCREEN_SIZE</span><span class="p">,</span> <span class="n">DOUBLEBUF</span> <span class="o">|</span> <span class="n">HWSURFACE</span> <span class="o">|</span> <span class="n">FULLSCREEN</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span></code></pre></div>

<p>通常当你调用<strong>pygame.display.update()</strong>时，整个屏幕从内存拷贝到显示设备，这会花费一些时间。而双缓冲允许你立刻切换到新的屏幕，使你的程序运行更快。</p>

<blockquote>
<p><strong>注意</strong>
如果使用双缓冲显示，应该调用<strong>pygame.display.flip()</strong>而不是<strong>pygame.display.update()</strong>。这个做立即显示切换而不是拷贝屏幕数据。</p>
</blockquote>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">flip</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">flip</span><span class="p">():</span> <span class="k">return</span> <span class="bp">None</span>
    <span class="n">update</span> <span class="n">the</span> <span class="n">full</span> <span class="n">display</span> <span class="n">Surface</span> <span class="n">to</span> <span class="n">the</span> <span class="n">screen</span></code></pre></div>

<p>最后一个显示标志是<strong>OPENGL</strong>，它能够使用3D加速显示。</p>

<h1 id="使用字体模块">使用字体模块</h1>

<p>字体模块使用TrueType字体(TTFs)。必须先创建一个Font对象才能使用字体。最简单的方式就是使用<strong>pygame.font.SysFont</strong>，它会使用系统自带的一个字体。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">my_font</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">font</span><span class="o">.</span><span class="n">SysFont</span><span class="p">(</span><span class="s2">&#34;arial&#34;</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span></code></pre></div>

<p>第一个参数是你想要创建字体的名字，第二个参数指定了字体的大小。Pygame会在系统字体里面查找，如果没找到则返回一个默认字体。<strong>pygame.font.get_fonts()</strong>可以获得当前系统所有可用字体。也可以使用<strong>pygame.font.Font</strong>直接从.ttf文件创建字体。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">my_font</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">font</span><span class="o">.</span><span class="n">Font</span><span class="p">(</span><span class="s2">&#34;my_font.ttf&#34;</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Font</span><span class="p">(</span><span class="n">__builtin__</span><span class="o">.</span><span class="n">object</span><span class="p">)</span>
 <span class="o">|</span>  <span class="n">pygame</span><span class="o">.</span><span class="n">font</span><span class="o">.</span><span class="n">Font</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span> <span class="k">return</span> <span class="n">Font</span>
 <span class="o">|</span>  <span class="n">pygame</span><span class="o">.</span><span class="n">font</span><span class="o">.</span><span class="n">Font</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span> <span class="k">return</span> <span class="n">Font</span>
 <span class="o">|</span>  <span class="n">create</span> <span class="n">a</span> <span class="n">new</span> <span class="n">Font</span> <span class="nb">object</span> <span class="kn">from</span> <span class="nn">a</span> <span class="nn">file</span>

<span class="n">get_fonts</span><span class="p">()</span>
    <span class="n">pygame</span><span class="o">.</span><span class="n">font</span><span class="o">.</span><span class="n">get_fonts</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">list</span>
    <span class="n">get</span> <span class="n">a</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">system</span> <span class="n">font</span> <span class="n">names</span>
    
    <span class="n">Returns</span> <span class="n">the</span> <span class="nb">list</span> <span class="n">of</span> <span class="nb">all</span> <span class="n">found</span> <span class="n">system</span> <span class="n">fonts</span><span class="o">.</span> <span class="n">Note</span> <span class="n">that</span>
    <span class="n">the</span> <span class="n">names</span> <span class="n">of</span> <span class="n">the</span> <span class="n">fonts</span> <span class="n">will</span> <span class="n">be</span> <span class="nb">all</span> <span class="n">lowercase</span> <span class="k">with</span> <span class="n">spaces</span>
    <span class="n">removed</span><span class="o">.</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">how</span> <span class="n">pygame</span> <span class="n">internally</span> <span class="n">stores</span> <span class="n">the</span> <span class="n">font</span>
    <span class="n">names</span> <span class="k">for</span> <span class="n">matching</span><span class="o">.</span></code></pre></div>

<p>一旦创建了Font对象，就可以使用Font对象的<strong>render</strong>函数来渲染文字。它创建一个新的包含文字的Surface，可以输出到显示设备。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">text_surface</span> <span class="o">=</span> <span class="n">my_font</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="s2">&#34;Pygame is cool!&#34;</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>

<span class="n">render</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">Font</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">antialias</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span> <span class="k">return</span> <span class="n">Surface</span>
    <span class="n">draw</span> <span class="n">text</span> <span class="n">on</span> <span class="n">a</span> <span class="n">new</span> <span class="n">Surface</span></code></pre></div>

<p><strong>render</strong>的第一个参数是你想渲染的文字，它必须是一行。如果有多行，必须使用多个<strong>render</strong>调用。第二个参数是一个布尔值，用来开启抗锯齿。如果设置为True，则文字看起来会比较平滑。后面两个参数是文字的颜色和背景颜色。背景色是可选的，默认为透明的。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">pygame</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

<span class="n">my_name</span> <span class="o">=</span> <span class="s1">&#39;Smith&#39;</span>
<span class="n">my_font</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">font</span><span class="o">.</span><span class="n">SysFont</span><span class="p">(</span><span class="s1">&#39;arial&#39;</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="n">name_surface</span> <span class="o">=</span> <span class="n">my_font</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">my_name</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">name_surface</span><span class="p">,</span> <span class="s1">&#39;name.png&#39;</span><span class="p">)</span></code></pre></div>

<p>font模块详尽参考见<a href="http://www.pygame.org/docs/ref/font.html">http://www.pygame.org/docs/ref/font.html</a></p>

<blockquote>
<p><strong>注意</strong>
安装的字体因机各异，不能保证某个字体一定存在。解决方法是.ttf文件同游戏一起发布，但必须得到字体作者的许可。</p>
</blockquote>

<h1 id="当pygame出错">当Pygame出错</h1>

<p>当<strong>pygame.image.load</strong>不能读取图片时，Pygame会抛出<strong>pygame.error</strong>异常。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">pygame</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="mi">640</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
<span class="n">File</span> <span class="s2">&#34;&lt;interactive input&gt;&#34;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="err">?</span>
<span class="n">pygame</span><span class="o">.</span><span class="n">error</span><span class="p">:</span> <span class="n">Cannot</span> <span class="nb">set</span> <span class="mi">0</span> <span class="n">sized</span> <span class="n">display</span> <span class="n">mode</span>

<span class="k">class</span> <span class="nc">error</span><span class="p">(</span><span class="n">exceptions</span><span class="o">.</span><span class="n">RuntimeError</span><span class="p">)</span>
 <span class="o">|</span>  <span class="n">Method</span> <span class="n">resolution</span> <span class="n">order</span><span class="p">:</span>
 <span class="o">|</span>      <span class="n">error</span>
 <span class="o">|</span>      <span class="n">exceptions</span><span class="o">.</span><span class="n">RuntimeError</span>
 <span class="o">|</span>      <span class="n">exceptions</span><span class="o">.</span><span class="n">StandardError</span>
 <span class="o">|</span>      <span class="n">exceptions</span><span class="o">.</span><span class="n">Exception</span>
 <span class="o">|</span>      <span class="n">exceptions</span><span class="o">.</span><span class="n">BaseException</span>
 <span class="o">|</span>      <span class="n">__builtin__</span><span class="o">.</span><span class="n">object</span></code></pre></div>

<p>一般而言，当你碰到<strong>pygame.error</strong>异常时，你也做不了什么事，因为这说明一个比较大的故障发生了。通常你能做的就是指导用户怎么做。在一个大的项目里面，检查错误很重要。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">try</span><span class="p">:</span>
    <span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">(</span><span class="n">SCREEN_SIZE</span><span class="p">)</span>
<span class="k">except</span> <span class="n">pygame</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span> <span class="s2">&#34;Can&#39;t create the display :-(&#34;</span>
    <span class="k">print</span> <span class="n">e</span>
    <span class="nb">exit</span><span class="p">()</span></code></pre></div>

<h1 id="pygame动起来">Pygame动起来</h1>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">background_image_filename</span> <span class="o">=</span> <span class="s1">&#39;sushiplate.jpg&#39;</span>
<span class="n">SCREEN_SIZE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">)</span>
<span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;    This is a demonstration of the scrolly message script.    &#39;</span>

<span class="kn">import</span> <span class="nn">pygame</span>
<span class="kn">from</span> <span class="nn">pygame.locals</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="nb">exit</span>

<span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">(</span><span class="n">SCREEN_SIZE</span><span class="p">)</span>

<span class="n">font</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">font</span><span class="o">.</span><span class="n">SysFont</span><span class="p">(</span><span class="s1">&#39;arial&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
<span class="n">text_surface</span> <span class="o">=</span> <span class="n">font</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>

<span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">SCREEN_SIZE</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">text_surface</span><span class="o">.</span><span class="n">get_height</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span>

<span class="n">background</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">background_image_filename</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">()</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">QUIT</span><span class="p">:</span>
            <span class="nb">exit</span><span class="p">()</span>

    <span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">background</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="n">x</span> <span class="o">-=</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">text_surface</span><span class="o">.</span><span class="n">get_width</span><span class="p">():</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">text_surface</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
    <span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">text_surface</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">text_surface</span><span class="o">.</span><span class="n">get_width</span><span class="p">(),</span> <span class="n">y</span><span class="p">))</span>

    <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></code></pre></div>
]]></content>
		</item>
		
		<item>
			<title>PyQt编程第8章 数据处理和自定义文件类型</title>
			<link>https://gitop.cc/posts/pyqt-8/</link>
			<pubDate>Fri, 30 Oct 2015 12:40:00 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/pyqt-8/</guid>
			<description>主窗口的职责 主窗口的职责通常是为用户提供高级文件处理动作和展示程序数据。</description>
			<content type="html"><![CDATA[

<h1 id="主窗口的职责">主窗口的职责</h1>

<p>主窗口的职责通常是为用户提供高级文件处理动作和展示程序数据。</p>
]]></content>
		</item>
		
		<item>
			<title>PyQt编程第7章 使用Qt Designer</title>
			<link>https://gitop.cc/posts/pyqt-7/</link>
			<pubDate>Wed, 28 Oct 2015 08:50:57 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/pyqt-7/</guid>
			<description>用户界面保存在.ui文件中，包含一个窗口部件和布局的详细情况。Qt Designer能够关联标签和它的伙伴， 设置tab顺序(这个也可以用QWi</description>
			<content type="html"><![CDATA[

<p>用户界面保存在.ui文件中，包含一个窗口部件和布局的详细情况。<strong>Qt Designer</strong>能够关联标签和它的伙伴，
设置tab顺序(这个也可以用<code>QWidget.setTabOrder()</code>完成)。<strong>Qt Designer</strong>也能够关联信号和槽，
但是只能是内置的信号和槽。</p>

<p>一旦用户界面设计完成并保存在.ui文件，必须转化为代码才能使用。这个可以用<code>pyuic4</code>完成，比如：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="err">$</span> <span class="n">pyuic4</span> <span class="o">-</span><span class="n">o</span> <span class="n">ui_findandreplacedlg</span><span class="o">.</span><span class="n">py</span> <span class="n">findandreplacedlg</span><span class="o">.</span><span class="n">ui</span></code></pre></div>

<h1 id="设计用户界面">设计用户界面</h1>

<p>使用<strong>Qt Designer</strong>通用步骤：</p>

<ol>
<li>拖动一个部件到窗体合适的位置，通常只有容器部件需要改变大小。</li>
<li>设置部件的属性。如果部件会在代码里面用到，设置一个有意义的名字。</li>
<li>重复1和2直到所有部件都在窗体上。</li>
<li>如果存在大的间隙，添加间隔器。</li>
<li>选择2个或多个部件进行布局(Shift+Click)，使用一个布局管理器布局。</li>
<li>重复5直到所有部件已经布局完毕。</li>
<li>点击窗体(不选择任何部件)，使用一个布局管理器布局窗体。</li>
<li>创建标签的伙伴。</li>
<li>设置窗体的tab顺序，如果顺序错误。</li>
<li>创建合适的内置信号和槽的关联。</li>
<li>预览窗体，检查所有东西都按照自己的意图工作。</li>
<li>设置窗体的对象名字和标题并保存。</li>
</ol>

<p>尽管可以先将布局拖进窗体，然后再添加部件到布局，但是最好是先将部件添加到窗体，然后再进行布局。</p>

<p><code>addStretch()</code>和插入<code>QSpacerItem</code>一样。</p>

<p>预览窗口点击Form-&gt;Preview或者Ctrl+R。如果想预览不同风格，点击Form-&gt;Preview in</p>

<h1 id="实现对话框">实现对话框</h1>

<p>当使用<strong>Qt Designer</strong>创建一个用户界面时，我们使用多继承创建一个子类。第一个父类是<code>QDialog</code>，
第二个父类是用<strong>Qt Designer</strong>设计的界面。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">PyQt4.QtCore</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">PyQt4.QtGui</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">ui_findandreplacedlg</span>

<span class="k">class</span> <span class="nc">FindAndReplaceDlg</span><span class="p">(</span><span class="n">QDialog</span><span class="p">,</span>
    <span class="n">ui_findandreplacedlg</span><span class="o">.</span><span class="n">Ui_FindAndReplaceDlg</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FindAndReplaceDlg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__text</span> <span class="o">=</span> <span class="nb">unicode</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setupUi</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">MAC</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">findButton</span><span class="o">.</span><span class="n">setFocusPolicy</span><span class="p">(</span><span class="n">Qt</span><span class="o">.</span><span class="n">NoFocus</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">replaceButton</span><span class="o">.</span><span class="n">setFocusPolicy</span><span class="p">(</span><span class="n">Qt</span><span class="o">.</span><span class="n">NoFocus</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">replaceAllButton</span><span class="o">.</span><span class="n">setFocusPolicy</span><span class="p">(</span><span class="n">Qt</span><span class="o">.</span><span class="n">NoFocus</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">closeButton</span><span class="o">.</span><span class="n">setFocusPolicy</span><span class="p">(</span><span class="n">Qt</span><span class="o">.</span><span class="n">NoFocus</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">updateUi</span><span class="p">()</span></code></pre></div>

<p><code>setupUi()</code>方法由生成的ui模块提供，调用这个方法创建用户界面。
<code>setupUi()</code>方法调用<code>QtCore.QMetaObject.connectSlotsByName()</code>创建信号和槽之间的联系。
任何具有形式<code>on_widgetName_signalName</code>的槽都有一个信号连接到它。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="nd">@pyqtSignature</span><span class="p">(</span><span class="s1">&#39;QString&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">on_findLineText_textEdited</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">updateUi</span><span class="p">()</span></code></pre></div>

<p>多亏<code>setupUi()</code>，这个方法自动连接到findLineEdit的<code>textEdited()</code>信号。当需要自动连接到指定
信号，使用<code>@pyqtSignature</code>装饰指定信号参数。装饰的作用是区分同名但参数不同的信号。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">updateUi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">enable</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">findLineEdit</span><span class="o">.</span><span class="n">text</span><span class="p">()</span><span class="o">.</span><span class="n">isEmpty</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">findButton</span><span class="o">.</span><span class="n">setEnabled</span><span class="p">(</span><span class="n">enable</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">replaceButton</span><span class="o">.</span><span class="n">setEnabled</span><span class="p">(</span><span class="n">enable</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">replaceAllButton</span><span class="o">.</span><span class="n">setEnabled</span><span class="p">(</span><span class="n">enable</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">text</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__text</span>

<span class="nd">@pyqtSignature</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">on_findButton_clicked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">regex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">makeRegex</span><span class="p">()</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">regex</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__text</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__index</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__index</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">SIGNAL</span><span class="p">(</span><span class="s1">&#39;found&#39;</span><span class="p">),</span> <span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">SIGNAL</span><span class="p">(</span><span class="s1">&#39;notfound&#39;</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">makeRegex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">findText</span> <span class="o">=</span> <span class="nb">unicode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">findLineEdit</span><span class="o">.</span><span class="n">text</span><span class="p">())</span>
    <span class="k">if</span> <span class="nb">unicode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">syntaxComboBox</span><span class="o">.</span><span class="n">currentText</span><span class="p">())</span> <span class="o">==</span> <span class="s1">&#39;Literal&#39;</span><span class="p">:</span>
        <span class="n">findText</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">findText</span><span class="p">)</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="o">|</span><span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="o">|</span><span class="n">re</span><span class="o">.</span><span class="n">UNICODE</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">caseCheckBox</span><span class="o">.</span><span class="n">isChecked</span><span class="p">():</span>
        <span class="n">flags</span> <span class="o">|=</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wholeCheckBox</span><span class="o">.</span><span class="n">isChecked</span><span class="p">():</span>
        <span class="n">findText</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\b</span><span class="si">%s</span><span class="s1">\b&#39;</span> <span class="o">%</span> <span class="n">findText</span>
    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">findText</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span></code></pre></div>

<p>如果被搜索的文本是<code>QString</code>而不是<code>unicode</code>，则选择<code>QRegExp</code>更好。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="nd">@pyqtSignature</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">on_replaceButton_clicked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">regex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">makeRegex</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__text</span> <span class="o">=</span> <span class="n">regex</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="nb">unicode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replaceLineEdit</span><span class="o">.</span><span class="n">text</span><span class="p">()),</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__text</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="nd">@pyqtSignature</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">on_replaceAllButton_clicked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">regex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">makeRegex</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__text</span> <span class="o">=</span> <span class="n">regex</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="nb">unicode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replaceLineEdit</span><span class="o">.</span><span class="n">text</span><span class="p">()),</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__text</span><span class="p">)</span></code></pre></div>

<h1 id="测试对话框">测试对话框</h1>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">sys</span>

    <span class="n">text</span> <span class="o">=</span> <span class="s2">&#34;&#34;&#34;US experience shows that, unlike traditional patents,
</span><span class="s2">software patents do not encourage innovation and R&amp;D, quite the
</span><span class="s2">contrary. In particular they hurt small and medium-sized enterprises
</span><span class="s2">and generally newcomers in the market. They will just weaken the market
</span><span class="s2">and increase spending on patents and litigation, at the expense of
</span><span class="s2">technological innovation and research. Especially dangerous are
</span><span class="s2">attempts to abuse the patent system by preventing interoperability as a
</span><span class="s2">means of avoiding competition with technological ability.
</span><span class="s2">--- Extract quoted from Linus Torvalds and Alan Cox&#39;s letter
</span><span class="s2">to the President of the European Parliament
</span><span class="s2">http://www.effi.org/patentit/patents_torvalds_cox.html&#34;&#34;&#34;</span>

    <span class="k">def</span> <span class="nf">found</span><span class="p">(</span><span class="n">where</span><span class="p">):</span>
        <span class="k">print</span> <span class="s1">&#39;Found at </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">where</span>

    <span class="k">def</span> <span class="nf">nomore</span><span class="p">():</span>
        <span class="k">print</span> <span class="s1">&#39;No more found&#39;</span>

    <span class="n">app</span> <span class="o">=</span> <span class="n">QApplication</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span>
    <span class="n">form</span> <span class="o">=</span> <span class="n">FindAndReplaceDlg</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="n">form</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">form</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="s1">&#39;found&#39;</span><span class="p">),</span> <span class="n">found</span><span class="p">)</span>
    <span class="n">form</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">form</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="s1">&#39;notfound&#39;</span><span class="p">),</span> <span class="n">nomore</span><span class="p">)</span>
    <span class="n">form</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="n">app</span><span class="o">.</span><span class="n">exec_</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">form</span><span class="o">.</span><span class="n">text</span><span class="p">()</span></code></pre></div>

<h1 id="总结">总结</h1>

<p>使用<strong>Qt Designer</strong>和手工创建界面最大的不同是在初始化的时候，我们简单地调用<code>setupUi()</code>创建界面，
布局，信号和槽的关联。槽的命名惯例是<code>on_widgetName_signalName</code>，连同<code>@pyqtSignature</code>装饰
就可以利用<code>setupUi()</code>自动关联信号和槽。</p>
]]></content>
		</item>
		
		<item>
			<title>Project Euler Problem 1</title>
			<link>https://gitop.cc/posts/project-euler-1/</link>
			<pubDate>Fri, 23 Oct 2015 16:30:00 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/project-euler-1/</guid>
			<description>Multiples of 3 and 5 If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000. sum = 3 * (1 + 999 / 3) * (999 / 3) / 2 + \ 5 * (1 + 999</description>
			<content type="html"><![CDATA[

<h1 id="multiples-of-3-and-5">Multiples of 3 and 5</h1>

<p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.</p>

<p>Find the sum of all the multiples of 3 or 5 below 1000.</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="nb">sum</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">999</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">999</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> \
      <span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">999</span> <span class="o">/</span> <span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">999</span> <span class="o">/</span> <span class="mi">5</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> \
      <span class="mi">15</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">999</span> <span class="o">/</span> <span class="mi">15</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">999</span> <span class="o">/</span> <span class="mi">15</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
<span class="k">print</span> <span class="nb">sum</span></code></pre></div>

<h1 id="3和5的倍数">3和5的倍数</h1>

<p>如果我们列出所有小于10且为3或5的倍数的自然数，我们得到3，5，6和9。这些数的和是23。找出所有低于1000且为3或5倍数的和。</p>
]]></content>
		</item>
		
		<item>
			<title>PyQt编程第6章 主窗口</title>
			<link>https://gitop.cc/posts/pyqt-6/</link>
			<pubDate>Wed, 21 Oct 2015 11:25:57 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/pyqt-6/</guid>
			<description>创建一个主窗口 import os import platform import sys from PyQt4.QtCore import * from PyQt4.QtGui import * import helpform import newimagedlg import qrc_resources __version__ = &amp;#34;1.0.0&amp;#34; import的顺序：先Python标准模块，然后第三方模块(比如PyQt)，最后</description>
			<content type="html"><![CDATA[

<h1 id="创建一个主窗口">创建一个主窗口</h1>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">platform</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">PyQt4.QtCore</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">PyQt4.QtGui</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">helpform</span>
<span class="kn">import</span> <span class="nn">newimagedlg</span>
<span class="kn">import</span> <span class="nn">qrc_resources</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&#34;1.0.0&#34;</span></code></pre></div>

<p><code>import</code>的顺序：先Python标准模块，然后第三方模块(比如PyQt)，最后自己定义的模块。
一个程序通常有一个版本字符串，按照惯例称为<code>__version__</code>。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">MainWindow</span><span class="p">(</span><span class="n">QMainWindow</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MainWindow</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">QImage</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dirty</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mirroredvertically</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mirroredhorizontally</span> <span class="o">=</span> <span class="bp">False</span></code></pre></div>

<p><code>QImage</code>并不是继承自<code>QObject</code>，不需要<code>parent</code>。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="bp">self</span><span class="o">.</span><span class="n">imageLabel</span> <span class="o">=</span> <span class="n">QLabel</span><span class="p">()</span>
<span class="bp">self</span><span class="o">.</span><span class="n">imageLabel</span><span class="o">.</span><span class="n">setMinimumSize</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">imageLabel</span><span class="o">.</span><span class="n">setAlignment</span><span class="p">(</span><span class="n">Qt</span><span class="o">.</span><span class="n">AlignCenter</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">imageLabel</span><span class="o">.</span><span class="n">setContextMenuPolicy</span><span class="p">(</span><span class="n">Qt</span><span class="o">.</span><span class="n">ActionsContextMenu</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">setCentralWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">imageLabel</span><span class="p">)</span></code></pre></div>

<p>PyQt提供许多种方式创建右键菜单，我们使用最简单和最常见的方式。首先必须设置部件的右键菜单策略，然后
给部件添加一些操作。</p>

<p>和对话框不一样，在一个主窗口风格的程序中，只有一个中心部件，尽管它可以是组合而成的。我么只需要调用
<code>setCentralWidget</code>就好了。</p>

<p>在PyQt中，悬浮窗口是<code>QDockWidget</code>类的实例。我们可以添加一个部件到悬浮部件。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">logDockWidget</span> <span class="o">=</span> <span class="n">QDockWidget</span><span class="p">(</span><span class="s2">&#34;Log&#34;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
<span class="n">logDockWidget</span><span class="o">.</span><span class="n">setObjectName</span><span class="p">(</span><span class="s2">&#34;LogDockWidget&#34;</span><span class="p">)</span>
<span class="n">logDockWidget</span><span class="o">.</span><span class="n">setAllowedAreas</span><span class="p">(</span><span class="n">Qt</span><span class="o">.</span><span class="n">LeftDockWidgetArea</span><span class="o">|</span>
                              <span class="n">Qt</span><span class="o">.</span><span class="n">RightDockWidgetArea</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">listWidget</span> <span class="o">=</span> <span class="n">QListWidget</span><span class="p">()</span>
<span class="n">logDockWidget</span><span class="o">.</span><span class="n">setWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">listWidget</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">addDockWidget</span><span class="p">(</span><span class="n">Qt</span><span class="o">.</span><span class="n">RightDockWidgetArea</span><span class="p">,</span> <span class="n">logDockWidget</span><span class="p">)</span></code></pre></div>

<p>悬浮部件不会被加入布局，所以当创建它们时，需要指定<code>parent</code>。</p>

<p>每一个PyQt对象都可以指定一个对象名字。PyQt使用对象名字区分悬浮部件。
<code>setFeatures</code>方法控制悬浮部件能否移动，悬浮或关闭。</p>

<p><code>QPrinter</code>对象管理打印机操作。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="bp">self</span><span class="o">.</span><span class="n">sizeLabel</span> <span class="o">=</span> <span class="n">QLabel</span><span class="p">()</span>
<span class="bp">self</span><span class="o">.</span><span class="n">sizeLabel</span><span class="o">.</span><span class="n">setFrameStyle</span><span class="p">(</span><span class="n">QFrame</span><span class="o">.</span><span class="n">StyledPanel</span><span class="o">|</span><span class="n">QFrame</span><span class="o">.</span><span class="n">Sunken</span><span class="p">)</span>
<span class="n">status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">statusBar</span><span class="p">()</span>
<span class="n">status</span><span class="o">.</span><span class="n">setSizeGripEnabled</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="n">status</span><span class="o">.</span><span class="n">addPermanentWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sizeLabel</span><span class="p">)</span>
<span class="n">status</span><span class="o">.</span><span class="n">showMessage</span><span class="p">(</span><span class="s2">&#34;Ready&#34;</span><span class="p">,</span> <span class="mi">5000</span><span class="p">)</span></code></pre></div>

<p>状态栏由<code>QMainWindow</code>第一次调用<code>statusBar</code>创建。<code>showMessage</code>在状态栏显示信息直到另一个
<code>showMessage</code>被调用或<code>clearMessage</code>被调用。</p>

<h1 id="动作和键序列">动作和键序列</h1>

<p>PyQt用<code>QAction</code>封装用户动作。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">fileNewAction</span> <span class="o">=</span> <span class="n">QAction</span><span class="p">(</span><span class="n">QIcon</span><span class="p">(</span><span class="s2">&#34;images/filenew.png&#34;</span><span class="p">),</span> <span class="s2">&#34;&amp;New&#34;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
<span class="n">fileNewAction</span><span class="o">.</span><span class="n">setShortcut</span><span class="p">(</span><span class="n">QKeySequence</span><span class="o">.</span><span class="n">New</span><span class="p">)</span>
<span class="n">helpText</span> <span class="o">=</span> <span class="s2">&#34;Create a new image&#34;</span>
<span class="n">fileNewAction</span><span class="o">.</span><span class="n">setToolTip</span><span class="p">(</span><span class="n">helpText</span><span class="p">)</span>
<span class="n">fileNewAction</span><span class="o">.</span><span class="n">setStatusTip</span><span class="p">(</span><span class="n">helpText</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">fileNewAction</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&#34;triggered()&#34;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileNew</span><span class="p">)</span></code></pre></div>

<p>许多键序列都标准化了，有些甚至跨平台。比如<code>Ctrl+N</code>对应新建，<code>Ctrl+S</code>对应保存。
<code>QKeySequence</code>提供标准化的键序列常量，如<code>QKeySequence.New</code>，<code>QKeySequence.Paste</code>
对于还未标准化的键序列(或向后兼容的原因)，可以用字符串作为快捷键，setShortcut(&ldquo;Ctrl+Q&rdquo;)。</p>

<p>注意我们给<code>QAction</code>一个self作为父亲。每一个<code>QObject</code>子类(除了顶级窗口)都有一个父亲。</p>

<table>
<thead>
<tr>
<th>语法</th>
<th align="left">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>a.data()</td>
<td align="left">返回QAction a的数据，作为QVariant</td>
</tr>

<tr>
<td>a.setData(v)</td>
<td align="left">设置QAction a的数据为QVariant v</td>
</tr>

<tr>
<td>a.isChecked()</td>
<td align="left">返回True如果QAction a被确认过</td>
</tr>

<tr>
<td>a.setChecked(b)</td>
<td align="left">选与不选QAction a取决于bool b</td>
</tr>

<tr>
<td>a.isEnabled()</td>
<td align="left">返回True如果QAction a生效</td>
</tr>

<tr>
<td>a.setEnabled(b)</td>
<td align="left">生效或失效QAction a取决于bool b</td>
</tr>

<tr>
<td>a.setSeparator(b)</td>
<td align="left">设置QAction a为正常动作或分隔符取决于bool b</td>
</tr>

<tr>
<td>a.setShortcut(k)</td>
<td align="left">设置QAction a的快捷键为QKeySequence k</td>
</tr>

<tr>
<td>a.setStatusTip(s)</td>
<td align="left">设置QAction a的状态提示为string s</td>
</tr>

<tr>
<td>a.setText(s)</td>
<td align="left">设置QAction a的文本为string s</td>
</tr>

<tr>
<td>a.setToolTip(s)</td>
<td align="left">设置QAction a的工具提示为string s</td>
</tr>

<tr>
<td>a.setWhatsThis(s)</td>
<td align="left">设置QAction a的What&rsquo;s This?文本为string s</td>
</tr>

<tr>
<td>a.toggled(b)</td>
<td align="left">这个信号被发射当QAction a的选中状态改变；bool b为True如果动作被选中</td>
</tr>

<tr>
<td>a.triggered(b)</td>
<td align="left">这个信号被发射QAction a被调用；bool b为True如果a被选中</td>
</tr>
</tbody>
</table>

<p>一旦创建了动作，我们就能把它添加到菜单或工具栏。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">fileMenu</span><span class="o">.</span><span class="n">addAction</span><span class="p">(</span><span class="n">fileNewAction</span><span class="p">)</span>
<span class="n">fileToolbar</span><span class="o">.</span><span class="n">addAction</span><span class="p">(</span><span class="n">fileNewAction</span><span class="p">)</span></code></pre></div>

<h1 id="资源文件">资源文件</h1>

<p>创建一个资源模块需要做两件事情。第一创建一个<code>.qrc</code>的文件，包含程序详细的资源。然后运行<code>pyrcc4</code>
读取<code>.qrc</code>文件生成资源模块。<code>.qrc</code>是一个XML格式的文件。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="o">&lt;</span><span class="err">!</span><span class="n">DOCTYPE</span> <span class="n">RCC</span><span class="o">&gt;&lt;</span><span class="n">RCC</span> <span class="n">version</span><span class="o">=</span><span class="s2">&#34;1.0&#34;</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">qresource</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nb">file</span> <span class="n">alias</span><span class="o">=</span><span class="s2">&#34;filenew.png&#34;</span><span class="o">&gt;</span><span class="n">images</span><span class="o">/</span><span class="n">filenew</span><span class="o">.</span><span class="n">png</span><span class="o">&lt;/</span><span class="nb">file</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nb">file</span> <span class="n">alias</span><span class="o">=</span><span class="s2">&#34;fileopen.png&#34;</span><span class="o">&gt;</span><span class="n">images</span><span class="o">/</span><span class="n">fileopen</span><span class="o">.</span><span class="n">png</span><span class="o">&lt;/</span><span class="nb">file</span><span class="o">&gt;</span>
<span class="err">···</span>
<span class="o">&lt;</span><span class="nb">file</span> <span class="n">alias</span><span class="o">=</span><span class="s2">&#34;icon.png&#34;</span><span class="o">&gt;</span><span class="n">images</span><span class="o">/</span><span class="n">icon</span><span class="o">.</span><span class="n">png</span><span class="o">&lt;/</span><span class="nb">file</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nb">file</span><span class="o">&gt;</span><span class="n">help</span><span class="o">/</span><span class="n">editmenu</span><span class="o">.</span><span class="n">html</span><span class="o">&lt;/</span><span class="nb">file</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nb">file</span><span class="o">&gt;</span><span class="n">help</span><span class="o">/</span><span class="n">filemenu</span><span class="o">.</span><span class="n">html</span><span class="o">&lt;/</span><span class="nb">file</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nb">file</span><span class="o">&gt;</span><span class="n">help</span><span class="o">/</span><span class="n">index</span><span class="o">.</span><span class="n">html</span><span class="o">&lt;/</span><span class="nb">file</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">qresource</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">RCC</span><span class="o">&gt;</span></code></pre></div>

<p>现在使用一个新建文件的图片，我们可以写成<code>QIcon(&quot;:/images/filenew.png&quot;)</code>，多亏了别名，
也可以缩写为<code>QIcon(&quot;:/filenew.png&quot;)</code>。前面的:/告诉PyQt文件是一个资源。在使用资源之前，
必须生成资源模块并导入进程序。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">C</span><span class="p">:</span>\<span class="n">pyqt</span>\<span class="n">chap06</span><span class="o">&gt;</span><span class="n">pyrcc4</span> <span class="o">-</span><span class="n">o</span> <span class="n">qrc_resources</span><span class="o">.</span><span class="n">py</span> <span class="n">resources</span><span class="o">.</span><span class="n">qrc</span></code></pre></div>

<h1 id="创建和使用动作">创建和使用动作</h1>

<p>一个辅助创建动作的函数：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">createAction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">slot</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">shortcut</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">icon</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">tip</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">checkable</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">signal</span><span class="o">=</span><span class="s2">&#34;triggered()&#34;</span><span class="p">):</span>
    <span class="n">action</span> <span class="o">=</span> <span class="n">QAction</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">icon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">action</span><span class="o">.</span><span class="n">setIcon</span><span class="p">(</span><span class="n">QIcon</span><span class="p">(</span><span class="s2">&#34;:/</span><span class="si">%s</span><span class="s2">.png&#34;</span> <span class="o">%</span> <span class="n">icon</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">shortcut</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">action</span><span class="o">.</span><span class="n">setShortcut</span><span class="p">(</span><span class="n">shortcut</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tip</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">action</span><span class="o">.</span><span class="n">setToolTip</span><span class="p">(</span><span class="n">tip</span><span class="p">)</span>
        <span class="n">action</span><span class="o">.</span><span class="n">setStatusTip</span><span class="p">(</span><span class="n">tip</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">slot</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">signal</span><span class="p">),</span> <span class="n">slot</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">checkable</span><span class="p">:</span>
        <span class="n">action</span><span class="o">.</span><span class="n">setCheckable</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">action</span>
<span class="n">fileNewAction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">createAction</span><span class="p">(</span><span class="s2">&#34;&amp;New...&#34;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileNew</span><span class="p">,</span>
        <span class="n">QKeySequence</span><span class="o">.</span><span class="n">New</span><span class="p">,</span> <span class="s2">&#34;filenew&#34;</span><span class="p">,</span> <span class="s2">&#34;Create an image file&#34;</span><span class="p">)</span>
<span class="n">fileQuitAction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">createAction</span><span class="p">(</span><span class="s2">&#34;&amp;Quit&#34;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">,</span>
        <span class="s2">&#34;Ctrl+Q&#34;</span><span class="p">,</span> <span class="s2">&#34;filequit&#34;</span><span class="p">,</span> <span class="s2">&#34;Close the application&#34;</span><span class="p">)</span>
<span class="n">editZoomAction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">createAction</span><span class="p">(</span><span class="s2">&#34;&amp;Zoom...&#34;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">editZoom</span><span class="p">,</span>
        <span class="s2">&#34;Alt+Z&#34;</span><span class="p">,</span> <span class="s2">&#34;editzoom&#34;</span><span class="p">,</span> <span class="s2">&#34;Zoom the image&#34;</span><span class="p">)</span>
<span class="n">editInvertAction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">createAction</span><span class="p">(</span><span class="s2">&#34;&amp;Invert&#34;</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">editInvert</span><span class="p">,</span> <span class="s2">&#34;Ctrl+I&#34;</span><span class="p">,</span> <span class="s2">&#34;editinvert&#34;</span><span class="p">,</span>
        <span class="s2">&#34;Invert the image&#39;s colors&#34;</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="s2">&#34;toggled(bool)&#34;</span><span class="p">)</span></code></pre></div>

<p><code>toggled(bool)</code>信号不仅告诉我们动作被调用，而且返回动作是否被选中。</p>

<p>一个动作组管理一组动作使得任何时候只有一个动作被选中。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">mirrorGroup</span> <span class="o">=</span> <span class="n">QActionGroup</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="n">editUnMirrorAction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">createAction</span><span class="p">(</span><span class="s2">&#34;&amp;Unmirror&#34;</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">editUnMirror</span><span class="p">,</span> <span class="s2">&#34;Ctrl+U&#34;</span><span class="p">,</span> <span class="s2">&#34;editunmirror&#34;</span><span class="p">,</span>
        <span class="s2">&#34;Unmirror the image&#34;</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="s2">&#34;toggled(bool)&#34;</span><span class="p">)</span>
<span class="n">mirrorGroup</span><span class="o">.</span><span class="n">addAction</span><span class="p">(</span><span class="n">editUnMirrorAction</span><span class="p">)</span>
<span class="n">editUnMirrorAction</span><span class="o">.</span><span class="n">setChecked</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span></code></pre></div>

<p>可选中的动作默认是未选中状态，所以在动作组中初始时必须选择一个为选中状态。</p>

<p>虽然所有动作已经创建好，但是它们还不能工作。只有当动作加进菜单或工具栏才能起作用。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">editMenu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">menuBar</span><span class="p">()</span><span class="o">.</span><span class="n">addMenu</span><span class="p">(</span><span class="s2">&#34;&amp;Edit&#34;</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">addActions</span><span class="p">(</span><span class="n">editMenu</span><span class="p">,</span> <span class="p">(</span><span class="n">editInvertAction</span><span class="p">,</span>
        <span class="n">editSwapRedAndBlueAction</span><span class="p">,</span> <span class="n">editZoomAction</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">addActions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">actions</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">action</span> <span class="ow">in</span> <span class="n">actions</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">action</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">target</span><span class="o">.</span><span class="n">addSeparator</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target</span><span class="o">.</span><span class="n">addAction</span><span class="p">(</span><span class="n">action</span><span class="p">)</span></code></pre></div>

<p>也可以使用<code>QWidget.addActions</code>添加多个动作到菜单或工具栏。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">mirrorMenu</span> <span class="o">=</span> <span class="n">editMenu</span><span class="o">.</span><span class="n">addMenu</span><span class="p">(</span><span class="n">QIcon</span><span class="p">(</span><span class="s2">&#34;:/editmirror.png&#34;</span><span class="p">),</span>
                              <span class="s2">&#34;&amp;Mirror&#34;</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">addActions</span><span class="p">(</span><span class="n">mirrorMenu</span><span class="p">,</span> <span class="p">(</span><span class="n">editUnMirrorAction</span><span class="p">,</span>
        <span class="n">editMirrorHorizontalAction</span><span class="p">,</span> <span class="n">editMirrorVerticalAction</span><span class="p">))</span></code></pre></div>

<p>子目录的创建和其它目录一样，不同的是使用<code>QMenu.addMenu</code>加进父目录。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="bp">self</span><span class="o">.</span><span class="n">fileMenu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">menuBar</span><span class="p">()</span><span class="o">.</span><span class="n">addMenu</span><span class="p">(</span><span class="s2">&#34;&amp;File&#34;</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">fileMenuActions</span> <span class="o">=</span> <span class="p">(</span><span class="n">fileNewAction</span><span class="p">,</span> <span class="n">fileOpenAction</span><span class="p">,</span>
        <span class="n">fileSaveAction</span><span class="p">,</span> <span class="n">fileSaveAsAction</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span>
        <span class="n">filePrintAction</span><span class="p">,</span> <span class="n">fileQuitAction</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fileMenu</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&#34;aboutToShow()&#34;</span><span class="p">),</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">updateFileMenu</span><span class="p">)</span>

<span class="n">fileToolbar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">addToolBar</span><span class="p">(</span><span class="s2">&#34;File&#34;</span><span class="p">)</span>
<span class="n">fileToolbar</span><span class="o">.</span><span class="n">setObjectName</span><span class="p">(</span><span class="s2">&#34;FileToolBar&#34;</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">addActions</span><span class="p">(</span><span class="n">fileToolbar</span><span class="p">,</span> <span class="p">(</span><span class="n">fileNewAction</span><span class="p">,</span> <span class="n">fileOpenAction</span><span class="p">,</span>
                              <span class="n">fileSaveAsAction</span><span class="p">))</span></code></pre></div>

<p><code>addToolBar</code>创建一个<code>QToolBar</code>对象。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">editToolbar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">addToolBar</span><span class="p">(</span><span class="s2">&#34;Edit&#34;</span><span class="p">)</span>
<span class="n">editToolbar</span><span class="o">.</span><span class="n">setObjectName</span><span class="p">(</span><span class="s2">&#34;EditToolBar&#34;</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">addActions</span><span class="p">(</span><span class="n">editToolbar</span><span class="p">,</span> <span class="p">(</span><span class="n">editInvertAction</span><span class="p">,</span>
        <span class="n">editSwapRedAndBlueAction</span><span class="p">,</span> <span class="n">editUnMirrorAction</span><span class="p">,</span>
        <span class="n">editMirrorVerticalAction</span><span class="p">,</span>
        <span class="n">editMirrorHorizontalAction</span><span class="p">))</span></code></pre></div>

<p>添加部件到工具栏都一样： 创建部件，配置好部件，连接信号，然后把部件添加到工具栏</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="bp">self</span><span class="o">.</span><span class="n">zoomSpinBox</span> <span class="o">=</span> <span class="n">QSpinBox</span><span class="p">()</span>
<span class="bp">self</span><span class="o">.</span><span class="n">zoomSpinBox</span><span class="o">.</span><span class="n">setRange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">400</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">zoomSpinBox</span><span class="o">.</span><span class="n">setSuffix</span><span class="p">(</span><span class="s2">&#34; %&#34;</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">zoomSpinBox</span><span class="o">.</span><span class="n">setValue</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">zoomSpinBox</span><span class="o">.</span><span class="n">setToolTip</span><span class="p">(</span><span class="s2">&#34;Zoom the image&#34;</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">zoomSpinBox</span><span class="o">.</span><span class="n">setStatusTip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zoomSpinBox</span><span class="o">.</span><span class="n">toolTip</span><span class="p">())</span>
<span class="bp">self</span><span class="o">.</span><span class="n">zoomSpinBox</span><span class="o">.</span><span class="n">setFocusPolicy</span><span class="p">(</span><span class="n">Qt</span><span class="o">.</span><span class="n">NoFocus</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zoomSpinBox</span><span class="p">,</span>
             <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&#34;valueChanged(int)&#34;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">showImage</span><span class="p">)</span>
<span class="n">editToolbar</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zoomSpinBox</span><span class="p">)</span></code></pre></div>

<p>之前有一行这样的代码：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="bp">self</span><span class="o">.</span><span class="n">imageLabel</span><span class="o">.</span><span class="n">setContextMenuPolicy</span><span class="p">(</span><span class="n">Qt</span><span class="o">.</span><span class="n">ActionsContextMenu</span><span class="p">)</span></code></pre></div>

<p>它告诉PyQt，如果动作被加进imageLabel部件，它们也被用作右键菜单。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="bp">self</span><span class="o">.</span><span class="n">addActions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">imageLabel</span><span class="p">,</span> <span class="p">(</span><span class="n">editInvertAction</span><span class="p">,</span>
        <span class="n">editSwapRedAndBlueAction</span><span class="p">,</span> <span class="n">editUnMirrorAction</span><span class="p">,</span>
        <span class="n">editMirrorVerticalAction</span><span class="p">,</span> <span class="n">editMirrorHorizontalAction</span><span class="p">))</span></code></pre></div>

<p><code>QWidget</code>类有一个<code>addAction</code>方法，因此<code>QMenu</code>，<code>QMenuBar</code>，<code>QToolBar</code>都继承了这个方法。
尽管<code>QWidget</code>没有<code>addSeparator</code>方法，为了方便，<code>QMenu</code>，<code>QMenuBar</code>，<code>QToolBar</code>都提供了。
如果要添加一个分隔符到右键菜单，则必须添加一个分隔动作。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">separator</span> <span class="o">=</span> <span class="n">QAction</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="n">separator</span><span class="o">.</span><span class="n">setSeparator</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">addActions</span><span class="p">(</span><span class="n">editToolbar</span><span class="p">,</span> <span class="p">(</span><span class="n">editInvertAction</span><span class="p">,</span>
        <span class="n">editSwapRedAndBlueAction</span><span class="p">,</span> <span class="n">separator</span><span class="p">,</span> <span class="n">editUnMirrorAction</span><span class="p">,</span>
        <span class="n">editMirrorVerticalAction</span><span class="p">,</span> <span class="n">editMirrorHorizontalAction</span><span class="p">))</span></code></pre></div>

<h1 id="恢复和保存主窗口状态">恢复和保存主窗口状态</h1>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">app</span> <span class="o">=</span> <span class="n">QApplication</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span>
    <span class="n">app</span><span class="o">.</span><span class="n">setOrganizationName</span><span class="p">(</span><span class="s2">&#34;Qtrac Ltd.&#34;</span><span class="p">)</span>
    <span class="n">app</span><span class="o">.</span><span class="n">setOrganizationDomain</span><span class="p">(</span><span class="s2">&#34;qtrac.eu&#34;</span><span class="p">)</span>
    <span class="n">app</span><span class="o">.</span><span class="n">setApplicationName</span><span class="p">(</span><span class="s2">&#34;Image Changer&#34;</span><span class="p">)</span>
    <span class="n">app</span><span class="o">.</span><span class="n">setWindowIcon</span><span class="p">(</span><span class="n">QIcon</span><span class="p">(</span><span class="s2">&#34;:/icon.png&#34;</span><span class="p">))</span>
    <span class="n">form</span> <span class="o">=</span> <span class="n">MainWindow</span><span class="p">()</span>
    <span class="n">form</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="n">app</span><span class="o">.</span><span class="n">exec_</span><span class="p">()</span></code></pre></div>

<p>函数main的第二行到第四行的主要作用就是程序配置的加载和保存。如果不传任何参数给<code>QSettings</code>对象，
则它会使用这三行代码设定的名字。这些名字使得程序配置保存在合适的地方，比如Windows的注册表，Linux
的$HOME/.config</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">settings</span> <span class="o">=</span> <span class="n">QSettings</span><span class="p">()</span>
<span class="bp">self</span><span class="o">.</span><span class="n">recentFiles</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="s2">&#34;RecentFiles&#34;</span><span class="p">)</span><span class="o">.</span><span class="n">toStringList</span><span class="p">()</span>
<span class="n">size</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="s2">&#34;MainWindow/Size&#34;</span><span class="p">,</span>
                      <span class="n">QVariant</span><span class="p">(</span><span class="n">QSize</span><span class="p">(</span><span class="mi">600</span><span class="p">,</span> <span class="mi">500</span><span class="p">)))</span><span class="o">.</span><span class="n">toSize</span><span class="p">()</span>
<span class="bp">self</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
<span class="n">position</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="s2">&#34;MainWindow/Position&#34;</span><span class="p">,</span>
                          <span class="n">QVariant</span><span class="p">(</span><span class="n">QPoint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span><span class="o">.</span><span class="n">toPoint</span><span class="p">()</span>
<span class="bp">self</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">restoreState</span><span class="p">(</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="s2">&#34;MainWindow/State&#34;</span><span class="p">)</span><span class="o">.</span><span class="n">toByteArray</span><span class="p">())</span>
<span class="bp">self</span><span class="o">.</span><span class="n">setWindowTitle</span><span class="p">(</span><span class="s2">&#34;Image Changer&#34;</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">updateFileMenu</span><span class="p">()</span>
<span class="n">QTimer</span><span class="o">.</span><span class="n">singleShot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loadInitialFile</span><span class="p">)</span></code></pre></div>

<p><code>QSettings.value()</code>返回一个<code>QVariant</code>，因此必须转换为我们期望的数据类型。
带2个参数形式的<code>value()</code>方法，第二个参数是默认值。</p>

<p><code>resize()</code>和<code>move()</code>并不会造成窗口抖动，因为这些操作是在窗口显示之前已经完成。
Qt4.2引入2个新的方法保存和恢复一个顶层窗口的几何位置。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="bp">self</span><span class="o">.</span><span class="n">restoreGeometry</span><span class="p">(</span><span class="n">settings</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="s2">&#34;Geometry&#34;</span><span class="p">)</span><span class="o">.</span><span class="n">toByteArray</span><span class="p">())</span></code></pre></div>

<p><code>QMainWindow</code>类提供<code>restoreState()</code>和<code>saveState()</code>方法，来恢复自或保存到一个<code>QByteArray</code>。
它们只保存拥有唯一对象名的悬浮窗口的大小和位置以及工具栏的位置。</p>

<blockquote>
<p><strong>启动时做大量处理</strong>
如果我们需要在启动时做大量处理，比如加载许多大文件，我们经常用一个独立的加载方法来做此事。
想象一下，比如这个方法是loadInitialFiles()，加载许多大文件。则在show()和事件循环(exec_())
开始之前，用户将体验到一个非常长的启动延迟。
我们希望窗口尽可能快的出现，使用户知道启动成功，并能够看到长时间运行的进程。这些通过0延迟的
singleShot计时器完成。因为它并不会立即执行连接的槽，相反它简单地将槽放到事件队列就返回。
0延迟计时器意思是，“当事件队列没有其它事件处理时处理这个事件”</p>
</blockquote>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">loadInitialFile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">settings</span> <span class="o">=</span> <span class="n">QSettings</span><span class="p">()</span>
    <span class="n">fname</span> <span class="o">=</span> <span class="nb">unicode</span><span class="p">(</span><span class="n">settings</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="s2">&#34;LastFile&#34;</span><span class="p">)</span><span class="o">.</span><span class="n">toString</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">fname</span> <span class="ow">and</span> <span class="n">QFile</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loadFile</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span></code></pre></div>

<p>如果用户试图关闭程序，不管什么方式，<code>closeEvent()</code>被调用。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">closeEvent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">okToContinue</span><span class="p">():</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="n">QSettings</span><span class="p">()</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">QVariant</span><span class="p">(</span><span class="n">QString</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">))</span> \
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">QVariant</span><span class="p">()</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">setValue</span><span class="p">(</span><span class="s2">&#34;LastFile&#34;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="n">recentFiles</span> <span class="o">=</span> <span class="n">QVariant</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">recentFiles</span><span class="p">)</span> \
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">recentFiles</span> <span class="k">else</span> <span class="n">QVariant</span><span class="p">()</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">setValue</span><span class="p">(</span><span class="s2">&#34;RecentFiles&#34;</span><span class="p">,</span> <span class="n">recentFiles</span><span class="p">)</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">setValue</span><span class="p">(</span><span class="s2">&#34;MainWindow/Size&#34;</span><span class="p">,</span> <span class="n">QVariant</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">()))</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">setValue</span><span class="p">(</span><span class="s2">&#34;MainWindow/Position&#34;</span><span class="p">,</span>
                <span class="n">QVariant</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">()))</span>
        <span class="n">settings</span><span class="o">.</span><span class="n">setValue</span><span class="p">(</span><span class="s2">&#34;MainWindow/State&#34;</span><span class="p">,</span>
                <span class="n">QVariant</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">saveState</span><span class="p">()))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">event</span><span class="o">.</span><span class="n">ignore</span><span class="p">()</span></code></pre></div>

<table>
<thead>
<tr>
<th>语法</th>
<th align="left">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>m.addDockWidget(a, d)</td>
<td align="left">在QMainWindow m中添加QDockWidget d到Qt.QDockWidgetArea a</td>
</tr>

<tr>
<td>m.addToolBar(s)</td>
<td align="left">添加并返回一个名叫string s的QToolBar</td>
</tr>

<tr>
<td>m.menuBar()</td>
<td align="left">返回QMainWindow m的QMenuBar(第一次调用创建目录)</td>
</tr>

<tr>
<td>m.restoreGeometry(ba)</td>
<td align="left">根据QByteArray ba恢复QMainWindow m的位置和大小(Qt4.3)</td>
</tr>

<tr>
<td>m.restoreState(ba)</td>
<td align="left">根据QByteArray ba恢复QMainWindow m的悬浮窗和工具栏的状态</td>
</tr>

<tr>
<td>m.saveGeometry()</td>
<td align="left">返回封装在QByteArray中QMainWindow m的位置和大小(Qt4.3)</td>
</tr>

<tr>
<td>m.saveState()</td>
<td align="left">返回封装在QByteArray中QMainWindow m的悬浮窗和工具栏的状态</td>
</tr>

<tr>
<td>m.setCentralWidget(w)</td>
<td align="left">设置QMainWindow m的中央部件为QWidget w</td>
</tr>

<tr>
<td>m.statusBar()</td>
<td align="left">返回QMainWindow的QStatusBar(第一次调用创建状态栏)</td>
</tr>

<tr>
<td>m.setWindowIcon(i)</td>
<td align="left">设置QMainWindow m的图标为QIcon i；这个方法继承自QWidget</td>
</tr>

<tr>
<td>m.setWindowTitle(s)</td>
<td align="left">设置QMainWindow m的标题为string s；这个方法继承自QWidget</td>
</tr>
</tbody>
</table>

<p>如果我们使用Qt4，使用<code>QWidget.restoreGeometry()</code>恢复窗口的几何位置，那么我们可以如此保存几何状态：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">settings</span><span class="o">.</span><span class="n">setValue</span><span class="p">(</span><span class="s2">&#34;Geometry&#34;</span><span class="p">,</span> <span class="n">QVariant</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">saveGeometry</span><span class="p">()))</span></code></pre></div>

<p>使用这种方法，不需要单独保存主窗口的大小和位置。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">okToContinue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dirty</span><span class="p">:</span>
    <span class="n">reply</span> <span class="o">=</span> <span class="n">QMessageBox</span><span class="o">.</span><span class="n">question</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="s2">&#34;Image Changer - Unsaved Changes&#34;</span><span class="p">,</span>
                    <span class="s2">&#34;Save unsaved changes?&#34;</span><span class="p">,</span>
                    <span class="n">QMessageBox</span><span class="o">.</span><span class="n">Yes</span><span class="o">|</span><span class="n">QMessageBox</span><span class="o">.</span><span class="n">No</span><span class="o">|</span>
                    <span class="n">QMessageBox</span><span class="o">.</span><span class="n">Cancel</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">reply</span> <span class="o">==</span> <span class="n">QMessageBox</span><span class="o">.</span><span class="n">Cancel</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">elif</span> <span class="n">reply</span> <span class="o">==</span> <span class="n">QMessageBox</span><span class="o">.</span><span class="n">Yes</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fileSave</span><span class="p">()</span>
    <span class="k">return</span> <span class="bp">True</span></code></pre></div>

<p>有些开发者使用<code>QMessageBox.Save</code>和<code>QMessageBox.Discard</code>。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">updateFileMenu</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">fileMenu</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">addActions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fileMenu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileMenuActions</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">QString</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span> \
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="bp">None</span>
    <span class="n">recentFiles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">recentFiles</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fname</span> <span class="o">!=</span> <span class="n">current</span> <span class="ow">and</span> <span class="n">QFile</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
            <span class="n">recentFiles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">recentFiles</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fileMenu</span><span class="o">.</span><span class="n">addSeparator</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fname</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">recentFiles</span><span class="p">):</span>
            <span class="n">action</span> <span class="o">=</span> <span class="n">QAction</span><span class="p">(</span><span class="n">QIcon</span><span class="p">(</span><span class="s2">&#34;:/icon.png&#34;</span><span class="p">),</span> <span class="s2">&#34;&amp;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">QFileInfo</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span><span class="o">.</span><span class="n">fileName</span><span class="p">()),</span> <span class="bp">self</span><span class="p">)</span>
            <span class="n">action</span><span class="o">.</span><span class="n">setData</span><span class="p">(</span><span class="n">QVariant</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&#34;triggered()&#34;</span><span class="p">),</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">loadFile</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fileMenu</span><span class="o">.</span><span class="n">addAction</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">fileMenu</span><span class="o">.</span><span class="n">addSeparator</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">fileMenu</span><span class="o">.</span><span class="n">addAction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fileMenuActions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></code></pre></div>

<blockquote>
<p><strong>QMessageBox的静态方法</strong>
QMessageBox类提供多个方便的静态方法，这些方法弹出一个有合适图标和按钮的模式对话框。
最常用的方法为critical()，information()，question()和waring()。这些方法携带参数
父类部件，窗口标题，消息文本(可以是纯文本或HTML)，0个或多个按钮。如果未指定按钮，则为OK按钮。
Qt4.0和Qt4.1中，OK按钮或Yes按钮位或QMessageBox.Default，Cancel按钮或No按钮位或
  QMessageBox.Escape很常见。
    reply = QMessageBox.question(self,
            &ldquo;Image Changer - Unsaved Changes&rdquo;, &ldquo;Save unsaved changes?&rdquo;,
            QMessageBox.Yes|QMessageBox.Default,
            QMessageBox.No|QMessageBox.Escape)
4.2中则自动绑定默认动作到相应的按钮上。
如果我们想创建自定义的消息框，可以创建一个QMessageBox实例，然后使用QMessageBox.addButton()
QMessageBox.setIcon()添加按钮，再调用QMessageBox.exec_()弹出消息框。</p>
</blockquote>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">addRecentFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">fname</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">recentFiles</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recentFiles</span><span class="o">.</span><span class="n">prepend</span><span class="p">(</span><span class="n">QString</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">recentFiles</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">recentFiles</span><span class="o">.</span><span class="n">takeLast</span><span class="p">()</span></code></pre></div>

<h1 id="处理文件动作">处理文件动作</h1>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">fileNew</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">okToContinue</span><span class="p">():</span>
        <span class="k">return</span>
    <span class="n">dialog</span> <span class="o">=</span> <span class="n">newimagedlg</span><span class="o">.</span><span class="n">NewImageDlg</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dialog</span><span class="o">.</span><span class="n">exec_</span><span class="p">():</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addRecentFile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">QImage</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">action</span><span class="p">,</span> <span class="n">check</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">resetableActions</span><span class="p">:</span>
            <span class="n">action</span><span class="o">.</span><span class="n">setChecked</span><span class="p">(</span><span class="n">check</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">dialog</span><span class="o">.</span><span class="n">image</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dirty</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">showImage</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sizeLabel</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="s2">&#34;</span><span class="si">%d</span><span class="s2"> x </span><span class="si">%d</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">width</span><span class="p">(),</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">height</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">updateStatus</span><span class="p">(</span><span class="s2">&#34;Created new image&#34;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">updateStatus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">statusBar</span><span class="p">()</span><span class="o">.</span><span class="n">showMessage</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="mi">5000</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">listWidget</span><span class="o">.</span><span class="n">addItem</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setWindowTitle</span><span class="p">(</span><span class="s2">&#34;Image Changer - </span><span class="si">%s</span><span class="s2">[*]&#34;</span> <span class="o">%</span> \
                            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">))</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">isNull</span><span class="p">():</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setWindowTitle</span><span class="p">(</span><span class="s2">&#34;Image Changer - Unnamed[*]&#34;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setWindowTitle</span><span class="p">(</span><span class="s2">&#34;Image Changer[*]&#34;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">setWindowModified</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dirty</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">fileOpen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">okToContinue</span><span class="p">():</span>
        <span class="k">return</span>
    <span class="nb">dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span> \
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="s2">&#34;.&#34;</span>
    <span class="n">formats</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;*.</span><span class="si">%s</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="nb">unicode</span><span class="p">(</span><span class="n">format</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> \
               <span class="k">for</span> <span class="n">format</span> <span class="ow">in</span> <span class="n">QImageReader</span><span class="o">.</span><span class="n">supportedImageFormats</span><span class="p">()]</span>
    <span class="n">fname</span> <span class="o">=</span> <span class="nb">unicode</span><span class="p">(</span><span class="n">QFileDialog</span><span class="o">.</span><span class="n">getOpenFileName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="s2">&#34;Image Changer - Choose Image&#34;</span><span class="p">,</span> <span class="nb">dir</span><span class="p">,</span>
                        <span class="s2">&#34;Image files (</span><span class="si">%s</span><span class="s2">)&#34;</span> <span class="o">%</span> <span class="s2">&#34; &#34;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">formats</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">fname</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loadFile</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span></code></pre></div>

<p><code>QFileDialog.getOpenFileName()</code>返回一个<code>QString</code>保存文件名的绝对路径，或者返回空。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">fname</span> <span class="o">=</span> <span class="nb">unicode</span><span class="p">(</span><span class="n">QFileDialog</span><span class="o">.</span><span class="n">getOpenFileName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="s2">&#34;</span><span class="si">%s</span><span class="s2"> - Choose Image&#34;</span> <span class="o">%</span> <span class="n">QApplication</span><span class="o">.</span><span class="n">applicationName</span><span class="p">(),</span>
                <span class="nb">dir</span><span class="p">,</span> <span class="s2">&#34;Image files (</span><span class="si">%s</span><span class="s2">)&#34;</span> <span class="o">%</span> <span class="s2">&#34; &#34;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">formats</span><span class="p">)))</span>

<span class="k">def</span> <span class="nf">loadFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">fname</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">action</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sender</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="n">QAction</span><span class="p">):</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="nb">unicode</span><span class="p">(</span><span class="n">action</span><span class="o">.</span><span class="n">data</span><span class="p">()</span><span class="o">.</span><span class="n">toString</span><span class="p">())</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">okToContinue</span><span class="p">():</span>
                <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span>
    <span class="k">if</span> <span class="n">fname</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">QImage</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">isNull</span><span class="p">():</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&#34;Failed to read </span><span class="si">%s</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="n">fname</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addRecentFile</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">QImage</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">action</span><span class="p">,</span> <span class="n">check</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">resetableActions</span><span class="p">:</span>
                <span class="n">action</span><span class="o">.</span><span class="n">setChecked</span><span class="p">(</span><span class="n">check</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">fname</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">showImage</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dirty</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sizeLabel</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="s2">&#34;</span><span class="si">%d</span><span class="s2"> x </span><span class="si">%d</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="p">(</span>
                        <span class="n">image</span><span class="o">.</span><span class="n">width</span><span class="p">(),</span> <span class="n">image</span><span class="o">.</span><span class="n">height</span><span class="p">()))</span>
            <span class="n">message</span> <span class="o">=</span> <span class="s2">&#34;Loaded </span><span class="si">%s</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">updateStatus</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">fileSave</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">isNull</span><span class="p">():</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fileSaveAs</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">updateStatus</span><span class="p">(</span><span class="s2">&#34;Saved as </span><span class="si">%s</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dirty</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">updateStatus</span><span class="p">(</span><span class="s2">&#34;Failed to save </span><span class="si">%s</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">fileSaveAs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">isNull</span><span class="p">():</span>
        <span class="k">return</span>
    <span class="n">fname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="s2">&#34;.&#34;</span>
    <span class="n">formats</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;*.</span><span class="si">%s</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="nb">unicode</span><span class="p">(</span><span class="n">format</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> \
               <span class="k">for</span> <span class="n">format</span> <span class="ow">in</span> <span class="n">QImageWriter</span><span class="o">.</span><span class="n">supportedImageFormats</span><span class="p">()]</span>
    <span class="n">fname</span> <span class="o">=</span> <span class="nb">unicode</span><span class="p">(</span><span class="n">QFileDialog</span><span class="o">.</span><span class="n">getSaveFileName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="s2">&#34;Image Changer - Save Image&#34;</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span>
                    <span class="s2">&#34;Image files (</span><span class="si">%s</span><span class="s2">)&#34;</span> <span class="o">%</span> <span class="s2">&#34; &#34;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">formats</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">fname</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&#34;.&#34;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fname</span><span class="p">:</span>
            <span class="n">fname</span> <span class="o">+=</span> <span class="s2">&#34;.png&#34;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addRecentFile</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">fname</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fileSave</span><span class="p">()</span></code></pre></div>

<p>QFileDialog.getSaveFileName()提示用户提供一个文件名用来保存当前文件。</p>

<h1 id="处理编辑动作">处理编辑动作</h1>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">editInvert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">on</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">isNull</span><span class="p">():</span>
        <span class="k">return</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">invertPixels</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">showImage</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dirty</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">updateStatus</span><span class="p">(</span><span class="s2">&#34;Inverted&#34;</span> <span class="k">if</span> <span class="n">on</span> <span class="k">else</span> <span class="s2">&#34;Uninverted&#34;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">editMirrorHorizontal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">on</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">isNull</span><span class="p">():</span>
        <span class="k">return</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">mirrored</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">showImage</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mirroredhorizontally</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">mirroredhorizontally</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dirty</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">updateStatus</span><span class="p">(</span><span class="s2">&#34;Mirrored Horizontally&#34;</span> \
            <span class="k">if</span> <span class="n">on</span> <span class="k">else</span> <span class="s2">&#34;Unmirrored Horizontally&#34;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">editUnMirror</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">on</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">isNull</span><span class="p">():</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mirroredhorizontally</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">editMirrorHorizontal</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mirroredvertically</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">editMirrorVertical</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">editZoom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">isNull</span><span class="p">():</span>
        <span class="k">return</span>
    <span class="n">percent</span><span class="p">,</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">QInputDialog</span><span class="o">.</span><span class="n">getInteger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="s2">&#34;Image Changer - Zoom&#34;</span><span class="p">,</span> <span class="s2">&#34;Percent:&#34;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zoomSpinBox</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">400</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ok</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zoomSpinBox</span><span class="o">.</span><span class="n">setValue</span><span class="p">(</span><span class="n">percent</span><span class="p">)</span></code></pre></div>

<p><code>QInputDialog</code>提供了一些其它方便的静态方法，<code>getDouble()</code>，<code>getItem()</code>，<code>getText()</code>。
所有这些方法返回一个tuple，包含一个指示用户是否输入的bool值和一个合法值。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">showImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">percent</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">isNull</span><span class="p">():</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="n">percent</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">percent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zoomSpinBox</span><span class="o">.</span><span class="n">value</span><span class="p">()</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="n">percent</span> <span class="o">/</span> <span class="mf">100.0</span>
    <span class="n">width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">width</span><span class="p">()</span> <span class="o">*</span> <span class="n">factor</span>
    <span class="n">height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">height</span><span class="p">()</span> <span class="o">*</span> <span class="n">factor</span>
    <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">scaled</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">Qt</span><span class="o">.</span><span class="n">KeepAspectRatio</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">imageLabel</span><span class="o">.</span><span class="n">setPixmap</span><span class="p">(</span><span class="n">QPixmap</span><span class="o">.</span><span class="n">fromImage</span><span class="p">(</span><span class="n">image</span><span class="p">))</span></code></pre></div>

<p>根据PyQt的文档，<code>QPixmap</code>对屏幕显示做了优化，而<code>QImage</code>对编辑做了优化，因此我们用它保存图像数据。</p>

<h1 id="处理帮助动作">处理帮助动作</h1>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">helpAbout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">QMessageBox</span><span class="o">.</span><span class="n">about</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&#34;About Image Changer&#34;</span><span class="p">,</span>
            <span class="s2">&#34;&#34;&#34;&lt;b&gt;Image Changer&lt;/b&gt; v </span><span class="si">%s</span><span class="s2">
</span><span class="s2">            &lt;p&gt;Copyright &amp;copy; 2007 Qtrac Ltd. 
</span><span class="s2">            All rights reserved.
</span><span class="s2">            &lt;p&gt;This application can be used to perform
</span><span class="s2">            simple image manipulations.
</span><span class="s2">            &lt;p&gt;Python </span><span class="si">%s</span><span class="s2"> - Qt </span><span class="si">%s</span><span class="s2"> - PyQt </span><span class="si">%s</span><span class="s2"> on </span><span class="si">%s</span><span class="s2">&#34;&#34;&#34;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">__version__</span><span class="p">,</span> <span class="n">platform</span><span class="o">.</span><span class="n">python_version</span><span class="p">(),</span>
            <span class="n">QT_VERSION_STR</span><span class="p">,</span> <span class="n">PYQT_VERSION_STR</span><span class="p">,</span> <span class="n">platform</span><span class="o">.</span><span class="n">system</span><span class="p">()))</span></code></pre></div>

<p><code>QMessageBox.about()</code>静态方法弹出一个给定标题和文本的只有OK按钮的模式对话框，其文本可以是HTML。</p>

<h1 id="总结">总结</h1>

<p>主窗口风格的程序由<code>QMainWindow</code>子类创建，其窗口只有一个单一的部件作为中央部件。</p>

<p>动作用来表示程序向用户提供的功能。这些动作保存在<code>QAction</code>对象中，包含文本(用于菜单)，图标(用于菜单
和工具栏)，工具栏提示和状态栏提示，以及所连接的槽。
通常所有的动作都会添加进菜单，而只有经常使用的一些加入工具栏。</p>

<p>动作，动作组和悬浮窗必须显式提供一个父亲，比如主窗口，以保证在合适的时候能被销毁。</p>

<p>程序通常使用资源(小文件，比如图标，和数据文件)，PyQt的资源机制使得访问和使用资源非常简单。使用
<code>pyrcc4</code>将资源文件编程Python模块，再导入程序使用。</p>
]]></content>
		</item>
		
		<item>
			<title>PyQt编程第5章 对话框</title>
			<link>https://gitop.cc/posts/pyqt-5/</link>
			<pubDate>Wed, 14 Oct 2015 16:20:56 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/pyqt-5/</guid>
			<description>对话框以“智力”分类为：哑巴，标准和聪明，取决于对话框知道程序数据的多少。 对话框以“模式”分类为：模式对话框和无模式对话框。 应用模式对话框一</description>
			<content type="html"><![CDATA[

<p>对话框以“智力”分类为：哑巴，标准和聪明，取决于对话框知道程序数据的多少。
对话框以“模式”分类为：模式对话框和无模式对话框。</p>

<p>应用模式对话框一旦被调用，用户只能与其交互，不能使用程序其它部分。
窗口模式对话框和应用模式对话框类似，只是它仅仅阻止与其父窗口交互。
无模式对话框允许用户与程序其它部分交互。</p>

<p>编写对话框另一个重要方面是如何处理有效性检验。我们尽量挑选合适的部件并设置其属性来避免编写有效性
检验代码。
我们称应用到单个部件的检验为部件级确认。当部件之间有相互关系时，称为表级确认。</p>

<h1 id="哑巴-对话框">“哑巴”对话框</h1>

<p>哑巴对话框不知道其部件使用的数据。哑巴对话框通常是带有<code>accept</code>和<code>reject</code>按钮的模式对话框。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">setPenProperties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">dialog</span> <span class="o">=</span> <span class="n">PenPropertiesDlg</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">dialog</span><span class="o">.</span><span class="n">widthSpinBox</span><span class="o">.</span><span class="n">setValue</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
    <span class="n">dialog</span><span class="o">.</span><span class="n">beveledCheckBox</span><span class="o">.</span><span class="n">setChecked</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beveled</span><span class="p">)</span>
    <span class="n">dialog</span><span class="o">.</span><span class="n">styleComboBox</span><span class="o">.</span><span class="n">setCurrentIndex</span><span class="p">(</span>
            <span class="n">dialog</span><span class="o">.</span><span class="n">styleComboBox</span><span class="o">.</span><span class="n">findText</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">style</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">dialog</span><span class="o">.</span><span class="n">exec_</span><span class="p">():</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">dialog</span><span class="o">.</span><span class="n">widthSpinBox</span><span class="o">.</span><span class="n">value</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beveled</span> <span class="o">=</span> <span class="n">dialog</span><span class="o">.</span><span class="n">beveledCheckBox</span><span class="o">.</span><span class="n">isChecked</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">style</span> <span class="o">=</span> <span class="nb">unicode</span><span class="p">(</span><span class="n">dialog</span><span class="o">.</span><span class="n">styleComboBox</span><span class="o">.</span><span class="n">currentText</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">updateData</span><span class="p">()</span></code></pre></div>

<p>当我们调用一个对话框的<code>exec_</code>时，则以模式对话框显示。当用户点击<code>accept</code>，<code>exec_</code>返回<code>True</code>，
否则返回<code>False</code>。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">PenPropertiesDlg</span><span class="p">(</span><span class="n">QDialog</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PenPropertiesDlg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
        <span class="n">widthLabel</span> <span class="o">=</span> <span class="n">QLabel</span><span class="p">(</span><span class="s2">&#34;&amp;Width:&#34;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widthSpinBox</span> <span class="o">=</span> <span class="n">QSpinBox</span><span class="p">()</span>
        <span class="n">widthLabel</span><span class="o">.</span><span class="n">setBuddy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widthSpinBox</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widthSpinBox</span><span class="o">.</span><span class="n">setAlignment</span><span class="p">(</span><span class="n">Qt</span><span class="o">.</span><span class="n">AlignRight</span><span class="o">|</span><span class="n">Qt</span><span class="o">.</span><span class="n">AlignVCenter</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">widthSpinBox</span><span class="o">.</span><span class="n">setRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">24</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beveledCheckBox</span> <span class="o">=</span> <span class="n">QCheckBox</span><span class="p">(</span><span class="s2">&#34;&amp;Beveled edges&#34;</span><span class="p">)</span>
        <span class="n">styleLabel</span> <span class="o">=</span> <span class="n">QLabel</span><span class="p">(</span><span class="s2">&#34;&amp;Style:&#34;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">styleComboBox</span> <span class="o">=</span> <span class="n">QComboBox</span><span class="p">()</span>
        <span class="n">styleLabel</span><span class="o">.</span><span class="n">setBuddy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">styleComboBox</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">styleComboBox</span><span class="o">.</span><span class="n">addItems</span><span class="p">([</span><span class="s2">&#34;Solid&#34;</span><span class="p">,</span> <span class="s2">&#34;Dashed&#34;</span><span class="p">,</span> <span class="s2">&#34;Dotted&#34;</span><span class="p">,</span>
                                     <span class="s2">&#34;DashDotted&#34;</span><span class="p">,</span> <span class="s2">&#34;DashDotDotted&#34;</span><span class="p">])</span>
        <span class="n">okButton</span> <span class="o">=</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s2">&#34;&amp;OK&#34;</span><span class="p">)</span>
        <span class="n">cancelButton</span> <span class="o">=</span> <span class="n">QPushButton</span><span class="p">(</span><span class="s2">&#34;Cancel&#34;</span><span class="p">)</span>

        <span class="n">buttonLayout</span> <span class="o">=</span> <span class="n">QHBoxLayout</span><span class="p">()</span>
        <span class="n">buttonLayout</span><span class="o">.</span><span class="n">addStretch</span><span class="p">()</span>
        <span class="n">buttonLayout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="n">okButton</span><span class="p">)</span>
        <span class="n">buttonLayout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="n">cancelButton</span><span class="p">)</span>
        <span class="n">layout</span> <span class="o">=</span> <span class="n">QGridLayout</span><span class="p">()</span>
        <span class="n">layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="n">widthLabel</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">widthSpinBox</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beveledCheckBox</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="n">styleLabel</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">styleComboBox</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">layout</span><span class="o">.</span><span class="n">addLayout</span><span class="p">(</span><span class="n">buttonLayout</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setLayout</span><span class="p">(</span><span class="n">layout</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">okButton</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&#34;clicked()&#34;</span><span class="p">),</span>
                     <span class="bp">self</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="s2">&#34;accept()&#34;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">cancelButton</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&#34;clicked()&#34;</span><span class="p">),</span>
                     <span class="bp">self</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="s2">&#34;reject()&#34;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setWindowTitle</span><span class="p">(</span><span class="s2">&#34;Pen Properties&#34;</span><span class="p">)</span></code></pre></div>

<p>在标签文字中的引号(<code>&amp;</code>)有2个可能的含义，一个简单地为字符引号。另一个指示引号后面的字母为键盘
加速键，可以使用Alt+字母快速定位。字符引号和加速键的区别是标签有没有一个“伙伴”。</p>

<p><strong>对话框按钮布局</strong></p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">buttonBox</span> <span class="o">=</span> <span class="n">QDialogButtonBox</span><span class="p">(</span><span class="n">QDialogButtonBox</span><span class="o">.</span><span class="n">Ok</span>
                             <span class="o">|</span> <span class="n">QDialogButtonBox</span><span class="o">.</span><span class="n">Cancel</span><span class="p">)</span>
<span class="n">buttonBox</span><span class="o">.</span><span class="n">button</span><span class="p">(</span><span class="n">QDialogButtonBox</span><span class="o">.</span><span class="n">Ok</span><span class="p">)</span><span class="o">.</span><span class="n">setDefault</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="n">layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="n">buttonBox</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">buttonBox</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&#34;accepted()&#34;</span><span class="p">),</span>
             <span class="bp">self</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="s2">&#34;accept()&#34;</span><span class="p">))</span>
<span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">buttonBox</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&#34;rejected()&#34;</span><span class="p">),</span>
             <span class="bp">self</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="s2">&#34;reject()&#34;</span><span class="p">))</span></code></pre></div>

<p><code>QDialogButtonBox</code>自动处理不同平台的默认外观。
<code>QDialogButtonBox</code>默认是水平布局，可以传递<code>Qt.Vertical</code>给它构造器设置垂直布局，或者调用
<code>setOrientation</code>函数。</p>

<p><code>QGridLayout.addWidget</code>方法的参数是部件，所在行，所在列，和可选的行扩展数，列扩展数。</p>

<table>
<thead>
<tr>
<th>语法</th>
<th align="left">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>b.addLayout(l)</td>
<td align="left">添加QLayout l到QBoxLayout b中, b通常是QHBoxLayout或QVBoxLayout</td>
</tr>

<tr>
<td>b.addSpacing(i)</td>
<td align="left">添加一个指定数量为i的QSpacerItem到QBoxLayout b中</td>
</tr>

<tr>
<td>b.addStretch(i)</td>
<td align="left">添加一个最小为0且伸展系数为i的QSpacerItem到QBoxLayout b中</td>
</tr>

<tr>
<td>b.addWidget(w)</td>
<td align="left">添加QWidget w到QBoxLayout b中</td>
</tr>

<tr>
<td>b.setStretchFactor(x, i)</td>
<td align="left">设置QBoxLayout b的伸展系数或QWidget x为i</td>
</tr>

<tr>
<td>g.addLayout(l, r, c)</td>
<td align="left">在行r列c添加QLayout l到QGridLayout g; 可以提供附加的行扩展和列扩展参数</td>
</tr>

<tr>
<td>g.addWidget(w, r, c)</td>
<td align="left">在行r列c添加QWidget w到QGridLayout g; 可以提供附加的行扩展和列扩展参数</td>
</tr>

<tr>
<td>g.setRowStretch(r, i)</td>
<td align="left">设置QGridLayout g行r的伸展为i</td>
</tr>

<tr>
<td>g.setColumnStretch(c, i)</td>
<td align="left">设置QGridLayout g列c的伸展为i</td>
</tr>
</tbody>
</table>

<h1 id="标准对话框">标准对话框</h1>

<p>我们认为一个对话框是标准对话框，如果它访问部件都是通过类方法，而不是部件本身。</p>

<h2 id="模式ok-cancel风格对话框">模式OK/Cancel风格对话框</h2>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">setNumberFormat1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">dialog</span> <span class="o">=</span> <span class="n">numberformatdlg1</span><span class="o">.</span><span class="n">NumberFormatDlg</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dialog</span><span class="o">.</span><span class="n">exec_</span><span class="p">():</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="n">dialog</span><span class="o">.</span><span class="n">numberFormat</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refreshTable</span><span class="p">()</span></code></pre></div>

<table>
<thead>
<tr>
<th>语法</th>
<th align="left">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>d.addButton(b, r)</td>
<td align="left">添加具有QDialogButtonBox.ButtonRole r的QPushButton b到QDialogButtonBox d中</td>
</tr>

<tr>
<td>d.addButton(t, r)</td>
<td align="left">添加具有QDialogButtonBox.ButtonRole r且名字为t的QPushButton到QDialogButtonBox d中，返回所添加的按钮</td>
</tr>

<tr>
<td>d.addButton(s)</td>
<td align="left">添加由QDialogButtonBox.StandardButton s指定的按钮QDialogButtonBox d中，返回所添加的按钮</td>
</tr>

<tr>
<td>d.setOrientation(o)</td>
<td align="left">设置QDialogButtonBox d的方向为Qt.Orientation o(垂直或水平)</td>
</tr>

<tr>
<td>d.button(s)</td>
<td align="left">返回QDialogButtonBox d中由StandardButton s指定的按钮，或None</td>
</tr>

<tr>
<td>d.accepted()</td>
<td align="left">当角色为QDialogButtonBox.Accept的按钮被点击，发射该信号</td>
</tr>

<tr>
<td>d.rejected()</td>
<td align="left">当角色为QDialogButtonBox.Reject的按钮被点击，发射该信号</td>
</tr>
</tbody>
</table>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">accept</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">class</span> <span class="nc">ThousandsError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span> <span class="k">pass</span>
    <span class="k">class</span> <span class="nc">DecimalError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span> <span class="k">pass</span>
    <span class="n">QMessageBox</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&#34;Decimal Marker Error&#34;</span><span class="p">,</span> <span class="nb">unicode</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
    <span class="n">QDialog</span><span class="o">.</span><span class="n">accept</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></code></pre></div>

<p>为什么这里不使用<code>super</code>来调用基类的<code>accept</code>而是显式使用<code>QDialog</code>？因为在这个环境下使用<code>super</code>
不起作用。PyQt为了尽可能效率高，使用懒惰属性查找，结果就是此处的<code>super</code>在PyQt的子类中不会像预期
那样工作。(见pyqt4ref.html文档，&rdquo;super and PyQt classes&rdquo;)</p>

<h1 id="智能对话框">智能对话框</h1>

<p>智能对话框通常是无模式的，带有<code>apply</code>和<code>close</code>按钮。</p>

<table>
<thead>
<tr>
<th>语法</th>
<th align="left">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>d.accept()</td>
<td align="left">关闭(隐藏)QDialog d，停止事件循环，并导致exec_()返回True。如果设置了Qt.WA_DeleteOnClose，则对话框被删除</td>
</tr>

<tr>
<td>d.reject()</td>
<td align="left">关闭(隐藏)QDialog d，停止事件循环，并导致exec_()返回False。</td>
</tr>

<tr>
<td>d.done(i)</td>
<td align="left">关闭(隐藏)QDialog d，停止事件循环，并导致exec_()返回i。</td>
</tr>

<tr>
<td>d.exec_()</td>
<td align="left">模式显示QDialog d，阻塞直到对话框关闭</td>
</tr>

<tr>
<td>d.show()</td>
<td align="left">无模式显示QDialog d；继承自QWidget</td>
</tr>

<tr>
<td>d.setSizeGripEnabled(b)</td>
<td align="left">显示或隐藏QDialog d的size grip，基于bool b</td>
</tr>
</tbody>
</table>

<h2 id="无模式apply-close风格对话框">无模式Apply/Close风格对话框</h2>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">setNumberFormat2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">dialog</span> <span class="o">=</span> <span class="n">numberformatdlg2</span><span class="o">.</span><span class="n">NumberFormatDlg</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">dialog</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&#34;changed&#34;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">refreshTable</span><span class="p">)</span>
    <span class="n">dialog</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></code></pre></div>

<p>尽管dialog超出范围，PyQt足够聪明地保存了一个无模式对话框的引用，因此dialog继续存在。可以设置
dialog的属性为Qt.WA_DeleteOnClose，则每次都删除对话框而不是隐藏。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">NumberFormatDlg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">setAttribute</span><span class="p">(</span><span class="n">Qt</span><span class="o">.</span><span class="n">WA_DeleteOnClose</span><span class="p">)</span>
    <span class="n">punctuationRe</span> <span class="o">=</span> <span class="n">QRegExp</span><span class="p">(</span><span class="sa">r</span><span class="s2">&#34;[ ,;:.]&#34;</span><span class="p">)</span>
    <span class="n">thousandsLabel</span> <span class="o">=</span> <span class="n">QLabel</span><span class="p">(</span><span class="s2">&#34;&amp;Thousands separator&#34;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">thousandsEdit</span> <span class="o">=</span> <span class="n">QLineEdit</span><span class="p">(</span><span class="n">format</span><span class="p">[</span><span class="s2">&#34;thousandsseparator&#34;</span><span class="p">])</span>
    <span class="n">thousandsLabel</span><span class="o">.</span><span class="n">setBuddy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thousandsEdit</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">thousandsEdit</span><span class="o">.</span><span class="n">setMaxLength</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">thousandsEdit</span><span class="o">.</span><span class="n">setValidator</span><span class="p">(</span>
            <span class="n">QRegExpValidator</span><span class="p">(</span><span class="n">punctuationRe</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
    <span class="n">decimalMarkerLabel</span> <span class="o">=</span> <span class="n">QLabel</span><span class="p">(</span><span class="s2">&#34;Decimal &amp;marker&#34;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">decimalMarkerEdit</span> <span class="o">=</span> <span class="n">QLineEdit</span><span class="p">(</span><span class="n">format</span><span class="p">[</span><span class="s2">&#34;decimalmarker&#34;</span><span class="p">])</span>
    <span class="n">decimalMarkerLabel</span><span class="o">.</span><span class="n">setBuddy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">decimalMarkerEdit</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">decimalMarkerEdit</span><span class="o">.</span><span class="n">setMaxLength</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">decimalMarkerEdit</span><span class="o">.</span><span class="n">setValidator</span><span class="p">(</span>
            <span class="n">QRegExpValidator</span><span class="p">(</span><span class="n">punctuationRe</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">decimalMarkerEdit</span><span class="o">.</span><span class="n">setInputMask</span><span class="p">(</span><span class="s2">&#34;X&#34;</span><span class="p">)</span>
    <span class="n">decimalPlacesLabel</span> <span class="o">=</span> <span class="n">QLabel</span><span class="p">(</span><span class="s2">&#34;&amp;Decimal places&#34;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">decimalPlacesSpinBox</span> <span class="o">=</span> <span class="n">QSpinBox</span><span class="p">()</span>
    <span class="n">decimalPlacesLabel</span><span class="o">.</span><span class="n">setBuddy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">decimalPlacesSpinBox</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">decimalPlacesSpinBox</span><span class="o">.</span><span class="n">setRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">decimalPlacesSpinBox</span><span class="o">.</span><span class="n">setValue</span><span class="p">(</span><span class="n">format</span><span class="p">[</span><span class="s2">&#34;decimalplaces&#34;</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">redNegativesCheckBox</span> <span class="o">=</span> <span class="n">QCheckBox</span><span class="p">(</span><span class="s2">&#34;&amp;Red negative numbers&#34;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">redNegativesCheckBox</span><span class="o">.</span><span class="n">setChecked</span><span class="p">(</span><span class="n">format</span><span class="p">[</span><span class="s2">&#34;rednegatives&#34;</span><span class="p">])</span>
    <span class="n">buttonBox</span> <span class="o">=</span> <span class="n">QDialogButtonBox</span><span class="p">(</span><span class="n">QDialogButtonBox</span><span class="o">.</span><span class="n">Apply</span><span class="o">|</span>
                                 <span class="n">QDialogButtonBox</span><span class="o">.</span><span class="n">Close</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">buttonBox</span><span class="o">.</span><span class="n">button</span><span class="p">(</span><span class="n">QDialogButtonBox</span><span class="o">.</span><span class="n">Apply</span><span class="p">),</span>
                 <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&#34;clicked()&#34;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">buttonBox</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&#34;rejected()&#34;</span><span class="p">),</span>
                 <span class="bp">self</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="s2">&#34;reject()&#34;</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">setWindowTitle</span><span class="p">(</span><span class="s2">&#34;Set Number Format (Modeless)&#34;</span><span class="p">)</span></code></pre></div>

<p><code>QRegExpValidator</code>初始化式需要一个正则表达式和一个<code>parent</code>。
一个掩饰“X”说明需要任意一个字符，格式掩饰在<code>QLineEdit.inputMask</code>文档中说明。</p>

<h2 id="无模式-live-对话框">无模式“Live”对话框</h2>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">setNumberFormat3</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">numberFormatDlg</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numberFormatDlg</span> <span class="o">=</span> <span class="n">numberformatdlg3</span><span class="o">.</span><span class="n">NumberFormatDlg</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">refreshTable</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">numberFormatDlg</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">numberFormatDlg</span><span class="o">.</span><span class="n">raise_</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">numberFormatDlg</span><span class="o">.</span><span class="n">activateWindow</span><span class="p">()</span></code></pre></div>

<p><code>raise_</code>将对话框置于其它窗口之上
<code>activateWindow</code>聚焦于对话框</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thousandsEdit</span><span class="p">,</span>
             <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&#34;textEdited(QString)&#34;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkAndFix</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">decimalMarkerEdit</span><span class="p">,</span>
             <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&#34;textEdited(QString)&#34;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkAndFix</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">decimalPlacesSpinBox</span><span class="p">,</span>
             <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&#34;valueChanged(int)&#34;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">redNegativesCheckBox</span><span class="p">,</span>
             <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&#34;toggled(bool)&#34;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">)</span></code></pre></div>
]]></content>
		</item>
		
		<item>
			<title>PyQt编程第4章 GUI编程介绍</title>
			<link>https://gitop.cc/posts/pyqt-4/</link>
			<pubDate>Mon, 12 Oct 2015 20:34:55 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/pyqt-4/</guid>
			<description>一个25行的弹出警告 import sys import time from PyQt4.QtCore import * from PyQt4.QtGui import * app = QApplication(sys.argv) try: due = QTime.currentTime() message = &amp;#34;Alert!&amp;#34; if len(sys.argv) &amp;lt; 2: raise ValueError hours, mins = sys.argv[1].split(&amp;#34;:&amp;#34;) due = QTime(int(hours), int(mins)) if not due.isValid(): raise ValueError if len(sys.argv) &amp;gt; 2: message = &amp;#34; &amp;#34;.join(sys.argv[2:]) except ValueError: message = &amp;#34;Usage: alert.pyw HH:MM [optional message]&amp;#34; # 24hr</description>
			<content type="html"><![CDATA[

<h1 id="一个25行的弹出警告">一个25行的弹出警告</h1>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">PyQt4.QtCore</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">PyQt4.QtGui</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">QApplication</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">due</span> <span class="o">=</span> <span class="n">QTime</span><span class="o">.</span><span class="n">currentTime</span><span class="p">()</span>
    <span class="n">message</span> <span class="o">=</span> <span class="s2">&#34;Alert!&#34;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span>
    <span class="n">hours</span><span class="p">,</span> <span class="n">mins</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&#34;:&#34;</span><span class="p">)</span>
    <span class="n">due</span> <span class="o">=</span> <span class="n">QTime</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">hours</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">mins</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">due</span><span class="o">.</span><span class="n">isValid</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">message</span> <span class="o">=</span> <span class="s2">&#34; &#34;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
<span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
    <span class="n">message</span> <span class="o">=</span> <span class="s2">&#34;Usage: alert.pyw HH:MM [optional message]&#34;</span> <span class="c1"># 24hr clock</span>

<span class="k">while</span> <span class="n">QTime</span><span class="o">.</span><span class="n">currentTime</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">due</span><span class="p">:</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="c1"># 20 seconds</span>

<span class="n">label</span> <span class="o">=</span> <span class="n">QLabel</span><span class="p">(</span><span class="s2">&#34;&lt;font color=red size=72&gt;&lt;b&gt;&#34;</span> <span class="o">+</span> <span class="n">message</span> <span class="o">+</span> <span class="s2">&#34;&lt;/b&gt;&lt;/font&gt;&#34;</span><span class="p">)</span>
<span class="n">label</span><span class="o">.</span><span class="n">setWindowFlags</span><span class="p">(</span><span class="n">Qt</span><span class="o">.</span><span class="n">SplashScreen</span><span class="p">)</span>
<span class="n">label</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="n">QTimer</span><span class="o">.</span><span class="n">singleShot</span><span class="p">(</span><span class="mi">60000</span><span class="p">,</span> <span class="n">app</span><span class="o">.</span><span class="n">quit</span><span class="p">)</span> <span class="c1"># 1 minute</span>
<span class="n">app</span><span class="o">.</span><span class="n">exec_</span><span class="p">()</span></code></pre></div>

<p>每一个PyQt图形程序必须有一个<code>QApplication</code>对象，因为它能识别一些命令行的参数，接受<code>sys.argv</code>作为
参数。</p>

<p>PyQt中任何部件都能用作顶级窗口，比如一个按钮或一个标签。当部件如此使用时，PyQt自动给它一个标题栏。
一旦窗口设置好后，就可以调用<code>show</code>方法，这个时候窗口没有显示。<code>show</code>方法仅仅是将一个画图事件加入
<code>QApplication</code>对象的事件队列。</p>

<p><code>app.exec_</code>开始<code>QApplication</code>对象事件循环。第一个事件是画图事件，因此标签窗口弹出。一分钟后超时
事件触发，<code>app.quit</code>被调用。这个方法执行图形程序的结束清理工作，关闭窗口，释放资源。</p>

<p>图形程序的事件循环，伪代码如下：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">event</span> <span class="o">=</span> <span class="n">getNextEvent</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">event</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">event</span> <span class="o">==</span> <span class="n">Terminate</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">processEvent</span><span class="p">(</span><span class="n">event</span><span class="p">)</span></code></pre></div>

<h1 id="一个30行的表达式求值程序">一个30行的表达式求值程序</h1>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">PyQt4.QtCore</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">PyQt4.QtGui</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">class</span> <span class="nc">Form</span><span class="p">(</span><span class="n">QDialog</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Form</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">browser</span> <span class="o">=</span> <span class="n">QTextBrowser</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lineedit</span> <span class="o">=</span> <span class="n">QLineEdit</span><span class="p">(</span><span class="s2">&#34;Type an expression and press Enter&#34;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lineedit</span><span class="o">.</span><span class="n">selectAll</span><span class="p">()</span>
        <span class="n">layout</span> <span class="o">=</span> <span class="n">QVBoxLayout</span><span class="p">()</span>
        <span class="n">layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">browser</span><span class="p">)</span>
        <span class="n">layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lineedit</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setLayout</span><span class="p">(</span><span class="n">layout</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lineedit</span><span class="o">.</span><span class="n">setFocus</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lineedit</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&#34;returnPressed()&#34;</span><span class="p">),</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">updateUi</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setWindowTitle</span><span class="p">(</span><span class="s2">&#34;Calculate&#34;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">updateUi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="nb">unicode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lineedit</span><span class="o">.</span><span class="n">text</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">browser</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&#34;</span><span class="si">%s</span><span class="s2"> = &lt;b&gt;</span><span class="si">%s</span><span class="s2">&lt;/b&gt;&#34;</span> <span class="o">%</span> <span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="nb">eval</span><span class="p">(</span><span class="n">text</span><span class="p">)))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">browser</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s2">&#34;&lt;font color=red&gt;</span><span class="si">%s</span><span class="s2"> is invalid!&lt;/font&gt;&#34;</span> <span class="o">%</span> <span class="n">text</span><span class="p">)</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">QApplication</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span>
<span class="n">form</span> <span class="o">=</span> <span class="n">Form</span><span class="p">()</span>
<span class="n">form</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="n">app</span><span class="o">.</span><span class="n">exec_</span><span class="p">()</span></code></pre></div>

<p>所有PyQt的部件，都继承自<code>QWidget</code>，并且都是新风格的类。默认地，当一个部件被关闭时，它仅仅是被隐藏了。
当一个窗体隐藏了，如果PyQt检查到程序没有可见窗体，而且进一步交互也不可能，PyQt会执行程序的结束清理工作。</p>

<blockquote>
<p><strong>对象所有权</strong>
*  所有PyQt类继承自<code>QObject</code>，包括所有的部件。没有父亲的部件是一个顶级窗口，孩子部件被包含在父亲部件
里面。父亲部件对孩子部件拥有所有权。
*  PyQt使用父子所有权模型来保证当一个父亲部件被销毁，所有它的孩子部件也被自动销毁。
*  为避免内存泄漏，除了顶级窗口，我们应该保证所有部件都有父亲。
*  布局管理器自动将部件重新绑定到正确的父亲部件上。</p>
</blockquote>

<p>PyQt提供3种布局管理器：垂直布局，水平布局，网格布局。布局可以嵌套。
每一个部件通过发射信号声明状态改变。</p>

<h1 id="一个70行的汇率转换器">一个70行的汇率转换器</h1>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">urllib2</span>
<span class="kn">from</span> <span class="nn">PyQt4.QtCore</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">PyQt4.QtGui</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">class</span> <span class="nc">Form</span><span class="p">(</span><span class="n">QDialog</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Form</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>

        <span class="n">date</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getdata</span><span class="p">()</span>
        <span class="n">rates</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rates</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="n">dateLabel</span> <span class="o">=</span> <span class="n">QLabel</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fromComboBox</span> <span class="o">=</span> <span class="n">QComboBox</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fromComboBox</span><span class="o">.</span><span class="n">addItems</span><span class="p">(</span><span class="n">rates</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fromSpinBox</span> <span class="o">=</span> <span class="n">QDoubleSpinBox</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fromSpinBox</span><span class="o">.</span><span class="n">setRange</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">10000000.00</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fromSpinBox</span><span class="o">.</span><span class="n">setValue</span><span class="p">(</span><span class="mf">1.00</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">toComboBox</span> <span class="o">=</span> <span class="n">QComboBox</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">toComboBox</span><span class="o">.</span><span class="n">addItems</span><span class="p">(</span><span class="n">rates</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">toLabel</span> <span class="o">=</span> <span class="n">QLabel</span><span class="p">(</span><span class="s2">&#34;1.00&#34;</span><span class="p">)</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">QGridLayout</span><span class="p">()</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="n">dateLabel</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fromComboBox</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fromSpinBox</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">toComboBox</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">toLabel</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setLayout</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fromComboBox</span><span class="p">,</span>
                <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&#34;currentIndexChanged(int)&#34;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">updateUi</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">toComboBox</span><span class="p">,</span>
                <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&#34;currentIndexChanged(int)&#34;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">updateUi</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fromSpinBox</span><span class="p">,</span>
                <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&#34;valueChanged(double)&#34;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">updateUi</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setWindowTitle</span><span class="p">(</span><span class="s2">&#34;Currency&#34;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">updateUi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">to</span> <span class="o">=</span> <span class="nb">unicode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">toComboBox</span><span class="o">.</span><span class="n">currentText</span><span class="p">())</span>
        <span class="n">from_</span> <span class="o">=</span> <span class="nb">unicode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fromComboBox</span><span class="o">.</span><span class="n">currentText</span><span class="p">())</span>
        <span class="n">amount</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rates</span><span class="p">[</span><span class="n">from_</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rates</span><span class="p">[</span><span class="n">to</span><span class="p">])</span> <span class="o">*</span> \
                 <span class="bp">self</span><span class="o">.</span><span class="n">fromSpinBox</span><span class="o">.</span><span class="n">value</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">toLabel</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="s2">&#34;</span><span class="si">%0.2f</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="n">amount</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getdata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># Idea taken from the Python Cookbook</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rates</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">date</span> <span class="o">=</span> <span class="s2">&#34;Unknown&#34;</span>
            <span class="n">fh</span> <span class="o">=</span> <span class="n">urllib2</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s2">&#34;http://www.bankofcanada.ca&#34;</span>
                                 <span class="s2">&#34;/en/markets/csv/exchange_eng.csv&#34;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">fh</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span> <span class="ow">or</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">((</span><span class="s2">&#34;#&#34;</span><span class="p">,</span> <span class="s2">&#34;Closing &#34;</span><span class="p">)):</span>
                    <span class="k">continue</span>
                <span class="n">fields</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&#34;,&#34;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&#34;Date &#34;</span><span class="p">):</span>
                    <span class="n">date</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">rates</span><span class="p">[</span><span class="nb">unicode</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="k">pass</span>
            <span class="k">return</span> <span class="s2">&#34;Exchange Rates Date: &#34;</span> <span class="o">+</span> <span class="n">date</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&#34;Failed to download:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="n">e</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">QApplication</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span>
<span class="n">form</span> <span class="o">=</span> <span class="n">Form</span><span class="p">()</span>
<span class="n">form</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="n">app</span><span class="o">.</span><span class="n">exec_</span><span class="p">()</span></code></pre></div>

<h1 id="信号和槽">信号和槽</h1>

<p>每一个<code>QObject</code>支持信号和槽机制。所有的PyQt部件都有一组预定义的信号。不管什么时候一个信号发射，PyQt
默认简单地将其丢掉。必须将信号连接到槽来捕捉信号。在PyQt中，槽是任何可调用的对象。大多数部件也有预定义
好的槽。</p>

<p><code>connect</code>的语法，s通常是<code>self</code>，w是部件：</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&#34;signalSignature&#34;</span><span class="p">),</span> <span class="n">functionName</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&#34;signalSignature&#34;</span><span class="p">),</span> <span class="n">instance</span><span class="o">.</span><span class="n">methodName</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&#34;signalSignature&#34;</span><span class="p">),</span> <span class="n">instance</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="s2">&#34;slotSignature&#34;</span><span class="p">))</span></code></pre></div>

<p>signalSignature是信号的名字，并带一个逗号隔开的参数列表。如果是Qt信号，则参数类型必须是C++类型。
当书写信号的C++参数类型时，可以丢弃<code>const</code>和<code>&amp;</code>，但是必须保留<code>*</code>。</p>

<p>PyQt信号发射时被定义，它们可以有任意数量，任意类型的参数。</p>

<p>slotSignature和signalSignature有着一样的形式。一个槽的参数可能比信号少。相应的信号和槽的参数必须类型相同。
如果是Qt槽而不是Python方法时，使用<code>SLOT</code>语法效率更高。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">dial</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&#34;valueChanged(int)&#34;</span><span class="p">),</span> <span class="n">spinbox</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="s2">&#34;setValue(int)&#34;</span><span class="p">))</span>
<span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">spinbox</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&#34;valueChanged(int)&#34;</span><span class="p">),</span> <span class="n">dial</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="s2">&#34;setValue(int)&#34;</span><span class="p">))</span></code></pre></div>

<p>可以将多个信号连接到同一个槽，也可以将一个信号连接到多个槽。尽管很罕见，我们也可以将一个信号连接到另一个
信号，这样当第一个信号发射时，将会引起它连接的信号发射。</p>

<p>通过<code>QObject.connect</code>建立连接，<code>QObject.disconnect</code>解除连接。实际上，我们很少需要自己解除连接，
PyQt会自动解除已经销毁的对象相关的连接。</p>

<p>使用<code>QObject.emit</code>发射自定义的信号。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">ZeroSpinBox</span><span class="p">(</span><span class="n">QSpinBox</span><span class="p">):</span>
    <span class="n">zeros</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ZeroSpinBox</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="s1">&#39;valueChanged(int)&#39;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkzero</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">checkzero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zeros</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">SIGNAL</span><span class="p">(</span><span class="s1">&#39;atzero&#39;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeros</span><span class="p">)</span></code></pre></div>

<p>一个没有参数(没有括号)的信号是一个短路Python信号。当这种信号被发射，任何数据都可以当作额外的参数传给
<code>emit</code>方法，这些参数被当作Python对象传递。
至少有一个参数的信号是Qt信号或非短路Python信号，其参数都将转换为C++数据类型。</p>

<p>PyQt的信号和槽机制并不局限于GUI类，任何<code>QObject</code>的子类都可以使用信号和槽。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">PyQt4.QtCore</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">class</span> <span class="nc">TaxRate</span><span class="p">(</span><span class="n">QObject</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">TaxRate</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__rate</span> <span class="o">=</span> <span class="mf">17.5</span>

    <span class="k">def</span> <span class="nf">rate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__rate</span>

    <span class="k">def</span> <span class="nf">setRate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rate</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">rate</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__rate</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__rate</span> <span class="o">=</span> <span class="n">rate</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">SIGNAL</span><span class="p">(</span><span class="s1">&#39;rateChanged&#39;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">__rate</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">rateChanged</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="k">print</span> <span class="s1">&#39;TaxRate changed to </span><span class="si">%.2f%%</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">value</span>

<span class="n">vat</span> <span class="o">=</span> <span class="n">TaxRate</span><span class="p">()</span>
<span class="n">vat</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">vat</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="s1">&#39;rateChanged&#39;</span><span class="p">),</span> <span class="n">rateChanged</span><span class="p">)</span>
<span class="n">vat</span><span class="o">.</span><span class="n">setRate</span><span class="p">(</span><span class="mf">17.5</span><span class="p">)</span>
<span class="n">vat</span><span class="o">.</span><span class="n">setRate</span><span class="p">(</span><span class="mf">8.5</span><span class="p">)</span></code></pre></div>

<p>多个信号连接到同一个槽时，如何确定谁调用了槽。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">button2</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&#34;clicked()&#34;</span><span class="p">),</span>
             <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">anyButton</span><span class="p">,</span> <span class="s2">&#34;Two&#34;</span><span class="p">))</span> <span class="c1"># WRONG for PyQt 4.0-4.2</span>
<span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">button3</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&#34;clicked()&#34;</span><span class="p">),</span>
             <span class="k">lambda</span> <span class="n">who</span><span class="o">=</span><span class="s2">&#34;Three&#34;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">anyButton</span><span class="p">(</span><span class="n">who</span><span class="p">))</span> <span class="c1"># WRONG before 4.1.1</span></code></pre></div>

<p>在PyQt4.3之前，在<code>connect</code>中创建的函数，在<code>connect</code>返回时被垃圾回收。因此需要保存一个引用到该函数。
在PyQt4.1.1之前，在<code>connect</code>中创建的<code>lambda</code>也会被垃圾回收，同样需要保存一个引用。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="bp">self</span><span class="o">.</span><span class="n">button2callback</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">anyButton</span><span class="p">,</span> <span class="s2">&#34;Two&#34;</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">button2</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&#34;clicked()&#34;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">button2callback</span><span class="p">)</span>

<span class="bp">self</span><span class="o">.</span><span class="n">button3callback</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">who</span><span class="o">=</span><span class="s2">&#34;Three&#34;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">anyButton</span><span class="p">(</span><span class="n">who</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">button3</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&#34;clicked()&#34;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">button3callback</span><span class="p">)</span></code></pre></div>

<p>另外一种方法是使用<code>sender</code>告诉我们是哪个对象。</p>

<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">button4</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&#34;clicked()&#34;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">clicked</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">button5</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="s2">&#34;clicked()&#34;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">clicked</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">clicked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">button</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sender</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">button</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">button</span><span class="p">,</span> <span class="n">QPushButton</span><span class="p">):</span>
        <span class="k">return</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="s2">&#34;You clicked button &#39;</span><span class="si">%s</span><span class="s2">&#39;&#34;</span> <span class="o">%</span> <span class="n">button</span><span class="o">.</span><span class="n">text</span><span class="p">())</span></code></pre></div>
]]></content>
		</item>
		
		<item>
			<title>第15章 面向对象编程</title>
			<link>https://gitop.cc/posts/cpp-primer-15/</link>
			<pubDate>Mon, 21 Sep 2015 09:04:53 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/cpp-primer-15/</guid>
			<description>15.1 OOP概述 面向对象编程的关键思想是数据抽象，继承和动态绑定。使用数据抽象，我们可以定义接口和实现分离的类。通过继承，我们可以定义相似类之间</description>
			<content type="html"><![CDATA[

<h1 id="15-1-oop概述">15.1 OOP概述</h1>

<p>面向对象编程的关键思想是数据抽象，继承和动态绑定。使用数据抽象，我们可以定义接口和实现分离的类。通过继承，我们可以定义相似类之间的关系模型。通过动态绑定，我们可以使用这些类对象而忽略它们之间的差别。</p>

<h2 id="继承">继承</h2>

<p>通过继承联系的类构成一个层级关系。典型地，有一个基类在层级的顶端，其它类直接或间接继承这个类。这些继承类被称为派生类。基类定义层级中共同的成员。每一个派生类定义它自己特定的成员。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Quote</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">isbn</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">double</span> <span class="nf">net_price</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>派生类必须指定继承自哪个（或哪些）基类。继承列表是逗号分隔的包含可选访问限定符的基类列表。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Bulk_quote</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Quote</span> <span class="p">{</span> <span class="c1">// Bulk_quote继承自Quote
</span><span class="c1"></span><span class="k">public</span><span class="o">:</span>
    <span class="kt">double</span> <span class="n">net_price</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>派生类必须在类定义里面包含所有它想定义的虚函数的声明。派生类可以声明这些函数为<strong>virtual</strong>，但没有要求这么做。新标准让派生类可以显式指定想要覆盖的虚函数，在参数列表后面指定<strong>override</strong>就可以。</p>

<h2 id="动态绑定">动态绑定</h2>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">double</span> <span class="nf">print_total</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">Quote</span> <span class="o">&amp;</span><span class="n">item</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 取决于绑定到item参数的类型调用Quote::net_price或Bulk_quote::net_price
</span><span class="c1"></span>    <span class="kt">double</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">item</span><span class="p">.</span><span class="n">net_price</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;ISBN: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="p">.</span><span class="n">isbn</span><span class="p">()</span> <span class="c1">// 调用Quote::isbn
</span><span class="c1"></span>       <span class="o">&lt;&lt;</span> <span class="s">&#34; # sold: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; total due: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">ret</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
     <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// basic是Quote类型; bulk是Bulk_quote类型
</span><span class="c1"></span><span class="n">print_total</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="n">basic</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span> <span class="c1">// 调用Quote::net_price
</span><span class="c1"></span><span class="n">print_total</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="n">bulk</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>  <span class="c1">// 调用Bulk_quote::net_price
</span></code></pre></div>

<p>因为直到运行时才能根据对象的实际类型确定调用哪个函数，因此动态绑定又叫运行时绑定。</p>

<blockquote>
<p><strong>注解</strong>
在C++中，动态绑定发生在通过基类的引用或指针调用虚函数时。</p>
</blockquote>

<h1 id="15-2-定义基类和派生类">15.2 定义基类和派生类</h1>

<h2 id="15-2-1-定义一个基类">15.2.1 定义一个基类</h2>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Quote</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Quote</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">Quote</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">book</span><span class="p">,</span> <span class="kt">double</span> <span class="n">sales_price</span><span class="p">)</span><span class="o">:</span>
                     <span class="n">bookNo</span><span class="p">(</span><span class="n">book</span><span class="p">),</span> <span class="n">price</span><span class="p">(</span><span class="n">sales_price</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">isbn</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">bookNo</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// 派生类将覆盖和应用不同的打折策略
</span><span class="c1"></span>    <span class="k">virtual</span> <span class="kt">double</span> <span class="nf">net_price</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span>
               <span class="p">{</span> <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">price</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Quote</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> <span class="c1">// 析构函数动态绑定
</span><span class="c1"></span><span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">bookNo</span><span class="p">;</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="kt">double</span> <span class="n">price</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<blockquote>
<p><strong>注解</strong>
基类通常应该定义一个虚析构函数，即使没有什么工作要做。</p>
</blockquote>

<h3 id="成员函数和继承">成员函数和继承</h3>

<p>基类将那些期望派生类覆盖的函数定义为虚函数。任何非<strong>static</strong>的成员函数，除了构造函数，都可以为虚函数。关键字<strong>virtual</strong>仅仅出现在类里面声明处，在类外面函数定义处不需要出现。基类中声明为<strong>virtual</strong>的函数，在派生类中隐式为<strong>virtual</strong>。</p>

<p>没有被声明为<strong>virtual</strong>的成员函数在编译的时候确定。</p>

<h3 id="访问控制和继承">访问控制和继承</h3>

<p>派生类继承基类的成员，但是派生类的成员函数不能访问基类的私有成员。有时候基类允许派生类访问而又禁止其他用户使用，我们指定这类成员为<strong>protected</strong>。</p>

<h2 id="15-2-2-定义一个派生类">15.2.2 定义一个派生类</h2>

<p>派生类必须指定继承自哪个类，子类在类继承列表中指定基类。类继承列表由逗号分隔的基类名组成，每个基类名前面可能有<strong>public</strong>，<strong>protected</strong>，<strong>private</strong>其中一个。派生类必须声明每一个想要覆盖的成员函数。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Bulk_quote</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Quote</span> <span class="p">{</span> <span class="c1">// Bulk_quote继承自Quote
</span><span class="c1"></span>    <span class="n">Bulk_quote</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">Bulk_quote</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="p">,</span> <span class="kt">double</span><span class="p">);</span>
    <span class="kt">double</span> <span class="nf">net_price</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">min_qty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 打折需要的最小购买量
</span><span class="c1"></span>    <span class="kt">double</span> <span class="n">discount</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>   <span class="c1">// 折扣
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div>

<p>当继承为<strong>public</strong>时，基类的<strong>public</strong>成员成为派生类的接口。另外，我们能将<strong>public</strong>继承的派生类对象绑定到基类的指针或引用。</p>

<p>大多数类直接继承一个基类，这种继承称为单继承，继承超过一个基类称为多继承。</p>

<h3 id="派生类中的虚函数">派生类中的虚函数</h3>

<p>派生类经常但不总是覆盖它们继承的虚函数。如果派生类不覆盖虚函数，则像其它成员一样，继承基类的版本。在参数列表后面，<strong>const</strong>或引用限定符后面使用<strong>override</strong>表示覆盖虚函数。</p>

<h3 id="派生类对象和派生类到基类的转换">派生类对象和派生类到基类的转换</h3>

<p>派生类对象包含了多个部分：一个子对象包含派生类自己定义的非<strong>static</strong>成员，加上一个从基类继承而来的相应的子对象。</p>

<p>因为派生类对象包含对应于基类的子部分，我们可以使用子类就好像它是基类一样。特别地，我们可以将子类对象的基类部分绑定到基类的引用或指针。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Quote</span> <span class="n">item</span><span class="p">;</span>        <span class="c1">// 基类对象
</span><span class="c1"></span><span class="n">Bulk_quote</span> <span class="n">bulk</span><span class="p">;</span>   <span class="c1">// 子类对象
</span><span class="c1"></span><span class="n">Quote</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">item</span><span class="p">;</span>  <span class="c1">// 指向基类的指针
</span><span class="c1"></span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bulk</span><span class="p">;</span>         <span class="c1">// p指向bulk的Quote部分
</span><span class="c1"></span><span class="n">Quote</span> <span class="o">&amp;</span><span class="n">r</span> <span class="o">=</span> <span class="n">bulk</span><span class="p">;</span>   <span class="c1">// r绑定到bulk的Quote部分
</span></code></pre></div>

<p>这种转换称为派生类到基类的转换。和其它转换一样，编译器隐式应用派生类到基类的转换。</p>

<blockquote>
<p><strong>注解</strong>
派生类对象包含基类的子对象是继承如何工作的关键。</p>
</blockquote>

<h3 id="派生类构造函数">派生类构造函数</h3>

<p>尽管派生类对象包含从基类继承的成员，但是派生类不能直接初始化这些成员。派生类必须使用基类的构造函数初始化基类部分。</p>

<blockquote>
<p><strong>注解</strong>
每一个类控制它的成员如何初始化。基类成员先初始化，然后按声明的顺序初始化派生类的成员。</p>
</blockquote>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Bulk_quote</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">book</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">qty</span><span class="p">,</span> <span class="kt">double</span> <span class="n">disc</span><span class="p">)</span> <span class="o">:</span>
           <span class="n">Quote</span><span class="p">(</span><span class="n">book</span><span class="p">,</span> <span class="n">p</span><span class="p">),</span> <span class="n">min_qty</span><span class="p">(</span><span class="n">qty</span><span class="p">),</span> <span class="n">discount</span><span class="p">(</span><span class="n">disc</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="c1">// as before
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div>

<h3 id="在派生类中使用基类的成员">在派生类中使用基类的成员</h3>

<p>派生类可以使用基类的<strong>public</strong>和<strong>protected</strong>成员：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 如果购买了指定数量的商品，使用折扣价格
</span><span class="c1"></span><span class="kt">double</span> <span class="n">Bulk_quote</span><span class="o">::</span><span class="n">net_price</span><span class="p">(</span><span class="n">size_t</span> <span class="n">cnt</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">min_qty</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cnt</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">discount</span><span class="p">)</span> <span class="o">*</span> <span class="n">price</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">cnt</span> <span class="o">*</span> <span class="n">price</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>值得知道的是派生类的作用域嵌套在基类作用域里面。因此派生类使用基类和自己的成员没有差别。</p>

<blockquote>
<p><strong>关键概念</strong>: 尊重基类的接口
派生类构造函数可以对基类的<strong>public</strong>和<strong>protected</strong>成员赋值。尽管如此，通常不应该这么做。像基类的其他用户一样，派生类应该尊重基类的接口，使用基类的构造函数初始化基类部分成员。</p>
</blockquote>

<h3 id="继承和static成员">继承和static成员</h3>

<p>如果基类定义了<strong>static</strong>成员，那么在整个继承层次中只有一个这样的成员。不管有多少个派生类，每一个<strong>static</strong>成员只有一个实例。<strong>static</strong>成员遵守正常的访问控制。如果成员是<strong>private</strong>，则不能访问。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">statmem</span><span class="p">();</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">Derived</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="n">Derived</span><span class="o">::</span><span class="n">f</span><span class="p">(</span><span class="k">const</span> <span class="n">Derived</span> <span class="o">&amp;</span><span class="n">derived_obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Base</span><span class="o">::</span><span class="n">statmem</span><span class="p">();</span>    <span class="c1">// ok: Base定义了statmem
</span><span class="c1"></span>    <span class="n">Derived</span><span class="o">::</span><span class="n">statmem</span><span class="p">();</span> <span class="c1">// ok: Derived继承类statmem
</span><span class="c1"></span>    <span class="c1">// ok: 派生类对象可以访问基类的static成员
</span><span class="c1"></span>    <span class="n">derived_obj</span><span class="p">.</span><span class="n">statmem</span><span class="p">();</span>
    <span class="n">statmem</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="派生类的声明">派生类的声明</h3>

<p>派生类的声明和其它类一样。声明包含类名字但不包括派生列表：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Bulk_quote</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Quote</span><span class="p">;</span> <span class="c1">// error: 派生列表不能出现在这
</span><span class="c1"></span><span class="k">class</span> <span class="nc">Bulk_quote</span><span class="p">;</span> <span class="c1">// ok: 声明派生类的正确方式
</span></code></pre></div>

<h3 id="作为基类使用的类">作为基类使用的类</h3>

<p>在使用类作为基类前，一个类必须定义，而不仅仅是声明：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Quote</span><span class="p">;</span>   <span class="c1">// 声明但是未定义
</span><span class="c1">// error: Quote必须定义
</span><span class="c1"></span><span class="k">class</span> <span class="nc">Bulk_quote</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Quote</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</code></pre></div>

<p>这个限制的原因很容易理解：每一个派生类包含从基类继承的成员。要使用这些成员，派生类必须知道它们是什么。这个规则暗示我们一个类不可能继承自己。一个基类本身也可以是派生类。</p>

<p>每一个类继承了其直接基类的所有成员。直接基类的成员包含了它的直接基类和继承链继承而来的成员。因此，最远的派生类包含了一个其直接基类的子对象和每一个间接基类的子对象。</p>

<h3 id="阻止继承">阻止继承</h3>

<p>在新标准下，我们可以在类名后面跟着<strong>final</strong>阻止类被继承：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">NoDerived</span> <span class="k">final</span> <span class="p">{</span> <span class="cm">/*  */</span> <span class="p">};</span> <span class="c1">// NoDerived不能作为基类
</span><span class="c1"></span><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span> <span class="cm">/*  */</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">Last</span> <span class="k">final</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="cm">/*  */</span> <span class="p">};</span> <span class="c1">// Last不能作为基类
</span><span class="c1"></span><span class="k">class</span> <span class="nc">Bad</span> <span class="o">:</span> <span class="n">NoDerived</span> <span class="p">{</span> <span class="cm">/*  */</span> <span class="p">};</span>   <span class="c1">// error: NoDerived is final
</span><span class="c1"></span><span class="k">class</span> <span class="nc">Bad2</span> <span class="o">:</span> <span class="n">Last</span> <span class="p">{</span> <span class="cm">/*  */</span> <span class="p">};</span>       <span class="c1">// error: Last is final
</span></code></pre></div>

<h2 id="15-2-3-转换和继承">15.2.3 转换和继承</h2>

<blockquote>
<p><strong>警告</strong>
理解基类和派生类之间的转换是理解C++面向对象编程如何工作的基础</p>
</blockquote>

<p>通常我们只能绑定指针或引用到相同类型的对象上或者需要一个可接受的转换。可以将基类的引用或指针绑定到一个派生类对象的事实暗示：当我们使用基类的指针或引用时，我们不知道指针或引用绑定的对象的实际类型。这个对象可以是基类对象或派生类对象。</p>

<blockquote>
<p><strong>注解</strong>
像内置指针一样，智能指针支持派生类到基类的转换。</p>
</blockquote>

<h3 id="静态类型和动态类型">静态类型和动态类型</h3>

<p>静态类型是变量声明的类型或表达式产生的类型，在编译期间就已经知道了。动态类型是变量或表达式表示的内存中对象的类型，直到运行时才知道。不是指针或引用的表达式的动态类型总是和静态类型一样。</p>

<blockquote>
<p><strong>注解</strong>
理解基类的指针或引用的静态类型与动态类型可能不一样很重要。</p>
</blockquote>

<h3 id="没有基类到派生类的隐式转换">没有基类到派生类的隐式转换</h3>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Quote</span> <span class="n">base</span><span class="p">;</span>
<span class="n">Bulk_quote</span><span class="o">*</span> <span class="n">bulkP</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">base</span><span class="p">;</span>  <span class="c1">// error: can&#39;t convert base to derived
</span><span class="c1"></span><span class="n">Bulk_quote</span><span class="o">&amp;</span> <span class="n">bulkRef</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span> <span class="c1">// error: can&#39;t convert base to derived
</span></code></pre></div>

<p>令人惊讶地是，即使基类指针或引用绑定的是派生类对象，我们也不能将基类转换到派生类：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Bulk_quote</span> <span class="n">bulk</span><span class="p">;</span>
<span class="n">Quote</span> <span class="o">*</span><span class="n">itemP</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bulk</span><span class="p">;</span>        <span class="c1">// ok: dynamic type is Bulk_quote
</span><span class="c1"></span><span class="n">Bulk_quote</span> <span class="o">*</span><span class="n">bulkP</span> <span class="o">=</span> <span class="n">itemP</span><span class="p">;</span>   <span class="c1">// error: can&#39;t convert base to derived
</span></code></pre></div>

<p>编译器在编译期间无法知道这种转换在运行时是否安全。如果基类有一个或多个虚函数，我们可以使用<strong>dynamic_cast</strong>要求在运行时检查转换。或者如果我们知道这些从基类到派生类的转换是安全的，我们可以使用<strong>static_cast</strong>替换编译器的检查。</p>

<h3 id="也没有对象间的转换">也没有对象间的转换</h3>

<p>派生类到基类的自动转换只发生在引用或指针类型的转换。派生类和基类之间没有这种转换。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Bulk_quote</span> <span class="n">bulk</span><span class="p">;</span>   <span class="c1">// object of derived type
</span><span class="c1"></span><span class="n">Quote</span> <span class="nf">item</span><span class="p">(</span><span class="n">bulk</span><span class="p">);</span>  <span class="c1">// uses the Quote::Quote(const Quote&amp;) constructor
</span><span class="c1"></span><span class="n">item</span> <span class="o">=</span> <span class="n">bulk</span><span class="p">;</span>       <span class="c1">// calls Quote::operator=(const Quote&amp;)
</span></code></pre></div>

<blockquote>
<p><strong>警告</strong>
当我们用一个派生类对象给一个基类对象初始化或赋值时，只有基类部分复制，移动或赋值了，派生类部分被忽略了。</p>

<p><strong>关键概念</strong>： 继承相关的类型转换
*  继承类到基类的转换只发生在指针或引用类型
*  没有基类到继承类的隐式转换
*  像其它成员一样，继承类到基类的转换可能因为访问控制的原因不能访问。</p>
</blockquote>

<h1 id="15-3-虚函数">15.3 虚函数</h1>

<p>因为运行之前我们不知道哪个函数会调用，虚函数必须总是定义了的。</p>

<h2 id="虚函数调用可能在运行时确定">虚函数调用可能在运行时确定</h2>

<p>动态绑定仅仅发生在通过指针或引用调用虚函数。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">base</span> <span class="o">=</span> <span class="n">derived</span><span class="p">;</span>         <span class="c1">// 从derived拷贝Quote部分到base 
</span><span class="c1"></span><span class="n">base</span><span class="p">.</span><span class="n">net_price</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>     <span class="c1">// 调用Quote::net_price
</span></code></pre></div>

<p>当我们在一个表达式中用一个非引用且非指针的普通类型调用虚函数时，绑定发生在编译期间。</p>

<blockquote>
<p><strong>关键概念</strong>： C++中的多态
指针和引用的动态类型和静态类型可以不同是C++支持多态的基石。</p>

<p><strong>注解</strong>
运行期间确定虚函数仅当通过指针或引用的调用。只有这些情况下，对象的动态类型才可能和静态类型不同。</p>
</blockquote>

<h2 id="派生类的虚函数">派生类的虚函数</h2>

<p>当派生类覆盖了一个虚函数时，声明时可以重复<strong>virtual</strong>关键字，但是没有要求这样做。一旦一个函数被声明为<strong>virtual</strong>，这个函数在所有继承类中都是<strong>virtual</strong>。</p>

<p>派生类中的虚函数必须和基类中虚函数参数一样。除了返回类型为和继承相关的指针或引用之外，派生类虚函数的返回类型也必须和基类一样。就是如果D继承自B，那么基类的虚函数可以返回B*，而派生类的虚函数可以返回D*。然而这种返回类型需要派生类到基类的转换可访问。</p>

<blockquote>
<p><strong>注解</strong>
基类中的虚函数在继承类中隐式为<strong>virtual</strong>。当派生类覆盖一个虚函数，参数必须和基类一样。</p>
</blockquote>

<h2 id="final和override限定符">final和override限定符</h2>

<p>继承类定义一个和基类虚函数同名但是参数不同的函数是合法的。编译器认为这样的函数独立于基类的虚函数。</p>

<p>新标准下我们可以在继承类中指定虚函数为<strong>override</strong>。编译器会拒绝程序如果函数标注为<strong>override</strong>却没有覆盖一个已存在的虚函数。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">B</span> <span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">f1</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">f2</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">f3</span><span class="p">();</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nc">D1</span> <span class="o">:</span> <span class="n">B</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="nf">f1</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span> <span class="c1">// ok: f1 matches f1 in the base
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span> <span class="c1">// error: B has no f2(int) function
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">f3</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>    <span class="c1">// error: f3 not virtual
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">f4</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>    <span class="c1">// error: B doesn&#39;t have a function named f4
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div>

<p>我们也可以将一个函数指定为<strong>final</strong>。任何试图覆盖一个被定义为<strong>final</strong>的函数都被视为错误：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">D2</span> <span class="o">:</span> <span class="n">B</span> <span class="p">{</span>
    <span class="c1">// inherits f2() and f3() from B and overrides f1(int)
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">f1</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">const</span> <span class="k">final</span><span class="p">;</span> <span class="c1">// 后续子类不能覆盖f1(int)
</span><span class="c1"></span><span class="p">};</span>
<span class="k">struct</span> <span class="nc">D3</span> <span class="o">:</span> <span class="n">D2</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="nf">f2</span><span class="p">();</span> <span class="c1">// ok: overrides f2 inherited from the indirect base, B
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">f1</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// error: D2 declared f2 as final
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div>

<p><strong>final</strong>和<strong>override</strong>限定符出现在参数列表（包含const或引用修饰符）和尾返回之后。</p>

<h2 id="虚函数和默认实参">虚函数和默认实参</h2>

<p>如果一个函数调用使用默认实参，被使用的值是函数定义的静态类型的值。</p>

<blockquote>
<p><strong>最佳实践</strong>
包含默认实参的虚函数应该在基类和派生类中使用相同的默认实参。</p>
</blockquote>

<h2 id="避开虚机制">避开虚机制</h2>

<p>我们可以使用<strong>::</strong>操作符强制调用指定版本的虚函数。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 调用基类版本，不管baseP的动态类型
</span><span class="c1"></span><span class="kt">double</span> <span class="n">undiscounted</span> <span class="o">=</span> <span class="n">baseP</span><span class="o">-&gt;</span><span class="n">Quote</span><span class="o">::</span><span class="n">net_price</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
</code></pre></div>

<blockquote>
<p><strong>注解</strong>
通常，只有成员函数或友元函数里面的代码应该使用作用域操作符来避开虚机制。</p>
</blockquote>

<p>为什么想要避开虚机制？最常见的理由是一个派生类的虚函数调用基类的版本。这种情况下，基类版本做了继承层次所有类型的共同工作。派生类定义的版本只需做自己的额外工作。</p>

<blockquote>
<p><strong>警告</strong>
如果继承类虚函数想要调用基类版本的虚函数，却忽略了作用域操作符，将会导致无限递归。</p>
</blockquote>

<h1 id="15-4-虚基类">15.4 虚基类</h1>

<h2 id="纯虚函数">纯虚函数</h2>

<p>和普通的虚函数不一样的是，纯虚函数没有必要定义。虚函数写上<strong>= 0</strong>替代函数体成为纯虚函数。<strong>= 0</strong>只出现在类里面函数声明处。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// class to hold the discount rate and quantity
</span><span class="c1">// derived classes will implement pricing strategies using these data
</span><span class="c1"></span><span class="k">class</span> <span class="nc">Disc_quote</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Quote</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Disc_quote</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">Disc_quote</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">book</span><span class="p">,</span> <span class="kt">double</span> <span class="n">price</span><span class="p">,</span>
              <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">qty</span><span class="p">,</span> <span class="kt">double</span> <span class="n">disc</span><span class="p">)</span><span class="o">:</span>
                 <span class="n">Quote</span><span class="p">(</span><span class="n">book</span><span class="p">,</span> <span class="n">price</span><span class="p">),</span>
                 <span class="n">quantity</span><span class="p">(</span><span class="n">qty</span><span class="p">),</span> <span class="n">discount</span><span class="p">(</span><span class="n">disc</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">double</span> <span class="nf">net_price</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">quantity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//  purchase size for the discount to apply
</span><span class="c1"></span>    <span class="kt">double</span> <span class="n">discount</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>    <span class="c1">//  fractional discount to apply
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div>

<p>虽然我们不能直接定义Disc_quote对象，但是Disc_quote的派生类会使用Disc_quote的构造函数构造Disc_quote部分。</p>

<p>值得注意的是我们可以提供纯虚函数的定义，但是必须定义在类外面。</p>

<h2 id="有纯虚函数的类为虚基类">有纯虚函数的类为虚基类</h2>

<p>包含纯虚函数的类（或继承而没有覆盖）是虚基类。虚基类为后续的子类定义了可覆盖的接口。不能直接创建虚基类的对象。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// Disc_quote定义了Bulk_quote将要覆盖的纯虚函数
</span><span class="c1"></span><span class="n">Disc_quote</span> <span class="n">discounted</span><span class="p">;</span> <span class="c1">// error: can&#39;t define a Disc_quote object
</span><span class="c1"></span><span class="n">Bulk_quote</span> <span class="n">bulk</span><span class="p">;</span>       <span class="c1">// ok: Bulk_quote has no pure virtual functions
</span></code></pre></div>

<p>继承自虚基类的类必须覆盖纯虚函数，否则这个类也是虚基类。</p>

<h2 id="派生类构造函数只初始化其直接基类">派生类构造函数只初始化其直接基类</h2>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// the discount kicks in when a specified number of copies of the same book are sold
</span><span class="c1">// the discount is expressed as a fraction to use to reduce the normal price
</span><span class="c1"></span><span class="k">class</span> <span class="nc">Bulk_quote</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Disc_quote</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Bulk_quote</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">Bulk_quote</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">book</span><span class="p">,</span> <span class="kt">double</span> <span class="n">price</span><span class="p">,</span>
              <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">qty</span><span class="p">,</span> <span class="kt">double</span> <span class="n">disc</span><span class="p">)</span><span class="o">:</span>
          <span class="n">Disc_quote</span><span class="p">(</span><span class="n">book</span><span class="p">,</span> <span class="n">price</span><span class="p">,</span> <span class="n">qty</span><span class="p">,</span> <span class="n">disc</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="c1">// overrides the base version to implement the bulk purchase discount policy
</span><span class="c1"></span>    <span class="kt">double</span> <span class="nf">net_price</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>每一个类控制自己类对象的初始化。</p>

<blockquote>
<p><strong>关键概念：重构</strong>
添加Disc_quote到Quote继承层次是重构的一个例子。重构包含重新设计类层次，从一个类移动操作或数据到另一个类。重构在面向对象程序里面很常见。
值得注意的是尽管我们改变了继承层次，使用Bulk_quote或Quote的代码不需要改变。</p>
</blockquote>

<h1 id="15-5-访问控制和继承">15.5 访问控制和继承</h1>

<p>就像每一个类控制自己成员的初始化，每一个类也控制其成员对派生类是否可访问。</p>

<h2 id="protected成员">protected成员</h2>

<p><strong>protected</strong>限定符可以被认为是<strong>private</strong>和<strong>public</strong>的混合：</p>

<ul>
<li>像<strong>private</strong>，<strong>protected</strong>成员对类用户是不可访问的。</li>
<li>像<strong>public</strong>，<strong>protected</strong>成员对派生类的成员和友元是可访问的。</li>
</ul>

<p>另外，<strong>protected</strong>有一个重要性质：
*   派生类成员或友元只能通过派生类对象访问基类的<strong>protected</strong>成员。派生类没有权限访问基类<strong>protected</strong>成员。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">prot_mem</span><span class="p">;</span>     <span class="c1">// protected member
</span><span class="c1"></span><span class="p">};</span>
<span class="k">class</span> <span class="nc">Sneaky</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span>  <span class="p">{</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="nf">clobber</span><span class="p">(</span><span class="n">Sneaky</span><span class="o">&amp;</span><span class="p">);</span>  <span class="c1">// can access Sneaky::prot_mem
</span><span class="c1"></span>    <span class="k">friend</span> <span class="kt">void</span> <span class="nf">clobber</span><span class="p">(</span><span class="n">Base</span><span class="o">&amp;</span><span class="p">);</span>    <span class="c1">// can&#39;t access Base::prot_mem
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>                          <span class="c1">// j is private by default
</span><span class="c1"></span><span class="p">};</span>
<span class="kt">void</span> <span class="nf">clobber</span><span class="p">(</span><span class="n">Sneaky</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="n">s</span><span class="p">.</span><span class="n">j</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">prot_mem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// ok
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">clobber</span><span class="p">(</span><span class="n">Base</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">b</span><span class="p">.</span><span class="n">prot_mem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// error
</span></code></pre></div>

<h2 id="public-private和protected继承">public，private和protected继承</h2>

<p>继承类成员的访问由基类中该成员访问控制符和派生列表访问控制符共同控制。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">pub_mem</span><span class="p">();</span>   <span class="c1">// public member
</span><span class="c1"></span><span class="k">protected</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">prot_mem</span><span class="p">;</span>     <span class="c1">// protected member
</span><span class="c1"></span><span class="k">private</span><span class="o">:</span>
    <span class="kt">char</span> <span class="n">priv_mem</span><span class="p">;</span>    <span class="c1">// private member
</span><span class="c1"></span><span class="p">};</span>
<span class="k">struct</span> <span class="nc">Pub_Derv</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
    <span class="c1">// ok: derived classes can access protected members
</span><span class="c1"></span>    <span class="kt">int</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">prot_mem</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// error: private members are inaccessible to derived classes
</span><span class="c1"></span>    <span class="kt">char</span> <span class="nf">g</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">priv_mem</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nc">Priv_Derv</span> <span class="o">:</span> <span class="k">private</span> <span class="n">Base</span> <span class="p">{</span>
    <span class="c1">// private derivation doesn&#39;t affect access in the derived class
</span><span class="c1"></span>    <span class="kt">int</span> <span class="nf">f1</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">prot_mem</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<p>派生类的访问控制符对派生类访问其直接基类的成员没有影响。基类成员的访问只由基类的访问控制符控制。派生类的访问控制符是用来控制派生类使用者及子类对其成员的使用。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Pub_Derv</span> <span class="n">d1</span><span class="p">;</span>   <span class="c1">//  members inherited from Base are public
</span><span class="c1"></span><span class="n">Priv_Derv</span> <span class="n">d2</span><span class="p">;</span>  <span class="c1">//  members inherited from Base are private
</span><span class="c1"></span><span class="n">d1</span><span class="p">.</span><span class="n">pub_mem</span><span class="p">();</span>  <span class="c1">//  ok: pub_mem is public in the derived class
</span><span class="c1"></span><span class="n">d2</span><span class="p">.</span><span class="n">pub_mem</span><span class="p">();</span>  <span class="c1">//  error: pub_mem is private in the derived class
</span><span class="c1"></span>
<span class="k">struct</span> <span class="nc">Derived_from_Public</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Pub_Derv</span> <span class="p">{</span>
    <span class="c1">// ok: Base::prot_mem remains protected in Pub_Derv
</span><span class="c1"></span>    <span class="kt">int</span> <span class="nf">use_base</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">prot_mem</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nc">Derived_from_Private</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Priv_Derv</span> <span class="p">{</span>
    <span class="c1">// error: Base::prot_mem is private in Priv_Derv
</span><span class="c1"></span>    <span class="kt">int</span> <span class="nf">use_base</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">prot_mem</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h2 id="派生类到基类转换的可访问性">派生类到基类转换的可访问性</h2>

<p>假设D继承B：
*   用户代码可以使用派生类到基类的转换当D公开继承B，私有继承或保护继承都不行。
*   D的成员函数和友元可以使用派生类到基类的转换而不管是如何继承的。派生类到直接基类的转换对于派生类的成员和友元总是可以访问的。
*   从D派生的成员函数和友元能使用派生类到基类的转换当D公开或保护继承B，私有继承不行。</p>

<blockquote>
<p><strong>提示</strong>
在代码的任何地方，如果基类的<strong>public</strong>成员能够访问，则派生类到基类的转换可以访问，反过来不行。</p>
</blockquote>

<h2 id="友元和继承">友元和继承</h2>

<p>就像友元不能传递，友元也不能继承。基类的友元对派生类没有特殊访问权限，派生类的友元对基类也没有特殊访问权限。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
    <span class="c1">// added friend declaration; other members as before
</span><span class="c1"></span>    <span class="k">friend</span> <span class="k">class</span> <span class="nc">Pal</span><span class="p">;</span> <span class="c1">// Pal has no access to classes derived from Base
</span><span class="c1"></span><span class="p">};</span>
<span class="k">class</span> <span class="nc">Pal</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">f</span><span class="p">(</span><span class="n">Base</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">b</span><span class="p">.</span><span class="n">prot_mem</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// ok: Pal is a friend of
</span><span class="c1"></span><span class="n">Base</span>
    <span class="kt">int</span> <span class="nf">f2</span><span class="p">(</span><span class="n">Sneaky</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">j</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// error: Pal not friend of
</span><span class="c1"></span><span class="n">Sneaky</span>
    <span class="c1">// access to a base class is controlled by the base class, even inside a derived
</span><span class="c1"></span><span class="n">object</span>
    <span class="kt">int</span> <span class="n">f3</span><span class="p">(</span><span class="n">Sneaky</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">prot_mem</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// ok: Pal is a friend
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div>

<p>f3的合法看似惊人，但是它直接遵循每一个类控制其成员的访问这条规则。类Pal是基类Base的友元，因此Pal可以访问基类对象的成员。这种访问包含嵌套在派生类对象中基类部分。</p>

<p>当一个类将另一个类作为友元，只有这个类被赋予了友元关系，其基类或者子类都没有友元关系。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// D2 has no access to protected or private members in Base
</span><span class="c1"></span><span class="k">class</span> <span class="nc">D2</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Pal</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="kt">int</span> <span class="n">mem</span><span class="p">(</span><span class="n">Base</span> <span class="n">b</span><span class="p">)</span>
       <span class="p">{</span> <span class="k">return</span> <span class="n">b</span><span class="p">.</span><span class="n">prot_mem</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// error: friendship doesn&#39;t inherit
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div>

<blockquote>
<p><strong>注解</strong>
友元关系不能继承，每一个类控制自己成员的访问。</p>
</blockquote>

<h2 id="免除个别成员访问规则">免除个别成员访问规则</h2>

<p>有时候需要改变派生类中成员的访问级别，可以使用<strong>using</strong>声明。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">n</span><span class="p">;</span> <span class="p">}</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">n</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">private</span> <span class="n">Base</span> <span class="p">{</span>    <span class="c1">//  note: private inheritance
</span><span class="c1"></span><span class="k">public</span><span class="o">:</span>
    <span class="c1">// maintain access levels for members related to the size of the object
</span><span class="c1"></span>    <span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="n">size</span><span class="p">;</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="n">n</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>因为Derived使用<strong>private</strong>继承，则继承的成员默认为<strong>private</strong>成员。<strong>using</strong>声明调整了这些成员的可访问级别。</p>

<p><strong>using</strong>声明可以命名任何可访问的直接或间接基类的成员。访问由<strong>using</strong>声明的名字取决于<strong>using</strong>声明之前的访问限定符。</p>

<blockquote>
<p><strong>注解</strong>
派生类只为允许访问的名字提供<strong>using</strong>声明。</p>
</blockquote>

<h2 id="默认继承保护级别">默认继承保护级别</h2>

<p>默认地，<strong>class</strong>关键字定义的派生类使用<strong>private</strong>继承，<strong>struct</strong>定义的派生类使用<strong>public</strong>继承。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span> <span class="cm">/* ...   */</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nc">D1</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="cm">/* ...   */</span> <span class="p">};</span>   <span class="c1">// public inheritance by default
</span><span class="c1"></span><span class="k">class</span> <span class="nc">D2</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="cm">/* ...   */</span> <span class="p">};</span>    <span class="c1">// private inheritance by default
</span></code></pre></div>

<p>一个常见的误解是使用<strong>struct</strong>和<strong>class</strong>定义的类有深层次的不同。唯一的不同就是成员的默认访问级别和默认继承访问限定符，没有其它差别。</p>

<blockquote>
<p><strong>最佳实践</strong>
类私有继承必须显式指定<strong>private</strong>而不是依赖默认行为。显式指定可以清晰的说明<strong>private</strong>继承是有意的而不是疏忽。</p>
</blockquote>

<h1 id="15-6-继承下的类作用域">15.6 继承下的类作用域</h1>

<p>每一个类定义自己的作用域，作用域里面定义其成员。在继承下，派生类的作用域嵌套在基类作用域里面。如果一个名字在派生类作用域找不到，则搜索外围基类作用域。正是这种分层嵌套的类作用域允许派生类成员使用基类成员就好像这些成员是派生类的一部分一样。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Bulk_quote</span> <span class="n">bulk</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">bulk</span><span class="p">.</span><span class="n">isbn</span><span class="p">();</span>
</code></pre></div>

<p>isbn的名字查找如下：</p>

<ul>
<li>因为isbn被Bulk_quote对象调用，查找从类Bulk_quote开始，没有找到。</li>
<li>因为Bulk_quote继承自Disc_quote，接下来查找Disc_quote，还是没找到。</li>
<li>因为Disc_quote继承自Quote，接下来查找Quote，找到了。</li>
</ul>

<h2 id="名字查找发生在编译时">名字查找发生在编译时</h2>

<p>对象，引用或指针的静态类型决定了对象的哪个成员可见，甚至当静态类型和动态类型不一样时。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Disc_quote</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Quote</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">size_t</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">discount_policy</span><span class="p">()</span> <span class="k">const</span>
        <span class="p">{</span> <span class="k">return</span> <span class="p">{</span><span class="n">quantity</span><span class="p">,</span> <span class="n">discount</span><span class="p">};</span> <span class="p">}</span>
    <span class="c1">// other members as before
</span><span class="c1"></span><span class="p">};</span>

<span class="n">Bulk_quote</span> <span class="n">bulk</span><span class="p">;</span>
<span class="n">Bulk_quote</span> <span class="o">*</span><span class="n">bulkP</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bulk</span><span class="p">;</span> <span class="c1">//  static and dynamic types are the same
</span><span class="c1"></span><span class="n">Quote</span> <span class="o">*</span><span class="n">itemP</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bulk</span><span class="p">;</span>      <span class="c1">//  static and dynamic types differ
</span><span class="c1"></span><span class="n">bulkP</span><span class="o">-&gt;</span><span class="n">discount_policy</span><span class="p">();</span>  <span class="c1">//  ok: bulkP has type Bulk_quote*
</span><span class="c1"></span><span class="n">itemP</span><span class="o">-&gt;</span><span class="n">discount_policy</span><span class="p">();</span>  <span class="c1">//  error: itemP has type Quote*
</span></code></pre></div>

<blockquote>
<p><strong>关键概念</strong>：名字查找和继承
给定调用p-&gt;mem()或obj.mem()
*  首先确定p的静态类型。因为调用了一个成员，p一定指向一个类类型。
*  查找p静态类型相应的成员mem，如果没找到，则继续在继承层级中找。如果基类中都没找到，编译错误。
*  一旦mem找到了，执行正常的类型检查以确认调用是否合法。
*  假设调用合法，编译器再根据调用是否为虚函数来产生代码。</p>
</blockquote>

<h2 id="名字冲突和继承">名字冲突和继承</h2>

<p>和其它作用域一样，继承类可以重用其直接或间接基类中的一个名字。和往常一样，定义在内部作用域(派生类）的名字，隐藏了外部作用域（基类）名字的使用。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">Base</span> <span class="p">{</span>
    <span class="n">Base</span><span class="p">()</span><span class="o">:</span> <span class="n">mem</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">mem</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span>
    <span class="n">Derived</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span><span class="o">:</span> <span class="n">mem</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// initializes Derived::mem to i
</span><span class="c1"></span>                               <span class="c1">// Base::mem is default initialized
</span><span class="c1"></span>    <span class="kt">int</span> <span class="nf">get_mem</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">mem</span><span class="p">;</span> <span class="p">}</span>  <span class="c1">// returns Derived::mem
</span><span class="c1"></span><span class="k">protected</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">mem</span><span class="p">;</span>   <span class="c1">// hides mem in the base
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div>

<blockquote>
<p><strong>注解</strong>
与基类成员同名的派生类成员隐藏了基类成员的直接使用。</p>
</blockquote>

<h2 id="使用作用域操作符使用被隐藏成员">使用作用域操作符使用被隐藏成员</h2>

<p>我们可以使用作用域操作符来使用被隐藏的基类成员。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="nf">get_base_mem</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Base</span><span class="o">::</span><span class="n">mem</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// ...
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div>

<p>作用域操作符覆盖正常的名字查找，并指引编译器从指定的作用域开始查找。</p>

<blockquote>
<p><strong>最佳实践</strong>
除了覆盖继承的虚函数，基类通常不应该重用已经在基类中定义过的名字。</p>
</blockquote>

<h2 id="名字查找发生在类型检查之前">名字查找发生在类型检查之前</h2>

<p>定义在派生类的同名函数不重载基类的函数。基类成员被隐藏了，即使参数列表不一样。一旦名字被找到，编译器不再继续查找。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">Base</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="nf">memfcn</span><span class="p">();</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="nf">memfcn</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>   <span class="c1">// hides memfcn in the base
</span><span class="c1"></span><span class="p">};</span>
<span class="n">Derived</span> <span class="n">d</span><span class="p">;</span> <span class="n">Base</span> <span class="n">b</span><span class="p">;</span>
<span class="n">b</span><span class="p">.</span><span class="n">memfcn</span><span class="p">();</span>       <span class="c1">//  calls Base::memfcn
</span><span class="c1"></span><span class="n">d</span><span class="p">.</span><span class="n">memfcn</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>     <span class="c1">//  calls Derived::memfcn
</span><span class="c1"></span><span class="n">d</span><span class="p">.</span><span class="n">memfcn</span><span class="p">();</span>       <span class="c1">//  error: memfcn with no arguments is hidden
</span><span class="c1"></span><span class="n">d</span><span class="p">.</span><span class="n">Base</span><span class="o">::</span><span class="n">memfcn</span><span class="p">();</span> <span class="c1">//  ok: calls Base::memfcn
</span></code></pre></div>

<h2 id="虚函数和作用域">虚函数和作用域</h2>

<p>我们现在可以理解为什么派生类和基类中的虚函数必须有一样的参数列表。如果基类和派生类中虚函数参数不一样，那么没有办法通过基类的引用或指针调用派生类虚函数。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">fcn</span><span class="p">();</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">D1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// hides fcn in the base; this fcn is not virtual
</span><span class="c1"></span>    <span class="c1">// D1 inherits the definition of Base::fcn()
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">fcn</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>      <span class="c1">// parameter list differs from fcn in Base
</span><span class="c1"></span>    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">f2</span><span class="p">();</span> <span class="c1">// new virtual function that does not exist in Base
</span><span class="c1"></span><span class="p">};</span>
<span class="k">class</span> <span class="nc">D2</span> <span class="o">:</span> <span class="k">public</span> <span class="n">D1</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">fcn</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">// nonvirtual function hides D1::fcn(int)
</span><span class="c1"></span>    <span class="kt">int</span> <span class="nf">fcn</span><span class="p">();</span>    <span class="c1">// overrides virtual fcn from Base
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">f2</span><span class="p">();</span>    <span class="c1">// overrides virtual f2 from D1
</span><span class="c1"></span><span class="p">};</span>

<span class="n">Base</span> <span class="n">bobj</span><span class="p">;</span>  <span class="n">D1</span> <span class="n">d1obj</span><span class="p">;</span> <span class="n">D2</span> <span class="n">d2obj</span><span class="p">;</span>
<span class="n">Base</span> <span class="o">*</span><span class="n">bp1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bobj</span><span class="p">,</span> <span class="o">*</span><span class="n">bp2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d1obj</span><span class="p">,</span> <span class="o">*</span><span class="n">bp3</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d2obj</span><span class="p">;</span>
<span class="n">bp1</span><span class="o">-&gt;</span><span class="n">fcn</span><span class="p">();</span> <span class="c1">// virtual call, will call Base::fcn at run time
</span><span class="c1"></span><span class="n">bp2</span><span class="o">-&gt;</span><span class="n">fcn</span><span class="p">();</span> <span class="c1">// virtual call, will call Base::fcn at run time
</span><span class="c1"></span><span class="n">bp3</span><span class="o">-&gt;</span><span class="n">fcn</span><span class="p">();</span> <span class="c1">// virtual call, will call D2::fcn at run time
</span><span class="c1"></span><span class="n">D1</span> <span class="o">*</span><span class="n">d1p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d1obj</span><span class="p">;</span> <span class="n">D2</span> <span class="o">*</span><span class="n">d2p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d2obj</span><span class="p">;</span>
<span class="n">bp2</span><span class="o">-&gt;</span><span class="n">f2</span><span class="p">();</span> <span class="c1">// error: Base has no member named f2
</span><span class="c1"></span><span class="n">d1p</span><span class="o">-&gt;</span><span class="n">f2</span><span class="p">();</span> <span class="c1">// virtual call, will call D1::f2() at run time
</span><span class="c1"></span><span class="n">d2p</span><span class="o">-&gt;</span><span class="n">f2</span><span class="p">();</span> <span class="c1">// virtual call, will call D2::f2() at run time
</span><span class="c1"></span>
<span class="n">Base</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d2obj</span><span class="p">;</span> <span class="n">D1</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d2obj</span><span class="p">;</span> <span class="n">D2</span> <span class="o">*</span><span class="n">p3</span> <span class="o">=</span>  <span class="o">&amp;</span><span class="n">d2obj</span><span class="p">;</span>
<span class="n">p1</span><span class="o">-&gt;</span><span class="n">fcn</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>  <span class="c1">// error: Base has no version of fcn that takes an int
</span><span class="c1"></span><span class="n">p2</span><span class="o">-&gt;</span><span class="n">fcn</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>  <span class="c1">// statically bound, calls D1::fcn(int)
</span><span class="c1"></span><span class="n">p3</span><span class="o">-&gt;</span><span class="n">fcn</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>  <span class="c1">// statically bound, calls D2::fcn(int)
</span></code></pre></div>

<h2 id="覆盖重载函数">覆盖重载函数</h2>

<p>派生类可以覆盖0个或多个继承的重载函数。如果派生类想要使所有重载版本可用，则必须覆盖所有的函数或所有函数不覆盖。</p>

<p>有时候只想覆盖一些重载函数，派生类可以提供一个<strong>using</strong>声明给重载的成员。一个<strong>using</strong>声明指定一个名字，不带参数列表。因此，<strong>using</strong>声明将基类的重载函数都加到派生类的作用域。派生类只需定义那些想要覆盖的函数。</p>

<h1 id="15-7-构造函数和复制控制">15.7 构造函数和复制控制</h1>

<p>像其它类一样，继承层次中的类控制其对象的创建，复制，移动，赋值和销毁。如果一个类没有定义自己的复制控制操作，编译器将合成这些操作。同样这些合成的操作可能是<strong>deleted</strong>的函数。</p>

<h2 id="15-7-1-虚析构函数">15.7.1 虚析构函数</h2>

<p>继承给基类的复制控制主要的直接影响是基类通常应该定义一个虚析构函数。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Quote</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// virtual destructor needed if a base pointer pointing to a derived object is deleted
</span><span class="c1"></span>    <span class="k">virtual</span> <span class="o">~</span><span class="n">Quote</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> <span class="c1">// dynamic binding for the destructor
</span><span class="c1"></span><span class="p">};</span>

<span class="n">Quote</span> <span class="o">*</span><span class="n">itemP</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Quote</span><span class="p">;</span>   <span class="c1">//  same static and dynamic type
</span><span class="c1"></span><span class="k">delete</span> <span class="n">itemP</span><span class="p">;</span>               <span class="c1">//  destructor for Quote called
</span><span class="c1"></span><span class="n">itemP</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bulk_quote</span><span class="p">;</span>     <span class="c1">//  static and dynamic types differ
</span><span class="c1"></span><span class="k">delete</span> <span class="n">itemP</span><span class="p">;</span>               <span class="c1">//  destructor for Bulk_quote called
</span></code></pre></div>

<blockquote>
<p><strong>警告</strong>
如果基类析构函数不是<strong>virtual</strong>的， <strong>delete</strong>基类指针指向派生类对象是<strong>undefined</strong>。</p>
</blockquote>

<p>对于如果一个类需要析构函数，它也需要复制和赋值操作符这个规则，基类的析构函数是个重要例外。</p>

<h3 id="虚析构函数关闭了合成的move">虚析构函数关闭了合成的Move</h3>

<p>如果一个类定义了虚析构函数，即使是<strong>= default</strong>使用合成版本，则编译器不会合成<strong>move</strong>操作。</p>

<h2 id="15-7-2-合成复制控制和继承">15.7.2 合成复制控制和继承</h2>

<p>基类或派生类中合成的复制控制成员和任何其它合成的复制控制成员一样：逐个初始化，复制或销毁类成员。另外，这些成员使用基类的相应操作初始化，复制或销毁其对象的直接基类部分。</p>

<p>值得注意的是基类的成员是否是合成的或用户定义的并没有关系。重要的是相应的成员是可访问的且不是一个被删除的函数。</p>

<h3 id="基类和派生类中被删除的复制控制成员">基类和派生类中被删除的复制控制成员</h3>

<p>基类或者派生类中合成的构造函数或任何复制控制成员，跟其它类的原因一样，都可能被定义为被删除的。另外基类定义的方式会导致派生类的成员被定义为被删除的：</p>

<ul>
<li>如果基类的默认构造函数，复制构造函数，赋值操作符或析构函数是被删除的或不能访问，则派生类中相应的成员被定义为被删除的，因为编译器无法使用基类的成员来构造，赋值或销毁派生类对象的基类部分。</li>
<li>如果基类有一个不能访问的或被删除的析构函数，则派生类中合成的默认构造函数和复制构造函数被定义为被删除的，因为没有办法销毁派生类对象的基类部分。</li>
<li>编译器不会合成一个被删除的移动操作。如果基类的移动操作是被删除的或不能访问，则派生类中的移动操作是被删除的，因为基类部分不能被移动。如果基类的析构函数是被删除的或不能访问，则派生类的移动构造函数是被删除的。</li>
</ul>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">B</span><span class="p">();</span>
    <span class="n">B</span><span class="p">(</span><span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="c1">// other members, not including a move constructor
</span><span class="c1"></span><span class="p">};</span>
<span class="k">class</span> <span class="nc">D</span> <span class="o">:</span> <span class="k">public</span> <span class="n">B</span> <span class="p">{</span>
    <span class="c1">// no constructors
</span><span class="c1"></span><span class="p">};</span>
<span class="n">D</span> <span class="n">d</span><span class="p">;</span>     <span class="c1">// ok: D&#39;s synthesized default constructor uses B&#39;s default constructor
</span><span class="c1"></span><span class="n">D</span> <span class="nf">d2</span><span class="p">(</span><span class="n">d</span><span class="p">);</span> <span class="c1">// error: D&#39;s synthesized copy constructor is deleted
</span><span class="c1"></span><span class="n">D</span> <span class="nf">d3</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">d</span><span class="p">));</span> <span class="c1">// error: implicitly uses D&#39;s deleted copy constructor
</span></code></pre></div>

<h3 id="移动操作和继承">移动操作和继承</h3>

<p>我们已经看到，大多数基类定义了一个虚析构函数。因此基类通常没有合成的移动操作，同样派生类也没有合成的移动操作。由于基类缺少移动操作而限制了派生类合成移动操作，如果合理基类一般应该定义移动操作。如果显式定义了移动操作，基类一般也要显式定义复制操作。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Quote</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Quote</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>             <span class="c1">// memberwise default initialize
</span><span class="c1"></span>    <span class="n">Quote</span><span class="p">(</span><span class="k">const</span> <span class="n">Quote</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> <span class="c1">// memberwise copy
</span><span class="c1"></span>    <span class="n">Quote</span><span class="p">(</span><span class="n">Quote</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>      <span class="c1">// memberwise copy
</span><span class="c1"></span>    <span class="n">Quote</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Quote</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> <span class="c1">// copy assign
</span><span class="c1"></span>    <span class="n">Quote</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Quote</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>      <span class="c1">// move assign
</span><span class="c1"></span>    <span class="k">virtual</span> <span class="o">~</span><span class="n">Quote</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="c1">// other members as before
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div>

<h2 id="15-7-3-派生类复制控制成员">15.7.3 派生类复制控制成员</h2>

<p>初始化阶段，派生类的构造函数初始化派生类对象的基类部分和自己的成员。因此派生类的复制和移动构造函数必须复制和移动派生类对象的基类部分和自己的成员。类似地，派生类的赋值操作符必须赋值基类部分给派生类对象。</p>

<p>不像构造函数和赋值操作符，析构函数只对派生类自己的申请的资源负责。</p>

<blockquote>
<p><strong>警告</strong>
当派生类定义了复制和移动操作，这些操作负责整个派生类对象的复制和移动，包括基类成员。</p>
</blockquote>

<h3 id="定义派生类复制和移动构造函数">定义派生类复制和移动构造函数</h3>

<p>当我们为派生类定义一个复制或移动构造函数，我们通常使用相应的基类构造函数来初始化对象的基类部分：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span> <span class="cm">/* ...    */</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">class</span> <span class="nc">D</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// by default, the base class default constructor initializes the base part of an object
</span><span class="c1"></span>    <span class="c1">// to use the copy or move constructor, we must explicitly call that
</span><span class="c1"></span>    <span class="c1">// constructor in the constructor initializer list
</span><span class="c1"></span>    <span class="n">D</span><span class="p">(</span><span class="k">const</span> <span class="n">D</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">)</span><span class="o">:</span> <span class="n">Base</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>      <span class="c1">// copy the base members
</span><span class="c1"></span>                 <span class="cm">/* initializers for members of D */</span> <span class="p">{</span> <span class="cm">/* ...  */</span> <span class="p">}</span>
    <span class="n">D</span><span class="p">(</span><span class="n">D</span><span class="o">&amp;&amp;</span> <span class="n">d</span><span class="p">)</span><span class="o">:</span> <span class="n">Base</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="c1">// move the base members
</span><span class="c1"></span>                 <span class="cm">/* initializers for members of D */</span> <span class="p">{</span> <span class="cm">/* ...  */</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<blockquote>
<p><strong>警告</strong>
默认地，基类默认构造函数初始化派生类对象的基类部分。如果我们想要复制或移动基类部分，必须在派生类构造函数的初始化列表中显式使用基类的复制或移动构造函数。</p>
</blockquote>

<h3 id="派生类赋值操作符">派生类赋值操作符</h3>

<p>和复制或移动构造函数一样，派生类的赋值操作符必须显式赋值其基类部分：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// Base::operator=(const Base&amp;) is not invoked automatically
</span><span class="c1"></span><span class="n">D</span> <span class="o">&amp;</span><span class="n">D</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">D</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Base</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span> <span class="c1">// assigns the base part
</span><span class="c1"></span>    <span class="c1">// assign the members in the derived class, as usual,
</span><span class="c1"></span>    <span class="c1">// handling self-assignment and freeing existing resources as appropriate
</span><span class="c1"></span>    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>值得注意的是派生类构造函数和赋值操作符可以使用基类的相应操作，不管基类是否定义了这些操作还是使用合成的版本。</p>

<h3 id="派生类析构函数">派生类析构函数</h3>

<p>一个对象的数据成员在析构函数执行完毕之后被隐式销毁。类似地，对象的基类部分也是隐式销毁。因此和构造函数和赋值操作符不同的是，派生类析构函数只对销毁派生类申请的资源负责。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">D</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// Base::~Base invoked automatically
</span><span class="c1"></span>    <span class="o">~</span><span class="n">D</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* do what it takes to clean up derived members   */</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="在构造函数和析构函数调用虚函数">在构造函数和析构函数调用虚函数</h3>

<p>我们已经知道，派生类对象的基类部分先被构造。当基类构造函数在执行时，派生类部分没有初始化。同样，派生类对象以相反的顺序被销毁，因此当基类的析构函数运行时，派生类部分已经被销毁。因此当这些基类成员在执行时，对象是不完整的。</p>

<p>为了适应这种不完整性，编译器在构造和析构之间将对象的类型看成是变化的。当对象被构造时，将它的类型看成和构造函数一样的类型，虚函数的调用会绑定到和构造函数一样的类型。对于析构函数也一样。</p>

<blockquote>
<p><strong>注解</strong>
如果构造函数和析构函数调用一个虚函数，虚函数运行版本是相对于构造函数或析构函数自己类型的版本。</p>
</blockquote>

<h2 id="15-7-4-继承的构造函数">15.7.4 继承的构造函数</h2>

<p>新标准下，派生类可以重用基类定义的构造函数。和只能初始化直接基类的原因一样，一个类只能继承直接基类的构造函数，不能继承默认的复制和移动构造函数。使用<strong>using</strong>声明指定继承基类的构造函数。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Bulk_quote</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Disc_quote</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">using</span> <span class="n">Disc_quote</span><span class="o">::</span><span class="n">Disc_quote</span><span class="p">;</span> <span class="c1">// inherit Disc_quote&#39;s constructors
</span><span class="c1"></span>    <span class="kt">double</span> <span class="nf">net_price</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p><strong>using</strong>声明只是使一个名字在当前作用域可见。当应用到构造函数，一个<strong>using</strong>声明引起编译器生成代码。编译器生成对应于每一个基类构造函数的派生类构造函数。这些编译器生成的构造函数具有以下形式：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">derived</span><span class="p">(</span><span class="n">parms</span><span class="p">)</span> <span class="o">:</span> <span class="n">base</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div>

<p>在Bulk_quote类，继承的构造函数如下：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Bulk_quote</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">book</span><span class="p">,</span> <span class="kt">double</span> <span class="n">price</span><span class="p">,</span>
          <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">qty</span><span class="p">,</span> <span class="kt">double</span> <span class="n">disc</span><span class="p">)</span><span class="o">:</span>
      <span class="n">Disc_quote</span><span class="p">(</span><span class="n">book</span><span class="p">,</span> <span class="n">price</span><span class="p">,</span> <span class="n">qty</span><span class="p">,</span> <span class="n">disc</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div>

<h3 id="继承构造函数的特征">继承构造函数的特征</h3>

<p>不像对普通成员使用<strong>using</strong>声明，构造函数<strong>using</strong>声明不会改变继承构造函数的访问级别。而且，<strong>using</strong>声明不能指定<strong>explicit</strong>或<strong>constexpr</strong>。如果构造函数在基类中是<strong>explicit</strong>或<strong>constexpr</strong>，则继承构造函数有一样的属性。</p>

<p>如果基类构造函数有默认实参，这些参数不会被继承。相反，派生类得到多个继承构造函数，每一个有默认实参的参数被相继忽略。比如，如果基类有一个2个参数的构造函数，第2个参数有默认实参，则派生类获得2个构造函数：一个带2个参数（没有默认实参）和一个带单一参数对应于基类最左边，非默认的参数的构造函数。</p>

<p>如果基类有多个构造函数，则除了两个例外，派生类继承基类每一个构造函数。第一个例外是派生类继承一些构造函数并定义其它构造函数自己的版本。如果派生类定义了一个与基类构造函数参数一样的构造函数，那么这个构造函数不会被继承。第二个例外是默认，复制和移动构造函数不会被继承。一个继承构造函数不会被看作用户定义的构造函数。因此，一个只有继承构造函数的类会合成默认构造函数。</p>

<h1 id="15-8-容器和继承">15.8 容器和继承</h1>

<p>当我们使用一个容器来存储来自继承层次的对象，通常我们必须间接存储这些对象。我们不能把继承相关的类型对象直接放进容器，因为没有办法定义一个容器存放不同类型的元素。</p>

<p>vector不能存放Quote类型可能不明显。这种情况下，我们能把Bulk_quote对象放进容器，但是这些对象不再是Bulk_quote对象了：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="n">Quote</span><span class="o">&gt;</span> <span class="n">basket</span><span class="p">;</span>
<span class="n">basket</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Quote</span><span class="p">(</span><span class="s">&#34;0-201-82470-1&#34;</span><span class="p">,</span> <span class="mi">50</span><span class="p">));</span>
<span class="c1">// ok, but copies only the Quote part of the object into basket
</span><span class="c1"></span><span class="n">basket</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Bulk_quote</span><span class="p">(</span><span class="s">&#34;0-201-54848-8&#34;</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">.25</span><span class="p">));</span>
<span class="c1">// calls version defined by Quote, prints 750, i.e., 15 * $50
</span><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">basket</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">net_price</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></div>

<blockquote>
<p><strong>警告</strong>
因为派生类对象赋值给基类对象被切掉，容器和继承相关的类型不能很好的融合。</p>
</blockquote>

<h2 id="将-智能-指针而不是对象放进容器">将（智能）指针而不是对象放进容器</h2>

<p>当我们需要容器存放继承相关的对象，定义容器存放基类的指针。和往常一样，指针指向的对象的动态类型可能是基类类型或派生类类型：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Quote</span><span class="o">&gt;&gt;</span> <span class="n">basket</span><span class="p">;</span>
<span class="n">basket</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Quote</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&#34;0-201-82470-1&#34;</span><span class="p">,</span> <span class="mi">50</span><span class="p">));</span>
<span class="n">basket</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span>
    <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Bulk_quote</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&#34;0-201-54848-8&#34;</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">.25</span><span class="p">));</span>
<span class="c1">// calls the version defined by Quote; prints 562.5, i.e., 15 * $50 less the discount
</span><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">basket</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">net_price</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</code></pre></div>

<p>就像我们能够转换指向派生类对象的普通指针为指向基类的普通指针，我们也能转换指向派生类的智能指针为指向基类的智能指针。</p>

<h2 id="15-8-1-编写basket类">15.8.1 编写Basket类</h2>

<p>C++中的面向对象编程的一个讽刺是我们不能使用对象直接支持它。反而，我们必须使用指针和引用。由于指针强加给程序的复杂性，我们通常定义辅助的类来帮助管理复杂性。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Basket</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// Basket uses synthesized default constructor and copy-control members
</span><span class="c1"></span>    <span class="kt">void</span> <span class="n">add_item</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Quote</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">sale</span><span class="p">)</span>
        <span class="p">{</span> <span class="n">items</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">sale</span><span class="p">);</span> <span class="p">}</span>
    <span class="c1">// prints the total price for each book and the overall total for all items in the
</span><span class="c1"></span><span class="n">basket</span>
    <span class="kt">double</span> <span class="nf">total_receipt</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
    <span class="c1">// function to compare shared_ptrs needed by the multiset member
</span><span class="c1"></span>    <span class="k">static</span> <span class="kt">bool</span> <span class="n">compare</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Quote</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span>
                        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Quote</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
    <span class="p">{</span> <span class="k">return</span> <span class="n">lhs</span><span class="o">-&gt;</span><span class="n">isbn</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="o">-&gt;</span><span class="n">isbn</span><span class="p">();</span> <span class="p">}</span>
    <span class="c1">// multiset to hold multiple quotes, ordered by the compare member
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">multiset</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Quote</span><span class="o">&gt;</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">compare</span><span class="p">)</span><span class="o">*&gt;</span>
                  <span class="n">items</span><span class="p">{</span><span class="n">compare</span><span class="p">};</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="定义basket的成员">定义Basket的成员</h3>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">double</span> <span class="n">Basket</span><span class="o">::</span><span class="n">total_receipt</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>   <span class="c1">// holds the running total
</span><span class="c1"></span>    <span class="c1">// iter refers to the first element in a batch of elements with the same ISBN
</span><span class="c1"></span>    <span class="c1">// upper_bound returns an iterator to the element just past the end of that batch
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">items</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span>
              <span class="n">iter</span> <span class="o">!=</span> <span class="n">items</span><span class="p">.</span><span class="n">cend</span><span class="p">();</span>
              <span class="n">iter</span> <span class="o">=</span> <span class="n">items</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// we know there&#39;s at least one element with this key in the Basket
</span><span class="c1"></span>        <span class="c1">// print the line item for this book
</span><span class="c1"></span>        <span class="n">sum</span> <span class="o">+=</span> <span class="n">print_total</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="o">**</span><span class="n">iter</span><span class="p">,</span> <span class="n">items</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Total Sale: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// print the final overall
</span><span class="c1"></span><span class="n">total</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="隐藏指针">隐藏指针</h3>

<p>Basket的用户仍然需要处理动态分配的内存，因为add_item带一个shared_ptr参数。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Basket</span> <span class="n">bsk</span><span class="p">;</span>
<span class="n">bsk</span><span class="p">.</span><span class="n">add_item</span><span class="p">(</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Quote</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&#34;123&#34;</span><span class="p">,</span> <span class="mi">45</span><span class="p">));</span>
<span class="n">bsk</span><span class="p">.</span><span class="n">add_item</span><span class="p">(</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Bulk_quote</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&#34;345&#34;</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">.15</span><span class="p">));</span>
</code></pre></div>

<p>我们下一步将重定义add_item来接收Quote对象而不是shared_ptr。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">add_item</span><span class="p">(</span><span class="k">const</span> <span class="n">Quote</span><span class="o">&amp;</span> <span class="n">sale</span><span class="p">);</span>  <span class="c1">// copy the given object
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">add_item</span><span class="p">(</span><span class="n">Quote</span><span class="o">&amp;&amp;</span> <span class="n">sale</span><span class="p">);</span>       <span class="c1">// move the given object
</span></code></pre></div>

<h3 id="模拟虚复制">模拟虚复制</h3>

<p>我们将通过给Quote类一个虚成员分配自己的拷贝来解决这个问题。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Quote</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// virtual function to return a dynamically allocated copy of itself
</span><span class="c1"></span>    <span class="c1">// these members use reference qualifiers; see §13.6.3 (p. 546)
</span><span class="c1"></span>    <span class="k">virtual</span> <span class="n">Quote</span><span class="o">*</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="p">{</span><span class="k">return</span> <span class="k">new</span> <span class="nf">Quote</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);}</span>
    <span class="k">virtual</span> <span class="n">Quote</span><span class="o">*</span> <span class="nf">clone</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">{</span><span class="k">return</span> <span class="k">new</span> <span class="n">Quote</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">));}</span>
    <span class="c1">// other members as before
</span><span class="c1"></span><span class="p">};</span>
<span class="k">class</span> <span class="nc">Bulk_quote</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Quote</span> <span class="p">{</span>
    <span class="n">Bulk_quote</span><span class="o">*</span> <span class="nf">clone</span><span class="p">()</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="p">{</span><span class="k">return</span> <span class="k">new</span> <span class="n">Bulk_quote</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);}</span>
    <span class="n">Bulk_quote</span><span class="o">*</span> <span class="nf">clone</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Bulk_quote</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">));}</span>
    <span class="c1">// other members as before
</span><span class="c1"></span><span class="p">};</span>

<span class="k">class</span> <span class="nc">Basket</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">add_item</span><span class="p">(</span><span class="k">const</span> <span class="n">Quote</span><span class="o">&amp;</span> <span class="n">sale</span><span class="p">)</span> <span class="c1">// copy the given object
</span><span class="c1"></span>      <span class="p">{</span> <span class="n">items</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Quote</span><span class="o">&gt;</span><span class="p">(</span><span class="n">sale</span><span class="p">.</span><span class="n">clone</span><span class="p">()));</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">add_item</span><span class="p">(</span><span class="n">Quote</span><span class="o">&amp;&amp;</span> <span class="n">sale</span><span class="p">)</span>      <span class="c1">// move the given object
</span><span class="c1"></span>      <span class="p">{</span> <span class="n">items</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span>
          <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Quote</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">sale</span><span class="p">).</span><span class="n">clone</span><span class="p">()));</span> <span class="p">}</span>
    <span class="c1">// other members as before
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div>

<h1 id="15-9-文本查询重温">15.9 文本查询重温</h1>
]]></content>
		</item>
		
		<item>
			<title>第14章 重载操作和转换</title>
			<link>https://gitop.cc/posts/cpp-primer-14/</link>
			<pubDate>Sun, 20 Sep 2015 10:47:02 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/cpp-primer-14/</guid>
			<description>基本概念 重载操作符是具有特殊名字的函数：关键字operator后面跟着需要被定义的操作符的符号。像其它函数一样，重载操作符有返回值，参数列表</description>
			<content type="html"><![CDATA[

<h1 id="基本概念">基本概念</h1>

<p>重载操作符是具有特殊名字的函数：关键字<strong>operator</strong>后面跟着需要被定义的操作符的符号。像其它函数一样，重载操作符有返回值，参数列表和函数体。</p>

<p>重载操作符的参数和操作符的操作数一样多。除了函数调用操作符(<strong>operator()</strong>)，重载操作符没有默认实参。</p>

<blockquote>
<p><strong>注意</strong>
当重载操作符是成员函数时，<strong>this</strong>绑定到左操作数。因此，成员操作符函数少一个操作数。</p>
</blockquote>

<p>操作符函数必须为类的成员或至少有一个类类型参数：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// error: cannot redefine the built-in operator for ints
</span><span class="c1"></span><span class="kt">int</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</code></pre></div>

<p>我们可以重载大多数操作符，而且只能重载已经存在的操作符：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp">              <span class="c1">//可以重载的操作符
</span><span class="c1"></span><span class="o">+</span>       <span class="o">-</span>       <span class="o">*</span>       <span class="o">/</span>       <span class="o">%</span>       <span class="o">^</span>
<span class="o">&amp;</span>       <span class="o">|</span>       <span class="o">~</span>       <span class="o">!</span>       <span class="p">,</span>       <span class="o">=</span>
<span class="o">&lt;</span>       <span class="o">&gt;</span>       <span class="o">&lt;=</span>      <span class="o">&gt;=</span>      <span class="o">++</span>      <span class="o">--</span>
<span class="o">&lt;&lt;</span>      <span class="o">&gt;&gt;</span>      <span class="o">==</span>      <span class="o">!=</span>      <span class="o">&amp;&amp;</span>      <span class="o">||</span>
<span class="o">+=</span>      <span class="o">-=</span>      <span class="o">/=</span>      <span class="o">%=</span>      <span class="o">^=</span>      <span class="o">&amp;=</span>
<span class="o">|=</span>      <span class="o">*=</span>      <span class="o">&lt;&lt;=</span>     <span class="o">&gt;&gt;=</span>     <span class="p">[]</span>      <span class="p">()</span>
<span class="o">-&gt;</span>      <span class="o">-&gt;*</span>     <span class="k">new</span>     <span class="k">new</span><span class="p">[]</span>   <span class="k">delete</span>  <span class="k">delete</span><span class="p">[]</span>
              <span class="c1">//不能重载的操作符
</span><span class="c1"></span>        <span class="o">::</span>      <span class="p">.</span><span class="o">*</span>      <span class="p">.</span>       <span class="o">?:</span>
</code></pre></div>

<p>重载操作符和相应的内置操作符有相同的优先级和结合性。</p>

<h3 id="直接调用重载操作符函数">直接调用重载操作符函数</h3>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">data1</span> <span class="o">+</span> <span class="n">data2</span><span class="p">;</span>           <span class="c1">// 表达式调用
</span><span class="c1"></span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">);</span> <span class="c1">// 等价的函数调用
</span><span class="c1"></span><span class="n">data1</span> <span class="o">+=</span> <span class="n">data2</span><span class="p">;</span>          <span class="c1">// 表达式调用
</span><span class="c1"></span><span class="n">data1</span><span class="p">.</span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">data2</span><span class="p">);</span> <span class="c1">// 等价的成员函数调用
</span></code></pre></div>

<h3 id="有些操作符不应该重载">有些操作符不应该重载</h3>

<p>重载操作符不保留求值顺序或短路求值。</p>

<blockquote>
<p><strong>最佳实践</strong>
通常，逗号（,），取地址（&amp;），逻辑与（&amp;&amp;）和逻辑或（||）不应该重载。</p>
</blockquote>

<h3 id="使用和内置操作符意思一致的定义">使用和内置操作符意思一致的定义</h3>

<ul>
<li>如果类使用IO，定义与内置类型IO操作一致的<strong>shift</strong>操作符</li>
<li>如果类有测试相等的操作，定义<strong>operator==</strong>。如果类有<strong>operator==</strong>，通常也应该定义<strong>operator!=</strong>。</li>
<li>如果类有单一的自然顺序的操作，定义<strong>operator&lt;</strong>。如果类有<strong>operator&lt;</strong>，通常也应该定义其它关系操作符。</li>
<li>重载操作符的返回类型应该和内置操作符的返回类型兼容：逻辑操作符和关系操作符应该返回<strong>bool</strong>，算术操作符应该返回类的值，赋值操作符应该返回左操作数的引用。</li>
</ul>

<blockquote>
<p><strong>注意</strong>：明智地使用操作符重载
当内置操作符和类的操作有逻辑映射的时候，操作符重载最有用。</p>
</blockquote>

<h3 id="选择成员或非成员实现">选择成员或非成员实现</h3>

<p>以下指导方针能够帮助我们决定是否将一个操作符定义为成员函数或普通的非成员函数：</p>

<ul>
<li>赋值操作符（=），下标操作符（[]），调用操作符（()），成员访问操作符（-&gt;）必须定义为成员。</li>
<li>复合赋值操作符通常应该定义为成员，但是没有要求一定这样。</li>
<li>改变对象状态或与类对象联系紧密的操作符，通常应该定义为成员。比如++，&ndash;和解引用（*）。</li>
<li>那些可能转换操作数的对称的操作符，比如算术操作符，关系操作符，位操作符，通常应该定义为非成员。</li>
</ul>

<h1 id="输入输出操作符">输入输出操作符</h1>

<h3 id="重载输出操作符">重载输出操作符 &lt;&lt;</h3>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="p">.</span><span class="n">isbn</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="p">.</span><span class="n">units_sold</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span>
        <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="p">.</span><span class="n">revenue</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="p">.</span><span class="n">avg_price</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<blockquote>
<p><strong>最佳实践</strong>
通常输出操作符应该最小格式化输出对象的内容，不应该打印换行。</p>
</blockquote>

<h3 id="io操作符必须是非成员函数">IO操作符必须是非成员函数</h3>

<p>输入输出操作符遵循库<strong>iostream</strong>的惯例必须为普通的非成员函数。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Sales_data</span> <span class="n">data</span><span class="p">;</span>
<span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="n">cout</span><span class="p">;</span> <span class="c1">// 如果operator&lt;&lt;是Sales_data的一个成员
</span></code></pre></div>

<p>如果这些操作符是任意一个类的成员，那它们应该是<strong>istream</strong>或<strong>ostream</strong>的成员，但是我们无法给标准库添加成员。输入输出操作符通常需要读或写非公开的数据成员。因此，IO操作符通常必须声明为<strong>friend</strong>。</p>

<h3 id="重载输入操作符">重载输入操作符 &gt;&gt;</h3>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">istream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">istream</span> <span class="o">&amp;</span><span class="n">is</span><span class="p">,</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">price</span><span class="p">;</span>
    <span class="n">is</span> <span class="o">&gt;&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">bookNo</span> <span class="o">&gt;&gt;</span> <span class="n">item</span><span class="p">.</span><span class="n">units_sold</span> <span class="o">&gt;&gt;</span> <span class="n">price</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is</span><span class="p">)</span>        <span class="c1">// 检查输入是否成功
</span><span class="c1"></span>        <span class="n">item</span><span class="p">.</span><span class="n">revenue</span> <span class="o">=</span> <span class="n">item</span><span class="p">.</span><span class="n">units_sold</span> <span class="o">*</span> <span class="n">price</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">item</span> <span class="o">=</span> <span class="n">Sales_data</span><span class="p">();</span> <span class="c1">// 输入失败：给对象一个默认值
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">is</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<blockquote>
<p><strong>注意</strong>
输入操作符必须处理输入失败的可能性。输出操作符通常没有这个困扰。</p>
</blockquote>

<p>我们选择在读取了所有数据之后，使用数据之前来检查流状态。</p>

<blockquote>
<p><strong>最佳实践</strong>
输入操作符应该决定做什么错误恢复。当错误发生时，使对象处于一个合法状态尤其重要，因为对象可能被部分修改。</p>
</blockquote>

<p>通常输入操作符应该只设置<strong>failbit</strong>。<strong>eofbit</strong>和<strong>badbit</strong>最好是留给IO库去指示。</p>

<h1 id="算术和关系操作符">算术和关系操作符</h1>

<p>通常我们将算术和关系操作符定义为非成员函数，以允许转换左右操作符中的一个。这些操作符不需要修改操作数的状态，所以参数通常为**const
**引用。定义了算术操作符的类通常也要定义相应的复合赋值操作符。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Sales_data</span>
<span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Sales_data</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">;</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">rhs</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<blockquote>
<p><strong>提示</strong>
定义了算术操作符和相应的复合赋值操作符的类，应该使用复合赋值操作符来实现算术操作符。</p>
</blockquote>

<h3 id="相等操作符">相等操作符</h3>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">isbn</span><span class="p">()</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">isbn</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
        <span class="n">lhs</span><span class="p">.</span><span class="n">units_sold</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">units_sold</span> <span class="o">&amp;&amp;</span>
        <span class="n">lhs</span><span class="p">.</span><span class="n">revenue</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">revenue</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">lhs</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>相等操作符的设计原理：
*   如果一个类有一个确定2个对象是否相等的操作，那么该类应该定义<strong>operator==</strong>，而不是命名函数，而且可以容易使用标准库容器和算法。
*   如果一个类定义了<strong>operator==</strong>，这个操作符通常应该确定给定的对象是否包含相同的数据。
*   通常地，相等操作符应该是可传递的， 比如如果a == b, b == c， 则a == c。
*   如果一个类定义了<strong>operator==</strong>，那也应该定义<strong>operator!=</strong>，反之也一样。
*   相等或不等操作符应该将实际工作委托给另一个。</p>

<blockquote>
<p><strong>最佳实践</strong>
相等性具有逻辑意义的类通常应该定义<strong>operator==</strong>，定义了<strong>operator==</strong>的类使得用户容易使用标准库算法。</p>
</blockquote>

<h3 id="关系操作符">关系操作符</h3>

<p>定义了相等操作符的类通常（不总是）也会定义关系操作符。特别地，关系容器和有些算法使用<strong>&lt;</strong>操作符，定义<strong>operator&lt;</strong>会很有用。</p>

<p>通常关系操作符应该：
*   定义一个顺序关系和关联容器的key的需求一致。
*   定义一个关系和<strong>==</strong>一致，如果类2种操作符都定义了。特别地，如果2个对象<strong>!=</strong>，则其中一个应该<strong>&lt;</strong>另一个。</p>

<blockquote>
<p><strong>最佳实践</strong>
如果只有一个逻辑定义<strong>&lt;</strong>存在，类通常应该定义<strong>&lt;</strong>操作符。然而，如果类也有<strong>==</strong>，只有当<strong>&lt;</strong>和<strong>==</strong>产生的结果一致时，定义<strong>&lt;</strong>。</p>
</blockquote>

<h3 id="赋值操作符">赋值操作符</h3>

<p>除了<strong>copy-</strong>和<strong>move-</strong>赋值操作符之外，类还可以定义其它的赋值操作符允许其它类型作为右操作数。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
<span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="s">&#34;an&#34;</span><span class="p">,</span> <span class="s">&#34;the&#34;</span><span class="p">};</span>
<span class="k">class</span> <span class="nc">StrVec</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">StrVec</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">);</span>
<span class="p">};</span>
<span class="n">StrVec</span> <span class="o">&amp;</span><span class="n">StrVec</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">data</span> <span class="o">=</span> <span class="n">alloc_n_copy</span><span class="p">(</span><span class="n">il</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">il</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="n">free</span><span class="p">();</span>
    <span class="n">elements</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
    <span class="n">first_free</span> <span class="o">=</span> <span class="n">cap</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>不像<strong>copy-</strong>和<strong>move-</strong>赋值操作符，这个操作符不需要检查自我赋值。</p>

<blockquote>
<p><strong>注意</strong>
赋值操作符可以被重载。不管参数类型是什么，赋值操作符必须定义为成员函数。</p>
</blockquote>

<p>复合赋值操作符不需要是类成员。然而，我们倾向于定义所有的赋值操作符，包括复合赋值操作符为类成员。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Sales_data</span><span class="o">&amp;</span> <span class="n">Sales_data</span><span class="o">::</span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">units_sold</span> <span class="o">+=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">units_sold</span><span class="p">;</span>
    <span class="n">revenue</span> <span class="o">+=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">revenue</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<blockquote>
<p><strong>最佳实践</strong>
赋值操作符必须，而且通常复合赋值操作符应该，定义为成员。这些操作符应该返回左操作数的引用。</p>
</blockquote>

<h3 id="下标操作符">下标操作符</h3>

<p>可以通过位置来获取元素的代表容器的类，通常定义下标操作符，<strong>operater[]</strong>。</p>

<blockquote>
<p><strong>注意</strong>
下标操作符必须为成员函数。</p>

<p><strong>最佳实践</strong>
如果一个类有下标操作符，它通常应该定义2个版本：一个返回普通引用，一个返回const引用。</p>
</blockquote>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">StrVec</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span> <span class="k">return</span> <span class="n">elements</span><span class="p">[</span><span class="n">n</span><span class="p">];</span> <span class="p">}</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="n">elements</span><span class="p">[</span><span class="n">n</span><span class="p">];</span> <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">*</span><span class="n">elements</span><span class="p">;</span> <span class="c1">// 指向数组第一个元素
</span><span class="c1"></span><span class="p">};</span>
 
<span class="k">const</span> <span class="n">StrVec</span> <span class="n">cvec</span> <span class="o">=</span> <span class="n">svec</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">svec</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">svec</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">empty</span><span class="p">())</span>  <span class="p">{</span>
    <span class="n">svec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;zero&#34;</span><span class="p">;</span> <span class="c1">// ok: 返回一个普通引用
</span><span class="c1"></span>    <span class="n">cvec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;Zip&#34;</span><span class="p">;</span>  <span class="c1">// error: 返回一个const引用
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>

<h3 id="自增和自减操作符">自增和自减操作符</h3>

<p>自增和自减操作符最常被迭代器类实现。语言并没要要求这些操作符是成员，但是由于这些操作符改变它们操作的对象的状态，我们选择将它们定义为成员。</p>

<blockquote>
<p><strong>最佳实践</strong>
定义自增或自减操作符的类应该定义<strong>prefix</strong>和<strong>postfix</strong>版本。这些操作符应该定义为成员。</p>
</blockquote>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">StrBlobPtr</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">StrBlobPtr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">();</span> <span class="c1">// 前自增操作符
</span><span class="c1"></span>    <span class="n">StrBlobPtr</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">--</span><span class="p">();</span> <span class="c1">// 前自减操作符
</span><span class="c1"></span><span class="p">};</span>

<span class="n">StrBlobPtr</span><span class="o">&amp;</span> <span class="n">StrBlobPtr</span><span class="o">::</span><span class="k">operator</span><span class="o">++</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">check</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="s">&#34;increment past end of StrBlobPtr&#34;</span><span class="p">);</span>
    <span class="o">++</span><span class="n">curr</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">StrBlobPtr</span><span class="o">&amp;</span> <span class="n">StrBlobPtr</span><span class="o">::</span><span class="k">operator</span><span class="o">--</span><span class="p">()</span>
<span class="p">{</span>
    <span class="o">--</span><span class="n">curr</span><span class="p">;</span>
    <span class="n">check</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#34;decrement past begin of StrBlobPtr&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<blockquote>
<p><strong>最佳实践</strong>
为了和内置操作符一致，前置操作符应该返回自增过或自减过的对象的引用。</p>
</blockquote>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">StrBlobPtr</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">StrBlobPtr</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>    <span class="c1">// 后置操作符
</span><span class="c1"></span>    <span class="n">StrBlobPtr</span> <span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">StrBlobPtr</span> <span class="n">StrBlobPtr</span><span class="o">::</span><span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">StrBlobPtr</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="o">++*</span><span class="k">this</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">StrBlobPtr</span> <span class="n">StrBlobPtr</span><span class="o">::</span><span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">StrBlobPtr</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="o">--*</span><span class="k">this</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<blockquote>
<p><strong>最佳实践</strong>
为了和内置操作符一致，后置操作符应该返回旧的（未自增或自减）值，而不是引用。</p>

<p><strong>注意</strong>
<strong>int</strong>参数没有用到，所以没有给它一个名字。</p>
</blockquote>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">StrBlobPtr</span> <span class="nf">p</span><span class="p">(</span><span class="n">a1</span><span class="p">);</span>
<span class="n">p</span><span class="p">.</span><span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>  <span class="c1">// 调用后自增操作符
</span><span class="c1"></span><span class="n">p</span><span class="p">.</span><span class="k">operator</span><span class="o">++</span><span class="p">();</span>   <span class="c1">// 调用前自增操作符
</span></code></pre></div>

<h3 id="成员访问操作符">成员访问操作符</h3>

<p>解引用（*）和箭头（-&gt;）操作符经常使用在迭代器类和智能指针类中。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">StrBlobPtr</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span> 
        <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">check</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="s">&#34;dereference past end&#34;</span><span class="p">);</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="n">curr</span><span class="p">];</span>  <span class="c1">// (*p)是这个对象指向的vector
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="o">&amp;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="k">operator</span><span class="o">*</span><span class="p">();</span> <span class="c1">// 将实际工作委托给解引用操作符
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<blockquote>
<p><strong>注意</strong>
箭头操作符必须定义为成员，没有要求解引用为成员但通常也应该为成员。</p>
</blockquote>

<p>值得注意的是我们定义这些操作符为<strong>const</strong>成员，获取一个元素不会改变这个对象的状态。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">StrBlob</span> <span class="n">a1</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;hi&#34;</span><span class="p">,</span> <span class="s">&#34;bye&#34;</span><span class="p">,</span> <span class="s">&#34;now&#34;</span><span class="p">};</span>
<span class="n">StrBlobPtr</span> <span class="nf">p</span><span class="p">(</span><span class="n">a1</span><span class="p">);</span>            <span class="c1">// p指向a1里面的vector
</span><span class="c1"></span><span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="s">&#34;okay&#34;</span><span class="p">;</span>                 <span class="c1">// 给a1中第一个元素赋值
</span><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>   <span class="c1">// 第一个元素的size()
</span><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">).</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 等价于p-&gt;size()
</span></code></pre></div>

<p>当我们写<strong>point-&gt;mem</strong>时，<strong>point</strong>必须是指向一个类对象的指针或是一个重载了<strong>operator-&gt;</strong>的类的对象。取决于<strong>point</strong>的类型，<strong>point-&gt;mem</strong>等价于：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="p">(</span><span class="o">*</span><span class="n">point</span><span class="p">).</span><span class="n">mem</span><span class="p">;</span>          <span class="c1">// point是一个内置指针类型
</span><span class="c1"></span><span class="n">point</span><span class="p">.</span><span class="k">operator</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">mem</span><span class="p">;</span> <span class="c1">// point是一个类的对象
</span></code></pre></div>

<blockquote>
<p><strong>注意</strong>
箭头操作符必须返回一个指向类类型的指针或一个定义了自己的箭头操作符的类类型的对象。</p>
</blockquote>

<h3 id="函数调用操作符">函数调用操作符</h3>

<p>重载了函数调用操作符的类允许它的对象像函数一样使用。因为这种类可以保存状态，它们比普通函数更灵活。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">absInt</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="nf">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="o">-</span><span class="nl">val</span> <span class="p">:</span> <span class="n">val</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<p>定义了函数调用操作符的类的对象被称为函数对象，我们可以像函数调用一样提供一个参数列表给函数对象：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">42</span><span class="p">;</span>
<span class="n">absInt</span> <span class="n">absObj</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">ui</span> <span class="o">=</span> <span class="n">absObj</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</code></pre></div>

<blockquote>
<p><strong>注意</strong>
函数调用操作符必须是成员函数。一个类可以定义多个版本的调用操作符，每一个参数类型或数量必须不一样。</p>
</blockquote>

<p>和其他类一样，一个函数对象类除了<strong>operator()</strong>，还可以有其它成员。函数对象类通常包含其它成员用来调整函数调用操作符的操作。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">PrintString</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">PrintString</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">o</span> <span class="o">=</span> <span class="n">cout</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">)</span><span class="o">:</span>
        <span class="n">os</span><span class="p">(</span><span class="n">o</span><span class="p">),</span> <span class="n">sep</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">sep</span><span class="p">;}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">;</span>   <span class="c1">// stream on which to write
</span><span class="c1"></span>    <span class="kt">char</span> <span class="n">sep</span><span class="p">;</span>      <span class="c1">// character to print after each output
</span><span class="c1"></span><span class="p">};</span>

<span class="n">PrintString</span> <span class="n">printer</span><span class="p">;</span>   <span class="c1">// uses the defaults; prints to cout
</span><span class="c1"></span><span class="n">printer</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>            <span class="c1">// prints s followed by a space on cout
</span><span class="c1"></span><span class="n">PrintString</span> <span class="nf">errors</span><span class="p">(</span><span class="n">cerr</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
<span class="n">errors</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>             <span class="c1">// prints s followed by a newline on cerr
</span></code></pre></div>

<p>函数对象最常用于泛型算法的参数：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">for_each</span><span class="p">(</span><span class="n">vs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vs</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">PrintString</span><span class="p">(</span><span class="n">cerr</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">));</span>
</code></pre></div>

<h3 id="lambdas是函数对象">Lambdas是函数对象</h3>

<p>当我们写一个<strong>lambda</strong>时，编译器将表达式翻译成一个匿名类的匿名对象。由<strong>lambda</strong>生成的类包含了一个重载的函数调用操作符。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">stable_sort</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
            <span class="p">[](</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
              <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">();});</span>
</code></pre></div>

<p>行为就像一个匿名对象的类，看起来像：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">ShorterString</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s2</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="n">s1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">stable_sort</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ShorterString</span><span class="p">());</span>
</code></pre></div>

<h3 id="类表示lambdas带捕获成员">类表示Lambdas带捕获成员</h3>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="n">wc</span> <span class="o">=</span> <span class="n">find_if</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
            <span class="p">[</span><span class="n">sz</span><span class="p">](</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">){</span> <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">sz</span><span class="p">;});</span>
</code></pre></div>

<p>会生成像这样的类：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">SizeComp</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">SizeComp</span><span class="p">(</span><span class="n">size_t</span> <span class="n">n</span><span class="p">)</span><span class="o">:</span> <span class="n">sz</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// parameter for each captured variable
</span><span class="c1"></span>    <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="k">const</span>
        <span class="p">{</span> <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">sz</span><span class="p">;</span> <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">size_t</span> <span class="n">sz</span><span class="p">;</span> <span class="c1">// a data member for each variable captured by value
</span><span class="c1"></span><span class="p">};</span>

<span class="k">auto</span> <span class="n">wc</span> <span class="o">=</span> <span class="n">find_if</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">SizeComp</span><span class="p">(</span><span class="n">sz</span><span class="p">));</span>
</code></pre></div>

<p>由lambda表达式生成的类有一个<strong>deleted</strong>默认构造函数，<strong>deleted</strong>赋值操作符和一个默认析构函数。是否有<strong>deleted</strong>或默认的<strong>copy/move</strong>构造函数取决于捕获的数据成员。</p>

<h3 id="标准库定义的函数对象">标准库定义的函数对象</h3>

<p>标准库定义了一个类集合，表示算术，关系和逻辑运算符。
<strong>plus</strong>类有一个函数调用操作符，应用<strong>+</strong>操作符。
<strong>modulus</strong>类有一个函数调用操作符，应用<strong>%</strong>操作符。
<strong>equal_to</strong>类有一个函数调用操作符，应用<strong>==</strong>操作符。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">plus</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">intAdd</span><span class="p">;</span>       <span class="c1">// function object that can add two int values
</span><span class="c1"></span><span class="n">negate</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">intNegate</span><span class="p">;</span>  <span class="c1">// function object that can negate an int value
</span><span class="c1"></span><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">intAdd</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>         <span class="c1">// sum = 30
</span><span class="c1"></span><span class="n">sum</span> <span class="o">=</span> <span class="n">intNegate</span><span class="p">(</span><span class="n">intAdd</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">));</span>  <span class="c1">// sum = -30
</span><span class="c1"></span><span class="n">sum</span> <span class="o">=</span> <span class="n">intAdd</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">intNegate</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>  <span class="c1">// sum = 0
</span></code></pre></div>

<h3 id="算法中使用标准库函数对象">算法中使用标准库函数对象</h3>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// passes a temporary function object that applies the &lt; operator to two strings
</span><span class="c1"></span><span class="n">sort</span><span class="p">(</span><span class="n">svec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">svec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">greater</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">());</span>
</code></pre></div>

<p>标准库函数对象保证对指针也有作用。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span> <span class="o">*&gt;</span> <span class="n">nameTable</span><span class="p">;</span>  <span class="c1">// vector of pointers
</span><span class="c1">// error: the pointers in nameTable are unrelated, so &lt; is undefined
</span><span class="c1"></span><span class="n">sort</span><span class="p">(</span><span class="n">nameTable</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nameTable</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
     <span class="p">[](</span><span class="n">string</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">string</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">;</span> <span class="p">});</span>
<span class="c1">// ok: library guarantees that less on pointer types is well defined
</span><span class="c1"></span><span class="n">sort</span><span class="p">(</span><span class="n">nameTable</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nameTable</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">less</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*&gt;</span><span class="p">());</span>
</code></pre></div>

<p>值得注意的是关联容器使用<strong>less<key_type></strong>排序它们的元素。因此，我们能定义一个指针集合，或者使用一个指针作为<strong>key</strong>的<strong>map</strong>容器而不用直接指定<strong>less</strong>。</p>

<h3 id="可调用对象和函数">可调用对象和函数</h3>

<p>C++有几种可调用对象：函数和函数指针，lambdas，由<strong>bind</strong>创建的对象和重载了函数调用操作符的类。</p>

<p>不同类型可以有相同的调用签名：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// 普通函数
</span><span class="c1"></span><span class="k">auto</span> <span class="n">mod</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="n">j</span><span class="p">;</span> <span class="p">};</span> <span class="c1">// 匿名函数
</span><span class="c1">// 函数对象类
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">div</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="nf">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">denominator</span><span class="p">,</span> <span class="kt">int</span> <span class="n">divisor</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">denominator</span> <span class="o">/</span> <span class="n">divisor</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">binops</span><span class="p">;</span>
   
<span class="n">binops</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="n">add</span><span class="p">});</span> <span class="c1">// ok: add是一个指向合适类型的函数指针
</span><span class="c1"></span><span class="n">binops</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#34;%&#34;</span><span class="p">,</span> <span class="n">mod</span><span class="p">});</span> <span class="c1">// error: mod不是一个指向函数的指针
</span></code></pre></div>

<h3 id="标准库function类型">标准库function类型</h3>

<p>function定义在头文件functional里面。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">;</span>          <span class="c1">//空函数对象。
</span><span class="c1"></span><span class="n">function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span> <span class="c1">//显式构造空函数对象。
</span><span class="c1"></span><span class="n">function</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>     <span class="c1">//保存一个obj的副本。
</span><span class="c1"></span><span class="n">f</span>                       <span class="c1">//true当f拥有一个可调用对象，否则false。
</span><span class="c1"></span><span class="n">f</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>                 <span class="c1">//传递参数args，调用函数。
</span><span class="c1"></span>
<span class="c1">//定义为function&lt;T&gt;的成员的类型
</span><span class="c1"></span><span class="n">result_type</span>             <span class="c1">//可调用对象的返回类型。
</span><span class="c1"></span><span class="n">argument_type</span>           <span class="c1">//当参数为1个或2个时的类型。
</span><span class="c1"></span><span class="n">first_argument_type</span>
<span class="n">second_argument_type</span>
</code></pre></div>

<p><strong>function</strong>是一个模板。和其它模板一样，我们必须指定<strong>function</strong>的函数类型。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">add</span><span class="p">;</span>    <span class="c1">// 函数指针
</span><span class="c1"></span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">div</span><span class="p">();</span>  <span class="c1">// 函数对象
</span><span class="c1"></span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f3</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="n">j</span><span class="p">;};</span> <span class="c1">// 匿名函数
</span><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f1</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// prints 6
</span><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f2</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// prints 2
</span><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f3</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// prints 8
</span><span class="c1"></span>
<span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="n">binops</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="n">add</span><span class="p">},</span>                  <span class="c1">// function pointer
</span><span class="c1"></span>    <span class="p">{</span><span class="s">&#34;-&#34;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">minus</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()},</span>    <span class="c1">// library function object
</span><span class="c1"></span>    <span class="p">{</span><span class="s">&#34;/&#34;</span><span class="p">,</span>  <span class="n">div</span><span class="p">()},</span>               <span class="c1">// user-defined function object
</span><span class="c1"></span>    <span class="p">{</span><span class="s">&#34;*&#34;</span><span class="p">,</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="n">j</span><span class="p">;</span> <span class="p">}},</span> <span class="c1">// unnamed lambda
</span><span class="c1"></span>    <span class="p">{</span><span class="s">&#34;%&#34;</span><span class="p">,</span> <span class="n">mod</span><span class="p">}</span> <span class="p">};</span>                <span class="c1">// named lambda object
</span><span class="c1"></span>
<span class="n">binops</span><span class="p">[</span><span class="s">&#34;+&#34;</span><span class="p">](</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// calls add(10, 5)
</span><span class="c1"></span><span class="n">binops</span><span class="p">[</span><span class="s">&#34;-&#34;</span><span class="p">](</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// uses the call operator of the minus&lt;int&gt; object
</span><span class="c1"></span><span class="n">binops</span><span class="p">[</span><span class="s">&#34;/&#34;</span><span class="p">](</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// uses the call operator of the div object
</span><span class="c1"></span><span class="n">binops</span><span class="p">[</span><span class="s">&#34;*&#34;</span><span class="p">](</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// calls the lambda function object
</span><span class="c1"></span><span class="n">binops</span><span class="p">[</span><span class="s">&#34;%&#34;</span><span class="p">](</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// calls the lambda function object
</span></code></pre></div>

<h3 id="重载函数和function">重载函数和function</h3>

<p>我们不能直接保存一个重载函数的函数名：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span> <span class="p">}</span>
<span class="n">Sales_data</span> <span class="nf">add</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Sales_data</span><span class="o">&amp;</span><span class="p">);</span>
<span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="n">binops</span><span class="p">;</span>
<span class="n">binops</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="n">add</span><span class="p">});</span> <span class="c1">// error: which add?
</span></code></pre></div>

<p>解决二义性的一个方法是存储函数指针：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="n">add</span><span class="p">;</span>
<span class="n">binops</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="n">fp</span><span class="p">});</span>
</code></pre></div>

<p>或者使用lambda消除歧义：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">binops</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="s">&#34;+&#34;</span><span class="p">,</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);}});</span>
</code></pre></div>

<h1 id="重载-转换和操作符">重载，转换和操作符</h1>

<p>转换构造函数和转换操作符定义了类类型的转换。这种转换又叫做用户定义的转换。</p>

<h3 id="转换操作符">转换操作符</h3>

<p>转换操作符是一种特殊的成员函数，将一个类类型的值转换为其它类型的值。一个典型的转换函数具有形式：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">operator</span> <span class="nf">type</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</code></pre></div>

<p>转换操作符可以为任意（除了<strong>void</strong>）函数返回的类型定义转换。不允许转换为数组或函数类型。允许转换为指针（数据指针和函数指针）和引用。</p>

<blockquote>
<p><strong>注意</strong>
转换函数必须是一个成员函数，不能指定返回类型，参数列表必须为空，通常为const。</p>
</blockquote>

<h3 id="定义一个具有转换操作符的类">定义一个具有转换操作符的类</h3>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">SmallInt</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">SmallInt</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">)</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">&#34;Bad SmallInt value&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">operator</span> <span class="nf">int</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span><span class="p">;</span> <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">SmallInt</span> <span class="n">si</span><span class="p">;</span>
<span class="n">si</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// implicitly converts 4 to SmallInt then calls SmallInt::operator=
</span><span class="c1"></span><span class="n">si</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// implicitly converts si to int followed by integer addition
</span></code></pre></div>

<p>尽管编译器每次只应用一个用户定义的转换操作，隐式调用用户定义的转换可以在之前或之后跟着一个标准转换。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">SmallInt</span> <span class="n">si</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
<span class="n">si</span> <span class="o">+</span> <span class="mf">3.14</span><span class="p">;</span>
</code></pre></div>

<p>因为转换操作符是隐式调用的，没有办法给它们传递参数。因此，转换操作符不带参数。尽管转换函数没有指定返回值，每一个转换函数必须返回相应的转换类型。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">SmallInt</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="k">operator</span> <span class="kt">int</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>            <span class="c1">// error: return type
</span><span class="c1"></span>    <span class="k">operator</span> <span class="nf">int</span><span class="p">(</span><span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>         <span class="c1">// error: parameter list
</span><span class="c1"></span>    <span class="k">operator</span> <span class="kt">int</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">42</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// error: 42 is not a pointer
</span><span class="c1"></span><span class="p">};</span>
<span class="k">operator</span> <span class="nf">int</span><span class="p">(</span><span class="n">SmallInt</span><span class="o">&amp;</span><span class="p">);</span>                 <span class="c1">// error: nonmember
</span></code></pre></div>

<blockquote>
<p><strong>警告</strong>
避免滥用转换函数。</p>
</blockquote>

<h3 id="转换操作符可以产生惊人的结果">转换操作符可以产生惊人的结果</h3>

<p>实际上，类很少定义转换操作符。然而一个例外是：类定义转换为bool类型并不罕见。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="n">cin</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// this code would be legal if the conversion to bool were not explicit!
</span></code></pre></div>

<h3 id="explicit转换操作符">explicit转换操作符</h3>

<p>为了防止前面的问题，新标准引入<strong>explicit</strong>转换。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">SmallInt</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// the compiler won&#39;t automatically apply this conversion
</span><span class="c1"></span>    <span class="k">explicit</span> <span class="k">operator</span> <span class="kt">int</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">SmallInt</span> <span class="n">si</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>  <span class="c1">// ok: the SmallInt constructor is not explicit
</span><span class="c1"></span><span class="n">si</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// error: implicit conversion is required, but operator int is explicit
</span><span class="c1"></span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">si</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// ok: explicitly request the conversion
</span></code></pre></div>

<p>如果转换操作符是<code>explicit</code>的，我们只能通过<strong>cast</strong>来显式转换。一个例外是编译器会在条件测试中应用显式转换：</p>

<ul>
<li><code>if</code>，<code>while</code>或<code>do while</code>条件测试</li>
<li><code>for</code>的条件表达式</li>
<li>逻辑非<code>!</code>，逻辑与<code>&amp;&amp;</code>或逻辑或<code>||</code>的操作数</li>
<li>条件运算符<code>?:</code>条件测试</li>
</ul>

<h3 id="转换为bool类型">转换为bool类型</h3>

<p>当我们在条件测试中使用流对象，我们使用定义在IO类型里面的<strong>operator bool</strong>转换操作：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">while</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">value</span><span class="p">)</span>
</code></pre></div>

<blockquote>
<p><strong>最佳实践</strong>
通常转换为<strong>bool</strong>是有意用于条件测试的。因此，<strong>operator bool</strong>通常应该定义为<strong>explicit</strong>。</p>
</blockquote>

<h3 id="避免歧义的转换">避免歧义的转换</h3>

<p>有两种方法会发生多个转换路径的情况。第一个就是当2个类提供了相互的转换。第二个就是定义了多个转换，其转换类型之间也可以转换。</p>

<blockquote>
<p><strong>警告</strong>
通常，类定义相互转换或定义了多个从算术类型或到算术类型的转换是个坏主意。</p>
</blockquote>

<h4 id="参数匹配和相互转换">参数匹配和相互转换</h4>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">B</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="n">A</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span><span class="p">);</span>        <span class="c1">// converts a B to an A
</span><span class="c1"></span><span class="p">};</span>
<span class="k">struct</span> <span class="nc">B</span> <span class="p">{</span>
    <span class="k">operator</span> <span class="nf">A</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// also converts a B to an A
</span><span class="c1"></span><span class="p">};</span>

<span class="n">A</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span><span class="p">);</span>
<span class="n">B</span> <span class="n">b</span><span class="p">;</span>
<span class="n">A</span> <span class="n">a</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="c1">// error ambiguous: f(B::operator A())
</span><span class="c1"></span>            <span class="c1">//          or f(A::A(const B&amp;))
</span><span class="c1"></span>
<span class="n">A</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="k">operator</span> <span class="n">A</span><span class="p">());</span> <span class="c1">// ok: use B&#39;s conversion operator
</span><span class="c1"></span><span class="n">A</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">A</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>           <span class="c1">// ok: use A&#39;s constructor
</span></code></pre></div>

<p>需要注意的是我们不能通过<strong>cast</strong>来解决这个二义性，因为<strong>cast</strong>有着一样的歧义。</p>

<h4 id="内置类型的多个转换和歧义">内置类型的多个转换和歧义</h4>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>   <span class="c1">// usually a bad idea to have two
</span><span class="c1"></span>    <span class="n">A</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>    <span class="c1">// conversions from arithmetic types
</span><span class="c1"></span>    <span class="k">operator</span> <span class="nf">int</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>    <span class="c1">// usually a bad idea to have two
</span><span class="c1"></span>    <span class="k">operator</span> <span class="nf">double</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// conversions to arithmetic types
</span><span class="c1"></span><span class="p">};</span>

<span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span><span class="p">);</span>
<span class="n">A</span> <span class="n">a</span><span class="p">;</span>
<span class="n">f2</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// error ambiguous: f(A::operator int())
</span><span class="c1"></span>       <span class="c1">//          or f(A::operator double())
</span><span class="c1"></span><span class="kt">long</span> <span class="n">lg</span><span class="p">;</span>
<span class="n">A</span> <span class="nf">a2</span><span class="p">(</span><span class="n">lg</span><span class="p">);</span> <span class="c1">// error ambiguous: A::A(int) or A::A(double)
</span><span class="c1"></span>
<span class="kt">short</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="c1">// promoting short to int is better than converting short to double
</span><span class="c1"></span><span class="n">A</span> <span class="nf">a3</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>  <span class="c1">// uses A::A(int)
</span></code></pre></div>

<blockquote>
<p><strong>注意</strong>
当使用2个用户定义的转换时，如果有标准转换，使用标准转换的级别来选择最佳匹配。</p>

<p>转换和操作符：
*   不要定义类之间的相互转换
*   避免定义多个到内置算术类型的转换。</p>

<p>最简单的规则就是：除了显式转换为<strong>bool</strong>类型外，避免定义转换函数和限制那些看起来对的隐式构造函数。</p>
</blockquote>

<h4 id="重载函数和转换构造函数">重载函数和转换构造函数</h4>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">C</span> <span class="p">{</span>
    <span class="n">C</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nc">D</span> <span class="p">{</span>
    <span class="n">D</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">manip</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">manip</span><span class="p">(</span><span class="k">const</span> <span class="n">D</span><span class="o">&amp;</span><span class="p">);</span>

<span class="n">manip</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// error ambiguous: manip(C(10)) or manip(D(10))
</span><span class="c1"></span><span class="n">manip</span><span class="p">(</span><span class="n">C</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span> <span class="c1">// ok: calls manip(const C&amp;)
</span></code></pre></div>

<blockquote>
<p><strong>警告</strong>
需要频繁地在函数调用中使用构造函数或强制转换来转换参数一个坏设计的表现。</p>
</blockquote>

<h4 id="重载函数和用户定义的转换">重载函数和用户定义的转换</h4>

<p>在重载函数调用中，如果有2个或更多用户定义的转换提供可行的匹配，转换被认为是一样好。</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">E</span> <span class="p">{</span>
    <span class="n">E</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="nf">manip2</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">manip2</span><span class="p">(</span><span class="k">const</span> <span class="n">E</span><span class="o">&amp;</span><span class="p">);</span>
<span class="c1">// error ambiguous: two different user-defined conversions could be used
</span><span class="c1"></span><span class="n">manip2</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// manip2(C(10) or manip2(E(double(10)))
</span></code></pre></div>

<blockquote>
<p><strong>注意</strong>
在重载函数调用中，附加的标准转换级别有作用仅当可行函数是同一个用户定义的转换。如果是不同的用户定义的转换，则调用有歧义。</p>
</blockquote>

<h3 id="函数匹配和操作符重载">函数匹配和操作符重载</h3>

<p>如果a是一个类类型，a sym b表达式可能是：</p>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">a</span><span class="p">.</span><span class="n">operatorsym</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="c1">// a has operatorsym as a member function
</span><span class="c1"></span><span class="n">operatorsym</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// operatorsym is an ordinary function
</span></code></pre></div>

<blockquote>
<p><strong>注意</strong>
在候选函数集中表达式中的操作符可以是成员或非成员函数。</p>
</blockquote>

<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">SmallInt</span> <span class="p">{</span>
    <span class="k">friend</span> <span class="n">SmallInt</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">SmallInt</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">SmallInt</span><span class="o">&amp;</span><span class="p">);</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">SmallInt</span><span class="p">(</span><span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>                   <span class="c1">// conversion from int
</span><span class="c1"></span>    <span class="k">operator</span> <span class="nf">int</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// conversion to int
</span><span class="c1"></span><span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">size_t</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">SmallInt</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">;</span>
<span class="n">SmallInt</span> <span class="n">s3</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span><span class="p">;</span>  <span class="c1">// uses overloaded operator+
</span><span class="c1"></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">s3</span> <span class="o">+</span> <span class="mi">0</span><span class="p">;</span>         <span class="c1">// error: ambiguous
</span></code></pre></div>

<blockquote>
<p><strong>警告</strong>
既提供了到算术类型的转换，又重载了相应的算术操作符，可能会导致二义性</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>Markdown语法</title>
			<link>https://gitop.cc/posts/syntax/</link>
			<pubDate>Sat, 19 Sep 2015 19:47:02 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/syntax/</guid>
			<description>原文拷贝自这里. NOTE: This is Simplelified Chinese Edition Document of Markdown Syntax. If you are seeking for English Edition Document. Please refer to Markdown: Syntax. 声明： 这份文档派生(fork)于繁体中文版，在此基础上进行了繁体转简体工作，并</description>
			<content type="html"><![CDATA[

<p>原文拷贝自<del><a href="https://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/syntax.md">这里</a></del>.</p>

<p><strong>NOTE</strong>: This is Simplelified Chinese Edition Document of Markdown Syntax. If you are seeking for English Edition Document. Please refer to <a href="http://daringfireball.net/projects/markdown/syntax">Markdown: Syntax</a>.</p>

<p><strong>声明</strong>： 这份文档派生(fork)于<a href="http://markdown.tw/">繁体中文版</a>，在此基础上进行了繁体转简体工作，并进行了适当的润色。此文档用 Markdown 语法编写，你可以到这里<del><a href="https://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/syntax.md">查看它的源文件</a></del>。「繁体中文版的原始文件可以<a href="https://github.com/othree/markdown-syntax-zhtw/blob/master/syntax.md">查看这里</a> 。」&ndash;By @<a href="http://twitter.com/riku">riku</a></p>

<p><strong>注</strong>： 本项目托管于<del><a href="http://gitcafe.com/riku/Markdown-Syntax-CN/">GitCafe</a></del>上，请通过”派生”和”合并请求”来帮忙改进本项目。</p>

<h1 id="markdown语法说明-点击查看快速入门-https-gitcafe-com-riku-markdown-syntax-cn-blob-master-basic-html">Markdown语法说明（<del><a href="https://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/basic.html">点击查看快速入门</a></del>）</h1>

<ul>
<li><a href="#overview">概述</a>

<ul>
<li><a href="#philosophy">宗旨</a></li>
<li><a href="#html">兼容 HTML</a></li>
<li><a href="#autoescape">特殊字符自动转换</a></li>
</ul></li>
<li><a href="#block">区块元素</a>

<ul>
<li><a href="#p">段落和换行</a></li>
<li><a href="#header">标题</a></li>
<li><a href="#blockquote">区块引用</a></li>
<li><a href="#list">列表</a></li>
<li><a href="#precode">代码区块</a></li>
<li><a href="#hr">分隔线</a></li>
</ul></li>
<li><a href="#span">区段元素</a>

<ul>
<li><a href="#link">链接</a></li>
<li><a href="#em">强调</a></li>
<li><a href="#code">代码</a></li>
<li><a href="#img">图片</a></li>
</ul></li>
<li><a href="#misc">其它</a>

<ul>
<li><a href="#backslash">反斜杠</a></li>
<li><a href="#autolink">自动链接</a></li>
</ul></li>
<li><a href="#acknowledgement">感谢</a></li>
<li><a href="#editor">Markdown 免费编辑器</a></li>
</ul>

<hr />

<h2 id="overview">概述</h2>

<h3 id="philosophy">宗旨</h3>

<p>Markdown 的目标是实现「易读易写」。</p>

<p>可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 <a href="http://docutils.sourceforge.net/mirror/setext.html">Setext</a>、<a href="http://www.aaronsw.com/2002/atx/">atx</a>、<a href="http://textism.com/tools/textile/">Textile</a>、<a href="http://docutils.sourceforge.net/rst.html">reStructuredText</a>、<a href="http://www.triptico.com/software/grutatxt.html">Grutatext</a> 和 <a href="http://ettext.taint.org/doc/">EtText</a>，而最大灵感来源其实是纯文本电子邮件的格式。</p>

<p>总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像*强调*。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。</p>

<h3 id="html">兼容 HTML</h3>

<p>Markdown 语法的目标是：成为一种适用于网络的书写语言。</p>

<p>Markdown 并不是想取代 HTML的地位，甚至接近它。它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想*不是*要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种*发布*的格式，Markdown 是一种*书写*的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。</p>

<p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。</p>

<p>要制约的只有一些 HTML 区块元素――比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 <code>&lt;p&gt;</code> 标签。</p>

<p>例子如下，在 Markdown 文件里加上一段 HTML 表格：</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html">这是一个普通段落。

<span class="p">&lt;</span><span class="nt">table</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">tr</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">td</span><span class="p">&gt;</span>Foo<span class="p">&lt;/</span><span class="nt">td</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">tr</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">table</span><span class="p">&gt;</span>

这是另一个普通段落。</code></pre></div>
<p>请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的<code>*强调*</code>会没有效果。</p>

<p>HTML 的区段（行内）标签如 <code>&lt;span&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;del&gt;</code> 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 <code>&lt;a&gt;</code> 或 <code>&lt;img&gt;</code> 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。</p>

<p>和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。</p>

<h3 id="autoescape">特殊字符自动转换</h3>

<p>在 HTML 文件中，有两个字符需要特殊处理： <code>&lt;</code> 和 <code>&amp;</code> 。 <code>&lt;</code> 符号用于起始标签，<code>&amp;</code> 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 <code>&amp;lt;</code> 和 <code>&amp;amp;</code>。</p>

<p><code>&amp;</code> 字符尤其让网络文档编写者受折磨，如果你要打「<code>AT&amp;T</code>」 ，你必须要写成「<code>AT&amp;amp;T</code>」。而网址中的 <code>&amp;</code> 字符也要转换。比如你要链接到：</p>

<pre><code>http://images.google.com/images?num=30&amp;q=larry+bird
</code></pre>

<p>你必须要把网址转换写为：</p>

<pre><code>http://images.google.com/images?num=30&amp;amp;q=larry+bird
</code></pre>

<p>才能放到链接标签的 <code>href</code> 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。</p>

<p>Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 <code>&amp;</code> 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 <code>&amp;amp;</code>。</p>

<p>所以你如果要在文档中插入一个版权符号 <code>©</code>，你可以这样写：</p>

<pre><code>&amp;copy;
</code></pre>

<p>Markdown 会保留它不动。而若你写：</p>

<pre><code>AT&amp;T
</code></pre>

<p>Markdown 就会将它转为：</p>

<pre><code>AT&amp;amp;T
</code></pre>

<p>类似的状况也会发生在 <code>&lt;</code> 符号上，因为 Markdown 允许 <a href="#html">兼容 HTML</a> ，如果你是把 <code>&lt;</code> 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写：</p>

<pre><code>4 &lt; 5
</code></pre>

<p>Markdown 将会把它转换为：</p>

<pre><code>4 &amp;lt; 5
</code></pre>

<p>不过需要注意的是，code 范围内，不论是行内还是区块， <code>&lt;</code> 和 <code>&amp;</code> 两个符号都一定会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 <code>&lt;</code> 和 <code>&amp;</code> 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。）</p>

<hr />

<h2 id="block">区块元素</h2>

<h3 id="p">段落和换行</h3>

<p>一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。</p>

<p>「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 <code>&lt;br /&gt;</code> 标签。</p>

<p>如果你*确实*想要依赖 Markdown 来插入 <code>&lt;br /&gt;</code> 标签的话，在插入处先按入两个以上的空格然后回车。</p>

<p>的确，需要多费点事（多加空格）来产生 <code>&lt;br /&gt;</code> ，但是简单地「每个换行都转换为 <code>&lt;br /&gt;</code>」的方法在 Markdown 中并不适合， Markdown 中 email 式的 <a href="#blockquote">区块引用</a> 和多段落的 <a href="#list">列表</a> 在使用换行来排版的时候，不但更好用，还更方便阅读。</p>

<h3 id="header">标题</h3>

<p>Markdown 支持两种标题的语法，类 <a href="http://docutils.sourceforge.net/mirror/setext.html">Setext</a> 和类 <a href="http://www.aaronsw.com/2002/atx/">atx</a> 形式。</p>

<p>类 Setext 形式是用底线的形式，利用 <code>=</code> （最高阶标题）和 <code>-</code> （第二阶标题），例如：</p>

<pre><code>This is an H1
=============

This is an H2
-------------
</code></pre>

<p>任何数量的 <code>=</code> 和 <code>-</code> 都可以有效果。</p>

<p>类 Atx 形式则是在行首插入 1 到 6 个 <code>#</code> ，对应到标题 1 到 6 阶，例如：</p>

<pre><code># 这是 H1

## 这是 H2

###### 这是 H6
</code></pre>

<p>你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 <code>#</code>，而行尾的 <code>#</code> 数量也不用和开头一样（行首的井字符数量决定标题的阶数）：</p>

<pre><code># 这是 H1 #

## 这是 H2 ##

### 这是 H3 ######
</code></pre>

<h3 id="blockquote">区块引用 Blockquotes</h3>

<p>Markdown 标记区块引用是使用类似 email 中用 <code>&gt;</code> 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 <code>&gt;</code> ：</p>

<pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
&gt; 
&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
&gt; id sem consectetuer libero luctus adipiscing.
</code></pre>

<p>Markdown 也允许你偷懒只在整个段落的第一行最前面加上 <code>&gt;</code> ：</p>

<pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.

&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.
</code></pre>

<p>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 <code>&gt;</code> ：</p>

<pre><code>&gt; This is the first level of quoting.
&gt;
&gt; &gt; This is nested blockquote.
&gt;
&gt; Back to the first level.
</code></pre>

<p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：</p>

<pre><code>&gt; ## 这是一个标题。
&gt; 
&gt; 1.   这是第一行列表项。
&gt; 2.   这是第二行列表项。
&gt; 
&gt; 给出一些例子代码：
&gt; 
&gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);
</code></pre>

<p>任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择*增加引用阶层*。</p>

<h3 id="list">列表</h3>

<p>Markdown 支持有序列表和无序列表。</p>

<p>无序列表使用星号、加号或是减号作为列表标记：</p>

<pre><code>*   Red
*   Green
*   Blue
</code></pre>

<p>效果就是
*   Red
*   Green
*   Blue</p>

<p>等同于：</p>

<pre><code>+   Red
+   Green
+   Blue
</code></pre>

<p>也等同于：</p>

<pre><code>-   Red
-   Green
-   Blue
</code></pre>

<p>有序列表则使用数字接着一个英文句点：</p>

<pre><code>1.  Bird
2.  McHale
3.  Parish
</code></pre>

<p>很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：</p>

<pre><code>&lt;ol&gt;
&lt;li&gt;Bird&lt;/li&gt;
&lt;li&gt;McHale&lt;/li&gt;
&lt;li&gt;Parish&lt;/li&gt;
&lt;/ol&gt;
</code></pre>

<p>如果你的列表标记写成：</p>

<pre><code>1.  Bird
1.  McHale
1.  Parish
</code></pre>

<p>或甚至是：</p>

<pre><code>3. Bird
1. McHale
8. Parish
</code></pre>

<p>你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。</p>

<p>如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。</p>

<p>列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。</p>

<p>要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：</p>

<pre><code>*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
    viverra nec, fringilla in, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
    Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre>

<p>但是如果你懒，那也行：</p>

<pre><code>*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla in, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre>

<p>如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 <code>&lt;p&gt;</code>
标签包起来，举例来说：</p>

<pre><code>*   Bird
*   Magic
</code></pre>

<p>会被转换为：</p>

<pre><code>&lt;ul&gt;
&lt;li&gt;Bird&lt;/li&gt;
&lt;li&gt;Magic&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>但是这个：</p>

<pre><code>*   Bird

*   Magic
</code></pre>

<p>会被转换为：</p>

<pre><code>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：</p>

<pre><code>1.  This is a list item with two paragraphs. Lorem ipsum dolor
    sit amet, consectetuer adipiscing elit. Aliquam hendrerit
    mi posuere lectus.

    Vestibulum enim wisi, viverra nec, fringilla in, laoreet
    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
    sit amet velit.

2.  Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre>

<p>如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：</p>

<pre><code>*   This is a list item with two paragraphs.

    This is the second paragraph in the list item. You're
only required to indent the first line. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit.

*   Another item in the same list.
</code></pre>

<p>如果要在列表项目内放进引用，那 <code>&gt;</code> 就需要缩进：</p>

<pre><code>*   A list item with a blockquote:

    &gt; This is a blockquote
    &gt; inside a list item.
</code></pre>

<p>如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：</p>

<pre><code>*   一列表项包含一个列表区块：

        &lt;代码写在这&gt;
</code></pre>

<p>当然，项目列表很可能会不小心产生，像是下面这样的写法：</p>

<pre><code>1986. What a great season.
</code></pre>

<p>换句话说，也就是在行首出现*数字-句点-空白*，要避免这样的状况，你可以在句点前面加上反斜杠。</p>

<pre><code>1986\. What a great season.
</code></pre>

<h3 id="precode">代码区块</h3>

<p>和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 <code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 标签来把代码区块包起来。</p>

<p>要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：</p>

<pre><code>这是一个普通段落：

    这是一个代码区块。
</code></pre>

<p>Markdown 会转换成：</p>

<pre><code>&lt;p&gt;这是一个普通段落：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这是一个代码区块。
&lt;/code&gt;&lt;/pre&gt;
</code></pre>

<p>这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：</p>

<pre><code>Here is an example of AppleScript:

    tell application &quot;Foo&quot;
        beep
    end tell
</code></pre>

<p>会被转换为：</p>

<pre><code>&lt;p&gt;Here is an example of AppleScript:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tell application &quot;Foo&quot;
    beep
end tell
&lt;/code&gt;&lt;/pre&gt;
</code></pre>

<p>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。</p>

<p>在代码区块里面， <code>&amp;</code> 、 <code>&lt;</code> 和 <code>&gt;</code> 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如：</p>

<pre><code>    &lt;div class=&quot;footer&quot;&gt;
        &amp;copy; 2004 Foo Corporation
    &lt;/div&gt;
</code></pre>

<p>会被转换为：</p>

<pre><code>&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;footer&quot;&amp;gt;
    &amp;amp;copy; 2004 Foo Corporation
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</code></pre>

<p>代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。</p>

<h3 id="hr">分隔线</h3>

<p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>

<pre><code>- * *

***

*****

+ - -

---------------------------------------
</code></pre>

<hr />

<h2 id="span">区段元素</h2>

<h3 id="link">链接</h3>

<p>Markdown 支持两种形式的链接语法： *行内式*和*参考式*两种形式。</p>

<p>不管是哪一种，链接文字都是用 [方括号] 来标记。</p>

<p>要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：</p>

<pre><code>This is [an example](http://example.com/ &quot;Title&quot;) inline link.

[This link](http://example.net/) has no title attribute.
</code></pre>

<p>会产生：</p>

<pre><code>&lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&gt;
an example&lt;/a&gt; inline link.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has no
title attribute.&lt;/p&gt;
</code></pre>

<p>如果你是要链接到同样主机的资源，你可以使用相对路径：</p>

<pre><code>See my [About](/about/) page for details.  
</code></pre>

<p>参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：</p>

<pre><code>This is [an example][id] reference-style link.
</code></pre>

<p>你也可以选择性地在两个方括号中间加上一个空格：</p>

<pre><code>This is [an example] [id] reference-style link.
</code></pre>

<p>接着，在文件的任意处，你可以把这个标记的链接内容定义出来：</p>

<pre><code>[id]: http://example.com/  &quot;Optional Title Here&quot;
</code></pre>

<p>链接内容定义的形式为：</p>

<ul>
<li>方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字</li>
<li>接着一个冒号</li>
<li>接着一个以上的空格或制表符</li>
<li>接着链接的网址</li>
<li>选择性地接着 title 内容，可以用单引号、双引号或是括弧包着</li>
</ul>

<p>下面这三种链接的定义都是相同：</p>

<pre><code>[foo]: http://example.com/  &quot;Optional Title Here&quot;
[foo]: http://example.com/  'Optional Title Here'
[foo]: http://example.com/  (Optional Title Here)
</code></pre>

<p><strong>请注意</strong>：**有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。</p>

<p>链接网址也可以用尖括号包起来：</p>

<pre><code>[id]: &lt;http://example.com/&gt;  &quot;Optional Title Here&quot;
</code></pre>

<p>你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：</p>

<pre><code>[id]: http://example.com/longish/path/to/resource/here
    &quot;Optional Title Here&quot;
</code></pre>

<p>网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。</p>

<p>链接辨别标签可以有字母、数字、空白和标点符号，但是并*不*区分大小写，因此下面两个链接是一样的：</p>

<pre><code>[link text][a]
[link text][A]
</code></pre>

<p>隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成：</p>

<pre><code>[Google][]
</code></pre>

<p>然后定义链接内容：</p>

<pre><code>[Google]: http://google.com/
</code></pre>

<p>由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：</p>

<pre><code>Visit [Daring Fireball][] for more information.
</code></pre>

<p>然后接着定义链接：</p>

<pre><code>[Daring Fireball]: http://daringfireball.net/
</code></pre>

<p>链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。</p>

<p>下面是一个参考式链接的范例：</p>

<pre><code>I get 10 times more traffic from [Google] [1] than from
[Yahoo] [2] or [MSN] [3].

  [1]: http://google.com/        &quot;Google&quot;
  [2]: http://search.yahoo.com/  &quot;Yahoo Search&quot;
  [3]: http://search.msn.com/    &quot;MSN Search&quot;
</code></pre>

<p>如果改成用链接名称的方式写：</p>

<pre><code>I get 10 times more traffic from [Google][] than from
[Yahoo][] or [MSN][].

  [google]: http://google.com/        &quot;Google&quot;
  [yahoo]:  http://search.yahoo.com/  &quot;Yahoo Search&quot;
  [msn]:    http://search.msn.com/    &quot;MSN Search&quot;
</code></pre>

<p>上面两种写法都会产生下面的 HTML。</p>

<pre><code>&lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot;
title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from
&lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt;
or &lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt;
</code></pre>

<p>下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用</p>

<pre><code>I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;)
than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or
[MSN](http://search.msn.com/ &quot;MSN Search&quot;).
</code></pre>

<p>参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。</p>

<p>使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。</p>

<h3 id="em">强调</h3>

<p>Markdown 使用星号（<code>*</code>）和底线（<code>_</code>）作为标记强调字词的符号，被 <code>*</code> 或 <code>_</code> 包围的字词会被转成用 <code>&lt;em&gt;</code> 标签包围，用两个 <code>*</code> 或 <code>_</code> 包起来的话，则会被转成 <code>&lt;strong&gt;</code>，例如：</p>

<pre><code>*single asterisks*

_single underscores_

**double asterisks**

__double underscores__
</code></pre>

<p>会转成：</p>

<pre><code>&lt;em&gt;single asterisks&lt;/em&gt;

&lt;em&gt;single underscores&lt;/em&gt;

&lt;strong&gt;double asterisks&lt;/strong&gt;

&lt;strong&gt;double underscores&lt;/strong&gt;
</code></pre>

<p>你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。</p>

<p>强调也可以直接插在文字中间：</p>

<pre><code>un*frigging*believable
</code></pre>

<p>但是<strong>如果你的 <code>*</code> 和 <code>_</code> 两边都有空白的话，它们就只会被当成普通的符号</strong>。</p>

<p>如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：</p>

<pre><code>\*this text is surrounded by literal asterisks\*
</code></pre>

<h3 id="code">代码</h3>

<p>如果要标记一小段行内代码，你可以用反引号把它包起来（<code>`</code>），例如：</p>

<pre><code>Use the `printf()` function.
</code></pre>

<p>会产生：</p>

<pre><code>&lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt;
</code></pre>

<p>如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：</p>

<pre><code>``There is a literal backtick (`) here.``
</code></pre>

<p>这段语法会产生：</p>

<pre><code>&lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt;
</code></pre>

<p>代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：</p>

<pre><code>A single backtick in a code span: `` ` ``

A backtick-delimited string in a code span: `` `foo` ``
</code></pre>

<p>会产生：</p>

<pre><code>&lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt;
</code></pre>

<p>在代码区段内，<code>&amp;</code> 和尖括号<strong>都</strong>会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段：</p>

<pre><code>Please don't use any `&lt;blink&gt;` tags.
</code></pre>

<p>转为：</p>

<pre><code>&lt;p&gt;Please don't use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt;
</code></pre>

<p>你也可以这样写：</p>

<pre><code>`&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`.
</code></pre>

<p>以产生：</p>

<pre><code>&lt;p&gt;&lt;code&gt;&amp;amp;#8212;&lt;/code&gt; is the decimal-encoded
equivalent of &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;.&lt;/p&gt;
</code></pre>

<h3 id="img">图片</h3>

<p>很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。</p>

<p>Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： *行内式*和*参考式*。</p>

<p>行内式的图片语法看起来像是：</p>

<pre><code>![Alt text](/path/to/img.jpg)

![Alt text](/path/to/img.jpg &quot;Optional title&quot;)
</code></pre>

<p>详细叙述如下：</p>

<ul>
<li>一个惊叹号 <code>!</code></li>
<li>接着一个方括号，里面放上图片的替代文字</li>
<li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上
选择性的 &lsquo;title&rsquo; 文字。</li>
</ul>

<p>参考式的图片语法则长得像这样：</p>

<pre><code>![Alt text][id]
</code></pre>

<p>「id」是图片参考的名称，图片参考的定义方式则和链接参考一样：</p>

<pre><code>[id]: url/to/image  &quot;Optional title attribute&quot;
</code></pre>

<p>到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code> 标签。</p>

<hr />

<h2 id="misc">其它</h2>

<h3 id="autolink">自动链接</h3>

<p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p>

<pre><code>&lt;http://example.com/&gt;
</code></pre>

<p>Markdown 会转为：</p>

<pre><code>&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;
</code></pre>

<p>邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：</p>

<pre><code>&lt;address@example.com&gt;
</code></pre>

<p>Markdown 会转成：</p>

<pre><code>&lt;a href=&quot;&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;
&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;
&amp;#109;&quot;&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;
&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;
</code></pre>

<p>在浏览器里面，这段字串（其实是 <code>&lt;a href=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt;</code>）会变成一个可以点击的「address@example.com」链接。</p>

<p>（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）</p>

<h3 id="backslash">反斜杠</h3>

<p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 <code>&lt;em&gt;</code> 标签），你可以在星号的前面加上反斜杠：</p>

<pre><code>\*literal asterisks\*
</code></pre>

<p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p>

<pre><code>\   反斜线
`   反引号
-   星号
_   底线
{}  花括号
[]  方括号
()  括弧
#   井字号
*   加号
+   减号
.   英文句点
!   惊叹号
</code></pre>

<h2 id="acknowledgement">感谢</h2>

<p>感谢 <a href="https://twitter.com/#!/leafy7382">leafy7382</a> 协助翻译，<a href="http://iamhlb.com/">hlb</a>、<a href="http://twitter.com/randylien">Randylien</a> 帮忙润稿，<a href="https://twitter.com/#!/ethantw">ethantw</a> 的<a href="http://ethantw.net/projects/han/">汉字标准格式・CSS Reset</a>， <a href="http://kidwm.net/">WM</a> 回报文字错误。</p>

<p>感谢 <a href="https://github.com/fenprace">fenprace</a>，<a href="https://github.com/addv">addv</a>。</p>

<hr />

<h2 id="editor">Markdown 免费编辑器</h2>

<p>Windows 平台</p>

<ul>
<li><a href="http://markdownpad.com/">MarkdownPad</a></li>
<li><a href="http://code52.org/DownmarkerWPF/">MarkPad</a></li>
</ul>

<p>Linux 平台</p>

<ul>
<li><a href="http://sourceforge.net/p/retext/home/ReText/">ReText</a></li>
</ul>

<p>Mac 平台</p>

<ul>
<li><a href="http://mouapp.com/">Mou</a></li>
</ul>

<p>在线编辑器</p>

<ul>
<li><a href="http://markable.in/">Markable.in</a></li>
<li><a href="http://dillinger.io/">Dillinger.io</a></li>
</ul>

<p>浏览器插件</p>

<ul>
<li><a href="https://chrome.google.com/webstore/detail/oknndfeeopgpibecfjljjfanledpbkog">MaDe</a> (Chrome)</li>
</ul>

<p>高级应用</p>

<ul>
<li><p><a href="http://www.sublimetext.com/2">Sublime Text 2</a> + <a href="http://ttscoff.github.com/MarkdownEditing/">MarkdownEditing</a> / <a href="http://lucifr.com/2012/07/12/markdownediting-for-sublime-text-2/">教程</a></p></li>

<li><p>如有更好的 Markdown 免费编辑器推荐，请到<del><a href="https://gitcafe.com/riku/Markdown-Syntax-CN/tickets/1">这里反馈</a></del>，谢谢！</p></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title></title>
			<link>https://gitop.cc/posts/postgres_data_type/</link>
			<pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
			
			<guid>https://gitop.cc/posts/postgres_data_type/</guid>
			<description>类型介绍 类型分类 PostgreSQL支持的数据类型分类如表：
   类型 说明 对比其他数据库     布尔类型 PostgreSQL支持SQL标准的boolean数据类型 与MySQL的BOOL、BOOLEAN类型相同，使用一字节存储空间   数值类型 整数类型有2字节的smallint、4字节的int、8字节的bigint，十进制精确类型有numeric，浮点类型有real和double precision。还有8字节的货币(money)类型 无MySQL的unsigned整数类型，也无MySQL 1字节长的tinyint整数类型和3字节长的medium int整数类型   字符类型 有varchar(n)、char(n)、text三种类型 PostgreSQL中的varchar(n)最大可以存储1GB，而MySQL中的varchar(n)最大只能是64KB。PostgreSQL中的text类型相当于MySQL中的LONGTEXT类型   二进制数据类型 只有一种bytea 对应MySQL的BLOB和LONGBLOB类型   位串类型 位串就是一串1和0的字符串，有bit(n)、bit varying(n)两种 N/A   日期和时间类型 有date、time、timestamp，而time和timestamp又分是否包括时区的两种类型 在PostgreSQL中，可以精确到秒以下，如毫秒。而MySQL的时间类型最多只能精确到秒，其日期时间的范围也与MySQL差异较大   枚举类型 枚举类型是一种包含一系列有序静态值集合的数据类型，等于某些编程语言中的enum类型 PostgreSQL使用枚举类型前需要先使用CREATE TYPE创建这个类型。MySQL也有枚举类型(ENUM)   几何类型 包括了点(point)、直线(line)、线段(lseg)、路径(path)、多边形(polygon)、圆(cycle)等类型 N/A   网络地址类型 有cidr、inet、macaddr三种类型 N/A   数组类型 可以存储一个数组 N/A   复合类型 可以把已有的简单类型组合成用户自定义的类型，就如C语言中的结构体一样 对应其他数据库的自定义类型   xml类型 可以存储XML数据的类型 N/A   json类型 可以存储json类型的数据 N/A   range类型 可以存储范围数据 N/A   对象标识符类型 PostgreSQL内部标识对象的类型，如oid类型、regproc类型、regclass类型等 N/A   伪类型 伪类型不能作为字段的数据类型，但是它可以用于声明一个函数的参数或者结果类型。有any、anyarray、anyelement、cstring、internal、language_handler、record、trigger、void、opaque N/A   其他类型 一些不好分类的类型都放到这里，如UUID类型、pg_Isn类型 N/A    为了提高SQL的兼容性，部分类型还有很多别名。</description>
			<content type="html"><![CDATA[

<h2 id="类型介绍">类型介绍</h2>

<h3 id="类型分类">类型分类</h3>

<p>PostgreSQL支持的数据类型分类如表：</p>

<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>对比其他数据库</th>
</tr>
</thead>

<tbody>
<tr>
<td>布尔类型</td>
<td>PostgreSQL支持SQL标准的boolean数据类型</td>
<td>与MySQL的BOOL、BOOLEAN类型相同，使用一字节存储空间</td>
</tr>

<tr>
<td>数值类型</td>
<td>整数类型有2字节的smallint、4字节的int、8字节的bigint，十进制精确类型有numeric，浮点类型有real和double precision。还有8字节的货币(money)类型</td>
<td>无MySQL的unsigned整数类型，也无MySQL 1字节长的tinyint整数类型和3字节长的medium int整数类型</td>
</tr>

<tr>
<td>字符类型</td>
<td>有varchar(n)、char(n)、text三种类型</td>
<td>PostgreSQL中的varchar(n)最大可以存储1GB，而MySQL中的varchar(n)最大只能是64KB。PostgreSQL中的text类型相当于MySQL中的LONGTEXT类型</td>
</tr>

<tr>
<td>二进制数据类型</td>
<td>只有一种bytea</td>
<td>对应MySQL的BLOB和LONGBLOB类型</td>
</tr>

<tr>
<td>位串类型</td>
<td>位串就是一串1和0的字符串，有bit(n)、bit varying(n)两种</td>
<td>N/A</td>
</tr>

<tr>
<td>日期和时间类型</td>
<td>有date、time、timestamp，而time和timestamp又分是否包括时区的两种类型</td>
<td>在PostgreSQL中，可以精确到秒以下，如毫秒。而MySQL的时间类型最多只能精确到秒，其日期时间的范围也与MySQL差异较大</td>
</tr>

<tr>
<td>枚举类型</td>
<td>枚举类型是一种包含一系列有序静态值集合的数据类型，等于某些编程语言中的enum类型</td>
<td>PostgreSQL使用枚举类型前需要先使用CREATE TYPE创建这个类型。MySQL也有枚举类型(ENUM)</td>
</tr>

<tr>
<td>几何类型</td>
<td>包括了点(point)、直线(line)、线段(lseg)、路径(path)、多边形(polygon)、圆(cycle)等类型</td>
<td>N/A</td>
</tr>

<tr>
<td>网络地址类型</td>
<td>有cidr、inet、macaddr三种类型</td>
<td>N/A</td>
</tr>

<tr>
<td>数组类型</td>
<td>可以存储一个数组</td>
<td>N/A</td>
</tr>

<tr>
<td>复合类型</td>
<td>可以把已有的简单类型组合成用户自定义的类型，就如C语言中的结构体一样</td>
<td>对应其他数据库的自定义类型</td>
</tr>

<tr>
<td>xml类型</td>
<td>可以存储XML数据的类型</td>
<td>N/A</td>
</tr>

<tr>
<td>json类型</td>
<td>可以存储json类型的数据</td>
<td>N/A</td>
</tr>

<tr>
<td>range类型</td>
<td>可以存储范围数据</td>
<td>N/A</td>
</tr>

<tr>
<td>对象标识符类型</td>
<td>PostgreSQL内部标识对象的类型，如oid类型、regproc类型、regclass类型等</td>
<td>N/A</td>
</tr>

<tr>
<td>伪类型</td>
<td>伪类型不能作为字段的数据类型，但是它可以用于声明一个函数的参数或者结果类型。有any、anyarray、anyelement、cstring、internal、language_handler、record、trigger、void、opaque</td>
<td>N/A</td>
</tr>

<tr>
<td>其他类型</td>
<td>一些不好分类的类型都放到这里，如UUID类型、pg_Isn类型</td>
<td>N/A</td>
</tr>
</tbody>
</table>

<p>为了提高SQL的兼容性，部分类型还有很多别名。</p>

<table>
<thead>
<tr>
<th>类型</th>
<th>别名</th>
</tr>
</thead>

<tbody>
<tr>
<td>integer</td>
<td>int、int4</td>
</tr>

<tr>
<td>smallint</td>
<td>int2</td>
</tr>

<tr>
<td>bigint</td>
<td>int8</td>
</tr>

<tr>
<td>char varying(n)</td>
<td>varchar(n)</td>
</tr>

<tr>
<td>numeric(m,n)</td>
<td>decimal(m,n)</td>
</tr>
</tbody>
</table>

<h3 id="类型输入与转换">类型输入与转换</h3>

<p>对于一些简单的类型，如数字及字符串，使用通常的方法输入就可以了：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># select 1, 1.1421, &#39;hello world&#39;;</span>
 ?column? <span class="p">|</span> ?column? <span class="p">|</span>  ?column?
----------+----------+-------------
        <span class="m">1</span> <span class="p">|</span>   <span class="m">1</span>.1421 <span class="p">|</span> hello world
<span class="o">(</span><span class="m">1</span> row<span class="o">)</span></code></pre></div>
<p>对于其他的复杂类型，可以使用“类型名”加上单引号括起来的类型值进行输入：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># select bit &#39;11100011&#39;;</span>
   bit
----------
 <span class="m">11100011</span>
<span class="o">(</span><span class="m">1</span> row<span class="o">)</span></code></pre></div>
<p>所有类型都可以使用上面的输入方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># select int &#39;2&#39; * int &#39;5&#39;;</span>
 ?column?
----------
       <span class="m">10</span>
<span class="o">(</span><span class="m">1</span> row<span class="o">)</span></code></pre></div>
<p>PostgreSQL支持使用标准SQL的类型转换函数<code>cast</code>进行类型转换：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># select cast(&#39;5&#39; as int), cast(&#39;2018-09-12&#39; as date);</span>
 int4 <span class="p">|</span>    date
------+------------
    <span class="m">5</span> <span class="p">|</span> <span class="m">2018</span>-09-12
<span class="o">(</span><span class="m">1</span> row<span class="o">)</span></code></pre></div>
<p>此外，PostgreSQL还有一种更简洁的类型转换方式，即双冒号转换：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># select &#39;5&#39;::int, &#39;2018-09-12&#39;::date;</span>
 int4 <span class="p">|</span>    date
------+------------
    <span class="m">5</span> <span class="p">|</span> <span class="m">2018</span>-09-12
<span class="o">(</span><span class="m">1</span> row<span class="o">)</span></code></pre></div>
<h2 id="布尔类型">布尔类型</h2>

<table>
<thead>
<tr>
<th>类型</th>
<th>值</th>
</tr>
</thead>

<tbody>
<tr>
<td>bool</td>
<td>true, false, &lsquo;true&rsquo;, &lsquo;false&rsquo;, &lsquo;yes&rsquo;, &lsquo;no&rsquo;（不区分大小写）</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># select true, false, &#39;true&#39;::bool, &#39;false&#39;::bool, &#39;yes&#39;::bool, &#39;no&#39;::bool;</span>
 bool <span class="p">|</span> bool <span class="p">|</span> bool <span class="p">|</span> bool <span class="p">|</span> bool <span class="p">|</span> bool
------+------+------+------+------+------
 t    <span class="p">|</span> f    <span class="p">|</span> t    <span class="p">|</span> f    <span class="p">|</span> t    <span class="p">|</span> f
<span class="o">(</span><span class="m">1</span> row<span class="o">)</span></code></pre></div>
<p>SQL使用三值的布尔逻辑：TRUE、FALSE和NULL，其中NULL代表“未知“</p>

<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>a and b</th>
<th>a or b</th>
</tr>
</thead>

<tbody>
<tr>
<td>t</td>
<td>t</td>
<td>t</td>
<td>t</td>
</tr>

<tr>
<td>t</td>
<td>f</td>
<td>f</td>
<td>t</td>
</tr>

<tr>
<td>t</td>
<td>null</td>
<td>null</td>
<td>t</td>
</tr>

<tr>
<td>f</td>
<td>f</td>
<td>f</td>
<td>f</td>
</tr>

<tr>
<td>f</td>
<td>null</td>
<td>f</td>
<td>null</td>
</tr>

<tr>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th>a</th>
<th>not a</th>
</tr>
</thead>

<tbody>
<tr>
<td>t</td>
<td>f</td>
</tr>

<tr>
<td>f</td>
<td>t</td>
</tr>

<tr>
<td>null</td>
<td>null</td>
</tr>
</tbody>
</table>

<p>布尔类型可以使用“IS”比较运算符：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">expression is <span class="nb">true</span>
expression is not <span class="nb">true</span>
expression is <span class="nb">false</span>
expression is not <span class="nb">false</span>
expression is unknown
expression is not unknown</code></pre></div>
<h2 id="数值类型">数值类型</h2>

<table>
<thead>
<tr>
<th>类型名</th>
<th>存储空间</th>
<th>范围</th>
</tr>
</thead>

<tbody>
<tr>
<td>smallint</td>
<td>2字节</td>
<td>-2^15~2^15-1</td>
</tr>

<tr>
<td>integer</td>
<td>4字节</td>
<td>-2^31~2^31-1</td>
</tr>

<tr>
<td>bigint</td>
<td>8字节</td>
<td>-2^63~2^63-1</td>
</tr>

<tr>
<td>numeric</td>
<td>变长</td>
<td>无限制</td>
</tr>

<tr>
<td>real</td>
<td>4字节</td>
<td>6位十进制数字精度</td>
</tr>

<tr>
<td>double precision</td>
<td>8字节</td>
<td>15位十进制数字精度</td>
</tr>

<tr>
<td>serial</td>
<td>4字节</td>
<td>1~2^31-1</td>
</tr>

<tr>
<td>bigserial</td>
<td>8字节</td>
<td>1~2^63-1</td>
</tr>
</tbody>
</table>

<h3 id="精确的小数类型">精确的小数类型</h3>
]]></content>
		</item>
		
	</channel>
</rss>
