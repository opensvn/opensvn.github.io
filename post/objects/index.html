<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>对象 - 招财猫的博客</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="招财猫" /><meta name="description" content="对象的属性也有属性： 可写属性指定属性的值是否可以设置。 枚举属性指定属性名是否能由for/in循环返回。 可配置属性指定属性是否可以删除和更改。" /><meta name="keywords" content="Emacs, Cocos2d, Graphics" />






<meta name="generator" content="Hugo 0.70.0 with theme even" />


<link rel="canonical" href="https://gitop.cc/post/objects/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.78f8f17bab244b9ee62ad16480c9584d5fc2db06ae20681d1ca225cefd80767c.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="对象" />
<meta property="og:description" content="对象的属性也有属性： 可写属性指定属性的值是否可以设置。 枚举属性指定属性名是否能由for/in循环返回。 可配置属性指定属性是否可以删除和更改。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://gitop.cc/post/objects/" />
<meta property="article:published_time" content="2018-11-03T21:39:25+08:00" />
<meta property="article:modified_time" content="2018-11-03T21:39:25+08:00" />
<meta itemprop="name" content="对象">
<meta itemprop="description" content="对象的属性也有属性： 可写属性指定属性的值是否可以设置。 枚举属性指定属性名是否能由for/in循环返回。 可配置属性指定属性是否可以删除和更改。">
<meta itemprop="datePublished" content="2018-11-03T21:39:25&#43;08:00" />
<meta itemprop="dateModified" content="2018-11-03T21:39:25&#43;08:00" />
<meta itemprop="wordCount" content="9668">



<meta itemprop="keywords" content="Javascript," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="对象"/>
<meta name="twitter:description" content="对象的属性也有属性： 可写属性指定属性的值是否可以设置。 枚举属性指定属性名是否能由for/in循环返回。 可配置属性指定属性是否可以删除和更改。"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">招财猫的博客</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">招财猫的博客</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">对象</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-11-03 </span>
        <div class="post-category">
            <a href="/categories/language/"> Language </a>
            </div>
          <span class="more-meta"> 约 9668 字 </span>
          <span class="more-meta"> 预计阅读 20 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#创建对象">创建对象</a></li>
        <li><a href="#查询和设置属性">查询和设置属性</a></li>
        <li><a href="#删除属性">删除属性</a></li>
        <li><a href="#测试属性">测试属性</a></li>
        <li><a href="#枚举属性">枚举属性</a></li>
        <li><a href="#属性getter和setter">属性getter和setter</a></li>
        <li><a href="#属性的属性">属性的属性</a></li>
        <li><a href="#对象属性">对象属性</a></li>
        <li><a href="#序列化对象">序列化对象</a></li>
        <li><a href="#对象方法">对象方法</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>对象的属性也有属性：</p>
<ul>
<li>可写属性指定属性的值是否可以设置。</li>
<li>枚举属性指定属性名是否能由for/in循环返回。</li>
<li>可配置属性指定属性是否可以删除和更改。</li>
</ul>
<p>在ES5之前，自己代码创建的对象中的所有属性都是可写的、可枚举的和可配置的。每个对象都有三个相关的对象属性：</p>
<ul>
<li>对象的prototype是对另一个对象的引用，从这个对象继承属性。</li>
<li>对象的class是区分对象类型的字符串。</li>
<li>对象的可扩展标志（ES5）指定是否可以向对象添加新的属性。</li>
</ul>
<p>我们使用以下术语来区分三大类JavaScript对象和两类属性：</p>
<ul>
<li>原生对象是由ECMAScript规范定义的对象。Array、function、Date和RegExp都是是原生对象。</li>
<li>宿主对象是由嵌入JavaScript解释器的宿主环境（如web浏览器）定义的对象。在客户端JavaScript中表示web页面结构的HTMLElement对象就是宿主对象。</li>
<li>用户定义对象是JavaScript代码执行时创建的任何对象。</li>
<li>自有属性是对象本身定义的属性。</li>
<li>继承属性是由原型对象定义的属性。</li>
</ul>
<h3 id="创建对象">创建对象</h3>
<h4 id="对象字面值">对象字面值</h4>
<p>对象字面值用逗号分隔的键值对。属性名是JavaScript标识符或字符串字面值（允许空字符串）。属性值是任何JavaScript表达式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="o">:</span><span class="mi">2</span><span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>
<p>在ES5中，保留字可以作为属性名使用，不需要用引号括起来。在ES3中保留字作为属性名必须用引号括起来。在ES5中，最后一个属性后面的逗号被忽略。在大多数ES3实现中，结尾逗号被忽略，但IE认为它们是错误的。</p>
<h4 id="用new创建对象">用new创建对象</h4>
<p>new操作符创建并初始化一个新对象。其后面必须有一个构造函数，用于初始化新创建的对象。JavaScript包含原生类型的内置构造函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span> <span class="c1">// Create an empty object: same as {}.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">();</span> <span class="c1">// Create an empty array: same as [].
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">();</span> <span class="c1">// Create a Date object representing the current time
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">r</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">RegExp</span><span class="p">(</span><span class="s2">&#34;js&#34;</span><span class="p">);</span> <span class="c1">// Create a RegExp object for pattern matching.
</span></code></pre></td></tr></table>
</div>
</div>
<h4 id="原型">原型</h4>
<p>每个JavaScript对象都有一个与之关联的原型对象。JavaScript对象从原型对象继承属性。</p>
<p>由对象字面值创建的所有对象都有相同的原型对象，这个原型对象是Object.prototype。使用new关键字和构造函数创建的对象的原型是构造函数的prototype属性。因此，new object()创建的对象继承自Object.prototype。new Array()创建的对象使用Array.prototype作为其原型，由new Date()创建的对象使用 Date.prototype作为原型。</p>
<p>Object.prototype是少有的没有原型的对象，它不继承任何属性。其他原型对象是有原型的普通对象。所有内置的构造函数（以及大多数用户定义的构造函数）都继承自Object.prototype。这一系列链接的原型对象被称为原型链。</p>
<h4 id="objectcreate">Object.create()</h4>
<p>ES5定义了一个方法Object.create()用于创建对象。第一个参数指定对象的原型。第二个参数可选，用于描述新对象的属性。Object.create()是一个静态函数，而不是方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o1</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span><span class="mi">2</span><span class="p">});</span> <span class="c1">// o1 inherits properties x and y.
</span></code></pre></td></tr></table>
</div>
</div>
<p>您可以传递null来创建一个没有原型的新对象，该对象没有继承任何东西：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o2</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span> <span class="c1">// o2 inherits no props or methods.
</span></code></pre></td></tr></table>
</div>
</div>
<p>如果您想创建一个普通的空对象（比如{}返回的对象或new object()），Object.prototype：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o3</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span> <span class="c1">// o3 is like {} or new Object().
</span></code></pre></td></tr></table>
</div>
</div>
<p>我们可以在ES3中用下面这个函数模拟它：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">// inherit() returns a newly created object that inherits properties from the
</span><span class="c1">// prototype object p. It uses the ECMAScript 5 function Object.create() if
</span><span class="c1">// it is defined, and otherwise falls back to an older technique.
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">inherit</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">p</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">TypeError</span><span class="p">();</span> <span class="c1">// p must be a non-null object
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">)</span> <span class="c1">// If Object.create() is defined...
</span><span class="c1"></span>        <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span> <span class="c1">// then just use it.
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">t</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">p</span><span class="p">;</span> <span class="c1">// Otherwise do some more type checking
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">t</span> <span class="o">!==</span> <span class="s2">&#34;object&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">t</span> <span class="o">!==</span> <span class="s2">&#34;function&#34;</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">TypeError</span><span class="p">();</span>
    <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{};</span> <span class="c1">// Define a dummy constructor function.
</span><span class="c1"></span>    <span class="nx">f</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">p</span><span class="p">;</span> <span class="c1">// Set its prototype property to p.
</span><span class="c1"></span>    <span class="k">return</span> <span class="k">new</span> <span class="nx">f</span><span class="p">();</span> <span class="c1">// Use f() to create an &#34;heir&#34; of p.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>
<p>inherit()函数的一种用法是当你想防止你无法控制的库函数无意修改对象时使用。不直接将对象传递给函数，而是传递一个继承对象。如果函数读取继承对象的属性，它将看到继承的值。如果它设置属性，这些属性只会影响继承对象，而不会影响原始对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span><span class="o">:</span> <span class="s2">&#34;don&#39;t change this value&#34;</span> <span class="p">};</span>
<span class="nx">library_function</span><span class="p">(</span><span class="nx">inherit</span><span class="p">(</span><span class="nx">o</span><span class="p">));</span> <span class="c1">// Guard against accidental modifications of o
</span></code></pre></td></tr></table>
</div>
</div>
<h3 id="查询和设置属性">查询和设置属性</h3>
<p>使用.或[]获取属性。运算符左边是一个值为对象的表达式。如果使用点运算符，右边必须是一个表示属性名字的简单的标识符。如果使用方括号，方括号中的值必须是结果为字符串的表达式，该字符串包含所需的属性名：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">author</span> <span class="o">=</span> <span class="nx">book</span><span class="p">.</span><span class="nx">author</span><span class="p">;</span> <span class="c1">// Get the &#34;author&#34; property of the book.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">author</span><span class="p">.</span><span class="nx">surname</span> <span class="c1">// Get the &#34;surname&#34; property of the author.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">title</span> <span class="o">=</span> <span class="nx">book</span><span class="p">[</span><span class="s2">&#34;main title&#34;</span><span class="p">]</span> <span class="c1">// Get the &#34;main title&#34; property of the book.
</span></code></pre></td></tr></table>
</div>
</div>
<p>要创建或设置属性，将.或[]表达式放在等号左边：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">book</span><span class="p">.</span><span class="nx">edition</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="c1">// Create an &#34;edition&#34; property of book.
</span><span class="c1"></span><span class="nx">book</span><span class="p">[</span><span class="s2">&#34;main title&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&#34;ECMAScript&#34;</span><span class="p">;</span> <span class="c1">// Set the &#34;main title&#34; property.
</span></code></pre></td></tr></table>
</div>
</div>
<p>在ES3中，点操作符后面的标识符不能是保留字，ES5放宽了这个限制。</p>
<h4 id="继承">继承</h4>
<p>JavaScript对象有一组“自己的属性”，它们也从原型对象继承一组属性：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1">// o inherits object methods from Object.prototype
</span><span class="c1"></span><span class="nx">o</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// and has an own property x.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nx">inherit</span><span class="p">(</span><span class="nx">o</span><span class="p">);</span> <span class="c1">// p inherits properties from o and Object.prototype
</span><span class="c1"></span><span class="nx">p</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// and has an own property y.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">q</span> <span class="o">=</span> <span class="nx">inherit</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span> <span class="c1">// q inherits properties from p, o, and Object.prototype
</span><span class="c1"></span><span class="nx">q</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// and has an own property z.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">s</span> <span class="o">=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span> <span class="c1">// toString is inherited from Object.prototype
</span><span class="c1"></span><span class="nx">q</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">q</span><span class="p">.</span><span class="nx">y</span> <span class="c1">// =&gt; 3: x and y are inherited from o and p
</span></code></pre></td></tr></table>
</div>
</div>
<p>假设你给对象o的属性x赋值。如果o已经有了一个自己的属性x，那么赋值只会改变这个现有属性的值。否则赋值将在对象o上创建一个名为x的新属性。如果o之前继承了属性x，那么这个继承的属性现在被新创建的同名属性所隐藏。</p>
<p>属性赋值检查原型链以确定是否允许赋值。如果o继承一个名为x的只读属性，则不允许赋值。如果允许赋值，则总是在原对象中创建或设置一个属性，并且从不修改原型链。继承发生在查询属性时，而不是设置属性时，这是JavaScript的一个关键特性，因为它允许我们有选择地覆盖继承属性：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">unitcircle</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">r</span><span class="o">:</span><span class="mi">1</span> <span class="p">};</span> <span class="c1">// An object to inherit from
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">inherit</span><span class="p">(</span><span class="nx">unitcircle</span><span class="p">);</span> <span class="c1">// c inherits the property r
</span><span class="c1"></span><span class="nx">c</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// c defines two properties of its own
</span><span class="c1"></span><span class="nx">c</span><span class="p">.</span><span class="nx">r</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// c overrides its inherited property
</span><span class="c1"></span><span class="nx">unitcircle</span><span class="p">.</span><span class="nx">r</span><span class="p">;</span> <span class="c1">// =&gt; 1: the prototype object is not affected
</span></code></pre></td></tr></table>
</div>
</div>
<p>如果o继承了一个带有setter方法的访问属性x，则调用该setter方法，而不是在o中创建新的属性x。但是setter方法是在对象o上调用的，因此如果setter方法定义了任何属性，都作用于o上，不会修改原型链。</p>
<h4 id="属性访问错误">属性访问错误</h4>
<p>查询不存在的属性不是错误。如果属性x不是o的自有属性或继承属性，则o.x值为undefined。null和undefined没有属性，查询或者设置它们的属性抛出TypeError。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">// A verbose and explicit technique
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">len</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">book</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">book</span><span class="p">.</span><span class="nx">subtitle</span><span class="p">)</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">book</span><span class="p">.</span><span class="nx">subtitle</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// A concise and idiomatic alternative to get subtitle length or undefined
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">book</span> <span class="o">&amp;&amp;</span> <span class="nx">book</span><span class="p">.</span><span class="nx">subtitle</span> <span class="o">&amp;&amp;</span> <span class="nx">book</span><span class="p">.</span><span class="nx">subtitle</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div>
<p>设置属性不总是成功的：有些属性是只读的，不能设置，有些对象不允许添加新属性。这些操作通常是悄悄失败的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">// The prototype properties of built-in constructors are read-only.
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Assignment fails silently; Object.prototype unchanged
</span></code></pre></td></tr></table>
</div>
</div>
<p>在ES5严格模式下，任何设置属性失败都会抛出TypeError。设置对象o的属性p在以下情况失败：</p>
<ul>
<li>o有一个只读属性p，不能设置只读属性。</li>
<li>o有只读的继承属性p，不能使用同名的属性隐藏继承的只读属性。</li>
<li>o没有自有属性p，o也没有通过setter方法继承属性p，而且o的可扩展属性为false。</li>
</ul>
<h3 id="删除属性">删除属性</h3>
<p>delete从对象中删除属性，它的操作数是一个属性访问表达式。delete并不操作属性的值，而是操作属性本身：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">delete</span> <span class="nx">book</span><span class="p">.</span><span class="nx">author</span><span class="p">;</span> <span class="c1">// The book object now has no author property.
</span><span class="c1"></span><span class="k">delete</span> <span class="nx">book</span><span class="p">[</span><span class="s2">&#34;main title&#34;</span><span class="p">];</span> <span class="c1">// Now it doesn&#39;t have &#34;main title&#34;, either.
</span></code></pre></td></tr></table>
</div>
</div>
<p>delete操作符只删除自己的属性，而不删除继承的属性。要删除继承的属性，必须从定义它的原型对象中删除它。这样做会影响从原型继承的每个对象。delete删除成功或删除没有效果时，返回true：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">o</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span><span class="mi">1</span><span class="p">};</span> <span class="c1">// o has own property x and inherits property toString
</span><span class="c1"></span><span class="k">delete</span> <span class="nx">o</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span> <span class="c1">// Delete x, and return true
</span><span class="c1"></span><span class="k">delete</span> <span class="nx">o</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span> <span class="c1">// Do nothing (x doesn&#39;t exist), and return true
</span><span class="c1"></span><span class="k">delete</span> <span class="nx">o</span><span class="p">.</span><span class="nx">toString</span><span class="p">;</span> <span class="c1">// Do nothing (toString isn&#39;t an own property), return true
</span><span class="c1"></span><span class="k">delete</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// Nonsense, but evaluates to true
</span></code></pre></td></tr></table>
</div>
</div>
<p>delete不会删除不可配置的属性，但是它可以删除不可扩展对象的可配置属性。内置对象的某些属性是不可配置的，通过变量声明和函数声明创建的全局对象的属性也是不可配置的。在严格模式下，删除不可配置属性会导致TypeError。在非严格模式下，delete返回false：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">delete</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span> <span class="c1">// Can&#39;t delete; property is non-configurable
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// Declare a global variable
</span><span class="c1"></span><span class="k">delete</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span> <span class="c1">// Can&#39;t delete this property
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// Declare a global function
</span><span class="c1"></span><span class="k">delete</span> <span class="k">this</span><span class="p">.</span><span class="nx">f</span><span class="p">;</span> <span class="c1">// Can&#39;t delete this property either
</span></code></pre></td></tr></table>
</div>
</div>
<p>在非严格模式下删除全局对象的可配置属性时，可以省略this：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// Create a configurable global property (no var)
</span><span class="c1"></span><span class="k">delete</span> <span class="nx">x</span><span class="p">;</span> <span class="c1">// And delete it
</span></code></pre></td></tr></table>
</div>
</div>
<p>在严格模式下，如果delete的操作数是一个非限定的标识符，那么就会引发SyntaxError：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">delete</span> <span class="nx">x</span><span class="p">;</span> <span class="c1">// SyntaxError in strict mode
</span><span class="c1"></span><span class="k">delete</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span> <span class="c1">// This works
</span></code></pre></td></tr></table>
</div>
</div>
<h3 id="测试属性">测试属性</h3>
<p>in操作符左边是一个属性名，右边是一个对象。如果对象这个名字的自有属性或继承的属性，则返回true：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span><span class="o">:</span> <span class="mi">1</span> <span class="p">}</span>
<span class="s2">&#34;x&#34;</span> <span class="k">in</span> <span class="nx">o</span><span class="p">;</span> <span class="c1">// true: o has an own property &#34;x&#34;
</span><span class="c1"></span><span class="s2">&#34;y&#34;</span> <span class="k">in</span> <span class="nx">o</span><span class="p">;</span> <span class="c1">// false: o doesn&#39;t have a property &#34;y&#34;
</span><span class="c1"></span><span class="s2">&#34;toString&#34;</span> <span class="k">in</span> <span class="nx">o</span><span class="p">;</span> <span class="c1">// true: o inherits a toString property
</span></code></pre></td></tr></table>
</div>
</div>
<p>对象的hasOwnProperty()方法测试该对象是否具有具有给定名称的自己的属性。对于继承的属性，返回false：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript">
</code></pre></td></tr></table>
</div>
</div>
<p>propertyIsEnumerable()只有当指定的属性是自己的属性且是可枚举的时，它才返回true：</p>
<p><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="nx">inherit</span><span class="p">({</span><span class="nx">y</span><span class="o">:</span> <span class="mi">2</span><span class="p">});</span>
<span class="nx">o</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">o</span><span class="p">.</span><span class="nx">propertyIsEnumerable</span><span class="p">(</span><span class="s2">&#34;x&#34;</span><span class="p">);</span> <span class="c1">// true: o has an own enumerable property x
</span><span class="c1"></span><span class="nx">o</span><span class="p">.</span><span class="nx">propertyIsEnumerable</span><span class="p">(</span><span class="s2">&#34;y&#34;</span><span class="p">);</span> <span class="c1">// false: y is inherited, not own
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">propertyIsEnumerable</span><span class="p">(</span><span class="s2">&#34;toString&#34;</span><span class="p">);</span> <span class="c1">// false: not enumerable
</span></code></pre></td></tr></table>
</div>
</div>
通常查询属性只需简单使用!==来确保它不是undefined：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span><span class="o">:</span> <span class="mi">1</span> <span class="p">}</span>
<span class="nx">o</span><span class="p">.</span><span class="nx">x</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span> <span class="c1">// true: o has a property x
</span><span class="c1"></span>
<span class="nx">o</span><span class="p">.</span><span class="nx">y</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span> <span class="c1">// false: o doesn&#39;t have a property y
</span><span class="c1"></span><span class="nx">o</span><span class="p">.</span><span class="nx">toString</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span> <span class="c1">// true: o inherits a toString property
</span></code></pre></td></tr></table>
</div>
</div>
<p>有一件事是in操作符可以做的，而上面所示的简单属性访问技术做不到的。in可以区分不存在的属性和设置为undefined 的属性：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">x</span><span class="o">:</span> <span class="kc">undefined</span> <span class="p">}</span> <span class="c1">// Property is explicitly set to undefined
</span><span class="c1"></span><span class="nx">o</span><span class="p">.</span><span class="nx">x</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="c1">// false: property exists but is undefined
</span><span class="c1"></span><span class="nx">o</span><span class="p">.</span><span class="nx">y</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="c1">// false: property doesn&#39;t even exist
</span><span class="c1"></span><span class="s2">&#34;x&#34;</span> <span class="k">in</span> <span class="nx">o</span> <span class="c1">// true: the property exists
</span><span class="c1"></span><span class="s2">&#34;y&#34;</span> <span class="k">in</span> <span class="nx">o</span> <span class="c1">// false: the property doesn&#39;t exists
</span><span class="c1"></span><span class="k">delete</span> <span class="nx">o</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span> <span class="c1">// Delete the property x
</span><span class="c1"></span><span class="s2">&#34;x&#34;</span> <span class="k">in</span> <span class="nx">o</span> <span class="c1">// false: it doesn&#39;t exist anymore
</span></code></pre></td></tr></table>
</div>
</div>
<h3 id="枚举属性">枚举属性</h3>
<p>通常使用for/in循环来枚举属性。对象继承来的内置方法是不可枚举的，但是自己代码添加的属性是可枚举的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span><span class="mi">2</span><span class="p">,</span> <span class="nx">z</span><span class="o">:</span><span class="mi">3</span><span class="p">};</span> <span class="c1">// Three enumerable own properties
</span><span class="c1"></span><span class="nx">o</span><span class="p">.</span><span class="nx">propertyIsEnumerable</span><span class="p">(</span><span class="s2">&#34;toString&#34;</span><span class="p">)</span> <span class="c1">// =&gt; false: not enumerable
</span><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="nx">p</span> <span class="k">in</span> <span class="nx">o</span><span class="p">)</span> <span class="c1">// Loop through the properties
</span><span class="c1"></span>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span> <span class="c1">// Prints x, y, and z, but not toString
</span></code></pre></td></tr></table>
</div>
</div>
<p>一些库向会添加新方法或属性到Object.prototype，以便所有对象可以继承和使用用。在ES5之前，没有办法使这些属性不可枚举，因此for/in循环可以枚举它们。为了防止这种情况发生，您可能需要过滤for/in返回的属性：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="k">for</span><span class="p">(</span><span class="nx">p</span> <span class="k">in</span> <span class="nx">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">o</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">p</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span> <span class="c1">// Skip inherited properties
</span><span class="c1"></span><span class="p">}</span>

<span class="k">for</span><span class="p">(</span><span class="nx">p</span> <span class="k">in</span> <span class="nx">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">o</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="o">===</span> <span class="s2">&#34;function&#34;</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span> <span class="c1">// Skip methods
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>
<p>下面定义了几个实用函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="cm">/*
</span><span class="cm">* Copy the enumerable properties of p to o, and return o.
</span><span class="cm">* If o and p have a property by the same name, o&#39;s property is overwritten.
</span><span class="cm">* This function does not handle getters and setters or copy attributes.
</span><span class="cm">*/</span>
<span class="kd">function</span> <span class="nx">extend</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="nx">prop</span> <span class="k">in</span> <span class="nx">p</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// For all props in p.
</span><span class="c1"></span>        <span class="nx">o</span><span class="p">[</span><span class="nx">prop</span><span class="p">]</span> <span class="o">=</span> <span class="nx">p</span><span class="p">[</span><span class="nx">prop</span><span class="p">];</span> <span class="c1">// Add the property to o.
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">o</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
</span><span class="cm">* Copy the enumerable properties of p to o, and return o.
</span><span class="cm">* If o and p have a property by the same name, o&#39;s property is left alone.
</span><span class="cm">* This function does not handle getters and setters or copy attributes.
</span><span class="cm">*/</span>
<span class="kd">function</span> <span class="nx">merge</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="nx">prop</span> <span class="k">in</span> <span class="nx">p</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// For all props in p.
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">[</span><span class="nx">prop</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span> <span class="c1">// Except those already in o.
</span><span class="c1"></span>        <span class="nx">o</span><span class="p">[</span><span class="nx">prop</span><span class="p">]</span> <span class="o">=</span> <span class="nx">p</span><span class="p">[</span><span class="nx">prop</span><span class="p">];</span> <span class="c1">// Add the property to o.
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">o</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
</span><span class="cm">* Remove properties from o if there is not a property with the same name in p.
</span><span class="cm">* Return o.
</span><span class="cm">*/</span>
<span class="kd">function</span> <span class="nx">restrict</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="nx">prop</span> <span class="k">in</span> <span class="nx">o</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// For all props in o
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">prop</span> <span class="k">in</span> <span class="nx">p</span><span class="p">))</span> <span class="k">delete</span> <span class="nx">o</span><span class="p">[</span><span class="nx">prop</span><span class="p">];</span> <span class="c1">// Delete if not in p
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">o</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
</span><span class="cm">* For each property of p, delete the property with the same name from o.
</span><span class="cm">* Return o.
</span><span class="cm">*/</span>
<span class="kd">function</span> <span class="nx">subtract</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="nx">prop</span> <span class="k">in</span> <span class="nx">p</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// For all props in p
</span><span class="c1"></span>        <span class="k">delete</span> <span class="nx">o</span><span class="p">[</span><span class="nx">prop</span><span class="p">];</span> <span class="c1">// Delete from o (deleting a nonexistent prop is harmless)
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">o</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
</span><span class="cm">* Return a new object that holds the properties of both o and p.
</span><span class="cm">* If o and p have properties by the same name, the values from o are used.
</span><span class="cm">*/</span>
<span class="kd">function</span> <span class="nx">union</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">extend</span><span class="p">(</span><span class="nx">extend</span><span class="p">({},</span><span class="nx">o</span><span class="p">),</span> <span class="nx">p</span><span class="p">);</span> <span class="p">}</span>

<span class="cm">/*
</span><span class="cm">* Return a new object that holds only the properties of o that also appear
</span><span class="cm">* in p. This is something like the intersection of o and p, but the values of
</span><span class="cm">* the properties in p are discarded
</span><span class="cm">*/</span>
<span class="kd">function</span> <span class="nx">intersection</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">restrict</span><span class="p">(</span><span class="nx">extend</span><span class="p">({},</span> <span class="nx">o</span><span class="p">),</span> <span class="nx">p</span><span class="p">);</span> <span class="p">}</span>

<span class="cm">/*
</span><span class="cm">* Return an array that holds the names of the enumerable own properties of o.
</span><span class="cm">*/</span>
<span class="kd">function</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">o</span> <span class="o">!==</span> <span class="s2">&#34;object&#34;</span><span class="p">)</span> <span class="k">throw</span> <span class="nx">TypeError</span><span class="p">();</span> <span class="c1">// Object argument required
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// The array we will return
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">prop</span> <span class="k">in</span> <span class="nx">o</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// For all enumerable properties
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">prop</span><span class="p">))</span> <span class="c1">// If it is an own property
</span><span class="c1"></span>            <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">prop</span><span class="p">);</span> <span class="c1">// add it to the array.
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span> <span class="c1">// Return the array.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>
<p>ES5定义了两个新函数来枚举属性名。第一个是Object.keys()，它返回一个对象的可枚举属性名数组。第二个是Object.getOwnPropertyNames()，它返回指定对象的所有自身属性名。</p>
<h3 id="属性getter和setter">属性getter和setter</h3>
<p>在ES5中，对象值可以被getter和setter方法替换。getter和setter定义的属性有时称为访问器属性，以区分数据属性。</p>
<p>当查询访问器属性时，JavaScript调用getter方法，返回值即属性值。当设置访问器属性时，JavaScript调用setter方法，传递赋值右侧的值，setter方法的返回值被忽略。</p>
<p>访问器属性不像数据属性那样具有可写属性。如果属性同时具有getter和setter方法，那么它就是可读/可写属性。如果它只有getter方法，它就是只读属性。如果它只有一个setter方法，那么它就是一个只写的属性，这对于数据属性不可能实现的，并且读取它总是返回undefined。</p>
<p>定义访问器属性的最简单方法是使用对象字面值语法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">// An ordinary data property
</span><span class="c1"></span>    <span class="nx">data_prop</span><span class="o">:</span> <span class="nx">value</span><span class="p">,</span>
    <span class="c1">// An accessor property defined as a pair of functions
</span><span class="c1"></span>    <span class="nx">get</span> <span class="nx">accessor_prop</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* function body here */</span> <span class="p">},</span>
    <span class="nx">set</span> <span class="nx">accessor_prop</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* function body here */</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>
<p>访问器属性定义为一个或两个名称与属性名称相同的函数，并将function替换为get或set。没有使用冒号将属性的名称与访问该属性的函数分隔开，但是在函数体之后仍然需要使用逗号与下一个方法或数据属性分隔开。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">// x and y are regular read-write data properties.
</span><span class="c1"></span>    <span class="nx">x</span><span class="o">:</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="nx">y</span><span class="o">:</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="c1">// r is a read-write accessor property with getter and setter.
</span><span class="c1"></span>    <span class="c1">// Don&#39;t forget to put a comma after accessor methods.
</span><span class="c1"></span>    <span class="nx">get</span> <span class="nx">r</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sqrt</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="p">);</span> <span class="p">},</span>
    <span class="nx">set</span> <span class="nx">r</span><span class="p">(</span><span class="nx">newvalue</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">oldvalue</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sqrt</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="p">);</span>
        <span class="kd">var</span> <span class="nx">ratio</span> <span class="o">=</span> <span class="nx">newvalue</span><span class="o">/</span><span class="nx">oldvalue</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">*=</span> <span class="nx">ratio</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">*=</span> <span class="nx">ratio</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="c1">// theta is a read-only accessor property with getter only.
</span><span class="c1"></span>    <span class="nx">get</span> <span class="nx">theta</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">atan2</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>
<p>JavaScript将getter和setter函数作为定义它们的对象的方法，这意味着这些函数可以引用对象的属性。访问器属性是可以继承的，就像数据属性一样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">q</span> <span class="o">=</span> <span class="nx">inherit</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span> <span class="c1">// Create a new object that inherits getters and setters
</span><span class="c1"></span><span class="nx">q</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Create q&#39;s own data properties
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">r</span><span class="p">);</span> <span class="c1">// And use the inherited accessor properties
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">theta</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div>
<p>使用访问器属性的另一个原因是对属性写入进行完整性检查，并且可以在读取的属性返回不同的值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">// This object generates strictly increasing serial numbers
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">serialnum</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">// This data property holds the next serial number.
</span><span class="c1"></span>    <span class="c1">// The $ in the property name hints that it is a private property.
</span><span class="c1"></span>    <span class="nx">$n</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="c1">// Return the current value and increment it
</span><span class="c1"></span>    <span class="nx">get</span> <span class="nx">next</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">$n</span><span class="o">++</span><span class="p">;</span> <span class="p">},</span>
    <span class="c1">// Set a new value of n, but only if it is larger than current
</span><span class="c1"></span>    <span class="nx">set</span> <span class="nx">next</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">&gt;=</span> <span class="k">this</span><span class="p">.</span><span class="nx">$n</span><span class="p">)</span> <span class="k">this</span><span class="p">.</span><span class="nx">$n</span> <span class="o">=</span> <span class="nx">n</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">throw</span> <span class="s2">&#34;serial number can only be set to a larger value&#34;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>
<p>最后，这里还有一个使用getter方法实现具有“神奇”行为的属性的示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">// This object has accessor properties that return random numbers.
</span><span class="c1">// The expression &#34;random.octet&#34;, for example, yields a random number
</span><span class="c1">// between 0 and 255 each time it is evaluated.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">random</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">get</span> <span class="nx">octet</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">256</span><span class="p">);</span> <span class="p">},</span>
    <span class="nx">get</span> <span class="nx">uint16</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">65536</span><span class="p">);</span> <span class="p">},</span>
    <span class="nx">get</span> <span class="nx">int16</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span><span class="o">*</span><span class="mi">65536</span><span class="p">)</span><span class="o">-</span><span class="mi">32768</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>
<h3 id="属性的属性">属性的属性</h3>
<p>数据属性的四个属性是值、可写、可枚举和可配置。访问器属性没有值属性和可写属性，它们是否可写取决于setter存在与否。因此访问器属性的四个属性是get、set、枚举和可配置。</p>
<p>ES5查询和设置属性的方法使用一个称为属性描述符的对象来表示四个属性的集合。使用Object.getOwnPropertyDescriptor()获得指定对象的属性描述符：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">// Returns {value: 1, writable:true, enumerable:true, configurable:true}
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span><span class="mi">1</span><span class="p">},</span> <span class="s2">&#34;x&#34;</span><span class="p">);</span>
<span class="c1">// Now query the octet property of the random object defined above.
</span><span class="c1">// Returns { get: /func/, set:undefined, enumerable:true, configurable:true}
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">random</span><span class="p">,</span> <span class="s2">&#34;octet&#34;</span><span class="p">);</span>
<span class="c1">// Returns undefined for inherited properties and properties that don&#39;t exist.
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">({},</span> <span class="s2">&#34;x&#34;</span><span class="p">);</span> <span class="c1">// undefined, no such prop
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">({},</span> <span class="s2">&#34;toString&#34;</span><span class="p">);</span> <span class="c1">// undefined, inherited
</span></code></pre></td></tr></table>
</div>
</div>
<p>getownpropertydescriptor()只适用于自己的属性。要查询继承属性的属性，必须显式地遍历原型链。</p>
<p>object.defineproperty()用于设置指定对象属性：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{};</span> <span class="c1">// Start with no properties at all
</span><span class="c1">// Add a nonenumerable data property x with value 1.
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="s2">&#34;x&#34;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">value</span> <span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="nx">writable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span>
    <span class="nx">configurable</span><span class="o">:</span> <span class="kc">true</span><span class="p">});</span>
<span class="c1">// Check that the property is there but is nonenumerable
</span><span class="c1"></span><span class="nx">o</span><span class="p">.</span><span class="nx">x</span><span class="p">;</span> <span class="c1">// =&gt; 1
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="c1">// =&gt; []
</span><span class="c1">// Now modify the property x so that it is read-only
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="s2">&#34;x&#34;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">writable</span><span class="o">:</span> <span class="kc">false</span> <span class="p">});</span>
<span class="c1">// Try to change the value of the property
</span><span class="c1"></span><span class="nx">o</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// Fails silently or throws TypeError in strict mode
</span><span class="c1"></span><span class="nx">o</span><span class="p">.</span><span class="nx">x</span> <span class="c1">// =&gt; 1
</span><span class="c1">// The property is still configurable, so we can change its value like this:
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="s2">&#34;x&#34;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="mi">2</span> <span class="p">});</span>
<span class="nx">o</span><span class="p">.</span><span class="nx">x</span> <span class="c1">// =&gt; 2
</span><span class="c1">// Now change x from a data property to an accessor property
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span> <span class="s2">&#34;x&#34;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span> <span class="p">});</span>
<span class="nx">o</span><span class="p">.</span><span class="nx">x</span> <span class="c1">// =&gt; 0
</span></code></pre></td></tr></table>
</div>
</div>
<p>传递给Object.defineProperty()的属性描述符不需要包含所有四个属性。如果创建一个新属性，那么省略的属性值被设为false或undefined。如果修改现有属性，则忽略的属性将保持不变。Object.defineProperty()只能用于创建或修改自有属性，不会修改继承的属性。</p>
<p>如果要创建或修改多个属性，使用Object.defineProperties()。第一个参数是要修改的对象，第二个参数是一个对象，它将要创建或修改的属性名映射到相应的属性描述符：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperties</span><span class="p">({},</span> <span class="p">{</span>
    <span class="nx">x</span><span class="o">:</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">writable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">enumerable</span><span class="o">:</span><span class="kc">true</span><span class="p">,</span> <span class="nx">configurable</span><span class="o">:</span><span class="kc">true</span> <span class="p">},</span>
    <span class="nx">y</span><span class="o">:</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">writable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">enumerable</span><span class="o">:</span><span class="kc">true</span><span class="p">,</span> <span class="nx">configurable</span><span class="o">:</span><span class="kc">true</span> <span class="p">},</span>
    <span class="nx">r</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">get</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sqrt</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">xthis</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">ythis</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span> <span class="p">},</span>
        <span class="nx">enumerable</span><span class="o">:</span><span class="kc">true</span><span class="p">,</span>
        <span class="nx">configurable</span><span class="o">:</span><span class="kc">true</span>
    <span class="p">}</span>
<span class="p">});</span>
</code></pre></td></tr></table>
</div>
</div>
<p>Object.create方法的第一个参数是新创建对象的原型对象，它的第二个可选参数是与Object.defineProperties()的第二个参数相同的对象。如果您将一组属性描述符传递给object.create()，那么它们将用于向新创建的对象添加属性。</p>
<p>当不允许创建或修改属性时，Object.defineProperty()和Object.defineProperties()会抛出TypeError：</p>
<ul>
<li>如果对象不可扩展，可以编辑现有的属性，但不能向其添加新属性。</li>
<li>如果属性不可配置，则无法更改其可配置或可枚举属性。</li>
<li>如果访问器属性不可配置，则不能更改其getter或setter方法，也不能将其更改为数据属性。</li>
<li>如果数据属性不可配置，则不能将其更改为访问器属性。</li>
<li>如果数据属性不可配置，则不能将其可写属性从false更改为true，但可以将其从true更改为false。</li>
<li>如果数据属性不可配置且不可写入，则无法更改其值。但是您可以更改可配置但不可写入的属性的值。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="cm">/*
</span><span class="cm">* Add a nonenumerable extend() method to Object.prototype.
</span><span class="cm">* This method extends the object on which it is called by copying properties
</span><span class="cm">* from the object passed as its argument. All property attributes are
</span><span class="cm">* copied, not just the property value. All own properties (even non-
</span><span class="cm">* enumerable ones) of the argument object are copied unless a property
</span><span class="cm">* with the same name already exists in the target object.
</span><span class="cm">*/</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="s2">&#34;extend&#34;</span><span class="p">,</span> <span class="c1">// Define Object.prototype.extend
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="nx">writable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="nx">enumerable</span><span class="o">:</span> <span class="kc">false</span><span class="p">,</span> <span class="c1">// Make it nonenumerable
</span><span class="c1"></span>        <span class="nx">configurable</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="nx">value</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Its value is this function
</span><span class="c1"></span>            <span class="c1">// Get all own props, even nonenumerable ones
</span><span class="c1"></span>            <span class="kd">var</span> <span class="nx">names</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span><span class="p">(</span><span class="nx">o</span><span class="p">);</span>
            <span class="c1">// Loop through them
</span><span class="c1"></span>            <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">names</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Skip props already in this object
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="nx">names</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="k">in</span> <span class="k">this</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
                <span class="c1">// Get property description from o
</span><span class="c1"></span>                <span class="kd">var</span> <span class="nx">desc</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">o</span><span class="p">,</span><span class="nx">names</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
                <span class="c1">// Use it to create property on this
</span><span class="c1"></span>                <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">names</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">desc</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">});</span>
</code></pre></td></tr></table>
</div>
</div>
<h4 id="getter和setter的遗留api">getter和setter的遗留API</h4>
<p><code>__lookupGetter__()</code>和<code>__lookupSetter__()</code>返回指定属性的getter或setter方法。<code>__defineGetter__()</code>和<code>__defineSetter__()</code>定义getter或setter方法，先传递属性名，然后传递getter或setter方法。这些方法是非标准方法。</p>
<h3 id="对象属性">对象属性</h3>
<p>每个对象都有相关的原型、类和可扩展属性。</p>
<h4 id="原型属性">原型属性</h4>
<p>对象的原型属性指定它从哪个对象继承属性。原型属性是在创建对象时设置的。用new创建的对象使用其构造函数的原型属性的值作为原型。使用Object.create()创建的对象使用该函数的第一个参数（可能为空）作为原型。</p>
<p>在ES5中，可以使用Object.getPrototypeOf()来查询任何对象的原型。ES3中没有等价的函数，但是通常可以使用o.constructor.prototype来确定对象o的原型。</p>
<p>要确定一个对象是另一个对象的原型或其原型链的一部分，使用isPrototypeOf()方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span><span class="mi">1</span><span class="p">};</span> <span class="c1">// Define a prototype object.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span> <span class="c1">// Create an object with that prototype.
</span><span class="c1"></span><span class="nx">p</span><span class="p">.</span><span class="nx">isPrototypeOf</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="c1">// =&gt; true: o inherits from p
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">isPrototypeOf</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="c1">// =&gt; true: p inherits from Object.prototype
</span></code></pre></td></tr></table>
</div>
</div>
<p>Mozilla的JavaScript实现通过特殊命名的<code>__proto__</code>属性公开了原型属性，您可以使用该属性直接查询或设置任何对象的原型。</p>
<h4 id="类属性">类属性</h4>
<p>对象的类属性是一个字符串，它提供关于对象类型的信息。ES3和ES5都没有提供任何方法来设置这个属性，并且只有一种间接的技术来查询它。默认的toString()方法返回这种形式的字符串：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="p">[</span><span class="nx">object</span> <span class="kr">class</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div>
<p>因此要获得对象的类，可以在其上调用toString()方法，并通过返回的字符提取。棘手的是，许多对象继承了其他更有用的toString()方法，为了调用正确的toString()版本，我们必须使用Function.call()方法间接地这样做：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">classof</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">o</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="s2">&#34;Null&#34;</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">o</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="k">return</span> <span class="s2">&#34;Undefined&#34;</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">o</span><span class="p">).</span><span class="nx">slice</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>
<p>数组和Date等对象具有与构造函数名称一样的类属性。宿主对象通常也具有有意义的类属性。通过对象字面值或Object.create创建的对象类属性为&quot;Object&rdquo;。自己定义的构造函数，创建的任何对象类属性都是&quot;Object&rdquo;：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">classof</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span> <span class="c1">// =&gt; &#34;Null&#34;
</span><span class="c1"></span><span class="nx">classof</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// =&gt; &#34;Number&#34;
</span><span class="c1"></span><span class="nx">classof</span><span class="p">(</span><span class="s2">&#34;&#34;</span><span class="p">)</span> <span class="c1">// =&gt; &#34;String&#34;
</span><span class="c1"></span><span class="nx">classof</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="c1">// =&gt; &#34;Boolean&#34;
</span><span class="c1"></span><span class="nx">classof</span><span class="p">({})</span> <span class="c1">// =&gt; &#34;Object&#34;
</span><span class="c1"></span><span class="nx">classof</span><span class="p">([])</span> <span class="c1">// =&gt; &#34;Array&#34;
</span><span class="c1"></span><span class="nx">classof</span><span class="p">(</span><span class="sr">/./</span><span class="p">)</span> <span class="c1">// =&gt; &#34;Regexp&#34;
</span><span class="c1"></span><span class="nx">classof</span><span class="p">(</span><span class="k">new</span> <span class="nb">Date</span><span class="p">())</span> <span class="c1">// =&gt; &#34;Date&#34;
</span><span class="c1"></span><span class="nx">classof</span><span class="p">(</span><span class="nb">window</span><span class="p">)</span> <span class="c1">// =&gt; &#34;Window&#34; (a client-side host object)
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{};</span> <span class="c1">// Define a custom constructor
</span><span class="c1"></span><span class="nx">classof</span><span class="p">(</span><span class="k">new</span> <span class="nx">f</span><span class="p">());</span> <span class="c1">// =&gt; &#34;Object&#34;
</span></code></pre></td></tr></table>
</div>
</div>
<h4 id="可扩展属性">可扩展属性</h4>
<p>对象的可扩展属性指定是否可以向对象添加新属性。所有内置和用户定义的对象都是隐式可扩展的，宿主对象的可扩展性是由实现定义的。但在ES5中，可以将它们被转换为不可扩展的。</p>
<p>ES5定义了查询和设置对象可扩展性的函数。Object.isExtensible()确定对象是否可扩展。Object.preventExtensions()使对象不可扩展，一旦使对象不可扩展，就无法使其再次可扩展。preventExtensions()只会影响对象本身的可扩展性，如果将新属性添加到不可扩展对象的原型中，该对象将继承这些新属性。</p>
<p>可扩展属性的目的是能够将对象“锁定”为已知状态，并防止外部篡改。可扩展对象属性通常与可配置和可写的属性属性一起使用，ES5定义了一些函数，可以很容易地设置这些属性。</p>
<p>Object.seal()除了使对象不可扩展之外，它还使该对象的所有属性都不可配置。这意味着不能向对象添加新属性，也不能删除或配置现有属性。但是仍然可以设置可写的现有属性。没有办法解封这个对象。可以使用Object.isSealed()来确定一个对象是否被密封。</p>
<p>Object.freeze()将对象锁得更紧。除了使对象不可扩展和其属性不可配置之外，它还使对象的所有数据属性都是只读的。（如果对象具有setter方法的访问器属性，这些属性不会受到影响）使用Object.isFrozen()来确定一个对象是否被冻结。</p>
<p>Object.seal() 和Object.freeze()只影响传递给它们的对象，对它们对原型对象没有影响。如果您想彻底锁定一个对象，您可能还需要密封或冻结原型链中的对象。</p>
<p>Object.preventExtensions() ，Object.seal() 和Object.freeze()都返回传递给它们的对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">// Create a sealed object with a frozen prototype and a nonenumerable property
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">seal</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({</span><span class="nx">x</span><span class="o">:</span><span class="mi">1</span><span class="p">}),</span>
    <span class="p">{</span><span class="nx">y</span><span class="o">:</span> <span class="p">{</span><span class="nx">value</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">writable</span><span class="o">:</span> <span class="kc">true</span><span class="p">}}));</span>
</code></pre></td></tr></table>
</div>
</div>
<h3 id="序列化对象">序列化对象</h3>
<p>ES5提供JSON.stringify()和JSON.parse()来序列化和反序列化JavaScript对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">o</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span><span class="p">{</span><span class="nx">z</span><span class="o">:</span><span class="p">[</span><span class="kc">false</span><span class="p">,</span><span class="kc">null</span><span class="p">,</span><span class="s2">&#34;&#34;</span><span class="p">]}};</span> <span class="c1">// Define a test object
</span><span class="c1"></span><span class="nx">s</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">o</span><span class="p">);</span> <span class="c1">// s is &#39;{&#34;x&#34;:1,&#34;y&#34;:{&#34;z&#34;:[false,null,&#34;&#34;]}}&#39;
</span><span class="c1"></span><span class="nx">p</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="c1">// p is a deep copy of o
</span></code></pre></td></tr></table>
</div>
</div>
<p>JSON语法是JavaScript语法的一个子集，它不能表示所有JavaScript值。对象、数组、字符串、有限数字、true、false和null可以序列化和还原。NaN、 Infinity和-Infinity序列化为null。日期对象被序列化为ISO格式的日期字符串，但是JSON.parse()将这些字符串保留为字符串形式。函数、RegExp和Error对象以及undefined无法序列化或恢复。JSON.stringify()只序列化对象的可枚举属性。如果一个属性值不能被序列化，则忽略这个属性。JSON.stringify()和JSON.parse()都接受可选的第二个参数，具体参考文档。</p>
<h3 id="对象方法">对象方法</h3>
<h4 id="tostring">toString()</h4>
<p>toString()方法返回一个字符串，该字符串以某种方式表示对象的值。当需要将对象转换为字符串时，JavaScript将调用对象的此方法。由于这个默认方法没有太多有用的信息，许多类都定义了自己的toString()版本。</p>
<h4 id="tolocalestring">toLocaleString()</h4>
<p>除了toString()方法外，对象都有一个toLocaleString()。此方法的目的是返回对象的本地化字符串表示。Object定义的默认toLocaleString()方法本身不做任何本地化，它只调用toString()。Date和Number类定义了toLocaleString()的定制版本，这些版本试图根据本地约定格式化数字、日期和时间。Array定义了一个toLocaleString()方法，它的工作原理与toString()类似，只是它通过调用数组元素的toLocaleString()方法。</p>
<h4 id="tojson">toJSON()</h4>
<p>Object.prototype没有定义toJSON()方法，但是JSON.stringify()方法寻找toJSON()序列化对象。如果该方法存在，则调用该方法，而不是序列化原始对象。</p>
<h4 id="valueof">valueOf()</h4>
<p>valueOf()方法与toString()方法非常相似，但是当JavaScript需要将对象转换为字符串以外的基本类型时调用它。默认的valueOf()方法没有什么有趣的地方，但是一些内置类定义了它们自己的valueOf()方法。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">招财猫</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2018-11-03
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">赞赏支持</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/weixin-donate.jpeg">
        <span>微信打赏</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/zhifubao-donate.jpeg">
        <span>支付宝打赏</span>
      </label>
  </div>
</div><footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/javascript/">Javascript</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/arrays/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">数组</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/statements/">
            <span class="next-text nav-default">语句</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  <span id="/post/objects/" class="leancloud_visitors" data-flag-title="对象">
		<span class="post-meta-item-text">文章阅读量 </span>
		<span class="leancloud-visitors-count">0</span>
		<p></p>
	  </span>
  <div id="vcomments"></div>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script type="text/javascript">
    new Valine({
        el: '#vcomments' ,
        appId: 'nTlkWW6BFHR3ekmRDf9ragQd-gzGzoHsz',
        appKey: 'aGlzQgiAeX7JBeHOTXK9SgpC',
        notify:  false ,
        verify:  false ,
        avatar:'mm',
        placeholder: '说点什么吧...',
        visitor:  true 
    });
  </script>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="https://github.com/opensvn" class="iconfont icon-github" title="github"></a>
      <a href="https://www.weibo.com/opensvn" class="iconfont icon-weibo" title="weibo"></a>
  <a href="https://gitop.cc/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2019 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">招财猫</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.d7b7ada643c9c1a983026e177f141f7363b4640d619caf01d8831a6718cd44ea.js"></script>








</body>
</html>
