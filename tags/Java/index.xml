<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on 招财猫的博客</title>
    <link>http://gitop.cc/tags/Java/</link>
    <description>Recent content in Java on 招财猫的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 24 Jul 2019 20:30:19 +0800</lastBuildDate>
    
	<atom:link href="http://gitop.cc/tags/Java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>重构、测试和调试</title>
      <link>http://gitop.cc/posts/refactoring-testing-debugging/</link>
      <pubDate>Wed, 24 Jul 2019 20:30:19 +0800</pubDate>
      
      <guid>http://gitop.cc/posts/refactoring-testing-debugging/</guid>
      <description>重构以提高可读性和灵活性 提高代码的可读性 我们介绍三个简单的重构，使用lambda、方法引用和流，将它们应用到代码中，以提高代码的可读性： 将匿名类重构为lambda表达式 将lambda表达式重构为方法引用 将命令式数据处理重构为流处理 从匿名类到lambda表达式 下面是使用匿名类创建一</description>
    </item>
    
    <item>
      <title>Collection API增强</title>
      <link>http://gitop.cc/posts/collection-api-enhancements/</link>
      <pubDate>Wed, 24 Jul 2019 14:22:44 +0800</pubDate>
      
      <guid>http://gitop.cc/posts/collection-api-enhancements/</guid>
      <description>Collection工厂 Java 9引入了一些创建小型集合对象的方法，比如Arrays.asList()： List&amp;lt;String&amp;gt; friends = Arrays.asList(&amp;#34;Raphael&amp;#34;, &amp;#34;Olivia&amp;#34;, &amp;#34;Thibaut&amp;#34;); Arrays.asList()返回一个固定大小的列表，可以对其进行更新，但不能添加或删除元素，否则抛出UnsupportedModificationException异常</description>
    </item>
    
    <item>
      <title>并行数据处理和性能</title>
      <link>http://gitop.cc/posts/parallel-data-processing-and-performance/</link>
      <pubDate>Tue, 23 Jul 2019 20:00:47 +0800</pubDate>
      
      <guid>http://gitop.cc/posts/parallel-data-processing-and-performance/</guid>
      <description>并行流 通过调用parallelStream方法，可以将集合转换为并行流。并行流是将元素分割成多个块的流，使用不同的线程处理每个块。因此，你可以自动划分指定操作的工作负载在多核处理器的所有核心上，并使它们一样忙。 public long sequentialSum(long n) { return Stream.iterate(1L, i -&amp;gt; i + 1).limit(n).reduce(0L, Long::sum); } 将顺序流转为并行流 调用parallel方法</description>
    </item>
    
    <item>
      <title>使用流收集数据</title>
      <link>http://gitop.cc/posts/collecting-data-with-streams/</link>
      <pubDate>Tue, 23 Jul 2019 13:04:54 +0800</pubDate>
      
      <guid>http://gitop.cc/posts/collecting-data-with-streams/</guid>
      <description>假设有一个事务列表，你希望根据货币对它们进行分组。在Java 8之前，即使是这样一个简单的例子也很难实现，如下所示： Map&amp;lt;Currency, List&amp;lt;Transaction&amp;gt;&amp;gt; transactionsByCurrencies = new HashMap&amp;lt;&amp;gt;(); for (Transaction transaction : transactions) { Currency currency = transaction.getCurrency(); List&amp;lt;Transaction&amp;gt; transactionsForCurrency = transactionsByCurrencies.get(currency); if (transactionsForCurrency == null) { transactionsForCurrency = new ArrayList&amp;lt;&amp;gt;(); transactionsByCurrencies.put(currency, transactionsForCurrency); } transactionsForCurrency.add(transaction); } 在Java 8之后，仅用一条语句就可以获得完全相同的结果： Map&amp;lt;Currency, List&amp;lt;Transaction&amp;gt;&amp;gt; transactionsByCurrencies = transactions.stream().collect(groupingBy(Transaction::getCurrency)); Collector接口提供了三个</description>
    </item>
    
    <item>
      <title>使用流</title>
      <link>http://gitop.cc/posts/working-with-streams/</link>
      <pubDate>Thu, 11 Jul 2019 08:39:11 +0800</pubDate>
      
      <guid>http://gitop.cc/posts/working-with-streams/</guid>
      <description>过滤 使用谓词过滤 filter方法接受一个谓词函数为参数，并返回包含所有匹配谓词的元素的流。如下例： List&amp;lt;Dish&amp;gt; vegetarianMenu = menu.stream().filter(Dish::isVegetarian).collect(toList()); 如下图所示： 过滤唯一元素 distinct方法返回包含唯一元素的流。如下例： List&amp;lt;Integer&amp;gt; numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4); numbers.stream().filter(i -&amp;gt; i % 2 == 0).distinct().forEach(System.out::println); 如下图所示： 切分流 Java 9添加了两个新方法takeWhile和drop</description>
    </item>
    
    <item>
      <title>流介绍</title>
      <link>http://gitop.cc/posts/introducing-streams/</link>
      <pubDate>Wed, 10 Jul 2019 17:22:30 +0800</pubDate>
      
      <guid>http://gitop.cc/posts/introducing-streams/</guid>
      <description>流是什么 流是对Java API的更新，允许你以声明式的方式操作数据集合。首先看一个例子，假设你想获得所有热量低于400卡的菜肴的名字，并按热量排序。在Java 8之前，你可以这样做： List&amp;lt;Dish&amp;gt; lowCaloricDishes = new ArrayList&amp;lt;&amp;gt;(); for (Dish dish : menu) { if (dish.getCalories() &amp;lt; 400) { lowCaloricDishes.add(dish); } } Collections.sort(lowCaloricDishes, new Comparator&amp;lt;Dish&amp;gt;() { public int compare(Dish dish1, Dish dish2) { return Integer.compare(dish1.getCalories(), dish2.getCalories()); } }); List&amp;lt;String&amp;gt; lowCaloricDishesName = new ArrayList&amp;lt;&amp;gt;(); for (Dish dish : lowCaloricDishes) { lowCaloricDishesName.add(dish.getName()); } 在Ja</description>
    </item>
    
    <item>
      <title>Lambda表达式</title>
      <link>http://gitop.cc/posts/lambda-expressions/</link>
      <pubDate>Wed, 10 Jul 2019 08:48:55 +0800</pubDate>
      
      <guid>http://gitop.cc/posts/lambda-expressions/</guid>
      <description>Lambda概述 lambda表达式没有名称，但是它有参数列表，函数体和返回类型，还可能包含一个异常列表。 匿名，lambda表达式不像方法一样有一个显式的名字 函数，lambda表达式不像方法一样关联到一个特定的类 传递，lambda表达式可以像函数参数一样传递，或者保存到变量里面 简洁</description>
    </item>
    
  </channel>
</rss>