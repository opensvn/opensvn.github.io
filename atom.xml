<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[opensvn]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="https://opensvn.github.io/"/>
  <updated>2015-10-14T03:05:16.238Z</updated>
  <id>https://opensvn.github.io/</id>
  
  <author>
    <name><![CDATA[opensvn]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[PyQt编程第四章 GUI编程介绍]]></title>
    <link href="https://opensvn.github.io/2015/10/12/pyqt-4/"/>
    <id>https://opensvn.github.io/2015/10/12/pyqt-4/</id>
    <published>2015-10-12T12:34:55.000Z</published>
    <updated>2015-10-14T03:05:16.238Z</updated>
    <content type="html"><![CDATA[<h1 id="一个25行的弹出警告">一个25行的弹出警告</h1><pre><code><span class="keyword">import</span> sys
<span class="keyword">import</span> time
<span class="keyword">from</span> PyQt4.QtCore <span class="keyword">import</span> *
<span class="keyword">from</span> PyQt4.QtGui <span class="keyword">import</span> *

app = QApplication(sys.argv)

<span class="keyword">try</span>:
    due = QTime.currentTime()
    message = <span class="string">"Alert!"</span>
    <span class="keyword">if</span> len(sys.argv) &lt; <span class="number">2</span>:
        <span class="keyword">raise</span> ValueError
    hours, mins = sys.argv[<span class="number">1</span>].split(<span class="string">":"</span>)
    due = QTime(int(hours), int(mins))
    <span class="keyword">if</span> <span class="keyword">not</span> due.isValid():
        <span class="keyword">raise</span> ValueError
    <span class="keyword">if</span> len(sys.argv) &gt; <span class="number">2</span>:
        message = <span class="string">" "</span>.join(sys.argv[<span class="number">2</span>:])
<span class="keyword">except</span> ValueError:
    message = <span class="string">"Usage: alert.pyw HH:MM [optional message]"</span> <span class="comment"># 24hr clock</span>

<span class="keyword">while</span> QTime.currentTime() &lt; due:
    time.sleep(<span class="number">20</span>) <span class="comment"># 20 seconds</span>

label = QLabel(<span class="string">"&lt;font color=red size=72&gt;&lt;b&gt;"</span> + message + <span class="string">"&lt;/b&gt;&lt;/font&gt;"</span>)
label.setWindowFlags(Qt.SplashScreen)
label.show()
QTimer.singleShot(<span class="number">60000</span>, app.quit) <span class="comment"># 1 minute</span>
app.exec_()
</code></pre><p>每一个<code>PyQt</code> GUI程序必须有一个<code>QApplication</code>对象。<br><code>QApplication</code>接受<code>sys.argv</code>作为参数是因为它能识别一些命令行的参数。</p>
<p>在<code>PyQt</code>中，任何部件都能用作最顶级的窗口，甚至是一个按钮或一个标签。当部件如此使用时，<code>PyQt</code>自动<br>给它一个标题栏。一旦窗口设置好后，就可以调用<code>show()</code>。这个时候，标签窗口没有显示。<code>show()</code><br>仅仅是将一个<code>paint</code>事件加入<code>QApplication</code>对象的事件队列。</p>
<p>在<code>PyQt</code>的术语中，函数或方法被称为<code>slot</code>，和<code>Python</code>的<code>__slots__</code>是不同的。</p>
<p><code>app.exec_()</code>开始<code>QApplication</code>对象事件循环。第一个事件是<code>paint</code>事件，因此标签窗口弹出。<br>一分钟后超时事件触发，<code>app.quit()</code>被调用。这个方法执行GUI程序的结束清理工作，关闭窗口，释放<br>资源。</p>
<p>GUI程序的事件循环，伪代码像这样：</p>
<pre><code><span class="keyword">while</span> <span class="keyword">True</span>:
    <span class="keyword">event</span> = getNextEvent()
    <span class="keyword">if</span> <span class="keyword">event</span>:
        <span class="keyword">if</span> <span class="keyword">event</span> == Terminate:
            <span class="keyword">break</span>
        processEvent(<span class="keyword">event</span>)
</code></pre><h1 id="一个30行的表达式求值程序">一个30行的表达式求值程序</h1><pre><code><span class="keyword">from</span> __future__ <span class="keyword">import</span> division
<span class="keyword">import</span> sys
<span class="keyword">from</span> math <span class="keyword">import</span> *
<span class="keyword">from</span> PyQt4.QtCore <span class="keyword">import</span> *
<span class="keyword">from</span> PyQt4.QtGui <span class="keyword">import</span> *

<span class="class"><span class="keyword">class</span> <span class="title">Form</span><span class="params">(QDialog)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent=None)</span>:</span>
        super(Form, self).__init__(parent)
        self.browser = QTextBrowser()
        self.lineedit = QLineEdit(<span class="string">"Type an expression and press Enter"</span>)
        self.lineedit.selectAll()
        layout = QVBoxLayout()
        layout.addWidget(self.browser)
        layout.addWidget(self.lineedit)
        self.setLayout(layout)
        self.lineedit.setFocus()
        self.connect(self.lineedit, SIGNAL(<span class="string">"returnPressed()"</span>),
                     self.updateUi)
        self.setWindowTitle(<span class="string">"Calculate"</span>)

    <span class="function"><span class="keyword">def</span> <span class="title">updateUi</span><span class="params">(self)</span>:</span>
        <span class="keyword">try</span>:
            text = unicode(self.lineedit.text())
            self.browser.append(<span class="string">"%s = &lt;b&gt;%s&lt;/b&gt;"</span> % (text, eval(text)))
        <span class="keyword">except</span>:
            self.browser.append(
                    <span class="string">"&lt;font color=red&gt;%s is invalid!&lt;/font&gt;"</span> % text)

app = QApplication(sys.argv)
form = Form()
form.show()
app.exec_()
</code></pre><p><code>QDialog</code>，<code>QMainWindow</code>和所有<code>PyQt</code>的部件，都继承自<code>QWidget</code>，并且都是新风格的类。<br>默认地，当一个部件被关闭时，它仅仅是被隐藏了。当一个窗体隐藏了，<code>PyQt</code>检查到程序没有可见<br>的窗体，而且进一步交互也不可能，<code>PyQt</code>会执行程序的结束清理工作。</p>
<blockquote>
<p><strong>对象所有权</strong><br>所有<code>PyQt</code>类继承自<code>QObject</code>，包括所有的部件。一个没有父亲的部件是一个顶级窗口，一个有父亲<br>的部件被包含在父亲里面。父亲拥有孩子。<br><code>PyQt</code>使用父子所有权模型来保证当一个父亲被<code>delete</code>，所有它的孩子也被自动<code>delete</code>。<br>为避免内存泄漏，除了顶级窗口，我们应该保证所有部件都有父亲。<br>布局管理器自动将部件重新绑定到正确的父亲部件上。</p>
</blockquote>
<p><code>PyQt</code>提供3种布局管理器：垂直布局，水平布局，网格布局。布局可以嵌套。</p>
<p>每一个部件通过发射信号声明状态改变。</p>
<h1 id="一个70行的汇率转换器">一个70行的汇率转换器</h1><pre><code>import sys
import urllib2
<span class="keyword">from</span> PyQt4.QtCore import *
<span class="keyword">from</span> PyQt4.QtGui import *

class Form(QDialog):
    def __init__(<span class="literal">self</span>, parent=None):
        super(Form, <span class="literal">self</span>).__init__(parent)

        date = <span class="literal">self</span>.getdata()
        rates = sorted(<span class="literal">self</span>.rates.keys())

        dateLabel = QLabel(date)
        <span class="literal">self</span>.<span class="keyword">from</span>ComboBox = QComboBox()
        <span class="literal">self</span>.<span class="keyword">from</span>ComboBox.addItems(rates)
        <span class="literal">self</span>.<span class="keyword">from</span>SpinBox = QDoubleSpinBox()
        <span class="literal">self</span>.<span class="keyword">from</span>SpinBox.<span class="built_in">set</span>Range(<span class="number">0.01</span>, <span class="number">10000000.00</span>)
        <span class="literal">self</span>.<span class="keyword">from</span>SpinBox.<span class="built_in">set</span>Value(<span class="number">1.00</span>)
        <span class="literal">self</span>.<span class="keyword">to</span>ComboBox = QComboBox()
        <span class="literal">self</span>.<span class="keyword">to</span>ComboBox.addItems(rates)
        <span class="literal">self</span>.<span class="keyword">to</span>Label = QLabel(<span class="string">"1.00"</span>)
        grid = QGridLayout()
        grid.addWidget(dateLabel, <span class="number">0</span>, <span class="number">0</span>)
        grid.addWidget(<span class="literal">self</span>.<span class="keyword">from</span>ComboBox, <span class="number">1</span>, <span class="number">0</span>)
        grid.addWidget(<span class="literal">self</span>.<span class="keyword">from</span>SpinBox, <span class="number">1</span>, <span class="number">1</span>)
        grid.addWidget(<span class="literal">self</span>.<span class="keyword">to</span>ComboBox, <span class="number">2</span>, <span class="number">0</span>)
        grid.addWidget(<span class="literal">self</span>.<span class="keyword">to</span>Label, <span class="number">2</span>, <span class="number">1</span>)
        <span class="literal">self</span>.<span class="built_in">set</span>Layout(grid)
        <span class="literal">self</span>.connect(<span class="literal">self</span>.<span class="keyword">from</span>ComboBox,
                SIGNAL(<span class="string">"currentIndexChanged(int)"</span>), <span class="literal">self</span>.updateUi)
        <span class="literal">self</span>.connect(<span class="literal">self</span>.<span class="keyword">to</span>ComboBox,
                SIGNAL(<span class="string">"currentIndexChanged(int)"</span>), <span class="literal">self</span>.updateUi)
        <span class="literal">self</span>.connect(<span class="literal">self</span>.<span class="keyword">from</span>SpinBox,
                SIGNAL(<span class="string">"valueChanged(double)"</span>), <span class="literal">self</span>.updateUi)
        <span class="literal">self</span>.<span class="built_in">set</span>WindowTitle(<span class="string">"Currency"</span>)

    def updateUi(<span class="literal">self</span>):
        <span class="keyword">to</span> = unicode(<span class="literal">self</span>.<span class="keyword">to</span>ComboBox.currentText())
        from_ = unicode(<span class="literal">self</span>.<span class="keyword">from</span>ComboBox.currentText())
        amount = (<span class="literal">self</span>.rates[from_] / <span class="literal">self</span>.rates[<span class="keyword">to</span>]) * \
                 <span class="literal">self</span>.<span class="keyword">from</span>SpinBox.value()
        <span class="literal">self</span>.<span class="keyword">to</span>Label.<span class="built_in">set</span>Text(<span class="string">"%0.2f"</span> % amount)

    def getdata(<span class="literal">self</span>): <span class="comment"># Idea taken from the Python Cookbook</span>
        <span class="literal">self</span>.rates = {}
        try:
            date = <span class="string">"Unknown"</span>
            fh = urllib2.urlopen(<span class="string">"http://www.bankofcanada.ca"</span>
                                 <span class="string">"/en/markets/csv/exchange_eng.csv"</span>)
            <span class="keyword">for</span> line <span class="keyword">in</span> fh:
                line = line.rstrip()
                if not line or line.startswith((<span class="string">"#"</span>, <span class="string">"Closing "</span>)):
                    continue
                fields = line.split(<span class="string">","</span>)
                if line.startswith(<span class="string">"Date "</span>):
                    date = fields[-<span class="number">1</span>]
                else:
                    try:
                        value = float(fields[-<span class="number">1</span>])
                        <span class="literal">self</span>.rates[unicode(fields[<span class="number">0</span>])] = value
                    except ValueError:
                        <span class="built_in">pass</span>
            return <span class="string">"Exchange Rates Date: "</span> + date
        except Exception, e:
            return <span class="string">"Failed to download:\n%s"</span> % e

app = QApplication(sys.argv)
form = Form()
form.show()
app.exec_()
</code></pre><h1 id="信号和槽">信号和槽</h1><p>每一个<code>QObject</code>支持信号和槽机制。所有的<code>PyQt</code>部件都有一组预定义的信号。不管什么时候一个信号<br>发射，<code>PyQt</code>默认简单地将其丢掉。必须将信号连接到槽来捕捉信号。在<code>PyQt</code>中，槽是任何可调用的<br>对象。大多数部件也有预定义好的槽。</p>
<p><code>connect</code>的语法，s通常是self，w是部件：</p>
<pre><code>s.<span class="function"><span class="title">connect</span><span class="params">(w, SIGNAL(<span class="string">"signalSignature"</span>)</span></span>, functionName)
s.<span class="function"><span class="title">connect</span><span class="params">(w, SIGNAL(<span class="string">"signalSignature"</span>)</span></span>, instance.methodName)
s.<span class="function"><span class="title">connect</span><span class="params">(w, SIGNAL(<span class="string">"signalSignature"</span>)</span></span>, instance, <span class="function"><span class="title">SLOT</span><span class="params">(<span class="string">"slotSignature"</span>)</span></span>)
</code></pre><p><code>signalSignature</code>是信号的名字，并带一个逗号隔开的参数列表。如果是<code>Qt</code>信号，则参数类型必须<br>是<code>C++</code>类型。当书写信号的<code>C++</code>参数类型时，可以丢弃<code>const</code>和<code>&amp;</code>，但是必须保留<code>*</code>。</p>
<p><code>PyQt</code>信号当它们发射时被定义，并且它们可以有任意数量，任意类型的参数。</p>
<p><code>slotSignature</code>和<code>signalSignature</code>有着一样的形式。一个槽的参数可能比信号少。相应的信号<br>和槽的参数必须类型相同。当槽是<code>Qt</code>槽而不是<code>Python</code>方法时，使用<code>SLOT()</code>语法效率更高。</p>
<pre><code>self.<span class="function"><span class="title">connect</span><span class="params">(dial, SIGNAL(<span class="string">"valueChanged(int)"</span>)</span></span>, spinbox, <span class="function"><span class="title">SLOT</span><span class="params">(<span class="string">"setValue(int)"</span>)</span></span>)
self.<span class="function"><span class="title">connect</span><span class="params">(spinbox, SIGNAL(<span class="string">"valueChanged(int)"</span>)</span></span>, dial, <span class="function"><span class="title">SLOT</span><span class="params">(<span class="string">"setValue(int)"</span>)</span></span>)
</code></pre><p>可以将多个信号连接到同一个槽，也可以将一个信号连接到多个槽。尽管很罕见，我们也可以将一个信号连接<br>到另一个信号，这样当第一个信号发射时，将会引起它连接的信号发射。</p>
<p>通过<code>QObject.connect()</code>建立连接，<code>QObject.disconnect()</code>解除连接。实际上，我们很少需要<br>自己解除连接，<code>PyQt</code>会自动解除已经删除的对象相关的连接。</p>
<p>使用<code>QObject.emit()</code>发射自定义的信号。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">ZeroSpinBox</span><span class="params">(QSpinBox)</span>:</span>
    zeros = <span class="number">0</span>

    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent=None)</span>:</span>
        super(ZeroSpinBox, self).__init__(parent)
        self.connect(self, SIGNAL(<span class="string">'valueChanged(int)'</span>), self.checkzero)

    <span class="function"><span class="keyword">def</span> <span class="title">checkzero</span><span class="params">(self)</span>:</span>
        <span class="keyword">if</span> self.value() == <span class="number">0</span>:
            self.zeros += <span class="number">1</span>
            self.emit(SIGNAL(<span class="string">'atzero'</span>), self.zeros)
</code></pre><p>一个没有参数(因此没有括号)的信号是一个短路<code>Python</code>信号。当这种信号被发射，任何数据都可以当作<br>额外的参数传给<code>emit()</code>方法，这些参数被当作<code>Python</code>对象传递。<br>至少有一个参数的信号是<code>Qt</code>信号或非短路<code>Python</code>信号，其参数都将转换为<code>C++</code>数据类型。</p>
<p><code>PyQt</code>的信号和槽机制并不局限于GUI类，任何<code>QObject</code>的子类都可以是用信号和槽。</p>
<pre><code><span class="keyword">from</span> PyQt4.QtCore <span class="keyword">import</span> *

<span class="class"><span class="keyword">class</span> <span class="title">TaxRate</span><span class="params">(QObject)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>
        super(TaxRate, self).__init__()
        self.__rate = <span class="number">17.5</span>

    <span class="function"><span class="keyword">def</span> <span class="title">rate</span><span class="params">(self)</span>:</span>
        <span class="keyword">return</span> self.__rate

    <span class="function"><span class="keyword">def</span> <span class="title">setRate</span><span class="params">(self, rate)</span>:</span>
        <span class="keyword">if</span> rate != self.__rate:
            self.__rate = rate
            self.emit(SIGNAL(<span class="string">'rateChanged'</span>), self.__rate)

<span class="function"><span class="keyword">def</span> <span class="title">rateChanged</span><span class="params">(value)</span>:</span>
    <span class="keyword">print</span> <span class="string">'TaxRate changed to %.2f%%'</span> % value

vat = TaxRate()
vat.connect(vat, SIGNAL(<span class="string">'rateChanged'</span>), rateChanged)
vat.setRate(<span class="number">17.5</span>)
vat.setRate(<span class="number">8.5</span>)
</code></pre><p>多个信号连接到同一个槽时，如何确定谁调用了槽。</p>
<pre><code><span class="literal">self</span>.connect(button2, SIGNAL(<span class="string">"clicked()"</span>),
             partial(<span class="literal">self</span>.<span class="literal">any</span>Button, <span class="string">"Two"</span>)) <span class="comment"># WRONG for PyQt 4.0-4.2</span>
<span class="literal">self</span>.connect(button3, SIGNAL(<span class="string">"clicked()"</span>),
             lambda who=<span class="string">"Three"</span>: <span class="literal">self</span>.<span class="literal">any</span>Button(who)) <span class="comment"># WRONG before 4.1.1</span>
</code></pre><p>在<code>PyQt</code>4.3之前，在<code>connect()</code>中创建的封装函数，在<code>connect()</code>函数返回时被垃圾回收。因此<br>需要保存一个引用到封装函数。在<code>PyQt</code>4.1.1之前，在<code>connect</code>中创建的<code>lambda</code>也会被垃圾回收，<br>同样需要保存一个引用。</p>
<pre><code>self<span class="class">.button2callback</span> = <span class="function"><span class="title">partial</span><span class="params">(self.anyButton, <span class="string">"Two"</span>)</span></span>
self.<span class="function"><span class="title">connect</span><span class="params">(button2, SIGNAL(<span class="string">"clicked()"</span>)</span></span>, self.button2callback)

self<span class="class">.button3callback</span> = lambda who=<span class="string">"Three"</span>: self.<span class="function"><span class="title">anyButton</span><span class="params">(who)</span></span>
self.<span class="function"><span class="title">connect</span><span class="params">(button3, SIGNAL(<span class="string">"clicked()"</span>)</span></span>, self.button3callback)
</code></pre><p>另外一种方法是使用<code>sender()</code>告诉我们是哪个对象。</p>
<pre><code>self.connect(button4, SIGNAL(<span class="string">"clicked()"</span>), self.clicked)
self.connect(button5, SIGNAL(<span class="string">"clicked()"</span>), self.clicked)
<span class="function"><span class="keyword">def</span> <span class="title">clicked</span><span class="params">(self)</span>:</span>
    button = self.sender()
    <span class="keyword">if</span> button <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> <span class="keyword">not</span> isinstance(button, QPushButton):
        <span class="keyword">return</span>
    self.label.setText(<span class="string">"You clicked button '%s'"</span> % button.text())
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="一个25行的弹出警告">一个25行的弹出警告</h1><pre><code><span class="keyword">import</span> sys
<span class="keyword">import</span> time
<span class="]]>
    </summary>
    
      <category term="Python" scheme="https://opensvn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PyQt编程第一章 数据类型和数据结构]]></title>
    <link href="https://opensvn.github.io/2015/10/12/pyqt-1/"/>
    <id>https://opensvn.github.io/2015/10/12/pyqt-1/</id>
    <published>2015-10-12T10:57:23.000Z</published>
    <updated>2015-10-14T03:05:18.914Z</updated>
    <content type="html"><![CDATA[<h1 id="执行Python代码">执行Python代码</h1><pre><code><span class="built_in">print</span> <span class="string">'Hello world'</span>
</code></pre><p><code>Python</code>读取<code>.py</code>或<code>.pyw</code>文件到内存，解析文件，生成字节码，然后运行。<br>对于<code>import</code>的模块，<code>Python</code>首先检查是否存在预编译的字节码(<code>pyo</code>或<code>pyc</code>)，根据时间戳判断<br>是否需要重新编译。在大多数<code>Python</code>的安装过程中，提供的模块都被编译了，来避免使用时编译。</p>
<h1 id="变量和对象">变量和对象</h1><p><code>Python</code>变量没有类型限制(动态类型)，而且它们也不需要声明。</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; x = <span class="number">71</span>
<span class="prompt">&gt;&gt;</span>&gt; y = <span class="string">'Dove'</span>
</code></pre><p>变量是对象的引用，并不是对象本身。</p>
<blockquote>
<p><strong>函数，方法和操作符</strong><br>函数是可以独立执行的子例程。方法是只能绑定到一个对象执行的函数。操作符可以独立或绑定到对象，<br>但是不需要括号。</p>
</blockquote>
<p><code>Python</code>有两种比较对象的方式：通过<strong>身份</strong>和通过<strong>值</strong>。一个对象的身份是内存中的有效地址，<br>这也是对象引用所保存的值。如果使用比较操作符，如<code>==</code>和<code>&lt;</code>，是值的比较。如果使用<code>is</code>，则是<br>身份的比较，这种比较很快。一个对象的身份可以通过<code>id()</code>获取。</p>
<p><code>Python</code>有一个特殊对象<code>None</code>，可以赋值给任何变量，意思是没有值。<code>None</code>对象只有一个实例，<br>因此<code>is</code>和<code>is not</code>比较<code>None</code>总是很快。</p>
<p>将一个值赋值给一个变量称为绑定。如果赋值给一个已经存在的变量，称为重新绑定。一旦一个对象没有<br>名字绑定，则加入垃圾回收进程。</p>
<p><code>Python</code>变量名由<code>ASCII</code>字母，数字和下划线组成。变量名不应该与<code>Python</code>的关键字或内置常量<br>如<code>None</code>，<code>True</code>，<code>False</code>相同。</p>
<h1 id="数字和字符串">数字和字符串</h1><p><code>Python</code>提供了几种数字类型和两种字符串类型。这些类型都是不可变的。</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; x = <span class="number">5</span>
<span class="prompt">&gt;&gt;</span>&gt; y = x
<span class="prompt">&gt;&gt;</span>&gt; x, y
(<span class="number">5</span>, <span class="number">5</span>)
<span class="prompt">&gt;&gt;</span>&gt; y += <span class="number">1</span>
<span class="prompt">&gt;&gt;</span>&gt; x, y
(<span class="number">5</span>, <span class="number">6</span>)
</code></pre><p>增量赋值操作符应用到不可变对象只是一个语法糖：它并没有改变对象，而是创建了一个新对象，并重新<br>绑定到新对象。</p>
<p>我们需要记住<code>=</code>操作符执行绑定操作而不是赋值。</p>
<h2 id="整数和长整数">整数和长整数</h2><p><code>Python</code>提供3种整数类型：<code>bool</code>，<code>int</code>，<code>long</code>。<br><code>bool</code>类型的值只能是<code>True</code>和<code>False</code>。当用于数字环境时，被当作1和0。<br><code>long</code>类型的长度只局限于机器的可用内存。<br><code>int</code>类型的长度和大多数语言的一样。当<code>int</code>类型有溢出危险时，自动提升为<code>long</code>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="执行Python代码">执行Python代码</h1><pre><code><span class="built_in">print</span> <span class="string">'Hello world'</span>
</code></pre><p>]]>
    </summary>
    
      <category term="Python" scheme="https://opensvn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[面向对象编程]]></title>
    <link href="https://opensvn.github.io/2015/09/21/cpp_primer_15/"/>
    <id>https://opensvn.github.io/2015/09/21/cpp_primer_15/</id>
    <published>2015-09-21T01:04:53.000Z</published>
    <updated>2015-09-30T10:55:41.034Z</updated>
    <content type="html"><![CDATA[<p>面向对象编程是基于三个基本概念：数据抽象，继承和动态绑定。</p>
<h1 id="OOP概述">OOP概述</h1><h2 id="继承">继承</h2><p>通过继承联系的类构成一个层级关系。典型地，有一个基类在层级的顶端，其它类直接或间接继承这个类。<br>这些继承类被称为派生类。基类定义层级中共同的成员。每一个派生类定义它自己特定的成员。</p>
<pre><code><span class="keyword">class</span> Quote {
<span class="keyword">public</span>:
    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span></span>;
    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::size_t n)</span> <span class="keyword">const</span></span>;
};
</code></pre><p>派生类必须指定继承自哪个（或哪些）基类。继承列表是逗号分隔的包含可选访问限定符的基类列表。</p>
<pre><code><span class="keyword">class</span> Bulk_quote : <span class="keyword">public</span> Quote { <span class="comment">// Bulk_quote继承自Quote</span>
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::size_t)</span> <span class="keyword">const</span> override</span>;
};
</code></pre><p>派生类必须在类定义里面包含所有它想定义的虚函数的声明。派生类可以声明这些函数为virtual，但没有<br>要求这么做。新标准让派生类可以显式指定想要覆盖的虚函数，在参数列表后面指定<code>override</code>就可以。</p>
<h2 id="动态绑定">动态绑定</h2><pre><code><span class="function"><span class="keyword">double</span> <span class="title">print_total</span><span class="params">(ostream &amp;os,
                   <span class="keyword">const</span> Quote &amp;item, size_t n)</span>
</span>{
    <span class="comment">// 取决于绑定到item参数的类型调用Quote::net_price或Bulk_quote::net_price</span>
    <span class="keyword">double</span> ret = item.net_price(n);
    os &lt;&lt; <span class="string">"ISBN: "</span> &lt;&lt; item.isbn() <span class="comment">// 调用Quote::isbn</span>
       &lt;&lt; <span class="string">" # sold: "</span> &lt;&lt; n &lt;&lt; <span class="string">" total due: "</span> &lt;&lt; ret &lt;&lt; endl;
     <span class="keyword">return</span> ret;
}

<span class="comment">// basic是Quote类型; bulk是Bulk_quote类型</span>
print_total(<span class="built_in">cout</span>, basic, <span class="number">20</span>); <span class="comment">// 调用Quote::net_price</span>
print_total(<span class="built_in">cout</span>, bulk, <span class="number">20</span>);  <span class="comment">// 调用Bulk_quote::net_price</span>
</code></pre><p>因为运行哪个函数取决于参数的类型的决定直到运行时才能确定，因此动态绑定又叫运行时绑定。</p>
<blockquote>
<p><strong>注解</strong><br>在C++中，动态绑定发生在通过基类的引用或指针调用虚函数时。</p>
</blockquote>
<h1 id="定义基类和派生类">定义基类和派生类</h1><h2 id="定义一个基类">定义一个基类</h2><pre><code><span class="keyword">class</span> Quote {
<span class="keyword">public</span>:
    Quote() = <span class="keyword">default</span>;
    Quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;book, <span class="keyword">double</span> sales_price):
                     bookNo(book), price(sales_price) { }
    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> bookNo; }
    <span class="comment">// 派生类将覆盖和应用不同的打折策略</span>
    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::size_t n)</span> <span class="keyword">const</span>
               </span>{ <span class="keyword">return</span> n * price; }
    <span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>; <span class="comment">// 析构函数动态绑定</span>
<span class="keyword">private</span>:
    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;
<span class="keyword">protected</span>:
    <span class="keyword">double</span> price = <span class="number">0.0</span>;
};
</code></pre><blockquote>
<p><strong>注解</strong><br>基类通常应该定义一个虚析构函数，即使没有什么工作要做。</p>
</blockquote>
<h3 id="成员函数和继承">成员函数和继承</h3><p>基类将那些期望派生类覆盖的函数定义为虚函数。<br>任何非<code>static</code>的成员函数，除了构造函数，可以为虚函数。关键字<code>virtual</code>仅仅出现在类里面声明处，<br>在类外面函数定义处不需要出现。基类中声明为<code>virtual</code>的函数，在派生类中隐式为<code>virtual</code>。</p>
<h3 id="访问控制和继承">访问控制和继承</h3><p>派生类继承基类的成员，但是派生类的成员函数不能访问基类的私有成员。有时候基类允许派生类访问而又<br>禁止其他用户使用，我们指定这类成员为<code>protected</code>。</p>
<h2 id="定义一个派生类">定义一个派生类</h2><p>派生类必须指定继承自哪个类，子类在类继承列表中指定基类。类继承列表由逗号分隔的基类名组成，每个<br>基类名前面可能有<code>public</code>，<code>protected</code>，<code>private</code>其中一个。<br>派生类必须声明每一个想要覆盖的成员函数。</p>
<pre><code><span class="keyword">class</span> Bulk_quote : <span class="keyword">public</span> Quote { <span class="comment">// Bulk_quote继承自Quote</span>
    Bulk_quote() = <span class="keyword">default</span>;
    Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;, <span class="keyword">double</span>, <span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="keyword">double</span>);
    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::size_t)</span> <span class="keyword">const</span> override</span>;
<span class="keyword">private</span>:
    <span class="built_in">std</span>::<span class="keyword">size_t</span> min_qty = <span class="number">0</span>; <span class="comment">// 打折需要的最小购买量</span>
    <span class="keyword">double</span> discount = <span class="number">0.0</span>;   <span class="comment">// 折扣</span>
};
</code></pre><p>当继承为<code>public</code>时，基类的<code>public</code>成员成为派生类的接口。另外，我们能将<code>public</code>继承的派生<br>类对象绑定到基类的指针或引用。</p>
<p>大多数类直接继承一个基类，这种继承称为单继承，继承超过一个基类称为多继承。</p>
<h3 id="派生类中的虚函数">派生类中的虚函数</h3><p>派生类经常但不总是覆盖它们继承的虚函数。如果派生类不覆盖虚函数，则像其它成员一样，继承基类的版本。<br>参数列表后面，或<code>const</code>或引用限定符后面指定<code>override</code>覆盖虚函数。</p>
<h3 id="派生类对象和派生类到基类的转换">派生类对象和派生类到基类的转换</h3><p>派生类对象包含了多个部分：一个子对象包含派生类自己定义的非<code>static</code>成员，加上一个从基类继承而来<br>的相应的子对象。</p>
<p>因为派生类对象包含对应于基类的子部分，我们可以使用子类就好像它是基类一样。特别地，我们可以将子类<br>对象绑定到基类的引用或指针。</p>
<pre><code><span class="label">Quote</span> <span class="keyword">item; </span>       // 基类对象
<span class="keyword">Bulk_quote </span><span class="keyword">bulk; </span>  // 子类对象
<span class="label">Quote</span> *p = &amp;<span class="keyword">item; </span> // 指向基类的指针
p = &amp;<span class="keyword">bulk; </span>        // p指向<span class="keyword">bulk的Quote部分
</span><span class="label">Quote</span> &amp;r = <span class="keyword">bulk; </span>  // r绑定到<span class="keyword">bulk的Quote部分</span>
</code></pre><p>这种转换称为派生类到基类的转换。和其它转换一样，编译器隐式应用派生类到基类的转换。</p>
<blockquote>
<p><strong>注解</strong><br>派生类对象包含基类的子对象是继承如何工作的关键。</p>
</blockquote>
<h3 id="派生类构造函数">派生类构造函数</h3><p>尽管派生类对象包含从基类继承的成员，但是派生类不能直接初始化这些成员。派生类必须使用基类的构造函数<br>初始化基类部分。</p>
<blockquote>
<p><strong>注解</strong><br>每一个类控制它的成员如何初始化。</p>
</blockquote>
<pre><code>Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> p,
           <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc) :
           Quote(book, p), min_qty(qty), discount(disc) { }
    <span class="comment">// as before</span>
};
</code></pre><blockquote>
<p><strong>注解</strong><br>基类成员先初始化，然后按声明的顺序初始化派生类的成员。</p>
</blockquote>
<h3 id="在派生类中使用基类的成员">在派生类中使用基类的成员</h3><p>派生类可以使用基类的<code>public</code>和<code>protected</code>成员：</p>
<pre><code><span class="comment">// 如果购买了指定数量的商品，使用折扣价格</span>
<span class="keyword">double</span> Bulk_quote::net_price(<span class="keyword">size_t</span> cnt) <span class="keyword">const</span>
{
    <span class="keyword">if</span> (cnt &gt;= min_qty)
        <span class="keyword">return</span> cnt * (<span class="number">1</span> - discount) * price;
    <span class="keyword">else</span>
        <span class="keyword">return</span> cnt * price;
}
</code></pre><p>值得知道的是派生类的作用域嵌套在基类作用域里面。因此派生类使用基类和自己的成员没有差别。</p>
<blockquote>
<p><strong>关键概念</strong>:尊重基类的接口<br>派生类构造函数可以对基类的<code>public</code>和<code>protected</code>成员赋值。尽管如此，通常不应该这么做。像基类<br>的其他用户一样，派生类应该尊重基类的接口，使用基类的构造函数初始化基类部分成员。</p>
</blockquote>
<h3 id="继承和static成员">继承和static成员</h3><p>如果基类定义了<code>static</code>成员，那么在整个继承层次中只有一个这样的成员。不管有多少个派生类，每一个<br><code>static</code>成员只有一个实例。</p>
<pre><code><span class="keyword">class</span> Base {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">statmem</span><span class="params">()</span></span>;
};
<span class="keyword">class</span> Derived : <span class="keyword">public</span> Base {
    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Derived&amp;)</span></span>;
};
<span class="keyword">void</span> Derived::f(<span class="keyword">const</span> Derived &amp;derived_obj)
{
    Base::statmem();    <span class="comment">// ok: Base定义了statmem</span>
    Derived::statmem(); <span class="comment">// ok: Derived继承类statmem</span>
    <span class="comment">// ok: 派生类对象可以访问基类的static成员</span>
    derived_obj.statmem();
    statmem();
}
</code></pre><h3 id="派生类的声明">派生类的声明</h3><p>派生类的声明和其它类一样。声明包含类名字但不包括派生列表：</p>
<pre><code><span class="keyword">class</span> <span class="title">Bulk_quote</span> : <span class="title">public</span> <span class="title">Quote</span>; <span class="comment">// error: 派生列表不能出现在这</span>
<span class="keyword">class</span> <span class="title">Bulk_quote</span>; <span class="comment">// ok: 声明派生类的正确方式</span>
</code></pre><h3 id="作为基类使用的类">作为基类使用的类</h3><p>在使用类作为基类前，一个类必须定义，而不仅仅是声明：</p>
<pre><code><span class="keyword">class</span> <span class="title">Quote</span>;   <span class="comment">// 声明但是未定义</span>
<span class="comment">// error: Quote必须定义</span>
<span class="keyword">class</span> <span class="title">Bulk_quote</span> : <span class="title">public</span> <span class="title">Quote</span> { ... };
</code></pre><p>这个规则暗示我们一个类不可能继承自己。</p>
<h3 id="阻止继承">阻止继承</h3><p>在新标准下，我们可以在类名后面跟着<code>final</code>阻止类被继承：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">NoDerived</span> <span class="title">final</span> </span>{ <span class="comment">/*  */</span> }; <span class="comment">// NoDerived不能作为基类</span>
<span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>{ <span class="comment">/*  */</span> };
<span class="class"><span class="keyword">class</span> <span class="title">Last</span> <span class="title">final</span> : <span class="title">Base</span> </span>{ <span class="comment">/*  */</span> }; <span class="comment">// Last不能作为基类</span>
<span class="class"><span class="keyword">class</span> <span class="title">Bad</span> : <span class="title">NoDerived</span> </span>{ <span class="comment">/*  */</span> };   <span class="comment">// error: NoDerived is final</span>
<span class="class"><span class="keyword">class</span> <span class="title">Bad2</span> : <span class="title">Last</span> </span>{ <span class="comment">/*  */</span> };       <span class="comment">// error: Last is final</span>
</code></pre><h2 id="转换和继承">转换和继承</h2><blockquote>
<p><strong>警告</strong><br>理解基类和派生类之间的转换是理解C++面向对象编程如何工作的基础</p>
</blockquote>
<p>通常我们只能绑定指针或引用到相同类型的对象上或者需要一个可接受的转换。<br>可以将基类的引用或指针绑定到一个派生类对象的事实暗示：当我们使用基类的指针或引用时，我们不知道指针<br>或引用绑定的对象的实际类型。这个对象可以是基类对象或派生类对象。</p>
<blockquote>
<p><strong>注解</strong><br>像内置指针一样，智能指针支持派生类到基类的转换。</p>
</blockquote>
<h3 id="静态类型和动态类型">静态类型和动态类型</h3><p>静态类型是变量声明的类型或表达式产生的类型，在编译期间就已经知道了。<br>动态类型是变量或表达式表示的内存中对象的类型，运行时才知道。</p>
<p>不是指针或引用的表达式的动态类型总是和静态类型一样。</p>
<blockquote>
<p><strong>注解</strong><br>理解基类的指针或引用的静态类型与动态类型可能不一样很重要。</p>
</blockquote>
<h3 id="没有基类到派生类的隐式转换">没有基类到派生类的隐式转换</h3><pre><code><span class="label">Quote</span> <span class="keyword">base;
</span><span class="keyword">Bulk_quote* </span><span class="keyword">bulkP </span>= &amp;<span class="keyword">base; </span> // error: can<span class="string">'t convert base to derived
Bulk_quote&amp; bulkRef = base; // error: can'</span>t convert <span class="keyword">base </span>to derived
</code></pre><p>令人惊讶地是，我们也不能将基类转换到派生类，即使基类指针或引用绑定的是派生类对象：</p>
<pre><code><span class="keyword">Bulk_quote </span><span class="keyword">bulk;
</span><span class="label">Quote</span> *<span class="keyword">itemP </span>= &amp;<span class="keyword">bulk; </span>       // ok: dynamic type is <span class="keyword">Bulk_quote
</span><span class="keyword">Bulk_quote </span>*<span class="keyword">bulkP </span>= <span class="keyword">itemP; </span>  // error: can<span class="string">'t convert base to derived</span>
</code></pre><h3 id="也没有对象间的转换">也没有对象间的转换</h3><p>派生类到基类的自动转换只发生在引用或指针类型的转换。派生类和基类之间没有这种转换。</p>
<pre><code>Bulk_quote bulk;  <span class="comment"> // object of derived type</span>
Quote <span class="keyword">item</span>(bulk); <span class="comment"> // uses the Quote::Quote(const Quote&amp;) constructor</span>
<span class="keyword">item</span> = bulk;      <span class="comment"> // calls Quote::operator=(const Quote&amp;)</span>
</code></pre><blockquote>
<p><strong>警告</strong><br>当我们用一个派生类对象给一个基类对象初始化或赋值时，只有基类部分复制，移动或赋值了，派生类部分被<br>忽略了。</p>
<p><strong>关键概念</strong>：继承相关的类型转换</p>
<ul>
<li>继承类到基类的转换只发生在指针或引用类型</li>
<li>没有基类到继承类的隐式转换</li>
<li>像其它成员一样，继承类到基类的转换可能因为访问控制的原因不能访问。</li>
</ul>
</blockquote>
<h1 id="虚函数">虚函数</h1><p>因为运行之前我们不知道哪个函数会调用，虚函数必须总是定义了的。</p>
<h2 id="虚函数调用可能在运行时确定">虚函数调用可能在运行时确定</h2><p>动态绑定仅仅发生在通过指针或引用调用虚函数。</p>
<pre><code><span class="keyword">base</span> = derived;         <span class="comment">// 从derived拷贝Quote部分到base </span>
<span class="keyword">base</span>.net_price(<span class="number">20</span>);     <span class="comment">// 调用Quote::net_price</span>
</code></pre><p>当我们在一个表达式中用一个非引用且非指针的普通类型调用虚函数时，绑定发生在编译期间。</p>
<blockquote>
<p><strong>关键概念</strong>：C++中的多态<br>指针和引用的动态类型和静态类型可以不同是C++支持多态的基石。</p>
<p><strong>注解</strong><br>运行期间确定虚函数仅当通过指针或引用的调用。只有这些情况下，对象的动态类型才可能和静态类型不同。</p>
</blockquote>
<h2 id="派生类的虚函数">派生类的虚函数</h2><p>当派生类覆盖了一个虚函数时，声明时可以重复<code>virtual</code>关键字，但是没有要求这样做。一旦一个函数被<br>声明为<code>virtual</code>，这个函数在所有继承类中都是<code>virtual</code>。</p>
<p>派生类中的虚函数必须和基类中虚函数参数一样。除了一个例外，派生类虚函数的返回类型也必须和基类一样。<br>这个例外就是返回类型为和继承相关的指针或引用。</p>
<blockquote>
<p><strong>注解</strong><br>基类中的虚函数在继承类中隐式为<code>virtual</code>。当派生类覆盖一个虚函数，参数必须和基类一样。</p>
</blockquote>
<h2 id="final和override限定符">final和override限定符</h2><p>继承类定义一个和基类虚函数同名但是参数不同的函数是合法的。编译器认为这样的函数独立于基类的虚函数。</p>
<p>新标准下我们可以在继承类中指定虚函数为<code>override</code>。编译器会拒绝程序如果函数标为<code>override</code>却<br>没有覆盖一个已存在的虚函数。</p>
<pre><code><span class="keyword">struct</span> B {
    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span>(<span class="params"><span class="keyword">int</span></span>) <span class="keyword">const</span></span>;
    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span>(<span class="params"></span>)</span>;
    <span class="function"><span class="keyword">void</span> <span class="title">f3</span>(<span class="params"></span>)</span>;
};
<span class="keyword">struct</span> D1 : B {
    <span class="function"><span class="keyword">void</span> <span class="title">f1</span>(<span class="params"><span class="keyword">int</span></span>) <span class="keyword">const</span> <span class="keyword">override</span></span>; <span class="comment">// ok: f1 matches f1 in the base</span>
    <span class="function"><span class="keyword">void</span> <span class="title">f2</span>(<span class="params"><span class="keyword">int</span></span>) <span class="keyword">override</span></span>; <span class="comment">// error: B has no f2(int) function</span>
    <span class="function"><span class="keyword">void</span> <span class="title">f3</span>(<span class="params"></span>) <span class="keyword">override</span></span>;    <span class="comment">// error: f3 not virtual</span>
    <span class="function"><span class="keyword">void</span> <span class="title">f4</span>(<span class="params"></span>) <span class="keyword">override</span></span>;    <span class="comment">// error: B doesn't have a function named f4</span>
};
</code></pre><p>我们也可以将一个函数指定为<code>final</code>。任何试图覆盖一个被定义为<code>final</code>的函数都被视为错误：</p>
<pre><code><span class="keyword">struct</span> D2 : B {
    <span class="comment">// inherits f2() and f3() from B and overrides f1(int)</span>
    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> final</span>; <span class="comment">// 后续子类不能覆盖f1(int)</span>
};
<span class="keyword">struct</span> D3 : D2 {
    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>; <span class="comment">// ok: overrides f2 inherited from the indirect base, B</span>
    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>; <span class="comment">// error: D2 declared f2 as final</span>
};
</code></pre><p><code>final</code>和<code>override</code>限定符出现在参数列表（包含const或引用修饰符）和尾返回之后。</p>
<h2 id="虚函数和默认实参">虚函数和默认实参</h2><p>如果一个函数调用使用默认实参，被使用的值是函数定义的静态类型的值。</p>
<blockquote>
<p><strong>最佳实践</strong><br>包含默认实参的虚函数应该在基类和派生类中使用相同的默认实参。</p>
</blockquote>
<h2 id="避开虚机制">避开虚机制</h2><p>我们可以使用<code>::</code>操作符强制调用指定版本的虚函数。</p>
<pre><code><span class="comment">// 调用基类版本，不管baseP的动态类型</span>
<span class="keyword">double</span> undiscounted = baseP-&gt;Quote::net_price(<span class="number">42</span>);
</code></pre><blockquote>
<p><strong>注解</strong><br>通常，只有成员函数或友元函数里面的代码应该使用作用域操作符来避开虚机制。</p>
<p><strong>警告</strong><br>如果继承类虚函数想要调用基类版本的虚函数，却忽略了作用域操作符，将会导致无限递归。</p>
</blockquote>
<h1 id="虚基类">虚基类</h1><h2 id="纯虚函数">纯虚函数</h2><p>和普通的虚函数不一样的是，纯虚函数没有必要定义。虚函数写上<code>= 0</code>替代函数体成为纯虚函数。<code>= 0</code>只<br>出现在类里面函数声明处。</p>
<pre><code><span class="comment">// class to hold the discount rate and quantity</span>
<span class="comment">// derived classes will implement pricing strategies using these data</span>
<span class="keyword">class</span> Disc_quote : <span class="keyword">public</span> Quote {
<span class="keyword">public</span>:
    Disc_quote() = <span class="keyword">default</span>;
    Disc_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> price,
              <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc):
                 Quote(book, price),
                 quantity(qty), discount(disc) { }
    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::size_t)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;
<span class="keyword">protected</span>:
    <span class="built_in">std</span>::<span class="keyword">size_t</span> quantity = <span class="number">0</span>; <span class="comment">//  purchase size for the discount to apply</span>
    <span class="keyword">double</span> discount = <span class="number">0.0</span>;    <span class="comment">//  fractional discount to apply</span>
};
</code></pre><p>值得注意的是我们可以提供纯虚函数的定义，但是必须定义在类外面。</p>
<h2 id="有纯虚函数的类为虚基类">有纯虚函数的类为虚基类</h2><p>包含纯虚函数的类（或继承而没有覆盖）是虚基类。虚基类为后续的子类定义了可覆盖的接口。不能直接创建<br>虚基类的对象。</p>
<pre><code>// Disc_quote定义了<span class="keyword">Bulk_quote将要覆盖的纯虚函数
</span><span class="label">Disc_quote</span> discounted<span class="comment">; // error: can't define a Disc_quote object</span>
<span class="keyword">Bulk_quote </span><span class="keyword">bulk; </span>      // ok: <span class="keyword">Bulk_quote </span>has no pure virtual functions
</code></pre><h2 id="派生类构造函数只初始化其直接基类">派生类构造函数只初始化其直接基类</h2><p>每一个类控制自己类对象的初始化。</p>
<blockquote>
<p><strong>关键概念：重构</strong><br>重构在面向对象程序里面很常见。</p>
</blockquote>
<h1 id="访问控制和继承-1">访问控制和继承</h1><h2 id="protected成员">protected成员</h2><p><code>protected</code>限定符可以被认为是<code>private</code>和<code>public</code>的混合：</p>
<ul>
<li>像<code>private</code>，<code>protected</code>成员对类用户是不可访问的。</li>
<li>像<code>public</code>，<code>protected</code>成员对派生类的成员和友元是可访问的。</li>
</ul>
<p>另外，<code>protected</code>有一个重要性质：</p>
<ul>
<li>派生类成员或友元只能通过派生类对象访问基类的<code>protected</code>成员。派生类没有权限访问基类<br><code>protected</code>成员。</li>
</ul>
<pre><code><span class="keyword">class</span> Base {
<span class="keyword">protected</span>:
    <span class="keyword">int</span> prot_mem;     <span class="comment">// protected member</span>
};
<span class="keyword">class</span> Sneaky : <span class="keyword">public</span> Base  {
    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;  <span class="comment">// can access Sneaky::prot_mem</span>
    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base&amp;)</span></span>;    <span class="comment">// can't access Base::prot_mem</span>
    <span class="keyword">int</span> j;                          <span class="comment">// j is private by default</span>
};
<span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span> </span>{ s.j = s.prot_mem = <span class="number">0</span>; } <span class="comment">// ok</span>
<span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span> </span>{ b.prot_mem = <span class="number">0</span>; } <span class="comment">// error</span>
</code></pre><h2 id="public，private和protected继承">public，private和protected继承</h2><p>继承类成员的访问由基类中该成员访问控制符和派生列表访问控制符共同控制。</p>
<pre><code><span class="keyword">class</span> <span class="title">Base</span> {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">void</span> <span class="title">pub_mem</span>(<span class="params"></span>)</span>;   <span class="comment">// public member</span>
<span class="keyword">protected</span>:
    <span class="keyword">int</span> prot_mem;     <span class="comment">// protected member</span>
<span class="keyword">private</span>:
    <span class="keyword">char</span> priv_mem;    <span class="comment">// private member</span>
};
<span class="keyword">struct</span> Pub_Derv : <span class="keyword">public</span> Base {
    <span class="comment">// ok: derived classes can access protected members</span>
    <span class="function"><span class="keyword">int</span> <span class="title">f</span>(<span class="params"></span>) </span>{ <span class="keyword">return</span> prot_mem; }
    <span class="comment">// error: private members are inaccessible to derived classes</span>
    <span class="function"><span class="keyword">char</span> <span class="title">g</span>(<span class="params"></span>) </span>{ <span class="keyword">return</span> priv_mem; }
};
<span class="keyword">struct</span> Priv_Derv : <span class="keyword">private</span> Base {
    <span class="comment">// private derivation doesn't affect access in the derived class</span>
    <span class="function"><span class="keyword">int</span> <span class="title">f1</span>(<span class="params"></span>) <span class="keyword">const</span> </span>{ <span class="keyword">return</span> prot_mem; }
};
</code></pre><p>派生类的访问控制符对派生类访问其直接基类的成员没有影响。基类成员的访问只由基类的访问控制符控制。<br>派生类的访问控制符是用来控制派生类使用者及子类对其成员的使用。</p>
<pre><code>Pub_Derv d1;   <span class="comment">//  members inherited from Base are public</span>
Priv_Derv d2;  <span class="comment">//  members inherited from Base are private</span>
d1.pub_mem();  <span class="comment">//  ok: pub_mem is public in the derived class</span>
d2.pub_mem();  <span class="comment">//  error: pub_mem is private in the derived class</span>

<span class="keyword">struct</span> Derived_from_Public : <span class="keyword">public</span> Pub_Derv {
    <span class="comment">// ok: Base::prot_mem remains protected in Pub_Derv</span>
    <span class="function"><span class="keyword">int</span> <span class="title">use_base</span><span class="params">()</span> </span>{ <span class="keyword">return</span> prot_mem; }
};
<span class="keyword">struct</span> Derived_from_Private : <span class="keyword">public</span> Priv_Derv {
    <span class="comment">// error: Base::prot_mem is private in Priv_Derv</span>
    <span class="function"><span class="keyword">int</span> <span class="title">use_base</span><span class="params">()</span> </span>{ <span class="keyword">return</span> prot_mem; }
};
</code></pre><h2 id="派生类到基类的转换的可访问性">派生类到基类的转换的可访问性</h2><p>假设D继承B：</p>
<ul>
<li>用户代码可以使用派生类到基类的转换当D公开继承B，私有继承或保护继承都不行。</li>
<li>D的成员函数和友元可以使用派生类到基类的转换而不管是如何继承的。派生类到直接基类的转换对于<br>派生类的成员和友元总是可以访问的。</li>
<li>从D派生的成员函数和友元能使用派生类到基类的转换当D公开或保护继承B，私有继承不行。</li>
</ul>
<blockquote>
<p><strong>提示</strong><br>在代码的任何地方，如果基类的<code>public</code>成员能够访问，则派生类到基类的转换可以访问，反过来不行。</p>
</blockquote>
<h2 id="友元和继承">友元和继承</h2><p>就像友元不能传递，友元也不能继承。</p>
<pre><code><span class="keyword">class</span> <span class="title">Base</span> {
    <span class="comment">// added friend declaration; other members as before</span>
    friend <span class="keyword">class</span> <span class="title">Pal</span>; <span class="comment">// Pal has no access to classes derived from Base</span>
};
<span class="keyword">class</span> <span class="title">Pal</span> {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">int</span> <span class="title">f</span>(<span class="params">Base b</span>) </span>{ <span class="keyword">return</span> b.prot_mem; } <span class="comment">// ok: Pal is a friend of</span>
<span class="function">Base
    <span class="keyword">int</span> <span class="title">f2</span>(<span class="params">Sneaky s</span>) </span>{ <span class="keyword">return</span> s.j; } <span class="comment">// error: Pal not friend of</span>
Sneaky
    <span class="comment">// access to a base class is controlled by the base class, even inside a derived</span>
<span class="function"><span class="keyword">object</span>
    <span class="keyword">int</span> <span class="title">f3</span>(<span class="params">Sneaky s</span>) </span>{ <span class="keyword">return</span> s.prot_mem; } <span class="comment">// ok: Pal is a friend</span>
};
</code></pre><p>当类A将类B作为友元时，只有类B被授予了友元关系。类B的基类或子类都没有A的特殊访问权限。</p>
<pre><code><span class="comment">// D2 has no access to protected or private members in Base</span>
<span class="keyword">class</span> D2 : <span class="keyword">public</span> Pal {
<span class="keyword">public</span>:
   <span class="function"><span class="keyword">int</span> <span class="title">mem</span><span class="params">(Base b)</span>
       </span>{ <span class="keyword">return</span> b.prot_mem; } <span class="comment">// error: friendship doesn't inherit</span>
};
</code></pre><blockquote>
<p><strong>注解</strong><br>友元关系不能继承，每一个类控制自己成员的访问。</p>
</blockquote>
<h2 id="免除个别成员访问规则">免除个别成员访问规则</h2><p>有时候需要改变派生类中成员的访问级别，可以使用<code>using</code>声明。</p>
<pre><code><span class="keyword">class</span> Base {
<span class="keyword">public</span>:
    <span class="built_in">std</span>::<span class="keyword">size_t</span> size() <span class="keyword">const</span> { <span class="keyword">return</span> n; }
<span class="keyword">protected</span>:
    <span class="built_in">std</span>::<span class="keyword">size_t</span> n;
};
<span class="keyword">class</span> Derived : <span class="keyword">private</span> Base {    <span class="comment">//  <span class="doctag">note:</span> private inheritance</span>
<span class="keyword">public</span>:
    <span class="comment">// maintain access levels for members related to the size of the object</span>
    <span class="keyword">using</span> Base::size;
<span class="keyword">protected</span>:
    <span class="keyword">using</span> Base::n;
};
</code></pre><p>因为Derived使用<code>private</code>继承，则继承的成员默认为<code>private</code>成员。<code>using</code>声明调整了这些成员的<br>可访问级别。</p>
<p><code>using</code>声明可以命名任何可访问的直接或间接基类的成员。访问由<code>using</code>声明的名字取决于<code>using</code>声明<br>之前的访问限定符。</p>
<blockquote>
<p><strong>注解</strong><br>派生类只为允许访问的名字提供<code>using</code>声明。</p>
</blockquote>
<h2 id="默认继承保护级别">默认继承保护级别</h2><p>默认地，<code>class</code>关键字定义的派生类使用<code>private</code>继承，<code>struct</code>定义的派生类使用<code>public</code>继承。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>{ <span class="comment">/* ...   */</span> };
<span class="class"><span class="keyword">struct</span> <span class="title">D1</span> : <span class="title">Base</span> </span>{ <span class="comment">/* ...   */</span> };   <span class="comment">// public inheritance by default</span>
<span class="class"><span class="keyword">class</span> <span class="title">D2</span> : <span class="title">Base</span> </span>{ <span class="comment">/* ...   */</span> };    <span class="comment">// private inheritance by default</span>
</code></pre><p>一个常见的误解是使用<code>struct</code>和<code>class</code>定义的类有深层次的不同。仅有的不同就是成员的默认访问级别<br>和派生类默认访问不同。没有其它差别。</p>
<blockquote>
<p><strong>最佳实践</strong><br>类私有继承必须显式指定<code>private</code>而不是依赖默认行为。显式指定可以清晰的说明<code>private</code>继承是有意<br>的而不是疏忽。</p>
</blockquote>
<h1 id="继承下的类作用域">继承下的类作用域</h1><p>每一个类定义自己的作用域，作用域里面定义其成员。在继承下，派生类的作用域嵌套在基类作用域里面。如果<br>一个名字在派生类作用域找不到，则搜索外围基类作用域。正是这种分层嵌套的类作用域允许派生类成员使用<br>基类成员就好像这些成员是派生类的一部分一样。</p>
<pre><code><span class="keyword">Bulk_quote </span><span class="keyword">bulk;
</span><span class="label">cout</span> &lt;&lt; <span class="keyword">bulk.isbn();</span>
</code></pre><p>isbn的名字查找如下：</p>
<ul>
<li>因为isbn被Bulk_quote对象调用，查找从类Bulk_quote开始，没有找到。</li>
<li>因为Bulk_quote继承自Disc_quote，接下来查找Disc_quote，还是没找到。</li>
<li>因为Disc_quote继承自Quote，接下来查找Quote，找到了。</li>
</ul>
<h2 id="名字查找发生在编译时">名字查找发生在编译时</h2><p>对象，引用或指针的静态类型决定了对象的哪个成员可见，甚至当静态类型和动态类型不一样时。</p>
<pre><code><span class="keyword">class</span> Disc_quote : <span class="keyword">public</span> Quote {
<span class="keyword">public</span>:
    <span class="built_in">std</span>::pair&lt;<span class="keyword">size_t</span>, <span class="keyword">double</span>&gt; discount_policy() <span class="keyword">const</span>
        { <span class="keyword">return</span> {quantity, discount}; }
    <span class="comment">// other members as before</span>
};

Bulk_quote bulk;
Bulk_quote *bulkP = &amp;bulk; <span class="comment">//  static and dynamic types are the same</span>
Quote *itemP = &amp;bulk;      <span class="comment">//  static and dynamic types differ</span>
bulkP-&gt;discount_policy();  <span class="comment">//  ok: bulkP has type Bulk_quote*</span>
itemP-&gt;discount_policy();  <span class="comment">//  error: itemP has type Quote*</span>
</code></pre><blockquote>
<p><strong>关键概念</strong>：名字查找和继承<br>给定调用p-&gt;mem()或obj.mem()</p>
<ul>
<li>首先确定p的静态类型。因为调用了一个成员，p一定指向一个类类型。</li>
<li>查找p静态类型相应的成员mem，如果没找到，则继续在继承层级中找。如果基类中都没找到，编译错误。</li>
<li>一旦mem找到了，执行正常的类型检查以确认调用是否合法。</li>
<li>假设调用合法，编译器再根据调用是否为虚函数来产生代码。</li>
</ul>
</blockquote>
<h2 id="名字冲突和继承">名字冲突和继承</h2><p>和其它作用域一样，继承类可以重用其直接或间接基类中的一个名字。和往常一样，定义在内部作用域的名字，<br>隐藏了外部作用域名字的使用。</p>
<pre><code><span class="keyword">struct</span> Base {
    Base(): mem(<span class="number">0</span>) { }
<span class="keyword">protected</span>:
    <span class="keyword">int</span> mem;
};
<span class="keyword">struct</span> Derived : Base {
    Derived(<span class="keyword">int</span> i): mem(i) { } <span class="comment">// initializes Derived::mem to i</span>
                               <span class="comment">// Base::mem is default initialized</span>
    <span class="function"><span class="keyword">int</span> <span class="title">get_mem</span><span class="params">()</span> </span>{ <span class="keyword">return</span> mem; }  <span class="comment">// returns Derived::mem</span>
<span class="keyword">protected</span>:
    <span class="keyword">int</span> mem;   <span class="comment">// hides mem in the base</span>
};
</code></pre><blockquote>
<p><strong>注解</strong><br>与基类成员同名的派生类成员隐藏了基类成员的直接使用。</p>
</blockquote>
<h2 id="使用作用域操作符使用隐藏成员">使用作用域操作符使用隐藏成员</h2><pre><code><span class="keyword">struct</span> Derived : Base {
    <span class="function"><span class="keyword">int</span> <span class="title">get_base_mem</span><span class="params">()</span> </span>{ <span class="keyword">return</span> Base::mem; }
    <span class="comment">// ...</span>
};
</code></pre><blockquote>
<p><strong>最佳实践</strong><br>除了覆盖继承的虚函数，基类通常不应该重用已经在基类中定义过的名字。</p>
</blockquote>
<h2 id="名字查找发生在类型检查之前">名字查找发生在类型检查之前</h2><p>定义在派生类的同名函数不重载基类的函数。基类成员被隐藏了，即使参数列表不一样。</p>
<pre><code><span class="keyword">struct</span> Base {
    <span class="function"><span class="keyword">int</span> <span class="title">memfcn</span><span class="params">()</span></span>;
};
<span class="keyword">struct</span> Derived : Base {
    <span class="function"><span class="keyword">int</span> <span class="title">memfcn</span><span class="params">(<span class="keyword">int</span>)</span></span>;   <span class="comment">// hides memfcn in the base</span>
};
Derived d; Base b;
b.memfcn();       <span class="comment">//  calls Base::memfcn</span>
d.memfcn(<span class="number">10</span>);     <span class="comment">//  calls Derived::memfcn</span>
d.memfcn();       <span class="comment">//  error: memfcn with no arguments is hidden</span>
d.Base::memfcn(); <span class="comment">//  ok: calls Base::memfcn</span>
</code></pre><h2 id="虚函数和作用域">虚函数和作用域</h2><p>我们现在可以理解为什么派生类和基类中的虚函数必须有一样的参数列表。如果基类和派生类中虚函数参数不<br>一样，那么没有办法通过基类的引用或指针调用派生类虚函数。</p>
<pre><code><span class="keyword">class</span> Base {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span></span>;
};
<span class="keyword">class</span> D1 : <span class="keyword">public</span> Base {
<span class="keyword">public</span>:
    <span class="comment">// hides fcn in the base; this fcn is not virtual</span>
    <span class="comment">// D1 inherits the definition of Base::fcn()</span>
    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span></span>;      <span class="comment">// parameter list differs from fcn in Base</span>
    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>; <span class="comment">// new virtual function that does not exist in Base</span>
};
<span class="keyword">class</span> D2 : <span class="keyword">public</span> D1 {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// nonvirtual function hides D1::fcn(int)</span>
    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span></span>;    <span class="comment">// overrides virtual fcn from Base</span>
    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;    <span class="comment">// overrides virtual f2 from D1</span>
};

Base bobj;  D1 d1obj; D2 d2obj;
Base *bp1 = &amp;bobj, *bp2 = &amp;d1obj, *bp3 = &amp;d2obj;
bp1-&gt;fcn(); <span class="comment">// virtual call, will call Base::fcn at run time</span>
bp2-&gt;fcn(); <span class="comment">// virtual call, will call Base::fcn at run time</span>
bp3-&gt;fcn(); <span class="comment">// virtual call, will call D2::fcn at run time</span>
D1 *d1p = &amp;d1obj; D2 *d2p = &amp;d2obj;
bp2-&gt;f2(); <span class="comment">// error: Base has no member named f2</span>
d1p-&gt;f2(); <span class="comment">// virtual call, will call D1::f2() at run time</span>
d2p-&gt;f2(); <span class="comment">// virtual call, will call D2::f2() at run time</span>

Base *p1 = &amp;d2obj; D1 *p2 = &amp;d2obj; D2 *p3 =  &amp;d2obj;
p1-&gt;fcn(<span class="number">42</span>);  <span class="comment">// error: Base has no version of fcn that takes an int</span>
p2-&gt;fcn(<span class="number">42</span>);  <span class="comment">// statically bound, calls D1::fcn(int)</span>
p3-&gt;fcn(<span class="number">42</span>);  <span class="comment">// statically bound, calls D2::fcn(int)</span>
</code></pre><h2 id="覆盖重载函数">覆盖重载函数</h2><p>派生类可以覆盖0个或多个继承的重载函数。如果派生类想要使所有重载版本可用，则必须覆盖所有的函数或<br>所有函数不覆盖。</p>
<p>有时候只想覆盖一些重载函数，派生类可以提供一个<code>using</code>声明给重载的成员。一个<code>using</code>声明指示指定<br>一个名字，不带参数列表。因此，<code>using</code>声明将基类的重载函数都加到派生类的作用域。派生类只需定义<br>那些想要覆盖的函数。</p>
<h1 id="构造函数和复制控制">构造函数和复制控制</h1><h2 id="虚析构函数">虚析构函数</h2><p>继承给基类的复制控制主要的直接影响是基类通常应该定义一个虚析构函数。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> </span>{
<span class="keyword">public</span>:
    <span class="comment">// virtual destructor needed if a base pointer pointing to a derived object is deleted</span>
    virtual ~Quote() = <span class="keyword">default</span>; <span class="comment">// dynamic binding for the destructor</span>
};

Quote *itemP = <span class="keyword">new</span> Quote;   <span class="comment">//  same static and dynamic type</span>
<span class="keyword">delete</span> itemP;               <span class="comment">//  destructor for Quote called</span>
itemP = <span class="keyword">new</span> Bulk_quote;     <span class="comment">//  static and dynamic types differ</span>
<span class="keyword">delete</span> itemP;               <span class="comment">//  destructor for Bulk_quote called</span>
</code></pre><blockquote>
<p><strong>警告</strong><br>如果基类析构函数不是<code>virtual</code>的， <code>delete</code>基类指针指向派生类对象是<code>undefined</code>。</p>
</blockquote>
<h3 id="虚析构函数关闭了合成的Move">虚析构函数关闭了合成的Move</h3><p>如果一个类定义了虚析构函数，即使是<code>= default</code>使用合成版本，则编译器不会合成<code>move</code>操作。</p>
<h2 id="合成复制控制和继承">合成复制控制和继承</h2><p>基类或派生类中合成的复制控制成员和任何其它合成的复制控制成员一样：逐个初始化，复制或销毁类成员。<br>另外，这些成员使用基类的相应操作初始化，复制或销毁其对象的直接基类部分。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>面向对象编程是基于三个基本概念：数据抽象，继承和动态绑定。</p>
<h1 id="OOP概述">OOP概述</h1><h2 id="继承">继承</h2><p>通过继承联系的类构成一个层级关系。典型地，有一个基类在层级的顶端，其它类直接或间接继承这个类。<br>这些继承类]]>
    </summary>
    
      <category term="C++" scheme="https://opensvn.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[重载操作和转换]]></title>
    <link href="https://opensvn.github.io/2015/09/20/cpp_primer_14/"/>
    <id>https://opensvn.github.io/2015/09/20/cpp_primer_14/</id>
    <published>2015-09-20T02:47:02.000Z</published>
    <updated>2015-09-22T01:25:23.903Z</updated>
    <content type="html"><![CDATA[<p>这是C++ primer第五版第14章的读书笔记。</p>
<h1 id="基本概念">基本概念</h1><p>重载操作符是具有特殊名字的函数：关键字<code>operator</code>后面跟着需要被定义的操作符的符号。<br>像其它函数一样，重载操作符有返回值，参数列表和函数体。</p>
<p>重载操作符的参数和操作符的操作数一样多。除了函数调用操作符，<code>operator()</code>，重载操作符<br>没有默认实参。</p>
<blockquote>
<p><strong>注意</strong><br>当重载操作符是成员函数时，<code>this</code>绑定到左操作数。因此，成员操作符函数少一个操作数。</p>
</blockquote>
<p>操作符函数必须为类的成员或至少有一个类类型参数：</p>
<pre><code><span class="comment">// error: cannot redefine the built-in operator for ints</span>
<span class="keyword">int</span> <span class="keyword">operator</span>+(<span class="keyword">int</span>, <span class="keyword">int</span>);
</code></pre><p>我们可以重载大多数操作符，而且只能重载已经存在的操作符：</p>
<pre><code>                可以重载的操作符
+       -       *       /       %       ^
&amp;       |       ~       !       ,       =
&lt;       &gt;       &lt;=      &gt;=      ++      --
&lt;&lt;      &gt;&gt;      ==      !=      &amp;&amp;      ||
+=      -=      /=      %=      ^=      &amp;=
|=      *=      &lt;&lt;=     &gt;&gt;=     []      <span class="function"><span class="params">()</span>
-&gt;</span><span class="function">      -&gt;*</span>     <span class="keyword">new</span>     <span class="keyword">new</span>[]   <span class="keyword">delete</span>  <span class="keyword">delete</span>[]
                不能重载的操作符
        ::      .*      .       ?:
</code></pre><p>重载操作符和相应的内置操作符有相同的优先级和结合性。</p>
<h2 id="直接调用重载操作符函数">直接调用重载操作符函数</h2><pre><code><span class="keyword">data</span>1 + <span class="keyword">data</span>2;           // 表达式调用
operator+(<span class="keyword">data</span>1, <span class="keyword">data</span>2); // 等价的函数调用
<span class="keyword">data</span>1 += <span class="keyword">data</span>2;          // 表达式调用
<span class="keyword">data</span>1.operator+=(<span class="keyword">data</span>2); // 等价的成员函数调用
</code></pre><h2 id="有些操作符不应该重载">有些操作符不应该重载</h2><p>重载操作符不保留求值顺序或短路求值。</p>
<blockquote>
<p><strong>最佳实践</strong><br>通常，逗号（,），取地址（&amp;），逻辑与（&amp;&amp;）和逻辑或（||）不应该重载。</p>
</blockquote>
<h2 id="使用和内置操作符意思一致的定义">使用和内置操作符意思一致的定义</h2><ul>
<li>如果类使用IO，定义与内置类型IO操作一致的<code>shift</code>操作符</li>
<li>如果类有测试相等的操作，定义<code>operator==</code>。如果类有<code>operator==</code>，通常也应该定义<code>operator!=</code>。</li>
<li>如果类有单一的，自然顺序的操作，定义<code>operator&lt;</code>。如果类有<code>operator&lt;</code>，通常也应该定义其它关系操作符。</li>
<li>重载操作符的返回类型应该和内置操作符的返回类型兼容：逻辑操作符和关系操作符应该返回<code>bool</code>，算术操作符<br>应该返回类的值，赋值操作符应该返回左操作数的引用。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：明智地使用操作符重载<br>当内置操作符和类的操作有逻辑映射的时候，操作符重载最有用。</p>
</blockquote>
<h2 id="选择成员或非成员实现">选择成员或非成员实现</h2><p>以下指导方针能够帮助我们决定是否将一个操作符定义为成员函数或普通的非成员函数：</p>
<ul>
<li>赋值操作符（=），下标操作符（[]），调用操作符（()），成员访问操作符（-&gt;）必须定义为成员。</li>
<li>复合赋值操作符通常应该定义为成员，但是没有要求一定这样。</li>
<li>改变对象状态或与类对象联系紧密的操作符，通常应该定义为成员。比如++，–和解引用（*）。</li>
<li>那些可能转换操作数的对称的操作符，比如算术操作符，关系操作符，位操作符，通常应该定义为非成员。</li>
</ul>
<h1 id="输入输出操作符">输入输出操作符</h1><h2 id="重载输出操作符_&lt;&lt;">重载输出操作符 &lt;&lt;</h2><pre><code>ostream &amp;operator&lt;&lt;(ostream &amp;os, const Sales_data &amp;<span class="property">item</span>)
{
    os &lt;&lt; <span class="property">item</span>.isbn() &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="property">item</span>.units_sold &lt;&lt; <span class="string">" "</span>
       &lt;&lt; <span class="property">item</span>.revenue &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="property">item</span>.avg_price();
<span class="command">    return</span> os;
}
</code></pre><blockquote>
<p><strong>最佳实践</strong><br>通常输出操作符应该最小格式化输出对象的内容，不应该打印换行。</p>
</blockquote>
<h2 id="IO操作符必须是非成员函数">IO操作符必须是非成员函数</h2><p>输入输出操作符遵循库<code>iostream</code>的惯例必须为普通的非成员函数。</p>
<pre><code><span class="type">Sales_data</span> <span class="typedef"><span class="keyword">data</span>;</span>
<span class="typedef"><span class="keyword">data</span> &lt;&lt; cout; // 如果operator&lt;&lt;是<span class="type">Sales_data</span>的一个成员</span>
</code></pre><p>如果这些操作符是任意一个类的成员，那它们应该是<code>istream</code>或<code>ostream</code>的成员，但是我们无法给标准库添加成员。<br>输入输出操作符通常需要读或写非公开的数据成员。因此，IO操作符通常必须声明为<code>friend</code>。</p>
<h2 id="重载输入操作符_&gt;&gt;">重载输入操作符 &gt;&gt;</h2><pre><code>istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;<span class="keyword">is</span>, Sales_data &amp;item)
{
    <span class="keyword">double</span> price;
    <span class="keyword">is</span> &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;
    <span class="keyword">if</span> (<span class="keyword">is</span>)        <span class="comment">// 检查输入是否成功</span>
        item.revenue = item.units_sold * price;
    <span class="keyword">else</span>
        item = Sales_data(); <span class="comment">// 输入失败：给对象一个默认值</span>
    <span class="keyword">return</span> <span class="keyword">is</span>;
}
</code></pre><blockquote>
<p><strong>注意</strong><br>输入操作符必须处理输入失败的可能性。输出操作符通常没有这个困扰。</p>
</blockquote>
<p>我们选择在读取了所有数据之后，使用数据之前来检查流状态。</p>
<blockquote>
<p><strong>最佳实践</strong><br>输入操作符应该决定做什么错误恢复。当错误发生时，使对象处于一个合法状态尤其重要，因为对象可能被部分修改。</p>
</blockquote>
<p>通常输入操作符应该只设置<code>failbit</code>。<code>eofbit</code>和<code>badbit</code>最好是留给IO库去指示。</p>
<h1 id="算术和关系操作符">算术和关系操作符</h1><p>通常我们将算术和关系操作符定义为非成员函数，以允许转换左右操作符中的一个。这些操作符不需要修改<br>操作数的状态，所以参数通常为<code>const</code>引用。<br>定义了算术操作符的类通常也要定义相应的复合赋值操作符。</p>
<pre><code>Sales_data
operator+(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)
{
    Sales_data <span class="keyword">sum</span> = lhs;
    <span class="keyword">sum</span> += rhs;
    <span class="keyword">return</span> <span class="keyword">sum</span>;
}
</code></pre><blockquote>
<p><strong>提示</strong><br>定义了算术操作符和相应的复合赋值操作符的类，应该使用复合赋值操作符来实现算术操作符。</p>
</blockquote>
<h2 id="相等操作符">相等操作符</h2><pre><code><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)
{
    <span class="keyword">return</span> lhs.isbn() == rhs.isbn() &amp;&amp;
           lhs.units_sold == rhs.units_sold &amp;&amp;
           lhs.revenue == rhs.revenue;
}
<span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)
{
    <span class="keyword">return</span> !(lhs == rhs);
}
</code></pre><p>相等操作符的设计原理：</p>
<ul>
<li>如果一个类有一个确定2个对象是否相等的操作，那么该类应该定义<code>operator==</code>，而不是命名函数。<br>而且可以容易使用标准库容器和算法。</li>
<li>如果一个类定义了<code>operator==</code>，这个操作符通常应该确定给定的对象是否包含相同的数据。</li>
<li>通常地，相等操作符应该是可传递的， <code>if a == b and b == c, then a == c</code>。</li>
<li>如果一个类定义了<code>operator==</code>，那也应该定义<code>operator!=</code>，反之也一样。</li>
<li>相等或不等操作符应该将实际工作委托给另一个。</li>
</ul>
<blockquote>
<p><strong>最佳实践</strong><br>相等性具有逻辑意义的类通常应该定义<code>operator==</code>，定义了<code>operator==</code>的类使得用户容易使用标准库算法。</p>
</blockquote>
<h2 id="关系操作符">关系操作符</h2><p>定义了相等操作符的类通常（不总是）也会定义关系操作符。特别地，关系容器和有些算法使用<code>&lt;</code>操作符，<br>定义<code>operator&lt;</code>会很有用。</p>
<p>通常关系操作符应该：</p>
<ul>
<li>定义一个顺序关系和关联容器的key的需求一致。</li>
<li>定义一个关系和<code>==</code>一致，如果类2种操作符都定义了。特别地，如果2个对象<code>!=</code>，则其中一个应该<code>&lt;</code>另一个。</li>
</ul>
<blockquote>
<p><strong>最佳实践</strong><br>如果只有一个逻辑定义<code>&lt;</code>存在，类通常应该定义<code>&lt;</code>操作符。然而，如果类也有<code>==</code>，只有当<code>&lt;</code>和<code>==</code>产生<br>的结果一致时，定义<code>&lt;</code>。</p>
</blockquote>
<h1 id="赋值操作符">赋值操作符</h1><p>除了<code>copy-</code>和<code>move-</code>赋值操作符之外，类还可以定义其它的赋值操作符允许其它类型作为右操作数。</p>
<pre><code><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;
v = {<span class="string">"a"</span>, <span class="string">"an"</span>, <span class="string">"the"</span>};
<span class="keyword">class</span> StrVec {
<span class="keyword">public</span>:
    StrVec &amp;<span class="keyword">operator</span>=(<span class="built_in">std</span>::initializer_list&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;);
};
StrVec &amp;StrVec::<span class="keyword">operator</span>=(initializer_list&lt;<span class="built_in">string</span>&gt; il)
{
    <span class="keyword">auto</span> data = alloc_n_copy(il.begin(), il.end());
    <span class="built_in">free</span>();
    elements = data.first;
    first_free = cap = data.second;
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
</code></pre><p>不像<code>copy-</code>和<code>move-</code>赋值操作符，这个操作符不需要检查自我赋值。</p>
<blockquote>
<p><strong>注意</strong><br>赋值操作符可以被重载。不管参数类型是什么，赋值操作符必须定义为成员函数。</p>
</blockquote>
<p>复合赋值操作符不需要是类成员。然而，我们倾向于定义所有的赋值操作符，包括复合赋值操作符为类成员。</p>
<pre><code>Sales_data&amp; Sales_data::<span class="keyword">operator</span>+=(<span class="keyword">const</span> Sales_data &amp;rhs)
{
    units_sold += rhs.units_sold;
    revenue += rhs.revenue;
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
</code></pre><blockquote>
<p><strong>最佳实践</strong><br>赋值操作符必须，而且通常复合赋值操作符应该，定义为成员。这些操作符应该返回左操作数的引用。</p>
</blockquote>
<h1 id="下标操作符">下标操作符</h1><p>可以通过位置来获取元素的代表容器的类，通常定义下标操作符，<code>operater[]</code>。</p>
<blockquote>
<p><strong>注意</strong><br>下标操作符必须为成员函数。</p>
<p><strong>最佳实践</strong><br>如果一个类有下标操作符，它通常应该定义2个版本：一个返回普通引用，一个返回const引用。</p>
</blockquote>
<pre><code><span class="keyword">class</span> StrVec {
<span class="keyword">public</span>:
    <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n)
        { <span class="keyword">return</span> elements[n]; }
    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n) <span class="keyword">const</span>
        { <span class="keyword">return</span> elements[n]; }
<span class="keyword">private</span>:
    <span class="built_in">std</span>::<span class="built_in">string</span> *elements; <span class="comment">// 指向数组第一个元素</span>
};

<span class="keyword">const</span> StrVec cvec = svec;
<span class="keyword">if</span> (svec.size() &amp;&amp; svec[<span class="number">0</span>].empty())  {
    svec[<span class="number">0</span>] = <span class="string">"zero"</span>; <span class="comment">// ok: 返回一个普通引用</span>
    cvec[<span class="number">0</span>] = <span class="string">"Zip"</span>;  <span class="comment">// error: 返回一个const引用</span>
}
</code></pre><h1 id="自增和自减操作符">自增和自减操作符</h1><p>自增和自减操作符最常被迭代器类实现。语言并没要要求这些操作符是成员，但是由于这些操作符改变它们操作<br>的对象的状态，我们选择将它们定义为成员。</p>
<blockquote>
<p><strong>最佳实践</strong><br>定义自增或自减操作符的类应该定义<code>prefix</code>和<code>postfix</code>版本。这些操作符应该定义为成员。</p>
</blockquote>
<pre><code><span class="keyword">class</span> StrBlobPtr {
<span class="keyword">public</span>:
    StrBlobPtr&amp; <span class="keyword">operator</span>++(); <span class="comment">// 前自增操作符</span>
    StrBlobPtr&amp; <span class="keyword">operator</span>--(); <span class="comment">// 前自减操作符</span>
};

StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>++()
{
    check(curr, <span class="string">"increment past end of StrBlobPtr"</span>);
    ++curr;
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>--()
{
    --curr;
    check(-<span class="number">1</span>, <span class="string">"decrement past begin of StrBlobPtr"</span>);
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
</code></pre><blockquote>
<p><strong>最佳实践</strong><br>为了和内置操作符一致，前置操作符应该返回自增过或自减过的对象的引用。</p>
</blockquote>
<pre><code><span class="keyword">class</span> StrBlobPtr {
<span class="keyword">public</span>:
    StrBlobPtr <span class="keyword">operator</span>++(<span class="keyword">int</span>);    <span class="comment">// 后置操作符</span>
    StrBlobPtr <span class="keyword">operator</span>--(<span class="keyword">int</span>);
};

StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>++(<span class="keyword">int</span>)
{
    StrBlobPtr ret = *<span class="keyword">this</span>;
    ++*<span class="keyword">this</span>;
    <span class="keyword">return</span> ret;
}
StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>--(<span class="keyword">int</span>)
{
    StrBlobPtr ret = *<span class="keyword">this</span>;
    --*<span class="keyword">this</span>;
    <span class="keyword">return</span> ret;
}
</code></pre><blockquote>
<p><strong>最佳实践</strong><br>为了和内置操作符一致，后置操作符应该返回旧的（未自增或自减）值，而不是引用。</p>
<p><strong>注意</strong><br><code>int</code>参数没有用到，所以没有给它一个名字。</p>
</blockquote>
<pre><code><span class="function">StrBlobPtr <span class="title">p</span><span class="params">(a1)</span></span>;
p.<span class="keyword">operator</span>++(<span class="number">0</span>);  <span class="comment">// 调用后自增操作符</span>
p.<span class="keyword">operator</span>++();   <span class="comment">// 调用前自增操作符</span>
</code></pre><h1 id="成员访问操作符">成员访问操作符</h1><p>解引用（*）和箭头（-&gt;）操作符经常使用在迭代器类和智能指针类中。</p>
<pre><code><span class="keyword">class</span> StrBlobPtr {
<span class="keyword">public</span>:
    <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>
    { 
        <span class="keyword">auto</span> p = check(curr, <span class="string">"dereference past end"</span>);
        <span class="keyword">return</span> (*p)[curr];  <span class="comment">// (*p)是这个对象指向的vector</span>
    }
    <span class="built_in">std</span>::<span class="built_in">string</span>* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>
    {
        <span class="keyword">return</span> &amp; <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*(); <span class="comment">// 将实际工作委托给解引用操作符</span>
    }
};
</code></pre><blockquote>
<p><strong>注意</strong><br>箭头操作符必须定义为成员，没有要求解引用为成员但通常也应该为成员。</p>
</blockquote>
<p>值得注意的是我们定义这些操作符为<code>const</code>成员，获取一个元素不会改变这个对象的状态。</p>
<pre><code>StrBlob a1 = {<span class="string">"hi"</span>, <span class="string">"bye"</span>, <span class="string">"now"</span>};
<span class="function">StrBlobPtr <span class="title">p</span><span class="params">(a1)</span></span>;            <span class="comment">// p指向a1里面的vector</span>
*p = <span class="string">"okay"</span>;                 <span class="comment">// 给a1中第一个元素赋值</span>
<span class="built_in">cout</span> &lt;&lt; p-&gt;size() &lt;&lt; endl;   <span class="comment">// 第一个元素的size()</span>
<span class="built_in">cout</span> &lt;&lt; (*p).size() &lt;&lt; endl; <span class="comment">// 等价于p-&gt;size()</span>
</code></pre><p>当我们写<code>point-&gt;mem</code>时，<code>point</code>必须是指向一个类对象的指针或是一个重载了<code>operator-&gt;</code>的类<br>的对象。取决于<code>point</code>的类型，<code>point-&gt;mem</code>等价于：</p>
<pre><code>(*<span class="built_in">point</span>).mem;          <span class="comment">// point是一个内置指针类型</span>
<span class="built_in">point</span>.operator()-&gt;mem; <span class="comment">// point是一个类的对象</span>
</code></pre><blockquote>
<p><strong>注意</strong><br>箭头操作符必须返回一个指向类类型的指针或一个定义了自己的箭头操作符的类类型的对象。</p>
</blockquote>
<h1 id="函数调用操作符">函数调用操作符</h1><p>重载了函数调用操作符的类允许它的对象像函数一样使用。因为这种类可以保存状态，它们比普通函数更灵活。</p>
<pre><code><span class="keyword">struct</span> absInt {
    <span class="built_in">int</span> operator<span class="literal">()</span>(<span class="built_in">int</span> <span class="keyword">val</span>) const {
        return <span class="keyword">val</span> &lt; <span class="number">0</span> ? -<span class="keyword">val</span> : <span class="keyword">val</span>;
    }
};
</code></pre><p>定义了函数调用操作符的类的对象被称为函数对象，我们可以像函数调用一样提供一个参数列表给函数对象：</p>
<pre><code><span class="keyword">int</span> i = -<span class="number">42</span>;
absInt absObj;
<span class="keyword">int</span> ui = absObj(i);
</code></pre><blockquote>
<p><strong>注意</strong><br>函数调用操作符必须是成员函数。一个类可以定义多个版本的调用操作符，每一个参数类型或数量必须不一样。</p>
</blockquote>
<p>和其他类一样，一个函数对象类除了<code>operator()</code>，还可以有其它成员。函数对象类通常包含其它成员用来<br>调整函数调用操作符的操作。</p>
<pre><code><span class="keyword">class</span> PrintString {
<span class="keyword">public</span>:
    PrintString(ostream &amp;o = <span class="built_in">cout</span>, <span class="keyword">char</span> c = <span class="string">' '</span>):
        os(o), sep(c) { }
    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> <span class="keyword">const</span> </span>{ os &lt;&lt; s &lt;&lt; sep;}
<span class="keyword">private</span>:
    ostream &amp;os;   <span class="comment">// stream on which to write</span>
    <span class="keyword">char</span> sep;      <span class="comment">// character to print after each output</span>
};

PrintString printer;   <span class="comment">// uses the defaults; prints to cout</span>
printer(s);            <span class="comment">// prints s followed by a space on cout</span>
<span class="function">PrintString <span class="title">errors</span><span class="params">(<span class="built_in">cerr</span>, <span class="string">'\n'</span>)</span></span>;
errors(s);             <span class="comment">// prints s followed by a newline on cerr</span>
</code></pre><p>函数对象最常用于泛型算法的参数：</p>
<pre><code>for_each<span class="list">(<span class="keyword">vs</span>.begin<span class="list">()</span>, vs.end<span class="list">()</span>, PrintString<span class="list">(<span class="keyword">cerr</span>, '\n')</span>)</span><span class="comment">;</span>
</code></pre><h2 id="Lambdas是函数对象">Lambdas是函数对象</h2><p>当我们写一个<code>lambda</code>时，编译器将表达式翻译成一个匿名类的匿名对象。由<code>lambda</code>生成的类<br>包含了一个重载的函数调用操作符。</p>
<pre><code>stable_sort<span class="list">(<span class="keyword">words</span>.begin<span class="list">()</span>, words.end<span class="list">()</span>,
            []<span class="list">(<span class="keyword">const</span> string <span class="keyword">&amp;a</span>, const string <span class="keyword">&amp;b</span>)</span>
              { return a.size<span class="list">()</span> &lt; b.size<span class="list">()</span><span class="comment">;});</span></span>
</code></pre><p>行为就像一个匿名对象的类，看起来像：</p>
<pre><code><span class="keyword">class</span> <span class="title">ShorterString</span> {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span>(<span class="params"></span>)(<span class="params"><span class="keyword">const</span> <span class="keyword">string</span> &amp;s1, <span class="keyword">const</span> <span class="keyword">string</span> &amp;s2</span>) <span class="keyword">const</span>
    </span>{ <span class="keyword">return</span> s1.size() &lt; s2.size(); }
};

stable_sort(words.begin(), words.end(), ShorterString());
</code></pre><h2 id="类表示Lambdas带捕获成员">类表示Lambdas带捕获成员</h2><pre><code>auto wc = find_if<span class="list">(<span class="keyword">words</span>.begin<span class="list">()</span>, words.end<span class="list">()</span>,
            [sz]<span class="list">(<span class="keyword">const</span> string <span class="keyword">&amp;a</span>)</span>{ return a.size<span class="list">()</span> &gt;= sz<span class="comment">;});</span></span>
</code></pre><p>会生成像这样的类：</p>
<pre><code><span class="keyword">class</span> SizeComp {
<span class="keyword">public</span>:
    SizeComp(<span class="keyword">size_t</span> n): sz(n) { } <span class="comment">// parameter for each captured variable</span>
    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> <span class="keyword">const</span>
        </span>{ <span class="keyword">return</span> s.size() &gt;= sz; }
<span class="keyword">private</span>:
    <span class="keyword">size_t</span> sz; <span class="comment">// a data member for each variable captured by value</span>
};

<span class="keyword">auto</span> wc = find_if(words.begin(), words.end(), SizeComp(sz));
</code></pre><p>由lambda表达式生成的类有一个<code>deleted</code>默认构造函数，<code>deleted</code>赋值操作符和一个默认析构函数。<br>是否有默认的或<code>deleted``copy/move</code>构造函数取决于捕获的数据成员。</p>
<h2 id="标准库定义的函数对象">标准库定义的函数对象</h2><p>标准库定义了一个类集合，表示算术，关系和逻辑运算符。<br><code>plus</code>类有一个函数调用操作符，应用<code>+</code>操作符。<br><code>modulus</code>类有一个函数调用操作符，应用<code>%</code>操作符。<br><code>equal_to</code>类有一个函数调用操作符，应用<code>==</code>操作符。</p>
<pre><code>plus&lt;<span class="built_in">int</span>&gt; intAdd;       // <span class="function"><span class="keyword">function</span></span> object that can add two <span class="built_in">int</span> values
negate&lt;<span class="built_in">int</span>&gt; intNegate;  // <span class="function"><span class="keyword">function</span></span> object that can negate an <span class="built_in">int</span> <span class="keyword">value</span>
<span class="built_in">int</span> <span class="built_in">sum</span> = intAdd(<span class="number">10</span>, <span class="number">20</span>);         // <span class="built_in">sum</span> = <span class="number">30</span>
<span class="built_in">sum</span> = intNegate(intAdd(<span class="number">10</span>, <span class="number">20</span>));  // <span class="built_in">sum</span> = -<span class="number">30</span>
<span class="built_in">sum</span> = intAdd(<span class="number">10</span>, intNegate(<span class="number">10</span>));  // <span class="built_in">sum</span> = <span class="number">0</span>
</code></pre><h2 id="算法中使用标准库函数对象">算法中使用标准库函数对象</h2><pre><code><span class="comment">// passes a temporary function object that applies the &lt; operator to two strings</span>
sort(svec.<span class="keyword">begin</span>(), svec.<span class="keyword">end</span>(), greater&lt;<span class="keyword">string</span>&gt;());
</code></pre><p>标准库函数对象保证对指针也有作用。</p>
<pre><code>vector&lt;<span class="keyword">string</span> *&gt; nameTable;  <span class="comment">// vector of pointers</span>
<span class="comment">// error: the pointers in nameTable are unrelated, so &lt; is undefined</span>
sort(nameTable.<span class="keyword">begin</span>(), nameTable.<span class="keyword">end</span>(),
     [](<span class="keyword">string</span> *a, <span class="keyword">string</span> *b) <span class="comment">{ return a &lt; b; }</span>);
<span class="comment">// ok: library guarantees that less on pointer types is well defined</span>
sort(nameTable.<span class="keyword">begin</span>(), nameTable.<span class="keyword">end</span>(), less&lt;<span class="keyword">string</span>*&gt;());
</code></pre><p>值得注意的是关联容器使用<code>less&lt;key_type&gt;</code>排序它们的元素。因此，我们能定义一个指针集合，或者使用<br>一个指针作为<code>key</code>的<code>map</code>容器而不用直接指定<code>less</code>。</p>
<h2 id="可调用对象和函数">可调用对象和函数</h2><p>C++有几种可调用对象：函数和函数指针，lambdas，由<code>bind</code>创建的对象和重载了函数调用操作符的类。</p>
<p>不同类型可以有相同的调用签名：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{ <span class="keyword">return</span> i + j; } <span class="comment">// 普通函数</span>
<span class="keyword">auto</span> mod = [](<span class="keyword">int</span> i, <span class="keyword">int</span> j) { <span class="keyword">return</span> i % j; }; <span class="comment">// 匿名函数</span>
<span class="comment">// 函数对象类</span>
<span class="keyword">struct</span> div {
    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> denominator, <span class="keyword">int</span> divisor)</span> </span>{
        <span class="keyword">return</span> denominator / divisor;
    }
};

<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>(*)(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; binops;

binops.insert({<span class="string">"+"</span>, add}); <span class="comment">// ok: add是一个指向合适类型的函数指针</span>
binops.insert({<span class="string">"%"</span>, mod}); <span class="comment">// error: mod不是一个指向函数的指针</span>
</code></pre><h3 id="标准库function类型">标准库function类型</h3><pre><code><span class="comment">#include &lt;functional&gt;</span>

<span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt; <span class="title">f</span></span>;          空函数对象。
<span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt; <span class="title">f</span><span class="params">(nullptr)</span></span>; 显式构造空函数对象。
<span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt; <span class="title">f</span><span class="params">(obj)</span></span>;     保存一个obj的副本。
f                       <span class="keyword">true</span>当f拥有一个可调用对象，否则<span class="keyword">false</span>。
f(args)                 传递参数args，调用函数。

定义为<span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;的成员的类型
<span class="title">result_type</span>             可调用对象的返回类型。
<span class="title">argument_type</span>           当参数为1个或2个时的类型。
<span class="title">first_argument_type</span>
<span class="title">second_argument_type</span></span>
</code></pre><p><code>function</code>是一个模板。和其它模板一样，我们必须指定<code>function</code>的函数类型。</p>
<pre><code>function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f1 = add;    <span class="comment">// 函数指针</span>
function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f2 = div();  <span class="comment">// 函数对象</span>
function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f3 = [](<span class="keyword">int</span> i, <span class="keyword">int</span> j) { <span class="keyword">return</span> i * j;}; <span class="comment">// 匿名函数</span>
<span class="built_in">cout</span> &lt;&lt; f1(<span class="number">4</span>,<span class="number">2</span>) &lt;&lt; endl; <span class="comment">// prints 6</span>
<span class="built_in">cout</span> &lt;&lt; f2(<span class="number">4</span>,<span class="number">2</span>) &lt;&lt; endl; <span class="comment">// prints 2</span>
<span class="built_in">cout</span> &lt;&lt; f3(<span class="number">4</span>,<span class="number">2</span>) &lt;&lt; endl; <span class="comment">// prints 8</span>

<span class="built_in">map</span>&lt;<span class="built_in">string</span>, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; binops = {
    {<span class="string">"+"</span>, add},                  <span class="comment">// function pointer</span>
    {<span class="string">"-"</span>, <span class="built_in">std</span>::minus&lt;<span class="keyword">int</span>&gt;()},    <span class="comment">// library function object</span>
    {<span class="string">"/"</span>,  div()},               <span class="comment">// user-defined function object</span>
    {<span class="string">"*"</span>, [](<span class="keyword">int</span> i, <span class="keyword">int</span> j) { <span class="keyword">return</span> i * j; }}, <span class="comment">// unnamed lambda</span>
    {<span class="string">"%"</span>, mod} };                <span class="comment">// named lambda object</span>

binops[<span class="string">"+"</span>](<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// calls add(10, 5)</span>
binops[<span class="string">"-"</span>](<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// uses the call operator of the minus&lt;int&gt; object</span>
binops[<span class="string">"/"</span>](<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// uses the call operator of the div object</span>
binops[<span class="string">"*"</span>](<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// calls the lambda function object</span>
binops[<span class="string">"%"</span>](<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// calls the lambda function object</span>
</code></pre><h3 id="重载函数和function">重载函数和function</h3><p>我们不能直接保存一个重载函数的函数名：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{ <span class="keyword">return</span> i + j; }
<span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;
<span class="built_in">map</span>&lt;<span class="built_in">string</span>, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; binops;
binops.insert({<span class="string">"+"</span>, add}); <span class="comment">// error: which add?</span>
</code></pre><p>解决二义性的一个方法是存储函数指针：</p>
<pre><code><span class="built_in">int</span> (*fp)(<span class="built_in">int</span>,<span class="built_in">int</span>) = <span class="built_in">add</span>;
binops.insert({<span class="string">"+"</span>, fp});
</code></pre><p>或者使用lambda消除歧义：</p>
<pre><code>binops.insert({<span class="string">"+"</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) {<span class="function"><span class="keyword">return</span> <span class="title">add</span><span class="params">(a, b)</span></span>;}});
</code></pre><h1 id="重载，转换和操作符">重载，转换和操作符</h1><p>转换构造函数和转换操作符定义了类类型的转换。这种转换又叫做用户定义的转换。</p>
<h2 id="转换操作符">转换操作符</h2><p>转换操作符是一种特殊的成员函数，将一个类类型的值转换为其它类型的值。一个典型的转换函数具有形式：</p>
<pre><code><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">const</span></span>;
</code></pre><p>转换操作符可以为任意（除了<code>void</code>）函数返回的类型定义转换。不允许转换为数组或函数类型。<br>允许转换为指针（数据指针和函数指针）和引用。</p>
<blockquote>
<p><strong>注意</strong><br>转换函数必须是一个成员函数，不能指定返回类型，参数列表必须为空，通常为const。</p>
</blockquote>
<h3 id="定义一个具有转换操作符的类">定义一个具有转换操作符的类</h3><pre><code><span class="keyword">class</span> SmallInt {
<span class="keyword">public</span>:
    SmallInt(<span class="keyword">int</span> i = <span class="number">0</span>): val(i)
    {
        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; <span class="number">255</span>)
            <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">"Bad SmallInt value"</span>);
    }
    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> val; }
<span class="keyword">private</span>:
    <span class="built_in">std</span>::<span class="keyword">size_t</span> val;
};

SmallInt si;
si = <span class="number">4</span>; <span class="comment">// implicitly converts 4 to SmallInt then calls SmallInt::operator=</span>
si + <span class="number">3</span>; <span class="comment">// implicitly converts si to int followed by integer addition</span>
</code></pre><p>尽管编译器每次只应用一个用户定义的转换操作，隐式调用用户定义的转换可以在之前或之后跟着一个标准转换。</p>
<pre><code>SmallInt si = <span class="number">3.14</span>;
si + <span class="number">3.14</span>;
</code></pre><p>因为转换操作符是隐式调用的，没有办法给它们传递参数。因此，转换操作符不带参数。尽管转换函数没有<br>指定返回值，每一个转换函数必须返回相应的转换类型。</p>
<pre><code><span class="keyword">class</span> SmallInt {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">int</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>;            <span class="comment">// error: return type</span>
    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">(<span class="keyword">int</span> = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;         <span class="comment">// error: parameter list</span>
    <span class="keyword">operator</span> <span class="keyword">int</span>*() <span class="keyword">const</span> { <span class="keyword">return</span> <span class="number">42</span>; } <span class="comment">// error: 42 is not a pointer</span>
};
<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">(SmallInt&amp;)</span></span>;                 <span class="comment">// error: nonmember</span>
</code></pre><blockquote>
<p><strong>警告</strong><br>避免滥用转换函数。</p>
</blockquote>
<h3 id="转换操作符可以产生惊人的结果">转换操作符可以产生惊人的结果</h3><p>实际上，类很少定义转换操作符。然而一个例外是：类定义转换为bool类型并不罕见。</p>
<pre><code><span class="keyword">int</span> i = <span class="number">42</span>;
<span class="built_in">cin</span> &lt;&lt; i; <span class="comment">// this code would be legal if the conversion to bool were not explicit!</span>
</code></pre><h3 id="explicit转换操作符">explicit转换操作符</h3><p>为了防止前面的问题，新标准引入<code>explicit</code>转换。</p>
<pre><code><span class="keyword">class</span> SmallInt {
<span class="keyword">public</span>:
    <span class="comment">// the compiler won't automatically apply this conversion</span>
    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> val; }
};

SmallInt si = <span class="number">3</span>;  <span class="comment">// ok: the SmallInt constructor is not explicit</span>
si + <span class="number">3</span>; <span class="comment">// error: implicit conversion is required, but operator int is explicit</span>
<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(si) + <span class="number">3</span>; <span class="comment">// ok: explicitly request the conversion</span>
</code></pre><p>如果转换操作符是<code>explicit</code>的，我们只能通过<code>cast</code>来显式转换。一个例外是编译器会在条件测试中应用显式转换：</p>
<ul>
<li><code>if</code>，<code>while</code>或<code>do while</code>条件测试</li>
<li><code>for</code>的条件表达式</li>
<li>逻辑非<code>!</code>，逻辑与<code>&amp;&amp;</code>或逻辑或<code>||</code>的操作数</li>
<li>条件运算符<code>?:</code>条件测试</li>
</ul>
<h3 id="转换为bool类型">转换为bool类型</h3><p>当我们在条件测试中使用流对象，我们使用定义在IO类型里面的<code>operator bool</code>转换操作：</p>
<pre><code><span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; value)
</code></pre><blockquote>
<p><strong>最佳实践</strong><br>通常转换为<code>bool</code>是有意用于条件测试的。因此，<code>operator bool</code>通常应该定义为<code>explicit</code>。</p>
</blockquote>
<h2 id="避免歧义的转换">避免歧义的转换</h2><p>有两种方法会发生多个转换路径的情况。第一个就是当2个类提供了相互的转换。第二个就是定义了多个转换，<br>转换类型之间也可以转换。</p>
<blockquote>
<p><strong>警告</strong><br>通常，类定义相互转换或定义了多个从算术类型或到算术类型的转换是个坏主意。</p>
</blockquote>
<h3 id="参数匹配和相互转换">参数匹配和相互转换</h3><pre><code><span class="keyword">struct</span> B;
<span class="keyword">struct</span> A {
    A() = <span class="keyword">default</span>;
    A(<span class="keyword">const</span> B&amp;);        <span class="comment">// converts a B to an A</span>
};
<span class="keyword">struct</span> B {
    <span class="function"><span class="keyword">operator</span> <span class="title">A</span>(<span class="params"></span>) <span class="keyword">const</span></span>; <span class="comment">// also converts a B to an A</span>
};

<span class="function">A <span class="title">f</span>(<span class="params"><span class="keyword">const</span> A&amp;</span>)</span>;
B b;
A a = f(b); <span class="comment">// error ambiguous: f(B::operator A())</span>
            <span class="comment">//          or f(A::A(const B&amp;))</span>

A a1 = f(b.<span class="function"><span class="keyword">operator</span> <span class="title">A</span>(<span class="params"></span>))</span>; <span class="comment">// ok: use B's conversion operator</span>
A a2 = f(A(b));           <span class="comment">// ok: use A's constructor</span>
</code></pre><p>需要注意的是我们不能通过<code>cast</code>来解决这个二义性，因为<code>cast</code>有着一样的歧义。</p>
<h3 id="内置类型的多个转换和歧义">内置类型的多个转换和歧义</h3><pre><code><span class="keyword">struct</span> A {
    A(<span class="keyword">int</span> = <span class="number">0</span>);   <span class="comment">// usually a bad idea to have two</span>
    A(<span class="keyword">double</span>);    <span class="comment">// conversions from arithmetic types</span>
    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>;    <span class="comment">// usually a bad idea to have two</span>
    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// conversions to arithmetic types</span>
};

<span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span>)</span></span>;
A a;
f2(a); <span class="comment">// error ambiguous: f(A::operator int())</span>
       <span class="comment">//          or f(A::operator double())</span>
<span class="keyword">long</span> lg;
<span class="function">A <span class="title">a2</span><span class="params">(lg)</span></span>; <span class="comment">// error ambiguous: A::A(int) or A::A(double)</span>

<span class="keyword">short</span> s = <span class="number">42</span>;
<span class="comment">// promoting short to int is better than converting short to double</span>
<span class="function">A <span class="title">a3</span><span class="params">(s)</span></span>;  <span class="comment">// uses A::A(int)</span>
</code></pre><blockquote>
<p><strong>注意</strong><br>当使用2个用户定义的转换时，如果有标准转换，使用标准转换的级别来选择最佳匹配。</p>
<p>转换和操作符：</p>
<ul>
<li>不要定义类之间的相互转换</li>
<li>避免定义多个到内置算术类型的转换。</li>
</ul>
<p>最简单的规则就是：除了显式转换为<code>bool</code>类型外，避免定义转换函数和限制那些看起来对的隐式构造函数。</p>
</blockquote>
<h3 id="重载函数和转换构造函数">重载函数和转换构造函数</h3><pre><code><span class="keyword">struct</span> C {
    C(<span class="keyword">int</span>);
};
<span class="keyword">struct</span> D {
    D(<span class="keyword">int</span>);
};

<span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">(<span class="keyword">const</span> C&amp;)</span></span>;
<span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">(<span class="keyword">const</span> D&amp;)</span></span>;

manip(<span class="number">10</span>); <span class="comment">// error ambiguous: manip(C(10)) or manip(D(10))</span>
manip(C(<span class="number">10</span>)); <span class="comment">// ok: calls manip(const C&amp;)</span>
</code></pre><blockquote>
<p><strong>警告</strong><br>需要频繁地在函数调用中使用构造函数或强制转换来转换参数一个坏设计的表现。</p>
</blockquote>
<h3 id="重载函数和用户定义的转换">重载函数和用户定义的转换</h3><p>在重载函数调用中，如果有2个或更多用户定义的转换提供可行的匹配，转换被认为是一样好。</p>
<pre><code><span class="keyword">struct</span> E {
    E(<span class="keyword">double</span>);
};
<span class="function"><span class="keyword">void</span> <span class="title">manip2</span><span class="params">(<span class="keyword">const</span> C&amp;)</span></span>;
<span class="function"><span class="keyword">void</span> <span class="title">manip2</span><span class="params">(<span class="keyword">const</span> E&amp;)</span></span>;
<span class="comment">// error ambiguous: two different user-defined conversions could be used</span>
manip2(<span class="number">10</span>); <span class="comment">// manip2(C(10) or manip2(E(double(10)))</span>
</code></pre><blockquote>
<p><strong>注意</strong><br>在重载函数调用中，附加的标准转换级别有作用仅当可行函数是同一个用户定义的转换。如果是不同的用户<br>定义的转换，则调用有歧义。</p>
</blockquote>
<h2 id="函数匹配和操作符重载">函数匹配和操作符重载</h2><p>如果a是一个类类型，a sym b表达式可能是：</p>
<pre><code>a.operatorsym<span class="comment">(b)</span>; <span class="comment">// a has operatorsym as a member function</span>
operatorsym<span class="comment">(a, b)</span>; <span class="comment">// operatorsym is an ordinary function</span>
</code></pre><blockquote>
<p><strong>注意</strong><br>在候选函数集中表达式中的操作符可以是成员或非成员函数。</p>
</blockquote>
<pre><code><span class="keyword">class</span> SmallInt {
    <span class="keyword">friend</span> SmallInt <span class="keyword">operator</span>+(<span class="keyword">const</span> SmallInt&amp;, <span class="keyword">const</span> SmallInt&amp;);
<span class="keyword">public</span>:
    SmallInt(<span class="keyword">int</span> = <span class="number">0</span>);                   <span class="comment">// conversion from int</span>
    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> val; } <span class="comment">// conversion to int</span>
<span class="keyword">private</span>:
    <span class="built_in">std</span>::<span class="keyword">size_t</span> val;
};

SmallInt s1, s2;
SmallInt s3 = s1 + s2;  <span class="comment">// uses overloaded operator+</span>
<span class="keyword">int</span> i = s3 + <span class="number">0</span>;         <span class="comment">// error: ambiguous</span>
</code></pre><blockquote>
<p><strong>警告</strong><br>既提供了到算术类型的转换，又重载了相应的算术操作符，可能会导致二义性。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是C++ primer第五版第14章的读书笔记。</p>
<h1 id="基本概念">基本概念</h1><p>重载操作符是具有特殊名字的函数：关键字<code>operator</code>后面跟着需要被定义的操作符的符号。<br>像其它函数一样，重载操作符有返回值，参数]]>
    </summary>
    
      <category term="C++" scheme="https://opensvn.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <link href="https://opensvn.github.io/2015/09/19/syntax/"/>
    <id>https://opensvn.github.io/2015/09/19/syntax/</id>
    <published>2015-09-19T11:47:02.000Z</published>
    <updated>2015-09-22T01:25:19.127Z</updated>
    <content type="html"><![CDATA[<p>原文拷贝自<a href="https://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/syntax.md" target="_blank" rel="external">这里</a>.</p>
<p><a href="http://wowubuntu.com/" target="_blank" rel="external">访问 Wow!Ubuntu</a></p>
<p><strong>NOTE</strong>: This is Simplelified Chinese Edition Document of Markdown Syntax. If you are seeking for English Edition Document. Please refer to <a href="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="external">Markdown: Syntax</a>.</p>
<p><strong>声明</strong>： 这份文档派生(fork)于<a href="http://markdown.tw/" target="_blank" rel="external">繁体中文版</a>，在此基础上进行了繁体转简体工作，并进行了适当的润色。此文档用 Markdown 语法编写，你可以到这里<a href="https://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/syntax.md" target="_blank" rel="external">查看它的源文件</a>。「繁体中文版的原始文件可以<a href="https://github.com/othree/markdown-syntax-zhtw/blob/master/syntax.md" target="_blank" rel="external">查看这里</a> 。」–By @<a href="http://twitter.com/riku" target="_blank" rel="external">riku</a></p>
<p><strong>注</strong>： 本项目托管于 <a href="http://gitcafe.com/riku/Markdown-Syntax-CN/" target="_blank" rel="external">GitCafe</a>上，请通过”派生”和”合并请求”来帮忙改进本项目。</p>
<h1 id="Markdown_语法说明_(简体中文版)_/_(点击查看快速入门)">Markdown 语法说明 (简体中文版) / (<a href="https://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/basic.html" target="_blank" rel="external">点击查看快速入门</a>)</h1><ul>
<li><a href="#overview">概述</a><ul>
<li><a href="#philosophy">宗旨</a></li>
<li><a href="#html">兼容 HTML</a></li>
<li><a href="#autoescape">特殊字符自动转换</a></li>
</ul>
</li>
<li><a href="#block">区块元素</a><ul>
<li><a href="#p">段落和换行</a></li>
<li><a href="#header">标题</a></li>
<li><a href="#blockquote">区块引用</a></li>
<li><a href="#list">列表</a></li>
<li><a href="#precode">代码区块</a></li>
<li><a href="#hr">分隔线</a></li>
</ul>
</li>
<li><a href="#span">区段元素</a><ul>
<li><a href="#link">链接</a></li>
<li><a href="#em">强调</a></li>
<li><a href="#code">代码</a></li>
<li><a href="#img">图片</a></li>
</ul>
</li>
<li><a href="#misc">其它</a><ul>
<li><a href="#backslash">反斜杠</a></li>
<li><a href="#autolink">自动链接</a></li>
</ul>
</li>
<li><a href="#acknowledgement">感谢</a></li>
<li><a href="#editor">Markdown 免费编辑器</a></li>
</ul>
<hr>
<h2 id="overview">概述</h2>

<h3 id="philosophy">宗旨</h3>

<p>Markdown 的目标是实现「易读易写」。</p>
<p>可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 <a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="external">Setext</a>、<a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="external">atx</a>、<a href="http://textism.com/tools/textile/" target="_blank" rel="external">Textile</a>、<a href="http://docutils.sourceforge.net/rst.html" target="_blank" rel="external">reStructuredText</a>、<a href="http://www.triptico.com/software/grutatxt.html" target="_blank" rel="external">Grutatext</a> 和 <a href="http://ettext.taint.org/doc/" target="_blank" rel="external">EtText</a>，而最大灵感来源其实是纯文本电子邮件的格式。</p>
<p>总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像*强调*。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。</p>
<h3 id="html">兼容 HTML</h3>

<p>Markdown 语法的目标是：成为一种适用于网络的书写语言。</p>
<p>Markdown 并不是想取代 HTML的地位，甚至接近它。它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想<em>不是</em>要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种<em>发布</em>的格式，Markdown 是一种<em>书写</em>的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。</p>
<p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。</p>
<p>要制约的只有一些 HTML 区块元素――比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 <code>&lt;p&gt;</code> 标签。</p>
<p>例子如下，在 Markdown 文件里加上一段 HTML 表格：</p>
<pre><code>这是一个普通段落。

<span class="tag">&lt;<span class="title">table</span>&gt;</span>
    <span class="tag">&lt;<span class="title">tr</span>&gt;</span>
        <span class="tag">&lt;<span class="title">td</span>&gt;</span>Foo<span class="tag">&lt;/<span class="title">td</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">tr</span>&gt;</span>
<span class="tag">&lt;/<span class="title">table</span>&gt;</span>

这是另一个普通段落。
</code></pre><p>请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的<code>*强调*</code>会没有效果。</p>
<p>HTML 的区段（行内）标签如 <code>&lt;span&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;del&gt;</code> 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 <code>&lt;a&gt;</code> 或 <code>&lt;img&gt;</code> 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。</p>
<p>和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。</p>
<h3 id="autoescape">特殊字符自动转换</h3>

<p>在 HTML 文件中，有两个字符需要特殊处理： <code>&lt;</code> 和 <code>&amp;</code> 。 <code>&lt;</code> 符号用于起始标签，<code>&amp;</code> 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 <code>&amp;lt;</code> 和 <code>&amp;amp;</code>。</p>
<p><code>&amp;</code> 字符尤其让网络文档编写者受折磨，如果你要打「<code>AT&amp;T</code>」 ，你必须要写成「<code>AT&amp;amp;T</code>」。而网址中的 <code>&amp;</code> 字符也要转换。比如你要链接到：</p>
<pre><code><span class="string">http:</span><span class="comment">//images.google.com/images?num=30&amp;q=larry+bird</span>
</code></pre><p>你必须要把网址转换写为：</p>
<pre><code><span class="string">http:</span><span class="comment">//images.google.com/images?num=30&amp;amp;q=larry+bird</span>
</code></pre><p>才能放到链接标签的 <code>href</code> 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。</p>
<p>Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 <code>&amp;</code> 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 <code>&amp;amp;</code>。</p>
<p>所以你如果要在文档中插入一个版权符号 <code>©</code>，你可以这样写：</p>
<pre><code>&amp;<span class="keyword">copy</span>;
</code></pre><p>Markdown 会保留它不动。而若你写：</p>
<pre><code><span class="built_in">AT</span>&amp;T
</code></pre><p>Markdown 就会将它转为：</p>
<pre><code>AT&amp;amp<span class="comment">;T</span>
</code></pre><p>类似的状况也会发生在 <code>&lt;</code> 符号上，因为 Markdown 允许 <a href="#html">兼容 HTML</a> ，如果你是把 <code>&lt;</code> 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写：</p>
<pre><code><span class="number">4</span> &lt; <span class="number">5</span>
</code></pre><p>Markdown 将会把它转换为：</p>
<pre><code><span class="number">4</span> &amp;lt; <span class="number">5</span>
</code></pre><p>不过需要注意的是，code 范围内，不论是行内还是区块， <code>&lt;</code> 和 <code>&amp;</code> 两个符号都一定会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 <code>&lt;</code> 和 <code>&amp;</code> 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。）</p>
<hr>
<h2 id="block">区块元素</h2>

<h3 id="p">段落和换行</h3>

<p>一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。</p>
<p>「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 <code>&lt;br /&gt;</code> 标签。</p>
<p>如果你<em>确实</em>想要依赖 Markdown 来插入 <code>&lt;br /&gt;</code> 标签的话，在插入处先按入两个以上的空格然后回车。</p>
<p>的确，需要多费点事（多加空格）来产生 <code>&lt;br /&gt;</code> ，但是简单地「每个换行都转换为 <code>&lt;br /&gt;</code>」的方法在 Markdown 中并不适合， Markdown 中 email 式的 <a href="#blockquote">区块引用</a> 和多段落的 <a href="#list">列表</a> 在使用换行来排版的时候，不但更好用，还更方便阅读。</p>
<h3 id="header">标题</h3>

<p>Markdown 支持两种标题的语法，类 <a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="external">Setext</a> 和类 <a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="external">atx</a> 形式。</p>
<p>类 Setext 形式是用底线的形式，利用 <code>=</code> （最高阶标题）和 <code>-</code> （第二阶标题），例如：</p>
<pre><code><span class="header">This is an H1
=============</span>

<span class="header">This is an H2
-------------</span>
</code></pre><p>任何数量的 <code>=</code> 和 <code>-</code> 都可以有效果。</p>
<p>类 Atx 形式则是在行首插入 1 到 6 个 <code>#</code> ，对应到标题 1 到 6 阶，例如：</p>
<pre><code><span class="preprocessor"># 这是 H1</span>

<span class="preprocessor">## 这是 H2</span>

<span class="preprocessor">###### 这是 H6</span>
</code></pre><p>你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 <code>#</code>，而行尾的 <code>#</code> 数量也不用和开头一样（行首的井字符数量决定标题的阶数）：</p>
<pre><code><span class="preprocessor"># 这是 H1 #</span>

<span class="preprocessor">## 这是 H2 ##</span>

<span class="preprocessor">### 这是 H3 ######</span>
</code></pre><h3 id="blockquote">区块引用 Blockquotes</h3>

<p>Markdown 标记区块引用是使用类似 email 中用 <code>&gt;</code> 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 <code>&gt;</code> ：</p>
<pre><code>&gt; This is a blockquote with two paragraphs. Lo<span class="comment">rem ipsum dolor sit amet,</span>
&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
&gt; Vestibulum enim wisi, viverra nec, fringilla <span class="flow">in</span>, laoreet vitae, risus.
&gt; 
&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
&gt; id sem consectetuer libero luctus adipiscing.
</code></pre><p>Markdown 也允许你偷懒只在整个段落的第一行最前面加上 <code>&gt;</code> ：</p>
<pre><code>&gt; This is a blockquote with two paragraphs. Lo<span class="comment">rem ipsum dolor sit amet,</span>
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla <span class="flow">in</span>, laoreet vitae, risus.

&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.
</code></pre><p>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 <code>&gt;</code> ：</p>
<pre><code>&gt; This <span class="keyword">is</span> <span class="keyword">the</span> <span class="keyword">first</span> level <span class="keyword">of</span> quoting.
&gt;
&gt; &gt; This <span class="keyword">is</span> nested blockquote.
&gt;
&gt; Back <span class="keyword">to</span> <span class="keyword">the</span> <span class="keyword">first</span> level.
</code></pre><p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：</p>
<pre><code>&gt; <span class="comment">## 这是一个标题。</span>
&gt; 
&gt; <span class="number">1</span>.   这是第一行列表项。
&gt; <span class="number">2</span>.   这是第二行列表项。
&gt; 
&gt; 给出一些例子代码：
&gt; 
&gt;     <span class="built_in">return</span> shell_<span class="built_in">exec</span>(<span class="string">"echo <span class="variable">$input</span> | <span class="variable">$markdown_script</span>"</span>);
</code></pre><p>任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择<em>增加引用阶层</em>。</p>
<h3 id="list">列表</h3>

<p>Markdown 支持有序列表和无序列表。</p>
<p>无序列表使用星号、加号或是减号作为列表标记：</p>
<pre><code><span class="bullet">*   </span>Red
<span class="bullet">*   </span>Green
<span class="bullet">*   </span>Blue
</code></pre><p>效果就是</p>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<p>等同于：</p>
<pre><code><span class="bullet">+   </span>Red
<span class="bullet">+   </span>Green
<span class="bullet">+   </span>Blue
</code></pre><p>也等同于：</p>
<pre><code>-<span class="ruby">   <span class="constant">Red</span>
</span>-<span class="ruby">   <span class="constant">Green</span>
</span>-<span class="ruby">   <span class="constant">Blue</span></span>
</code></pre><p>有序列表则使用数字接着一个英文句点：</p>
<pre><code><span class="number">1.</span>  Bird
<span class="number">2.</span>  McHale
<span class="number">3.</span>  Parish
</code></pre><p>很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：</p>
<pre><code><span class="tag">&lt;<span class="title">ol</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span>Bird<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span>McHale<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span>Parish<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ol</span>&gt;</span>
</code></pre><p>如果你的列表标记写成：</p>
<pre><code><span class="number">1.</span>  Bird
<span class="number">1.</span>  McHale
<span class="number">1.</span>  Parish
</code></pre><p>或甚至是：</p>
<pre><code><span class="number">3.</span> Bird
<span class="number">1.</span> McHale
<span class="number">8.</span> Parish
</code></pre><p>你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。</p>
<p>如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。</p>
<p>列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。</p>
<p>要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：</p>
<pre><code>*   Lo<span class="comment">rem ipsum dolor sit amet, consectetuer adipiscing elit.</span>
    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
    viverra nec, fringilla <span class="flow">in</span>, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
    Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre><p>但是如果你懒，那也行：</p>
<pre><code>*   Lo<span class="comment">rem ipsum dolor sit amet, consectetuer adipiscing elit.</span>
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla <span class="flow">in</span>, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre><p>如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 <code>&lt;p&gt;</code><br>标签包起来，举例来说：</p>
<pre><code><span class="bullet">*   </span>Bird
<span class="bullet">*   </span>Magic
</code></pre><p>会被转换为：</p>
<pre><code><span class="tag">&lt;<span class="title">ul</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span>Bird<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span>Magic<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
</code></pre><p>但是这个：</p>
<pre><code><span class="bullet">*   </span>Bird

<span class="bullet">*   </span>Magic
</code></pre><p>会被转换为：</p>
<pre><code><span class="tag">&lt;<span class="title">ul</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">p</span>&gt;</span>Bird<span class="tag">&lt;/<span class="title">p</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">p</span>&gt;</span>Magic<span class="tag">&lt;/<span class="title">p</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
</code></pre><p>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：</p>
<pre><code><span class="number">1</span>.  This is a list item with two paragraphs. Lo<span class="comment">rem ipsum dolor</span>
    sit amet, consectetuer adipiscing elit. Aliquam hendrerit
    mi posuere lectus.

    Vestibulum enim wisi, viverra nec, fringilla <span class="flow">in</span>, laoreet
    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
    sit amet velit.

<span class="number">2</span>.  Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre><p>如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：</p>
<pre><code>*   This <span class="keyword">is</span> a <span class="type">list</span> <span class="property">item</span> <span class="keyword">with</span> two <span class="property">paragraphs</span>.

    This <span class="keyword">is</span> <span class="keyword">the</span> <span class="keyword">second</span> <span class="property">paragraph</span> <span class="keyword">in</span> <span class="keyword">the</span> <span class="type">list</span> <span class="property">item</span>. You're
only required <span class="keyword">to</span> indent <span class="keyword">the</span> <span class="keyword">first</span> line. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit.

*   Another <span class="property">item</span> <span class="keyword">in</span> <span class="keyword">the</span> same <span class="type">list</span>.
</code></pre><p>如果要在列表项目内放进引用，那 <code>&gt;</code> 就需要缩进：</p>
<pre><code>*   A <span class="type">list</span> <span class="property">item</span> <span class="keyword">with</span> a blockquote:

    &gt; This <span class="keyword">is</span> a blockquote
    &gt; inside a <span class="type">list</span> <span class="property">item</span>.
</code></pre><p>如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：</p>
<pre><code><span class="keyword">*</span>   一列表项包含一个列表区块：

        <span class="variable">&lt;代码写在这&gt;</span>
</code></pre><p>当然，项目列表很可能会不小心产生，像是下面这样的写法：</p>
<pre><code><span class="number">1986</span>. What <span class="tag">a</span> great season.
</code></pre><p>换句话说，也就是在行首出现<em>数字-句点-空白</em>，要避免这样的状况，你可以在句点前面加上反斜杠。</p>
<pre><code><span class="number">1986</span>\. What <span class="tag">a</span> great season.
</code></pre><h3 id="precode">代码区块</h3>

<p>和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 <code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 标签来把代码区块包起来。</p>
<p>要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：</p>
<pre><code>这是一个普通段落：

    这是一个代码区块。
</code></pre><p>Markdown 会转换成：</p>
<pre><code><span class="tag">&lt;<span class="title">p</span>&gt;</span>这是一个普通段落：<span class="tag">&lt;/<span class="title">p</span>&gt;</span>

<span class="tag">&lt;<span class="title">pre</span>&gt;</span><span class="tag">&lt;<span class="title">code</span>&gt;</span>这是一个代码区块。
<span class="tag">&lt;/<span class="title">code</span>&gt;</span><span class="tag">&lt;/<span class="title">pre</span>&gt;</span>
</code></pre><p>这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：</p>
<pre><code>Here <span class="keyword">is</span> an example <span class="keyword">of</span> <span class="constant">AppleScript</span>:

    <span class="keyword">tell</span> <span class="type">application</span> <span class="string">"Foo"</span>
        <span class="command">beep</span>
    <span class="keyword">end</span> <span class="keyword">tell</span>
</code></pre><p>会被转换为：</p>
<pre><code>&lt;p&gt;Here <span class="keyword">is</span> an example <span class="keyword">of</span> <span class="constant">AppleScript</span>:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;<span class="keyword">tell</span> <span class="type">application</span> <span class="string">"Foo"</span>
    <span class="command">beep</span>
<span class="keyword">end</span> <span class="keyword">tell</span>
&lt;/code&gt;&lt;/pre&gt;
</code></pre><p>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。</p>
<p>在代码区块里面， <code>&amp;</code> 、 <code>&lt;</code> 和 <code>&gt;</code> 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"footer"</span>&gt;
    &amp;<span class="keyword">copy</span>; <span class="number">2004</span> Foo Corporation
&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>会被转换为：</p>
<pre><code>&lt;<span class="keyword">pre</span>&gt;&lt;code&gt;&amp;<span class="keyword">lt</span>;div class=<span class="string">"footer"</span>&amp;gt;
    &amp;amp;<span class="built_in">copy</span>; <span class="number">2004</span> Foo Corporation
&amp;<span class="keyword">lt</span>;/div&amp;gt;
&lt;/code&gt;&lt;/<span class="keyword">pre</span>&gt;
</code></pre><p>代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。</p>
<h3 id="hr">分隔线</h3>

<p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<pre><code>- <span class="keyword">*</span> <span class="keyword">*</span>

<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>

<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>

+ - -

---------------------------------------
</code></pre><hr>
<h2 id="span">区段元素</h2>

<h3 id="link">链接</h3>

<p>Markdown 支持两种形式的链接语法： <em>行内式</em>和<em>参考式</em>两种形式。</p>
<p>不管是哪一种，链接文字都是用 [方括号] 来标记。</p>
<p>要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：</p>
<pre><code>This is [<span class="link_label">an example</span>](<span class="link_url">http://example.com/ "Title"</span>) inline link.

[<span class="link_label">This link</span>](<span class="link_url">http://example.net/</span>) has no title attribute.
</code></pre><p>会产生：</p>
<pre><code><span class="tag">&lt;<span class="title">p</span>&gt;</span>This is <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"http://example.com/"</span> <span class="attribute">title</span>=<span class="value">"Title"</span>&gt;</span>
an example<span class="tag">&lt;/<span class="title">a</span>&gt;</span> inline link.<span class="tag">&lt;/<span class="title">p</span>&gt;</span>

<span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"http://example.net/"</span>&gt;</span>This link<span class="tag">&lt;/<span class="title">a</span>&gt;</span> has no
title attribute.<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
</code></pre><p>如果你是要链接到同样主机的资源，你可以使用相对路径：</p>
<pre><code>See my [<span class="link_label">About</span>](<span class="link_url">/about/</span>) page for details.  
</code></pre><p>参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：</p>
<pre><code>This is [<span class="link_label">an example</span>][<span class="link_reference">id</span>] reference-style link.
</code></pre><p>你也可以选择性地在两个方括号中间加上一个空格：</p>
<pre><code>This <span class="keyword">is</span> [an example] [<span class="property">id</span>] <span class="keyword">reference</span>-style link.
</code></pre><p>接着，在文件的任意处，你可以把这个标记的链接内容定义出来：</p>
<pre><code><span class="attr_selector">[id]</span>: <span class="rule"><span class="attribute">http</span>:<span class="value">//example.com/  <span class="string">"Optional Title Here"</span></span></span>
</code></pre><p>链接内容定义的形式为：</p>
<ul>
<li>方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字</li>
<li>接着一个冒号</li>
<li>接着一个以上的空格或制表符</li>
<li>接着链接的网址</li>
<li>选择性地接着 title 内容，可以用单引号、双引号或是括弧包着</li>
</ul>
<p>下面这三种链接的定义都是相同：</p>
<pre><code>[<span class="link_reference">foo</span>]:<span class="link_url"> http://example.com/  "Optional Title Here"</span>
[<span class="link_reference">foo</span>]:<span class="link_url"> http://example.com/  'Optional Title Here'</span>
[<span class="link_reference">foo</span>]:<span class="link_url"> http://example.com/  (Optional Title Here)</span>
</code></pre><p><strong>请注意</strong>：**有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。</p>
<p>链接网址也可以用尖括号包起来：</p>
<pre><code><span class="attr_selector">[id]</span>: &lt;<span class="rule"><span class="attribute">http</span>:<span class="value">//example.com/&gt;  <span class="string">"Optional Title Here"</span></span></span>
</code></pre><p>你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：</p>
<pre><code>[id]<span class="symbol">:</span> <span class="symbol">http:</span>/<span class="regexp">/example.com/longish</span><span class="regexp">/path/to</span><span class="regexp">/resource/here</span>
    <span class="string">"Optional Title Here"</span>
</code></pre><p>网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。</p>
<p>链接辨别标签可以有字母、数字、空白和标点符号，但是并<em>不</em>区分大小写，因此下面两个链接是一样的：</p>
<pre><code>[<span class="link_label">link text</span>][<span class="link_reference">a</span>]
[<span class="link_label">link text</span>][<span class="link_reference">A</span>]
</code></pre><p>隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成：</p>
<pre><code>[<span class="link_label">Google</span>][<span class="link_reference"></span>]
</code></pre><p>然后定义链接内容：</p>
<pre><code>[<span class="link_reference">Google</span>]:<span class="link_url"> http://google.com/</span>
</code></pre><p>由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：</p>
<pre><code>Visit [<span class="link_label">Daring Fireball</span>][<span class="link_reference"></span>] for more information.
</code></pre><p>然后接着定义链接：</p>
<pre><code>[<span class="link_reference">Daring Fireball</span>]:<span class="link_url"> http://daringfireball.net/</span>
</code></pre><p>链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。</p>
<p>下面是一个参考式链接的范例：</p>
<pre><code><span class="name">I</span> <span class="atom">get</span> <span class="number">10</span> <span class="atom">times</span> <span class="atom">more</span> <span class="atom">traffic</span> <span class="atom">from</span> [<span class="name">Google</span>] [<span class="number">1</span>] <span class="atom">than</span> <span class="atom">from</span>
[<span class="name">Yahoo</span>] [<span class="number">2</span>] <span class="atom">or</span> [<span class="name">MSN</span>] [<span class="number">3</span>].

  [<span class="number">1</span>]: <span class="atom">http</span>://<span class="atom">google</span>.<span class="atom">com</span>/        <span class="string">"Google"</span>
  [<span class="number">2</span>]: <span class="atom">http</span>://<span class="atom">search</span>.<span class="atom">yahoo</span>.<span class="atom">com</span>/  <span class="string">"Yahoo Search"</span>
  [<span class="number">3</span>]: <span class="atom">http</span>://<span class="atom">search</span>.<span class="atom">msn</span>.<span class="atom">com</span>/    <span class="string">"MSN Search"</span>
</code></pre><p>如果改成用链接名称的方式写：</p>
<pre><code>I get 10 times more traffic from [<span class="link_label">Google</span>][<span class="link_reference"></span>] than from
[<span class="link_label">Yahoo</span>][<span class="link_reference"></span>] or [<span class="link_label">MSN</span>][<span class="link_reference"></span>].

  [google]: http://google.com/        "Google"
  [yahoo]:  http://search.yahoo.com/  "Yahoo Search"
  [msn]:    http://search.msn.com/    "MSN Search"
</code></pre><p>上面两种写法都会产生下面的 HTML。</p>
<pre><code>&lt;p&gt;I <span class="built_in">get</span> <span class="number">10</span> times more traffic <span class="built_in">from</span> &lt;<span class="operator">a</span> href=<span class="string">"http://google.com/"</span>
title=<span class="string">"Google"</span>&gt;Google&lt;/<span class="operator">a</span>&gt; than <span class="built_in">from</span>
&lt;<span class="operator">a</span> href=<span class="string">"http://search.yahoo.com/"</span> title=<span class="string">"Yahoo Search"</span>&gt;Yahoo&lt;/<span class="operator">a</span>&gt;
<span class="operator">or</span> &lt;<span class="operator">a</span> href=<span class="string">"http://search.msn.com/"</span> title=<span class="string">"MSN Search"</span>&gt;MSN&lt;/<span class="operator">a</span>&gt;.&lt;/p&gt;
</code></pre><p>下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用</p>
<pre><code>I get 10 times more traffic from [<span class="link_label">Google</span>](<span class="link_url">http://google.com/ "Google"</span>)
than from [<span class="link_label">Yahoo</span>](<span class="link_url">http://search.yahoo.com/ "Yahoo Search"</span>) or
[<span class="link_label">MSN</span>](<span class="link_url">http://search.msn.com/ "MSN Search"</span>).
</code></pre><p>参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。</p>
<p>使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。</p>
<h3 id="em">强调</h3>

<p>Markdown 使用星号（<code>*</code>）和底线（<code>_</code>）作为标记强调字词的符号，被 <code>*</code> 或 <code>_</code> 包围的字词会被转成用 <code>&lt;em&gt;</code> 标签包围，用两个 <code>*</code> 或 <code>_</code> 包起来的话，则会被转成 <code>&lt;strong&gt;</code>，例如：</p>
<pre><code><span class="keyword">*</span>single asterisks<span class="keyword">*</span>

_single underscores_

<span class="keyword">*</span><span class="keyword">*</span>double asterisks<span class="keyword">*</span><span class="keyword">*</span>

__double underscores__
</code></pre><p>会转成：</p>
<pre><code><span class="tag">&lt;<span class="title">em</span>&gt;</span>single asterisks<span class="tag">&lt;/<span class="title">em</span>&gt;</span>

<span class="tag">&lt;<span class="title">em</span>&gt;</span>single underscores<span class="tag">&lt;/<span class="title">em</span>&gt;</span>

<span class="tag">&lt;<span class="title">strong</span>&gt;</span>double asterisks<span class="tag">&lt;/<span class="title">strong</span>&gt;</span>

<span class="tag">&lt;<span class="title">strong</span>&gt;</span>double underscores<span class="tag">&lt;/<span class="title">strong</span>&gt;</span>
</code></pre><p>你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。</p>
<p>强调也可以直接插在文字中间：</p>
<pre><code>un<span class="keyword">*</span>frigging<span class="keyword">*</span>believable
</code></pre><p>但是<strong>如果你的 <code>*</code> 和 <code>_</code> 两边都有空白的话，它们就只会被当成普通的符号</strong>。</p>
<p>如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：</p>
<pre><code><span class="string">\*this</span> text <span class="keyword">is</span> surrounded <span class="keyword">by</span> literal asterisks<span class="string">\*</span>
</code></pre><h3 id="code">代码</h3>

<p>如果要标记一小段行内代码，你可以用反引号把它包起来（<code>` </code>），例如：</p>
<pre><code><span class="keyword">Use</span> the `printf()` <span class="function"><span class="keyword">function</span>.</span>
</code></pre><p>会产生：</p>
<pre><code><span class="tag">&lt;<span class="title">p</span>&gt;</span>Use the <span class="tag">&lt;<span class="title">code</span>&gt;</span>printf()<span class="tag">&lt;/<span class="title">code</span>&gt;</span> function.<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
</code></pre><p>如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：</p>
<pre><code><span class="escape">``</span>There is <span class="literal">a</span> literal backtick (<span class="escape">`)</span> here.<span class="escape">``</span>
</code></pre><p>这段语法会产生：</p>
<pre><code><span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">code</span>&gt;</span>There is a literal backtick (`) here.<span class="tag">&lt;/<span class="title">code</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span>
</code></pre><p>代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：</p>
<pre><code>A single backtick <span class="keyword">in</span> <span class="tag">a</span> <span class="tag">code</span> <span class="tag">span</span>: `` ` ``

A backtick-delimited string <span class="keyword">in</span> <span class="tag">a</span> <span class="tag">code</span> <span class="tag">span</span>: `` `foo` ``
</code></pre><p>会产生：</p>
<pre><code>&lt;p&gt;A single backtick <span class="keyword">in</span> <span class="tag">a</span> <span class="tag">code</span> <span class="tag">span</span>: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A backtick-delimited string <span class="keyword">in</span> <span class="tag">a</span> <span class="tag">code</span> <span class="tag">span</span>: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt;
</code></pre><p>在代码区段内，<code>&amp;</code> 和尖括号<strong>都</strong>会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段：</p>
<pre><code>Please don't <span class="operator"><span class="keyword">use</span> <span class="keyword">any</span> <span class="string">`&lt;blink&gt;`</span> tags.</span>
</code></pre><p>转为：</p>
<pre><code><span class="variable">&lt;p&gt;</span>Please don't use <span class="literal">any</span> <span class="variable">&lt;code&gt;</span>&amp;lt;blink&amp;gt;<span class="variable">&lt;/code&gt;</span> tags.<span class="variable">&lt;/p&gt;</span>
</code></pre><p>你也可以这样写：</p>
<pre><code>`<span class="javascript">&amp;#<span class="number">8212</span>;</span>` <span class="keyword">is</span> the decimal-encoded equivalent <span class="keyword">of</span> `<span class="javascript">&amp;mdash;</span>`.
</code></pre><p>以产生：</p>
<pre><code><span class="variable">&lt;p&gt;</span><span class="variable">&lt;code&gt;</span>&amp;amp;<span class="comment">#8212;&lt;/code&gt; is the decimal-encoded</span>
equivalent of <span class="variable">&lt;code&gt;</span>&amp;amp;mdash;<span class="variable">&lt;/code&gt;</span>.<span class="variable">&lt;/p&gt;</span>
</code></pre><h3 id="img">图片</h3>

<p>很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。</p>
<p>Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： <em>行内式</em>和<em>参考式</em>。</p>
<p>行内式的图片语法看起来像是：</p>
<pre><code>![<span class="link_label">Alt text</span>](<span class="link_url">/path/to/img.jpg</span>)

![<span class="link_label">Alt text</span>](<span class="link_url">/path/to/img.jpg "Optional title"</span>)
</code></pre><p>详细叙述如下：</p>
<ul>
<li>一个惊叹号 <code>!</code></li>
<li>接着一个方括号，里面放上图片的替代文字</li>
<li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上<br>选择性的 ‘title’ 文字。</li>
</ul>
<p>参考式的图片语法则长得像这样：</p>
<pre><code>![<span class="link_label">Alt text</span>][<span class="link_reference">id</span>]
</code></pre><p>「id」是图片参考的名称，图片参考的定义方式则和链接参考一样：</p>
<pre><code>[<span class="property">id</span>]: url/<span class="keyword">to</span>/image  <span class="string">"Optional title attribute"</span>
</code></pre><p>到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code> 标签。</p>
<hr>
<h2 id="misc">其它</h2>

<h3 id="autolink">自动链接</h3>

<p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p>
<pre><code>&lt;<span class="string">http:</span><span class="comment">//example.com/&gt;</span>
</code></pre><p>Markdown 会转为：</p>
<pre><code>&lt;<span class="tag">a</span> href=<span class="string">"http://example.com/"</span>&gt;http:<span class="comment">//example.com/&lt;/a&gt;</span>
</code></pre><p>邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：</p>
<pre><code><span class="tag">&lt;address@example.com&gt;</span>
</code></pre><p>Markdown 会转成：</p>
<pre><code>&lt;a href=<span class="string">"&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;
&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;
&amp;#109;"</span>&gt;&amp;<span class="title">#x61</span>;&amp;<span class="title">#x64</span>;&amp;<span class="title">#x64</span>;&amp;<span class="title">#x72</span>;&amp;<span class="title">#x65</span>;&amp;<span class="title">#115</span>;&amp;<span class="title">#115</span>;&amp;<span class="title">#64</span>;&amp;<span class="title">#101</span>;&amp;<span class="title">#120</span>;&amp;<span class="title">#x61</span>;
&amp;<span class="title">#109</span>;&amp;<span class="title">#x70</span>;&amp;<span class="title">#x6</span>C;e&amp;<span class="title">#x2</span>E;&amp;<span class="title">#99</span>;&amp;<span class="title">#111</span>;&amp;<span class="title">#109</span>;&lt;/a&gt;
</code></pre><p>在浏览器里面，这段字串（其实是 <code>&lt;a href=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt;</code>）会变成一个可以点击的「address@example.com」链接。</p>
<p>（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）</p>
<h3 id="backslash">反斜杠</h3>

<p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 <code>&lt;em&gt;</code> 标签），你可以在星号的前面加上反斜杠：</p>
<pre><code>\<span class="keyword">*</span>literal asterisks\<span class="keyword">*</span>
</code></pre><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p>
<pre><code>\   反斜线
`   反引号
<span class="bullet">-   </span>星号
_   底线
{}  花括号
[]  方括号
()  括弧
<span class="header">#   井字号</span>
<span class="bullet">*   </span>加号
<span class="bullet">+   </span>减号
.   英文句点
!   惊叹号
</code></pre><h2 id="acknowledgement">感谢</h2>

<p>感谢 <a href="https://twitter.com/#!/leafy7382" target="_blank" rel="external">leafy7382</a> 协助翻译，<a href="http://iamhlb.com/" target="_blank" rel="external">hlb</a>、<a href="http://twitter.com/randylien" target="_blank" rel="external">Randylien</a> 帮忙润稿，<a href="https://twitter.com/#!/ethantw" target="_blank" rel="external">ethantw</a> 的<a href="http://ethantw.net/projects/han/" target="_blank" rel="external">汉字标准格式・CSS Reset</a>， <a href="http://kidwm.net/" target="_blank" rel="external">WM</a> 回报文字错误。</p>
<p>感谢 <a href="https://github.com/fenprace" target="_blank" rel="external">fenprace</a>，<a href="https://github.com/addv" target="_blank" rel="external">addv</a>。</p>
<hr>
<h2 id="editor">Markdown 免费编辑器</h2>

<p>Windows 平台</p>
<ul>
<li><a href="http://markdownpad.com/" target="_blank" rel="external">MarkdownPad</a></li>
<li><a href="http://code52.org/DownmarkerWPF/" target="_blank" rel="external">MarkPad</a></li>
</ul>
<p>Linux 平台</p>
<ul>
<li><a href="http://sourceforge.net/p/retext/home/ReText/" target="_blank" rel="external">ReText</a></li>
</ul>
<p>Mac 平台</p>
<ul>
<li><a href="http://mouapp.com/" target="_blank" rel="external">Mou</a></li>
</ul>
<p>在线编辑器</p>
<ul>
<li><a href="http://markable.in/" target="_blank" rel="external">Markable.in</a></li>
<li><a href="http://dillinger.io/" target="_blank" rel="external">Dillinger.io</a></li>
</ul>
<p>浏览器插件</p>
<ul>
<li><a href="https://chrome.google.com/webstore/detail/oknndfeeopgpibecfjljjfanledpbkog" target="_blank" rel="external">MaDe</a> (Chrome)</li>
</ul>
<p>高级应用</p>
<ul>
<li><a href="http://www.sublimetext.com/2" target="_blank" rel="external">Sublime Text 2</a> + <a href="http://ttscoff.github.com/MarkdownEditing/" target="_blank" rel="external">MarkdownEditing</a> / <a href="http://lucifr.com/2012/07/12/markdownediting-for-sublime-text-2/" target="_blank" rel="external">教程</a></li>
</ul>
<p>*** 如有更好的 Markdown 免费编辑器推荐，请到<a href="https://gitcafe.com/riku/Markdown-Syntax-CN/tickets/1" target="_blank" rel="external">这里反馈</a>，谢谢！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文拷贝自<a href="https://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/syntax.md" target="_blank" rel="external">这里</a>.</p>
<p><a href="h]]>
    </summary>
    
      <category term="Markdown" scheme="https://opensvn.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="https://opensvn.github.io/2015/09/19/hello-world/"/>
    <id>https://opensvn.github.io/2015/09/19/hello-world/</id>
    <published>2015-09-19T02:47:02.000Z</published>
    <updated>2015-09-22T01:25:35.011Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io]]>
    </summary>
    
      <category term="Hexo" scheme="https://opensvn.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
