<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[opensvn]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="https://opensvn.github.io/"/>
  <updated>2015-11-19T06:38:37.556Z</updated>
  <id>https://opensvn.github.io/</id>
  
  <author>
    <name><![CDATA[opensvn]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Pygame简单帮助文档]]></title>
    <link href="https://opensvn.github.io/2015/11/19/pygame-doc/"/>
    <id>https://opensvn.github.io/2015/11/19/pygame-doc/</id>
    <published>2015-11-19T06:37:15.000Z</published>
    <updated>2015-11-19T06:38:37.556Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
      <category term="Pygame" scheme="https://opensvn.github.io/tags/Pygame/"/>
    
      <category term="Python" scheme="https://opensvn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Pygame第六章 接受用户输入]]></title>
    <link href="https://opensvn.github.io/2015/11/16/pygame-6/"/>
    <id>https://opensvn.github.io/2015/11/16/pygame-6/</id>
    <published>2015-11-16T08:39:23.000Z</published>
    <updated>2015-11-19T01:03:57.480Z</updated>
    <content type="html"><![CDATA[<p>用户可以有很多种方式与游戏交互，这一章详细讲解多种输入设备。除了从设备获取信息，我们也要探索如何将用户所做的事情翻译成游戏中有意义的事件。容易交互对任何游戏都至关重要，不管你有多好的外观和声音。</p>
<h1 id="控制游戏">控制游戏</h1><p>玩过游戏的都知道鼠标和键盘是游戏的不可或缺的输入设备。键盘可以控制有限的方向和诸多的命令操作，而鼠标更是提供了全方位的方向和位置操作。不过这两个设备并不是为游戏而生，专业的游戏手柄给玩家提供了更好的操作感，加上力反馈等技术，应该说游戏设备越来越丰富，玩家们也是越来越幸福。</p>
<h1 id="理解键盘控制">理解键盘控制</h1><p>现在大多数键盘都是qwerty键盘。我们可以使用pygame.key模块检测所有的键。</p>
<h3 id="检测键盘按下">检测键盘按下</h3><p>在Pygame里面有两种方式检测键盘按下。一种方式是处理KEYDOWN事件和KEYUP事件，分别对应键盘按下和键盘松开。当我们使用键盘输入代表移动时，我们只需知道键是否被按下，这种情况可以直接使用pygame.key模块。</p>
<p>每一个键盘上的键都有一个常量键值关联它。每一个常量以<strong>K_</strong>开头，比如字母是K_a到K_z，数字是K_0到K_9，其它的如K_F1，K_LEFT，K_RETURN等。完整列表参考(<a href="http://www.pygame.org/docs/ref/key.html" target="_blank" rel="external">http://www.pygame.org/docs/ref/key.html</a>)。没有大写字母对应的键值，因为大写字母是小写字母和其它键的组合。</p>
<p>我们可以使用<strong>pygame.key.get_pressed</strong>函数检查一个键是否被按下。它返回一个布尔值列表，每一个布尔值对应一个键值常量。要查询某一个键，使用其键值常量作为列表下标。比如查看空格是否被按下：</p>
<pre><code>pressed_keys = pygame.<span class="variable">key</span>.get_pressed()
<span class="keyword">if</span> pressed_keys[K_SPACE]:
    # Space <span class="variable">key</span> has been pressed
    fire()
</code></pre><blockquote>
<p><strong>注意</strong> 由于硬件的限制，有些键组合不能被检测。原因请看<a href="http://www.sjbaker.org/steve/omniv/keyboards_are_evil.html" target="_blank" rel="external">http://www.sjbaker.org/steve/omniv/keyboards_are_evil.html</a></p>
</blockquote>
<pre><code>import pygame
<span class="keyword">from</span> pygame.locals import *
<span class="keyword">from</span> sys import <span class="keyword">exit</span>

pygame.init()
screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

font = pygame.font.SysFont(<span class="comment">'arial', 32)</span>
font_height = font.get_linesize()

<span class="keyword">while</span> <span class="literal">True</span>:
    <span class="keyword">for</span> <span class="keyword">event</span> <span class="keyword">in</span> pygame.<span class="keyword">event</span>.<span class="keyword">get</span>():
        <span class="keyword">if</span> <span class="keyword">event</span>.type == QUIT:
            <span class="keyword">exit</span>()

    screen.fill((<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))

    pressed_key_text = []
    pressed_keys = pygame.<span class="keyword">key</span>.get_pressed()
    y = font_height

    <span class="keyword">for</span> key_constant, pressed <span class="keyword">in</span> enumerate(pressed_keys):
        <span class="keyword">if</span> pressed:
            key_name = pygame.<span class="keyword">key</span>.name(key_constant)
            text_surface = font.render(key_name + <span class="comment">' pressed', True, (0, 0, 0))</span>
            screen.blit(text_surface, (<span class="number">8</span>, y))
            y += font_height

    pygame.display.update()
</code></pre><p>让我们更详细地复习<strong>pygame.key</strong>：</p>
<ul>
<li><strong>key.get_focused</strong> - Pygame窗口只有获得焦点后才会接受键事件。<strong>get_focused</strong>函数返回真，如果窗口获得焦点，否则返回假。全屏模式，总是返回真。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>用户可以有很多种方式与游戏交互，这一章详细讲解多种输入设备。除了从设备获取信息，我们也要探索如何将用户所做的事情翻译成游戏中有意义的事件。容易交互对任何游戏都至关重要，不管你有多好的外观和声音。</p>
<h1 id="控制游戏">控制游戏</h1><p>玩过游戏的都知道鼠]]>
    </summary>
    
      <category term="Pygame" scheme="https://opensvn.github.io/tags/Pygame/"/>
    
      <category term="Python" scheme="https://opensvn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Pygame第五章 让画面动起来]]></title>
    <link href="https://opensvn.github.io/2015/11/10/pygame-5/"/>
    <id>https://opensvn.github.io/2015/11/10/pygame-5/</id>
    <published>2015-11-10T12:21:33.000Z</published>
    <updated>2015-11-19T06:52:09.672Z</updated>
    <content type="html"><![CDATA[<p>这一章描述如何以一种可以预测的方式在屏幕上移动对象，和如何使运动在其他人电脑里面一致。</p>
<h1 id="理解帧率">理解帧率</h1><p>我们需要知道计算机游戏中关于运动的第一件事情就是<strong>没有什么东西真正在移动</strong>。电脑屏幕或电视机展示给我们一系列图片，当两张图片间隔时间够短时，我们的大脑将这些图片混合在一起从而制造了流畅运动的假象。一张图片称为一帧，FPS(Frame Per Second)是每秒的帧数，也就是帧率。产生流畅运动需要的帧数，因人而异。</p>
<p>游戏的帧率也受限于显示设备的刷新速度。比如，显示器的刷新速度为60HZ，也就是每秒刷新60次。产生帧的速度比刷新速度快会导致“tearing”现象，即下一个帧混进前一个帧。电脑要做的事情越多，帧率就会越慢。好消息是现在的桌面电脑已经足以产生你想要的视觉效果。</p>
<p>只需记住几个常量：一般的电视画面是24FPS；30FPS基本可以给玩家提供流畅的体验了；60FPS是LCD常用的刷新率，所以你的游戏的帧率再高也没什么意义了；在70FPS以上，很少有人能察觉任何提升了！</p>
<h1 id="直线运动">直线运动</h1><pre><code>background_image_filename = <span class="string">'sushiplate.jpg'</span>
sprite_image_filename = <span class="string">'fugu.png'</span>

import pygame
<span class="keyword">from</span> pygame.locals import *
<span class="keyword">from</span> sys import <span class="keyword">exit</span>

pygame.init()

screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

background = pygame.image.load(background_image_filename).convert()
sprite = pygame.image.load(sprite_image_filename)

# The x coordinate <span class="keyword">of</span> our sprite
x = <span class="number">0</span>.

<span class="keyword">while</span> <span class="keyword">True</span>:
    <span class="keyword">for</span> <span class="keyword">event</span> <span class="keyword">in</span> pygame.<span class="keyword">event</span>.get():
        <span class="keyword">if</span> <span class="keyword">event</span>.<span class="keyword">type</span> == QUIT:
            <span class="keyword">exit</span>()

    screen.blit(background, (<span class="number">0</span>, <span class="number">0</span>))
    screen.blit(sprite, (x, <span class="number">100</span>))
    x += <span class="number">10</span>.

    # <span class="keyword">If</span> the image goes off the <span class="keyword">end</span> <span class="keyword">of</span> the screen, move it back
    <span class="keyword">if</span> x &gt; <span class="number">640</span>.:
        x -= <span class="number">640</span>.

    pygame.display.update()
</code></pre><p>这段代码有两个问题，第一个是我们不能精确知道画一张图片到屏幕需要多长时间，另一个问题是这个精灵在配置差的机器上移动慢，在配置好的机器上移动更快。</p>
<h3 id="关于时间">关于时间</h3><p>解决第一个问题的技巧是使运动基于时间。我们需要知道距离上一个帧已经过去多长时间，据此我们能相应地在屏幕上放置任何物体。<strong>pygame.time</strong>模块有一个Clock对象可以用来跟踪时间。使用<strong>pygame.time.Clock()</strong>创建clock对象。</p>
<pre><code>clock = pygame<span class="class">.time</span><span class="class">.Clock</span>()
</code></pre><p>一旦创建了clock对象，你应该每一帧调用一次<strong>tick</strong>函数，返回上次调用该函数已过去的时间，单位毫秒。</p>
<pre><code>time_passed = clock.<span class="function"><span class="title">tick</span><span class="params">()</span></span>
</code></pre><p><strong>tick</strong>函数也接收一个可选参数表示最大帧率。</p>
<pre><code><span class="preprocessor"># Game will run at a maximum <span class="number">30</span> frames per second</span>
time_passed = clock.tick(<span class="number">30</span>)
time_passed_seconds = time_passed / <span class="number">1000.0</span>
</code></pre><p>我们要怎样使用这个time_passed_seconds来移动精灵呢？需要做的第一件事就是选择一个精灵移动的速度。接下来只要用这个速度乘于时间就能得出精灵该移动多远。</p>
<pre><code>background_image_filename = <span class="comment">'sushiplate.jpg'</span>
sprite_image_filename = <span class="comment">'fugu.png'</span>

import pygame
<span class="keyword">from</span> pygame.locals import *
<span class="keyword">from</span> sys import <span class="keyword">exit</span>

pygame.init()

screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

background = pygame.image.load(background_image_filename).convert()
sprite = pygame.image.load(sprite_image_filename)

<span class="preprocessor"># Our clock object</span>
clock = pygame.time.Clock()

<span class="preprocessor"># X coordinate of our sprite</span>
x = <span class="number">0.</span>
<span class="preprocessor"># Speed in pixels per second</span>
speed = <span class="number">250.</span>

<span class="keyword">while</span> <span class="literal">True</span>:
    <span class="keyword">for</span> <span class="keyword">event</span> <span class="keyword">in</span> pygame.<span class="keyword">event</span>.<span class="keyword">get</span>():
        <span class="keyword">if</span> <span class="keyword">event</span>.type == QUIT:
            <span class="keyword">exit</span>()

    screen.blit(background, (<span class="number">0</span>, <span class="number">0</span>))
    screen.blit(sprite, (x, <span class="number">100</span>))

    time_passed = clock.tick()
    time_passed_seconds = time_passed / <span class="number">1000.0</span>

    distance_moved = time_passed_seconds * speed
    x += distance_moved

    <span class="keyword">if</span> x &gt; <span class="number">640.</span>:
        x -= <span class="number">640.</span>

    pygame.display.update()
</code></pre><p>理解帧率和精灵移动速度的不同很重要。</p>
<pre><code>background_image_filename = <span class="string">'sushiplate.jpg'</span>
sprite_image_filename = <span class="string">'fugu.png'</span>

import pygame
<span class="built_in">from</span> pygame.locals import *
<span class="built_in">from</span> sys import exit

pygame.init()

screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

background = pygame.image.<span class="built_in">load</span>(background_image_filename).<span class="built_in">convert</span>()
sprite = pygame.image.<span class="built_in">load</span>(sprite_image_filename)

<span class="comment"># Our clock object</span>
clock = pygame.<span class="built_in">time</span>.Clock()

x1 = <span class="number">0.</span>
x2 = <span class="number">0.</span>
<span class="comment"># Speed in pixels per second</span>
speed = <span class="number">250.</span>

frame_no = <span class="number">0</span>

<span class="keyword">while</span> True:
    <span class="keyword">for</span> event <span class="operator">in</span> pygame.event.<span class="built_in">get</span>():
        <span class="keyword">if</span> event.type == QUIT:
            exit()

    screen.blit(background, (<span class="number">0</span>, <span class="number">0</span>))
    screen.blit(sprite, (x1, <span class="number">50</span>))
    screen.blit(sprite, (x2, <span class="number">250</span>))

    time_passed = clock.<span class="built_in">tick</span>(<span class="number">30</span>)
    time_passed_seconds = time_passed / <span class="number">1000.0</span>

    distance_moved = time_passed_seconds * speed
    x1 += distance_moved

    <span class="keyword">if</span> frame_no % <span class="number">5</span> == <span class="number">0</span>:
        distance_moved = time_passed_seconds * speed
        x2 += distance_moved * <span class="number">5</span>

    <span class="comment"># If the image goes off the end of the screen, move it back</span>
    <span class="keyword">if</span> x1 &gt; <span class="number">640.</span>:
        x1 -= <span class="number">640.</span>
    <span class="keyword">if</span> x2 &gt; <span class="number">640.</span>:
        x2 -= <span class="number">640.</span>

    pygame.display.update()
    frame_no += <span class="number">1</span>
</code></pre><h3 id="斜线运动">斜线运动</h3><p>直线运动很有用，但是一个游戏如果所有物体都水平或垂直移动看起来就很笨。我们需要能够在任何方向移动精灵。可以通过调整每个帧的x和y坐标做到。</p>
<pre><code>background_image_filename = <span class="symbol">'sushiplate</span>.jpg'
sprite_image_filename = <span class="symbol">'fugu</span>.png'

import pygame
from pygame.locals import *
from sys import exit

pygame.init<span class="literal">()</span>

screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

background = pygame.image.load(background_image_filename).convert<span class="literal">()</span>
sprite = pygame.image.load(sprite_image_filename).convert_alpha<span class="literal">()</span>

clock = pygame.time.<span class="type">Clock</span><span class="literal">()</span>

x, y = <span class="number">100.</span>, <span class="number">100.</span>
speed_x, speed_y = <span class="number">133.</span>, <span class="number">170.</span>

<span class="keyword">while</span> <span class="type">True</span>:
    for event <span class="keyword">in</span> pygame.event.get<span class="literal">()</span>:
        <span class="keyword">if</span> event.<span class="keyword">type</span> == <span class="type">QUIT</span>:
            exit<span class="literal">()</span>

    screen.blit(background, (<span class="number">0</span>, <span class="number">0</span>))
    screen.blit(sprite, (x, y))

    time_passed = clock.tick(<span class="number">30</span>)
    time_passed_seconds = time_passed / <span class="number">1000.0</span>

    x += speed_x * time_passed_seconds
    y += speed_y * time_passed_seconds

    # <span class="type">If</span> the sprite goes off the edge <span class="keyword">of</span> the screen,
    # make it move <span class="keyword">in</span> the opposite direction
    <span class="keyword">if</span> x &gt; <span class="number">640</span> - sprite.get_width<span class="literal">()</span>:
        speed_x = -speed_x
        x = <span class="number">640</span> - sprite.get_width<span class="literal">()</span>
    elif x &lt; <span class="number">0</span>:
        speed_x = -speed_x
        x = <span class="number">0</span>

    <span class="keyword">if</span> y &gt; <span class="number">480</span> - sprite.get_height<span class="literal">()</span>:
        speed_y = -speed_y
        y = <span class="number">480</span> - sprite.get_height<span class="literal">()</span>
    elif y &lt; <span class="number">0</span>:
        speed_y = -speed_y
        y = <span class="number">0</span>

    pygame.display.update<span class="literal">()</span>
</code></pre><p>为了达到反弹的效果，我们首先必须检查是否撞击到边缘。在坐标上做点简单的算术就行。如果x坐标小于0，则我们超过了屏幕的左边缘。如果x加上精灵的宽度比屏幕的宽度大，则精灵的右边缘超过屏幕的宽度。y坐标的判断类似，只是使用高度而不是宽度。</p>
<h1 id="探索向量">探索向量</h1><p>游戏开发者从数学借来向量并用到很多领域，比如2D和3D游戏。向量和点类似，它们都有x和y值(在2D中)，但是用途不一样。一个点的坐标(10, 20)在屏幕上总是同一个位置，而一个向量(10, 20)意思是从当前位置x坐标加上10，y坐标加上20。因此你可以认为一个点的坐标就是从原点(0, 0)到该点的向量。</p>
<h3 id="创建向量">创建向量</h3><p>你可以从任意2个点计算向量，只要用第二个点坐标减去第一个点坐标。比如点A(10, 20)，点B(30, 35)，则向量AB就是(20, 15)。这个向量告诉我们从A到B需要在x方向移动20个单位，在y方向移动15个单位。</p>
<h3 id="存储向量">存储向量</h3><p>在Python里面没有内置的向量类型，但是你可以将向量存入list，或者自己定义向量类。方便起见，我们选择定义自己的向量类。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Vector2</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x=<span class="number">0.0</span>, y=<span class="number">0.0</span>)</span>:</span>
        self.x = x
        self.y = y

    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>
        <span class="keyword">return</span> <span class="string">'(%s, %s)'</span> % (self.x, self.y)

<span class="decorator">    @classmethod</span>
    <span class="function"><span class="keyword">def</span> <span class="title">from_points</span><span class="params">(cls, P1, P2)</span>:</span>
        <span class="keyword">return</span> cls(P2[<span class="number">0</span>] - P1[<span class="number">0</span>], P2[<span class="number">1</span>] - P1[<span class="number">1</span>])
</code></pre><p><code>@classmethod</code>装饰使函数from_points变成一个类方法。类方法是通过类调用的，不是通过类实例调用，比如Vector2.from_points(P1, P2)。将from_points定义为一个类方法是因为它创建一个新的Vector2对象，而不是修改已经存在的对象。</p>
<h3 id="向量大小">向量大小</h3><p>从A到B的向量大小就是2个点之间的距离。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">get_magnitude</span><span class="params">(self)</span>:</span>
    <span class="keyword">return</span> math.sqrt(self.x ** <span class="number">2</span> + self.y ** <span class="number">2</span>)
</code></pre><h3 id="单位向量">单位向量</h3><p>向量实际描述了两件事情：大小和方向。通常这两个信息绑定在一个向量里面，但有时候你只需其中一个。有一种特殊的向量叫单位向量，它的大小总是为1。我们可以把任意向量缩放到一个单位向量，这叫向量的规格化。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">normalize</span><span class="params">(self)</span>:</span>
    magnitude = self.get_magnitude()
    self.x /= magnitude
    self.y /= magnitude
</code></pre><h3 id="向量加法">向量加法</h3><p>向量加法是将两个向量组合产生一个向量，它有两个向量组合的效果。也就是AC=AB+BC。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, rhs)</span>:</span>
    <span class="keyword">return</span> Vector2(self.x + rhs.x, self.y + rhs.y)
</code></pre><h3 id="向量减法">向量减法</h3><p>向量减法和加法类似。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">__sub__</span><span class="params">(self, rhs)</span>:</span>
    <span class="keyword">return</span> Vector2(self.x - rhs.x, self.y - rhs.y)
</code></pre><h3 id="否定向量">否定向量</h3><p>如果想要改变向量的方向，使向量AB变成向量BA，需要将向量每个元素都改变符号。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">__neg__</span><span class="params">(self)</span>:</span>
    <span class="keyword">return</span> Vector2(-self.x, -self.y)
</code></pre><h3 id="向量乘法和除法">向量乘法和除法</h3><p>将一个向量乘于或除于一个系数(数字)，效果是改变向量的大小。如果向量乘于一个整数，则产生同一方向的向量，如果乘于一个负数，则产生相反方向的向量。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, scalar)</span>:</span>
    <span class="keyword">return</span> Vector2(self.x * scalar, self.y * scalar)

<span class="function"><span class="keyword">def</span> <span class="title">__div__</span><span class="params">(self, scalar)</span>:</span>
    <span class="keyword">return</span> Vector2(self.x / scalar, self.y / scalar)
</code></pre><blockquote>
<p><strong>注意</strong> 向量乘于向量也是可以的，但是在游戏中不常用，你可能永远都不需要它。</p>
</blockquote>
<p>向量乘法如何使用呢？基于时间把向量分解为很多步，向量乘法很有用。如果我们知道从A到B需要10秒，我们可以计算出每一秒我们到达的坐标。</p>
<pre><code>A = (<span class="number">10.0</span>, <span class="number">20.0</span>)
B = (<span class="number">30.0</span>, <span class="number">35.0</span>)
AB = Vector2.from_points(A, B)
step = AB * <span class="number">.1</span>
<span class="keyword">position</span> = Vector2(A.x, A.y)
for n <span class="type">in</span> <span class="built_in">range</span>(<span class="number">10</span>):
    <span class="keyword">position</span> += step
    <span class="built_in">print</span> <span class="keyword">position</span>
</code></pre><p>当在两个点之间移动，计算中间位置是基本的。你还可以用向量计算在重力，外部作用力和摩擦力作用下很多种现实的运动。</p>
<h3 id="游戏对象向量类">游戏对象向量类</h3><p>作者已经写了一个二维向量类作为游戏对象的一部分。</p>
<pre><code>from gameobjects.vector2 import *
A = (<span class="number">10.0</span>, <span class="number">20.0</span>)
B = (<span class="number">30.0</span>, <span class="number">35.0</span>)
AB = Vector2.from_points(A, B)
print <span class="string">"Vector AB is"</span>, AB
print <span class="string">"AB * 2 is"</span>, AB * <span class="number">2</span>
print <span class="string">"AB / 2 is"</span>, AB / <span class="number">2</span>
print <span class="string">"AB + (-10, 5) is"</span>, AB + (-<span class="number">10</span>, <span class="number">5</span>)
print <span class="string">"Magnitude of AB is"</span>, AB.get_magnitude()
print <span class="string">"AB normalized is"</span>, AB.get_normalized()
</code></pre><h1 id="使用向量创建运动">使用向量创建运动</h1><p>既然我们了解了向量，我们可以使用它以多种方式移动游戏角色，而且可以实现简单的，基于力学的物理现象，使得游戏更加可信。</p>
<h3 id="斜线运动-1">斜线运动</h3><p>让我们使用向量创建更加精确的斜线运动。</p>
<pre><code>background_image_filename = <span class="string">'sushiplate.jpg'</span>
sprite_image_filename = <span class="string">'fugu.png'</span>

from sys <span class="keyword">import</span> exit
<span class="keyword">import</span> pygame
from pygame.locals <span class="keyword">import</span> *
from gameobjects.vector2 <span class="keyword">import</span> Vector2

pygame.init()

screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

background = pygame.image.load(background_image_filename).convert()
sprite = pygame.image.load(sprite_image_filename).convert_alpha()

clock = pygame.time.Clock()

position = Vector2(<span class="number">100.0</span>, <span class="number">100.0</span>)
speed = <span class="number">250</span>
heading = Vector2()

<span class="keyword">while</span> True:
    <span class="keyword">for</span> event in pygame.event.<span class="keyword">get</span>():
        <span class="keyword">if</span> event.type == QUIT:
            exit()
        <span class="keyword">if</span> event.type == MOUSEBUTTONDOWN:
            destination = Vector2(*event.pos) - Vector2(*sprite.get_size()) / 2.
            heading = Vector2.from_points(position, destination)
            heading.normalize()

        screen.blit(background, (0, 0))
        screen.blit(sprite, position)

        time_passed = clock.tick()
        time_passed_seconds = time_passed / 1000.0

        distance_moved = time_passed_seconds * speed
        position += heading * distance_moved
        pygame.display.update()
</code></pre><p>目的坐标的计算需要解释一下。星号(<code>*</code>)用在函数的参数时，扩展为一个元组或列表。因此Vector2(*event.pos)相当于Vector2(event.pos[0], event.pos[1])。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一章描述如何以一种可以预测的方式在屏幕上移动对象，和如何使运动在其他人电脑里面一致。</p>
<h1 id="理解帧率">理解帧率</h1><p>我们需要知道计算机游戏中关于运动的第一件事情就是<strong>没有什么东西真正在移动</strong>。电脑屏幕或电视机展示]]>
    </summary>
    
      <category term="Pygame" scheme="https://opensvn.github.io/tags/Pygame/"/>
    
      <category term="Python" scheme="https://opensvn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[整理代码片段]]></title>
    <link href="https://opensvn.github.io/2015/11/10/colleague/"/>
    <id>https://opensvn.github.io/2015/11/10/colleague/</id>
    <published>2015-11-10T03:18:10.000Z</published>
    <updated>2015-11-12T03:14:49.539Z</updated>
    <content type="html"><![CDATA[<h1 id="根据pid获取进程名">根据pid获取进程名</h1><pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;libgen.h&gt;</span></span>

<span class="function"><span class="keyword">void</span> <span class="title">get_process_name_by_pid</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">char</span> *name)</span>
</span>{
    <span class="keyword">char</span> buf[<span class="number">256</span>] = {<span class="number">0</span>};
    <span class="keyword">char</span> path[<span class="number">256</span>] = {<span class="number">0</span>};

    <span class="built_in">sprintf</span>(buf, <span class="string">"/proc/%d/exe"</span>, pid);
    readlink(buf, path, <span class="keyword">sizeof</span>(path));

    <span class="keyword">char</span> *filename = basename(path);
    <span class="built_in">strcpy</span>(name, filename);
}

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    <span class="keyword">int</span> pid = getpid();
    <span class="keyword">char</span> name[<span class="number">256</span>] = {<span class="number">0</span>};
    get_process_name_by_pid(pid, name);
    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, name);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><h1 id="C语言变长数组">C语言变长数组</h1><pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span>

<span class="function"><span class="keyword">void</span> <span class="title">test_vla</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span>
</span>{
    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);

    <span class="keyword">char</span> a[len + <span class="number">1</span>];
    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));

    <span class="built_in">strcpy</span>(a, str);

    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, a);
}

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    test_vla(<span class="string">"hello"</span>);
    test_vla(<span class="string">"world!"</span>);
    test_vla(<span class="string">"Amazing"</span>);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><h1 id="确保路径存在">确保路径存在</h1><pre><code><span class="function"><span class="keyword">bool</span> <span class="title">besure_path</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span>
</span>{
    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(pathname);

    <span class="keyword">char</span> buffer[len + <span class="number">1</span>];
    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));

    <span class="built_in">strcpy</span>(buffer, pathname);

    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)
    {
        <span class="keyword">if</span> (buffer[i] == <span class="string">'/'</span>)
        {
            buffer[i] = <span class="number">0</span>;

            <span class="keyword">if</span> (access(buffer, F_OK) &lt; <span class="number">0</span>)
            {
                <span class="keyword">if</span> (mkdir(buffer, <span class="number">0755</span>) &lt; <span class="number">0</span>)
                {
                    <span class="keyword">return</span> <span class="literal">false</span>;
                }
            }

            buffer[i] = <span class="string">'/'</span>;
        }
    }

    <span class="keyword">return</span> <span class="literal">true</span>;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="根据pid获取进程名">根据pid获取进程名</h1><pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdi]]>
    </summary>
    
      <category term="C" scheme="https://opensvn.github.io/tags/C/"/>
    
      <category term="Linux" scheme="https://opensvn.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Pygame第四章 创建视觉]]></title>
    <link href="https://opensvn.github.io/2015/11/07/pygame-4/"/>
    <id>https://opensvn.github.io/2015/11/07/pygame-4/</id>
    <published>2015-11-07T13:28:44.000Z</published>
    <updated>2015-11-19T06:20:46.008Z</updated>
    <content type="html"><![CDATA[<p>电脑游戏倾向于视觉上很自然，游戏开发者花费很多精力在处理图像和提升视觉效果来创建最令人愉快的体验上。</p>
<h1 id="像素的威力">像素的威力</h1><p>显示器里的一个独立的点称为一个图像单元或像素。如果一个显示器分辨率为1280x1024，则像素总数为1310720。一个屏幕上像素越多，则图片的质量越好。典型的家用电脑可以显示的颜色数量最高为16.7百万个。如果你想显示每一种颜色，你需要一个分辨率4096x4096的显示器。</p>
<pre><code>import pygame
pygame.init()

screen = pygame.<span class="keyword">display</span>.set_mode((640, 480))

all_colors = pygame.Surface((4096, 4096), depth=24)

<span class="keyword">for</span> r <span class="keyword">in</span> xrange(256):
    <span class="keyword">print</span> r + 1, '<span class="keyword">out</span> of 256'
    x = (r &amp; 15) * 256
    y = (r &gt;&gt; 4) * 256
    <span class="keyword">for</span> <span class="keyword">g</span> <span class="keyword">in</span> xrange(256):
        <span class="keyword">for</span> b <span class="keyword">in</span> xrange(256):
            all_colors.set_at((x + <span class="keyword">g</span>, y + b), (r, <span class="keyword">g</span>, b))

pygame.image.<span class="keyword">save</span>(all_colors, 'allcolors.bmp')
</code></pre><p>上面程序用到的类或方法：</p>
<pre><code>class Surface(__builtin__.object)
 |  pygame.Surface((<span class="variable">width</span>, <span class="variable">height</span>), flags=<span class="number">0</span>, depth=<span class="number">0</span>, masks=None): <span class="keyword">return</span> Surface
 |  pygame.Surface((<span class="variable">width</span>, <span class="variable">height</span>), flags=<span class="number">0</span>, Surface): <span class="keyword">return</span> Surface
 |  pygame object <span class="keyword">for</span> representing images

set_at(...)
    Surface.set_at((x, y), Color): <span class="keyword">return</span> None
    <span class="built_in">set</span> the <span class="built_in">color</span> value <span class="keyword">for</span> a single pixel

<span class="built_in">save</span>(...)
    pygame.<span class="built_in">image</span>.<span class="built_in">save</span>(Surface, filename): <span class="keyword">return</span> None
    <span class="built_in">save</span> an <span class="built_in">image</span> to disk
</code></pre><h1 id="和颜色打交道">和颜色打交道</h1><h3 id="Pygame中表示颜色">Pygame中表示颜色</h3><p>当Pygame需要一种颜色，你需要传进一个包含三个数字的元组，分别对应红绿蓝三种颜色，每个数值范围为[0, 255]。</p>
<table>
<thead>
<tr>
<th>颜色</th>
<th style="text-align:left">红色</th>
<th style="text-align:left">绿色</th>
<th style="text-align:left">蓝色</th>
<th style="text-align:left">元组</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑(Black)</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">(0, 0, 0)</td>
</tr>
<tr>
<td>蓝(Blue)</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">255</td>
<td style="text-align:left">(0, 0, 255)</td>
</tr>
<tr>
<td>绿(Green)</td>
<td style="text-align:left">0</td>
<td style="text-align:left">255</td>
<td style="text-align:left">0</td>
<td style="text-align:left">(0, 255, 0)</td>
</tr>
<tr>
<td>蓝绿(Cyan)</td>
<td style="text-align:left">0</td>
<td style="text-align:left">255</td>
<td style="text-align:left">255</td>
<td style="text-align:left">(0, 255, 255)</td>
</tr>
<tr>
<td>红(Red)</td>
<td style="text-align:left">255</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">(255, 0, 0)</td>
</tr>
<tr>
<td>洋红(Magenta)</td>
<td style="text-align:left">255</td>
<td style="text-align:left">0</td>
<td style="text-align:left">255</td>
<td style="text-align:left">(255, 0, 255)</td>
</tr>
<tr>
<td>黄(Yellow)</td>
<td style="text-align:left">255</td>
<td style="text-align:left">255</td>
<td style="text-align:left">0</td>
<td style="text-align:left">(255, 255, 0)</td>
</tr>
<tr>
<td>白(White)</td>
<td style="text-align:left">255</td>
<td style="text-align:left">255</td>
<td style="text-align:left">255</td>
<td style="text-align:left">(255, 255, 255)</td>
</tr>
</tbody>
</table>
<pre><code><span class="keyword">import</span> pygame
from pygame.locals <span class="keyword">import</span> *
from sys <span class="keyword">import</span> <span class="built_in">exit</span>

pygame.init()

screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

# Creates images with <span class="built_in">smooth</span> gradients
def create_scales(<span class="variable">height</span>):
    red_scale_surface = pygame.surface.Surface((<span class="number">640</span>, <span class="variable">height</span>))
    green_scale_surface = pygame.surface.Surface((<span class="number">640</span>, <span class="variable">height</span>))
    blue_scale_surface = pygame.surface.Surface((<span class="number">640</span>, <span class="variable">height</span>))
    <span class="keyword">for</span> x in range(<span class="number">640</span>):
        c = <span class="built_in">int</span>((x / <span class="number">639.</span>) * <span class="number">255.</span>)
        <span class="built_in">red</span> = (c, <span class="number">0</span>, <span class="number">0</span>)
        <span class="built_in">green</span> = (<span class="number">0</span>, c, <span class="number">0</span>)
        <span class="built_in">blue</span> = (<span class="number">0</span>, <span class="number">0</span>, c)
        line_rect = Rect(x, <span class="number">0</span>, <span class="number">1</span>, <span class="variable">height</span>)
        pygame.<span class="title">draw</span>.<span class="built_in">rect</span>(red_scale_surface, <span class="built_in">red</span>, line_rect)
        pygame.<span class="title">draw</span>.<span class="built_in">rect</span>(green_scale_surface, <span class="built_in">green</span>, line_rect)
        pygame.<span class="title">draw</span>.<span class="built_in">rect</span>(blue_scale_surface, <span class="built_in">blue</span>, line_rect)
    <span class="keyword">return</span> red_scale_surface, green_scale_surface, blue_scale_surface

red_scale, green_scale, blue_scale = create_scales(<span class="number">80</span>)

<span class="built_in">color</span> = [<span class="number">127</span>, <span class="number">127</span>, <span class="number">127</span>]

<span class="keyword">while</span> True:
    <span class="keyword">for</span> event in pygame.event.<span class="built_in">get</span>():
        <span class="keyword">if</span> event.type == QUIT:
            <span class="built_in">exit</span>()

    screen.<span class="built_in">fill</span>((<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))

    # Draw the scales to the screen
    screen.blit(red_scale, (<span class="number">0</span>, <span class="number">0</span>))
    screen.blit(green_scale, (<span class="number">0</span>, <span class="number">80</span>))
    screen.blit(blue_scale, (<span class="number">0</span>, <span class="number">160</span>))

    x, y = pygame.mouse.get_pos()

    # If the mouse was pressed on one of the sliders, adjust the <span class="built_in">color</span> component
    <span class="keyword">if</span> pygame.mouse.get_pressed()[<span class="number">0</span>]:
        <span class="keyword">for</span> component in range(<span class="number">3</span>):
            <span class="keyword">if</span> y &gt; component * <span class="number">80</span> and y &lt; (component + <span class="number">1</span>) * <span class="number">80</span>:
                <span class="built_in">color</span>[component] = <span class="built_in">int</span>((x / <span class="number">639.</span>) * <span class="number">255.</span>)
        pygame.display.set_caption(<span class="string">'Pygame Color Test - '</span> + <span class="built_in">str</span>(tuple(<span class="built_in">color</span>)))

    # Draw a circle <span class="keyword">for</span> each slider to represent the current setting
    <span class="keyword">for</span> component in range(<span class="number">3</span>):
        pos = (<span class="built_in">int</span>((<span class="built_in">color</span>[component] / <span class="number">255.</span>) * <span class="number">639</span>), component * <span class="number">80</span> + <span class="number">40</span>)
        pygame.<span class="title">draw</span>.circle(screen, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), pos, <span class="number">20</span>)

    pygame.<span class="title">draw</span>.<span class="built_in">rect</span>(screen, tuple(<span class="built_in">color</span>), (<span class="number">0</span>, <span class="number">240</span>, <span class="number">640</span>, <span class="number">240</span>))

    pygame.display.update()
</code></pre><p>上面程序用到的类或方法：</p>
<pre><code>class Rect(__builtin__.object)
 |  pygame.Rect(left, top, <span class="variable">width</span>, <span class="variable">height</span>): <span class="keyword">return</span> Rect
 |  pygame.Rect((left, top), (<span class="variable">width</span>, <span class="variable">height</span>)): <span class="keyword">return</span> Rect
 |  pygame.Rect(object): <span class="keyword">return</span> Rect
 |  pygame object <span class="keyword">for</span> storing rectangular coordinates

<span class="built_in">rect</span>(...)
    pygame.<span class="title">draw</span>.<span class="built_in">rect</span>(Surface, <span class="built_in">color</span>, Rect, <span class="variable">width</span>=<span class="number">0</span>): <span class="keyword">return</span> Rect
    <span class="title">draw</span> a rectangle <span class="built_in">shape</span>

get_pressed(...)
    pygame.mouse.get_pressed(): <span class="keyword">return</span> (button1, button2, button3)
    <span class="built_in">get</span> the state of the mouse buttons

circle(...)
    pygame.<span class="title">draw</span>.circle(Surface, <span class="built_in">color</span>, pos, radius, <span class="variable">width</span>=<span class="number">0</span>): <span class="keyword">return</span> Rect
    <span class="title">draw</span> a circle around a <span class="built_in">point</span>
</code></pre><h3 id="调整颜色">调整颜色</h3><p>要使颜色变暗，只需RGB每一个值都乘于一个0和1之间的系数。</p>
<pre><code>def scale_color(<span class="built_in">color</span>, <span class="built_in">scale</span>):
    <span class="built_in">red</span>, <span class="built_in">green</span>, <span class="built_in">blue</span> = <span class="built_in">color</span>
    <span class="built_in">red</span> = <span class="built_in">int</span>(<span class="built_in">red</span> * <span class="built_in">scale</span>)
    <span class="built_in">green</span> = <span class="built_in">int</span>(<span class="built_in">green</span> * <span class="built_in">scale</span>)
    <span class="built_in">blue</span> = <span class="built_in">int</span>(<span class="built_in">blue</span> * <span class="built_in">scale</span>)
    <span class="keyword">return</span> <span class="built_in">red</span>, <span class="built_in">green</span>, <span class="built_in">blue</span>

fireball_orange = (<span class="number">221</span>, <span class="number">99</span>, <span class="number">20</span>)
<span class="built_in">print</span> fireball_orange
<span class="built_in">print</span> scale_color(fireball_orange, <span class="number">.5</span>)
</code></pre><p>如果乘于一个大于1的数，颜色会变得更亮。但是如果颜色值大于255时，Pygame会抛出TypeError异常。</p>
<pre><code>def saturate_color(<span class="built_in">color</span>):
    <span class="built_in">red</span>, <span class="built_in">green</span>, <span class="built_in">blue</span> = <span class="built_in">color</span>
    <span class="built_in">red</span> = <span class="built_in">min</span>(<span class="built_in">red</span>, <span class="number">255</span>)
    <span class="built_in">green</span> = <span class="built_in">min</span>(<span class="built_in">green</span>, <span class="number">255</span>)
    <span class="built_in">blue</span> = <span class="built_in">min</span>(<span class="built_in">blue</span>, <span class="number">255</span>)
    <span class="keyword">return</span> <span class="built_in">red</span>, <span class="built_in">green</span>, <span class="built_in">blue</span>
</code></pre><p>当颜色饱和至255时，可能就失去原来的色调了，所以需要注意调整的系数。</p>
<h3 id="混合颜色">混合颜色</h3><p>有时候我们想要将一种颜色逐渐混入另一种颜色，比如一个僵尸在路过一个火山熔岩坑的时候，它会由绿色变成橙红色，再变为正常的绿色。我们怎样才能计算中间的颜色使得颜色转换平滑自然呢？<br>我们用一种叫做<strong>线性插值(linear interpolation)</strong>的方法来做这件事情。公式如下：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">lerp</span><span class="params">(value1, value2, factor)</span>:</span>
    <span class="keyword">return</span> value1 + (value2 - value1) * factor
</code></pre><p>如果逐渐改变系数因子，就会产生颜色的平滑转换。</p>
<pre><code><span class="keyword">import</span> pygame
<span class="keyword">from</span> pygame.locals <span class="keyword">import</span> *
<span class="keyword">from</span> sys <span class="keyword">import</span> exit

pygame.init()

screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

color1 = (<span class="number">221</span>, <span class="number">99</span>, <span class="number">20</span>) <span class="comment"># 火球黄</span>
color2 = (<span class="number">96</span>, <span class="number">130</span>, <span class="number">51</span>) <span class="comment"># 僵尸绿</span>

factor = <span class="number">0</span>

<span class="function"><span class="keyword">def</span> <span class="title">lerp</span><span class="params">(value1, value2, factor)</span>:</span>
    <span class="keyword">return</span> value1 + (value2 - value1) * factor

<span class="function"><span class="keyword">def</span> <span class="title">blend_color</span><span class="params">(color1, color2, blend_factor)</span>:</span>
    red1, green1, blue1 = color1
    red2, green2, blue2 = color2
    red = lerp(red1, red2, blend_factor)
    green = lerp(green1, green2, blend_factor)
    blue = lerp(blue1, blue2, blend_factor)
    <span class="keyword">return</span> int(red), int(green), int(blue)

<span class="keyword">while</span> <span class="keyword">True</span>:
    <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():
        <span class="keyword">if</span> event.type == QUIT:
            exit()

    screen.fill((<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))

    tri = [(<span class="number">0</span>, <span class="number">120</span>), (<span class="number">639</span>, <span class="number">100</span>), (<span class="number">639</span>, <span class="number">140</span>)]
    pygame.draw.polygon(screen, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), tri)
    pygame.draw.circle(screen, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), (int(factor * <span class="number">639.</span>), <span class="number">120</span>), <span class="number">10</span>)

    x, y = pygame.mouse.get_pos()
    <span class="keyword">if</span> pygame.mouse.get_pressed()[<span class="number">0</span>]:
        factor = x / <span class="number">639.</span>
        pygame.display.set_caption(<span class="string">'Pygame Color Blend Test - %.3f'</span> % factor)

    color = blend_color(color1, color2, factor)
    pygame.draw.rect(screen, color, (<span class="number">0</span>, <span class="number">240</span>, <span class="number">640</span>, <span class="number">240</span>))

    pygame.display.update()
</code></pre><p>用到的方法：</p>
<pre><code><span class="function"><span class="title">polygon</span><span class="params">(...)</span></span>
    pygame<span class="class">.draw</span><span class="class">.polygon</span>(Surface, <span class="attribute">color</span>, pointlist, <span class="attribute">width</span>=<span class="number">0</span>): return Rect
    draw <span class="tag">a</span> shape with any number of sides
</code></pre><h1 id="使用图片">使用图片</h1><p>图片对大多数游戏都是一个必须的部分。电脑存储图片为颜色的网阵。除了常见的红绿蓝，有些图片还存储额外的信息(alpha通道)。颜色的alpha值通常用来表示当图片画在另一张图片上的透明度。</p>
<h3 id="存储图片">存储图片</h3><p>有很多方式存储图片到硬盘。多年来，多种图片格式被开发出来。最有用的两种格式是JPEG和PNG。</p>
<ul>
<li>JPEG(Joint Photographic Expert Group)-JPEG图片文件扩展名为.jpg或.jpeg。数码相机常用这种格式，因为它是特别设计来存储图片的。它使用有损压缩，会降低图片质量，但是能很好地减小文件大小。JPEG不支持透明，对拥有硬边缘的东西比如字体和图表支持不好。</li>
<li>PNG(Portable Network Graphics)-PNG可能是最全面的图片格式，因为它能保存很多种图片类型并且压缩也很好。它也支持alpha通道，对游戏开发者来说是福利。PNG使用的压缩是无损压缩，缺点就是文件比JPEG文件大。</li>
</ul>
<p>除了JPEG和PNG，Pygame支持读取下面的格式：</p>
<ul>
<li>GIF(非动态)-网上使用的很多，支持透明和动画，只是只能有256种颜色，软件和游戏中使用很少</li>
<li>BMP-Windows上的标准图像格式，无压缩，质量很高但尺寸很大，一般不使用</li>
<li>PCX</li>
<li>TGA(只限非压缩的)</li>
<li>TIF</li>
<li>LBM(和PBM)</li>
<li>PBM(和PGM，PPM)</li>
<li>XPM</li>
</ul>
<p>根据经验，对于拥有很多颜色变化的大图片文件使用JPEG，否则使用PNG。</p>
<h3 id="使用Surface对象">使用Surface对象</h3><p>加载图片到Pygame只需一行，<strong>pygame.image.load</strong>接收一个图片文件名返回一个Surface对象，它是图片的容器。Surface对象可以表示许多种图片类型，但是Pygame隐藏了大多数细节，因此我们能够以相同的方式对待它们。你可以在Surface对象上画图，变形，或拷贝到另一个Surface。甚至屏幕也是一个Surface对象。</p>
<h3 id="创建Surface对象">创建Surface对象</h3><p>调用<strong>pygame.image.load</strong>是一种创建Surface的方式，它会创建和图片文件相同尺寸和颜色的Surface。也可以创建任意尺寸的空白Surface。使用<strong>pygame.Surface</strong>构造函数可以创建一个空白Surface。</p>
<pre><code>blank_surface = pygame.<span class="function"><span class="title">Surface</span><span class="params">((<span class="number">256</span>, <span class="number">256</span>)</span></span>)
</code></pre><p>还有一些选项会影响图片的创建。第一个参数是flags：</p>
<ul>
<li>HWSURFACE-创建硬件外观，比非硬件外观更快。通常最好不要设置这个标志，而是留给Pygame决定是否使用硬件外观。</li>
<li>SRCALPHA-创建拥有alpha信息的外观。这个选项需要depth参数设为32。</li>
</ul>
<p>第二个参数为depth，这个参数和<strong>pygame.display.set_mode</strong>的depth参数一样。通常最好不要设置这个参数(或设置为0)，但是如果想要保留alpha信息，则必须设置为32。</p>
<pre><code>blank_alpha_surface = pygame.Surface((<span class="number">256</span>, <span class="number">256</span>), flags=SRCALPHA, depth=<span class="number">32</span>)
</code></pre><h3 id="转换Surface">转换Surface</h3><p>当你使用Surface对象时，你不需要担心图像信息在内存是怎么存储的，因为Pygame隐藏了这些细节，因此不管什么图片类型，你的代码都能工作。自动转换的唯一缺点是如果你使用不同格式的图片，Pygame需要做更多工作，这可能会降低游戏性能。解决的方法是使用<strong>convert</strong>方法转换所有的图片为相同的格式。</p>
<p>如果不带参数调用<strong>convert</strong>，Surface会被转换为和显示设备的Surface一样的格式。这很有用因为通常起点和终点是相同类型的话拷贝Surface非常快，而大多数图片最终会被拷贝到显示设备。调用<strong>pygame.image.load</strong>时附加<strong>.convert()</strong>是个好习惯。Pygame还提供<strong>convert_alpha</strong>方法，转换Surface并保留alpha信息。</p>
<p><strong>convert</strong>和<strong>convert_alpha</strong>可以接收另外一个Surface参数，如果提供了这个参数，则Surface会被转换为和参数一样的Surface。</p>
<h3 id="矩形对象">矩形对象</h3><p>当一个函数调用会影响到屏幕的某一部分时，Pygame通常需要你提供一个矩形区域。你可以使用一个4元组定义矩形区域，(left, top, width, height)。或者使用2个2元组，((left, top), (width, height))。</p>
<pre><code>my_rect1 = (<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">150</span>)
my_rect2 = ((<span class="number">100</span>, <span class="number">100</span>), (<span class="number">200</span>, <span class="number">150</span>))
</code></pre><p>Pygame有一个Rect类存储和处理矩形对象。因为Rect对象很常使用，所以它包含在<strong>pygame.locals</strong>里面。创建Rect对象使用一样的元组参数。</p>
<pre><code>my_rect3 = Rect(<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">150</span>)
my_rect4 = Rect((<span class="number">100</span>, <span class="number">100</span>), (<span class="number">200</span>, <span class="number">150</span>))
</code></pre><p>一旦创建了Rect对象，就可以使用它来调整位置和大小，检查一个点是否在其中，判断矩形是否交叉等。详细请参考<a href="http://www.pygame.org/docs/ref/rect.html" target="_blank" rel="external">http://www.pygame.org/docs/ref/rect.html</a></p>
<h3 id="剪裁">剪裁</h3><p>通常创建游戏画面的时候，你可能想只绘制一部分。为了解决这个问题，Surface有一个剪裁区域，定义了屏幕的哪一部分可以被绘制。使用<strong>set_clip</strong>方法设置剪裁区域，<strong>get_clip</strong>获得当前剪裁区域。</p>
<pre><code>screen.<span class="function"><span class="title">set_clip</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">640</span>, <span class="number">300</span>)</span></span>
<span class="function"><span class="title">draw_map</span><span class="params">()</span></span>
screen.<span class="function"><span class="title">set_clip</span><span class="params">(<span class="number">0</span>, <span class="number">300</span>, <span class="number">640</span>, <span class="number">180</span>)</span></span>
<span class="function"><span class="title">draw_panel</span><span class="params">()</span></span>
</code></pre><h3 id="子表面(Subsurface)">子表面(Subsurface)</h3><p>一个子表面在其它Surface里面的Surface。当你在子表面上画图时，也会画在父表面上。子表面的一个用法是画图形字体。<strong>pygame.font</strong>模块可以产生漂亮的一种颜色的文字，但是游戏可能需要更丰富的表现。你可以为每一个字母保存一个文本，但是更简单的方法是保存所有字母到一张图片，然后创建26个子表面。</p>
<p>使用Surface对象的<strong>subsurface</strong>方法创建子表面，它接收一个Rect参数，表示覆盖父表面哪一部分，返回一个新的和父表面一样格式的Surface对象。</p>
<pre><code>my_font_image = Pygame.load(<span class="string">"font.png"</span>)
letters = {}
letters[<span class="string">"a"</span>] = my_font_image.subsurface((<span class="number">0</span>,<span class="number">0</span>), (<span class="number">80</span>,<span class="number">80</span>))
letters[<span class="string">"b"</span>] = my_font_image.subsurface((<span class="number">80</span>,<span class="number">0</span>), (<span class="number">80</span>,<span class="number">80</span>))

subsurface(...)
    Surface.subsurface(Rect): <span class="keyword">return</span> Surface
    create a <span class="keyword">new</span> surface that references its parent
</code></pre><p>当你使用子表面时，需要记住它们拥有自己的坐标系统。</p>
<h3 id="填充表面">填充表面</h3><p><strong>fill</strong>方法使用指定颜色填充Surface对象。</p>
<pre><code>screen.fill((<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))
</code></pre><p><strong>fill</strong>方法也可以带一个可选的Rect参数，指定填充区域。</p>
<blockquote>
<p><strong>注意</strong> 如果你使用其它方法画整个屏幕，就不必调用<strong>fill</strong>来清屏了。</p>
</blockquote>
<h3 id="设置表面像素">设置表面像素</h3><p>你能对表面做的一个最基本的事情就是设置单一像素，效果就是画一个非常小的点。很少需要一次画一个像素，因为有更多有效的画图方式，但是你需要处理脱机图片将会很有用。<br>使用<strong>set_at</strong>方法，参数为坐标和颜色，可以在表面画一个像素。</p>
<pre><code><span class="keyword">import</span> pygame
from pygame.locals <span class="keyword">import</span> *
from sys <span class="keyword">import</span> exit
from random <span class="keyword">import</span> randint

pygame.init()
screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

<span class="keyword">while</span> True:
    <span class="keyword">for</span> event in pygame.event.<span class="keyword">get</span>():
        <span class="keyword">if</span> event.type == QUIT:
            exit()

    rand_col = (randint(0, 255), randint(0, 255), randint(0, 255))
    <span class="keyword">for</span> _ in xrange(100):
        rand_pos = (randint(0, 639), randint(0, 479))
        screen.set_at(rand_pos, rand_col)

    pygame.display.update()
</code></pre><h3 id="获得表面的像素">获得表面的像素</h3><p>与<strong>set_at</strong>相对的是<strong>get_at</strong>，它返回给定坐标像素的颜色。获取像素有时候对于碰撞检测很必要。</p>
<pre><code>my_color = screen.<span class="function"><span class="title">get_at</span><span class="params">((<span class="number">100</span>, <span class="number">100</span>)</span></span>)
</code></pre><blockquote>
<p><strong>注意</strong> <strong>get_at</strong>在读取硬件表面时很慢。显示可能是硬件表面，尤其是全屏显示的时候，所以这时应该避免使用<strong>get_at</strong>。</p>
</blockquote>
<h3 id="锁定Surface">锁定Surface</h3><p>当Pygame在surface上画图时，surface必须先锁定。当surface被锁定时，Pygame完全控制surface，计算机其它进程只能等到surface解锁时才能使用。当你在surface上画图时，加锁和解锁自动发生。但是如果Pygame需要做太多加锁和解锁，程序会变得没有效率。我们可以通过手动加锁和解锁来减少加锁和解锁的次数，从而提高运行速度。</p>
<blockquote>
<p><strong>注意</strong> <strong>lock</strong>和<strong>unlock</strong>的次数必须一样，如果忘记了<strong>unlock</strong>一个surface，Pygame将失去响应。</p>
</blockquote>
<pre><code><span class="keyword">import</span> pygame
from pygame.locals <span class="keyword">import</span> *
from sys <span class="keyword">import</span> exit
from random <span class="keyword">import</span> randint

pygame.init()
screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

<span class="keyword">while</span> True:
    <span class="keyword">for</span> event in pygame.event.<span class="keyword">get</span>():
        <span class="keyword">if</span> event.type == QUIT:
            exit()

    rand_col = (randint(0, 255), randint(0, 255), randint(0, 255))
    screen.lock()
    <span class="keyword">for</span> _ in xrange(100):
        rand_pos = (randint(0, 639), randint(0, 479))
        screen.set_at(rand_pos, rand_col)
    screen.unlock()
    pygame.display.update()
</code></pre><p>不是所有的surface需要加锁。硬件surface需要(屏幕通常是硬件surface)，普通的surface不需要。Pygame提供一个<strong>mustlock</strong>方法返回True如果surface需要加锁。加锁不需要加锁的surface没有问题。</p>
<h3 id="Blitting">Blitting</h3><p>最常用的surface对象的方法可能是<strong>blit</strong>，是位块传输(<strong>bit block transfer</strong>)的缩写。Blitting意思是从一个surface拷贝图片数据到另一个surface。你可以使用它来画背景，字体，角色和游戏中几乎所有的事。</p>
<p>为了blit一个surface，用目标surface对象调用<strong>blit</strong>，传递源surface和目的坐标。也可以只blit一部分surface。</p>
<pre><code>screen.blit(background, (<span class="number">0</span>,<span class="number">0</span>))
screen.blit(ogre, (<span class="number">300</span>, <span class="number">200</span>), (<span class="number">100</span>*frame_no, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>))
</code></pre><h1 id="用Pygame画图">用Pygame画图</h1><p>我们在之前的例子中已经使用过一些<strong>pygame.draw</strong>模块的函数了。这个模块的用途就是在屏幕上画几何图形。你可以使用它创建整个游戏而不需要加载其它图片。</p>
<p><strong>pygame.draw</strong>模块的函数前两个参数都是surface和颜色。每一个函数也会至少带一个点，也许是一个点的列表。每个点是一个包含坐标的元组。</p>
<p>画图函数返回一个Rect对象包含了绘制过的区域，对于只想绘制屏幕的一部分很有用。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>rect</td>
<td style="text-align:left">绘制矩形</td>
</tr>
<tr>
<td>polygon</td>
<td style="text-align:left">绘制多边形(三条边或更多)</td>
</tr>
<tr>
<td>circle</td>
<td style="text-align:left">绘制圆</td>
</tr>
<tr>
<td>ellipse</td>
<td style="text-align:left">绘制椭圆</td>
</tr>
<tr>
<td>arc</td>
<td style="text-align:left">绘制圆弧</td>
</tr>
<tr>
<td>line</td>
<td style="text-align:left">绘制直线</td>
</tr>
<tr>
<td>lines</td>
<td style="text-align:left">绘制多个直线</td>
</tr>
<tr>
<td>aaline</td>
<td style="text-align:left">绘制平滑直线</td>
</tr>
<tr>
<td>aalines</td>
<td style="text-align:left">绘制多个平滑直线</td>
</tr>
</tbody>
</table>
<h3 id="pygame-draw-rect">pygame.draw.rect</h3><p>这个函数在surface上画一个矩形。除了目的surface和颜色，<strong>pygame.draw.rect</strong>接收一个Rect对象和width作为参数。如果width为0或忽略，则用固定颜色填充矩形，否则只画边缘。</p>
<pre><code><span class="keyword">import</span> pygame
from pygame.locals <span class="keyword">import</span> *
from sys <span class="keyword">import</span> exit

from random <span class="keyword">import</span> *

pygame.<span class="keyword">init</span>()
screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

<span class="keyword">while</span> <span class="type">True</span>:
    <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.<span class="keyword">get</span>():
        <span class="keyword">if</span> event.type == <span class="type">QUIT</span>:
            exit()

    screen.lock()
    <span class="keyword">for</span> <span class="built_in">count</span> <span class="keyword">in</span> range(<span class="number">10</span>):
        random_color = (randint(<span class="number">0</span>, <span class="number">255</span>), randint(<span class="number">0</span>, <span class="number">255</span>), randint(<span class="number">0</span>, <span class="number">255</span>))
        random_pos = (randint(<span class="number">0</span>, <span class="number">639</span>), randint(<span class="number">0</span>, <span class="number">479</span>))
        random_size = (<span class="number">639</span> - randint(random_pos[<span class="number">0</span>], <span class="number">639</span>), <span class="number">479</span> -
            randint(random_pos[<span class="number">1</span>], <span class="number">479</span>))
        pygame.draw.rect(screen, random_color, <span class="type">Rect</span>(random_pos, random_size))
    screen.unlock()

    pygame.display.update()
</code></pre><p>还有另外一个方法画填充的矩形。surface的<strong>fill</strong>方法接收一个Rect对象指定要填充的区域。<strong>fill</strong>比<strong>pygame.draw.rect</strong>要快，因为<strong>fill</strong>由显卡来执行。</p>
<h3 id="pygame-draw-polygon">pygame.draw.polygon</h3><p><strong>pygame.draw.polygon</strong>接收一系列点的列表并在它们之间画形状。它也有一个width参数，如果width被忽略或设置为0，则多边形被填充，否则只画边缘。</p>
<pre><code>import pygame
<span class="keyword">from</span> pygame.locals import *
<span class="keyword">from</span> sys import <span class="keyword">exit</span>

pygame.init()
screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

points = []

<span class="keyword">while</span> <span class="keyword">True</span>:
    <span class="keyword">for</span> <span class="keyword">event</span> <span class="keyword">in</span> pygame.<span class="keyword">event</span>.get():
        <span class="keyword">if</span> <span class="keyword">event</span>.<span class="keyword">type</span> == QUIT:
            <span class="keyword">exit</span>()
        <span class="keyword">if</span> <span class="keyword">event</span>.<span class="keyword">type</span> == MOUSEBUTTONDOWN:
            points.append(<span class="keyword">event</span>.pos)

    screen.fill((<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))

    <span class="keyword">if</span> len(points) &gt;= <span class="number">3</span>:
        pygame.draw.polygon(screen, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), points, <span class="number">1</span>)
    <span class="keyword">for</span> point <span class="keyword">in</span> points:
        pygame.draw.circle(screen, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), point, <span class="number">5</span>)

    pygame.display.update()
</code></pre><h3 id="pygame-draw-circle">pygame.draw.circle</h3><p><strong>circle</strong>函数在surface上画圆。它接收一个圆心坐标和半径作为参数。和之前一样，width参数如果为0或忽略，则圆被填充，否则只画边缘。</p>
<pre><code>import pygame
from pygame.locals import *
from sys import <span class="built_in">exit</span>
from random import *

pygame.init()
screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

<span class="keyword">while</span> True:
    <span class="keyword">for</span> event in pygame.event.get():
        <span class="keyword">if</span> event.type == QUIT:
            <span class="built_in">exit</span>()

    random_color = (randint(<span class="number">0</span>, <span class="number">255</span>), randint(<span class="number">0</span>, <span class="number">255</span>), randint(<span class="number">0</span>, <span class="number">255</span>))
    random_pos = (randint(<span class="number">0</span>, <span class="number">639</span>), randint(<span class="number">0</span>, <span class="number">479</span>))
    random_radius = randint(<span class="number">1</span>, <span class="number">200</span>)
    pygame.draw.circle(screen, random_color, random_pos, random_radius)

    pygame.display.update()
</code></pre><h3 id="pygame-draw-ellipse">pygame.draw.ellipse</h3><p><strong>用法</strong>： pygame.draw.ellipse(Surface, color, Rect, width=0)</p>
<pre><code>from random import *
import pygame
from pygame.locals import *
from sys import <span class="built_in">exit</span>

pygame.init()
screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

<span class="keyword">while</span> True:
    <span class="keyword">for</span> event in pygame.event.get():
        <span class="keyword">if</span> event.type == QUIT:
            <span class="built_in">exit</span>()

    x, y = pygame.mouse.get_pos()
    screen.fill((<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))
    pygame.draw.ellipse(screen, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">0</span>, x, y))

    pygame.display.update()
</code></pre><h3 id="pygame-draw-arc">pygame.draw.arc</h3><p><strong>用法</strong>：pygame.draw.arc(Surface, color, Rect, start_angle, stop_angle, width=1)<br><strong>arc</strong>函数仅仅画椭圆的一部分，而且只画边缘。圆弧是不封闭的，因此没有<strong>fill</strong>方法。这个函数的width参数默认为1，你也可以设置为更大的值以得到更粗的线。</p>
<pre><code>from random import *
from math import pi
import pygame
from pygame.locals import *
from sys import <span class="built_in">exit</span>

pygame.init()
screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

<span class="keyword">while</span> True:
    <span class="keyword">for</span> event in pygame.event.get():
        <span class="keyword">if</span> event.type == QUIT:
            <span class="built_in">exit</span>()

    x, y = pygame.mouse.get_pos()
    angle = (x / <span class="number">639.</span>) * pi * <span class="number">2</span>
    screen.fill((<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))
    pygame.draw.arc(screen, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">639</span>, <span class="number">479</span>), <span class="number">0</span>, angle)

    pygame.display.update()
</code></pre><h3 id="pygame-draw-line">pygame.draw.line</h3><p><strong>用法</strong>：pygame.draw.line(Surface, color, start_pos, end_pos, width=1)</p>
<pre><code><span class="keyword">import</span> pygame
from pygame.locals <span class="keyword">import</span> *
from sys <span class="keyword">import</span> exit

pygame.init()
screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

<span class="keyword">while</span> True:
    <span class="keyword">for</span> event in pygame.event.<span class="keyword">get</span>():
        <span class="keyword">if</span> event.type == QUIT:
            exit()

    screen.fill((255, 255, 255))
    mouse_pos = pygame.mouse.get_pos()

    <span class="keyword">for</span> x in xrange(0, 640, 20):
        pygame.draw.line(screen, (0, 0, 0), (x, 0), mouse_pos)
        pygame.draw.line(screen, (0, 0, 0), (x, 479), mouse_pos)

    <span class="keyword">for</span> y in xrange(0, 480, 20):
        pygame.draw.line(screen, (0, 0, 0), (0, y), mouse_pos)
        pygame.draw.line(screen, (0, 0, 0), (639, y), mouse_pos)

    pygame.display.update()
</code></pre><h3 id="pygame-draw-lines">pygame.draw.lines</h3><p><strong>用法</strong>：pygame.draw.lines(Surface, color, closed, pointlist, width=1)</p>
<p>closed是一个布尔值，指明是否需要多画一条线来使这些线条闭合。</p>
<pre><code>import pygame
<span class="keyword">from</span> pygame.locals import *
<span class="keyword">from</span> sys import <span class="keyword">exit</span>

pygame.init()
screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

points = []

<span class="keyword">while</span> <span class="keyword">True</span>:
    <span class="keyword">for</span> <span class="keyword">event</span> <span class="keyword">in</span> pygame.<span class="keyword">event</span>.get():
        <span class="keyword">if</span> <span class="keyword">event</span>.<span class="keyword">type</span> == QUIT:
            <span class="keyword">exit</span>()
        <span class="keyword">if</span> <span class="keyword">event</span>.<span class="keyword">type</span> == MOUSEMOTION:
            points.append(<span class="keyword">event</span>.pos)
            <span class="keyword">if</span> len(points) &gt; <span class="number">100</span>:
                del points[<span class="number">0</span>]

    screen.fill((<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))

    <span class="keyword">if</span> len(points) &gt; <span class="number">1</span>:
        pygame.draw.lines(screen, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="keyword">False</span>, points, <span class="number">2</span>)

    pygame.display.update()
</code></pre><h3 id="pygame-draw-aaline">pygame.draw.aaline</h3><p><strong>用法</strong>：pygame.draw.aaline(Surface, color, start_pos, end_pos, width=1)</p>
<p>你可能注意到了上一个画线函数画出的线有锯齿。这是因为一个像素对应一个坐标，而这个坐标可能没有直接在线里面，这个现象叫做锯齿。任何试图避免或减少锯齿的方法称为抗锯齿。</p>
<p><strong>pygame.draw.aaline</strong>和<strong>pygame.draw.line</strong>参数一样，但是能画出平滑的直线。缺点是它慢一点。</p>
<h3 id="pygame-draw-aalines">pygame.draw.aalines</h3><p><strong>用法</strong>：pygame.draw.aalines(Surface, color, closed, pointlist, width=1)</p>
<p><strong>pygame.draw.aalines</strong>和<strong>pygame.draw.lines</strong>用法一样。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>电脑游戏倾向于视觉上很自然，游戏开发者花费很多精力在处理图像和提升视觉效果来创建最令人愉快的体验上。</p>
<h1 id="像素的威力">像素的威力</h1><p>显示器里的一个独立的点称为一个图像单元或像素。如果一个显示器分辨率为1280x1024，则像素总数为1310]]>
    </summary>
    
      <category term="Pygame" scheme="https://opensvn.github.io/tags/Pygame/"/>
    
      <category term="Python" scheme="https://opensvn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Pygame第三章 Pygame介绍]]></title>
    <link href="https://opensvn.github.io/2015/11/02/pygame-3/"/>
    <id>https://opensvn.github.io/2015/11/02/pygame-3/</id>
    <published>2015-11-02T00:16:02.000Z</published>
    <updated>2015-11-19T02:30:42.293Z</updated>
    <content type="html"><![CDATA[<h1 id="安装Pygame">安装Pygame</h1><p>Ubuntu下安装Pygame:</p>
<pre><code>sudo apt-<span class="built_in">get</span> install <span class="keyword">python</span>-pygame
</code></pre><p>装好后，查看Pygame版本:</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; import pygame
<span class="prompt">&gt;&gt;</span>&gt; print pygame.ver
</code></pre><h1 id="使用Pygame">使用Pygame</h1><p>Pygame有很多模块。每一个设备都有一个对应的模块。Pygame模块一览：</p>
<table>
<thead>
<tr>
<th>模块名</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>pygame.cdrom</td>
<td style="text-align:left">访问和控制光驱</td>
</tr>
<tr>
<td>pygame.cursors</td>
<td style="text-align:left">加载光标图片</td>
</tr>
<tr>
<td>pygame.display</td>
<td style="text-align:left">访问显示设备</td>
</tr>
<tr>
<td>pygame.draw</td>
<td style="text-align:left">绘制形状、线和点</td>
</tr>
<tr>
<td>pygame.event</td>
<td style="text-align:left">管理事件</td>
</tr>
<tr>
<td>pygame.font</td>
<td style="text-align:left">使用字体</td>
</tr>
<tr>
<td>pygame.image</td>
<td style="text-align:left">加载和存储图片</td>
</tr>
<tr>
<td>pygame.joystick</td>
<td style="text-align:left">使用游戏手柄或者类似设备</td>
</tr>
<tr>
<td>pygame.key</td>
<td style="text-align:left">读取键盘按键</td>
</tr>
<tr>
<td>pygame.mixer</td>
<td style="text-align:left">加载和播放声音</td>
</tr>
<tr>
<td>pygame.mouse</td>
<td style="text-align:left">管理鼠标</td>
</tr>
<tr>
<td>pygame.movie</td>
<td style="text-align:left">播放视频</td>
</tr>
<tr>
<td>pygame.music</td>
<td style="text-align:left">处理音乐和音频流</td>
</tr>
<tr>
<td>pygame.overlay</td>
<td style="text-align:left">访问高级视频叠加</td>
</tr>
<tr>
<td>pygame</td>
<td style="text-align:left">包含高层Pygame函数</td>
</tr>
<tr>
<td>pygame.rect</td>
<td style="text-align:left">管理矩形区域</td>
</tr>
<tr>
<td>pygame.sndarray</td>
<td style="text-align:left">操作声音数据</td>
</tr>
<tr>
<td>pygame.sprite</td>
<td style="text-align:left">操作移动图像</td>
</tr>
<tr>
<td>pygame.surface</td>
<td style="text-align:left">管理图像和屏幕</td>
</tr>
<tr>
<td>pygame.surfarray</td>
<td style="text-align:left">管理点阵图像数据</td>
</tr>
<tr>
<td>pygame.time</td>
<td style="text-align:left">管理时间和帧信息</td>
</tr>
<tr>
<td>pygame.transform</td>
<td style="text-align:left">缩放和移动图像</td>
</tr>
</tbody>
</table>
<p>有些模块可能在某些平台上不存在，比如游戏运行的硬件驱动没有安装，这种情况下，Pygame将设置这个模块为None，可以使用None来测试。下面这段代码检测<code>pygame.font</code>是否可用：</p>
<pre><code><span class="keyword">if</span> pygame<span class="class">.font</span> is None:
    print <span class="string">'The font module is not available!'</span>
    <span class="function"><span class="title">exit</span><span class="params">()</span></span>
</code></pre><h1 id="重温Hello_World">重温Hello World</h1><pre><code>background_image_filename = <span class="string">'sushiplate.jpg'</span>
mouse_image_filename = <span class="string">'fugu.png'</span>

<span class="keyword">import</span> pygame
from pygame.locals <span class="keyword">import</span> *
from sys <span class="keyword">import</span> exit

pygame.init()

screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)
pygame.display.set_caption(<span class="string">'Hello, World!'</span>)

background = pygame.image.load(background_image_filename).convert()
mouse_cursor = pygame.image.load(mouse_image_filename).convert_alpha()

<span class="keyword">while</span> True:
    <span class="keyword">for</span> event in pygame.event.<span class="keyword">get</span>():
        <span class="keyword">if</span> event.type == QUIT:
            exit()

    screen.blit(background, (0, 0))

    x, y = pygame.mouse.get_pos()
    x -= mouse_cursor.get_width() / 2
    y -= mouse_cursor.get_height() / 2
    screen.blit(mouse_cursor, (x, y))

    pygame.display.update()
</code></pre><p>第一行导入pygame包，使我们可以访问它的所有子模块。第二行导入一些常用函数和常量，这个不是必须的，但是更方便。</p>
<p><strong>pygame.init()</strong>非常简单，实际上却做了非常多工作。它初始化每一个Pygame的子模块。可以单独初始化某一个模块，比如<strong>pygame.sound.init()</strong>。</p>
<p><strong>pygame.display.set_mode</strong>返回一个Surface对象，代表桌面窗口。第一个参数为元祖，代表分辨率(必须)。第二个是一个标志位，具体意思见下表，如果不用什么特性，就指定0。第三个为色深，如果未提供或设置为0，Pygame将使用当前桌面的值。</p>
<table>
<thead>
<tr>
<th>标志位</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>FULLSCREEN</td>
<td style="text-align:left">创建一个全屏窗口</td>
</tr>
<tr>
<td>DOUBLEBUF</td>
<td style="text-align:left">创建一个“双缓冲”窗口，建议在HWSURFACE或者OPENGL时使用</td>
</tr>
<tr>
<td>HWSURFACE</td>
<td style="text-align:left">创建一个硬件加速的窗口，必须和FULLSCREEN同时使用</td>
</tr>
<tr>
<td>OPENGL</td>
<td style="text-align:left">创建一个OpenGL渲染的窗口</td>
</tr>
<tr>
<td>RESIZABLE</td>
<td style="text-align:left">创建一个可变大小的窗口</td>
</tr>
<tr>
<td>NOFRAME</td>
<td style="text-align:left">创建一个没有边框的窗口</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>色深</th>
<th style="text-align:left">颜色个数</th>
</tr>
</thead>
<tbody>
<tr>
<td>8 bits</td>
<td style="text-align:left">256种颜色</td>
</tr>
<tr>
<td>15 bits</td>
<td style="text-align:left">32768种颜色，空闲一位</td>
</tr>
<tr>
<td>16 bits</td>
<td style="text-align:left">65536种颜色</td>
</tr>
<tr>
<td>24 bits</td>
<td style="text-align:left">16.7百万种颜色</td>
</tr>
<tr>
<td>32 bits</td>
<td style="text-align:left">16.7百万种颜色，空闲8位</td>
</tr>
</tbody>
</table>
<p><strong>load</strong>函数读取一个文件并返回一个包含图片数据的Surface对象，直到画出来之前是不可见的。<br><strong>convert</strong>函数是将图像数据转化为Surface对象，每次加载完图像以后就应该做这件事件(事实上因为它太常用了，如果你不写Pygame也会帮你做)；<br><strong>convert_alpha</strong>相比<strong>convert</strong>，保留了Alpha通道信息(可以简单理解为透明的部分)，这样我们的光标才可以是不规则的形状。</p>
<p>游戏的主循环是一个无限循环，直到用户跳出。在这个主循环里做的事情就是不停地画背景和更新光标位置，虽然背景是不动的，我们还是需要每次都画它，否则鼠标覆盖过的位置就不能恢复正常了。<br>画完以后一定要<strong>update</strong>更新一下，否则画面一片漆黑。</p>
<pre><code><span class="function"><span class="title">init</span><span class="params">(...)</span></span>
    pygame.<span class="function"><span class="title">init</span><span class="params">()</span></span>: return (numpass, numfail)
    initialize all imported pygame modules

<span class="function"><span class="title">set_mode</span><span class="params">(...)</span></span>
    pygame<span class="class">.display</span><span class="class">.set_mode</span>(resolution=(<span class="number">0</span>,<span class="number">0</span>), flags=<span class="number">0</span>, depth=<span class="number">0</span>): return Surface
    initialize <span class="tag">a</span> window or screen <span class="keyword">for</span> <span class="attribute">display</span>

<span class="function"><span class="title">set_caption</span><span class="params">(...)</span></span>
    pygame<span class="class">.display</span><span class="class">.set_caption</span>(title, icontitle=None): return None
    set the current window <span class="tag">caption</span>

<span class="function"><span class="title">load</span><span class="params">(...)</span></span>
    pygame<span class="class">.image</span><span class="class">.load</span>(filename): return Surface
    pygame<span class="class">.image</span><span class="class">.load</span>(fileobj, namehint=): return Surface
    load new image from <span class="tag">a</span> file

<span class="function"><span class="title">convert</span><span class="params">(...)</span></span>
    Surface.<span class="function"><span class="title">convert</span><span class="params">(Surface)</span></span>: return Surface
    Surface.<span class="function"><span class="title">convert</span><span class="params">(depth, flags=<span class="number">0</span>)</span></span>: return Surface
    Surface.<span class="function"><span class="title">convert</span><span class="params">(masks, flags=<span class="number">0</span>)</span></span>: return Surface
    Surface.<span class="function"><span class="title">convert</span><span class="params">()</span></span>: return Surface
    change the pixel format of an image

<span class="function"><span class="title">convert_alpha</span><span class="params">(...)</span></span>
    Surface.<span class="function"><span class="title">convert_alpha</span><span class="params">(Surface)</span></span>: return Surface
    Surface.<span class="function"><span class="title">convert_alpha</span><span class="params">()</span></span>: return Surface
    change the pixel format of an image including per pixel alphas

<span class="function"><span class="title">get</span><span class="params">(...)</span></span>
    pygame<span class="class">.event</span><span class="class">.get</span>(): return Eventlist
    pygame<span class="class">.event</span><span class="class">.get</span>(type): return Eventlist
    pygame<span class="class">.event</span><span class="class">.get</span>(typelist): return Eventlist
    get events from the queue

<span class="function"><span class="title">blit</span><span class="params">(...)</span></span>
    Surface.<span class="function"><span class="title">blit</span><span class="params">(source, dest, area=None, special_flags = <span class="number">0</span>)</span></span>: return Rect
    draw one image onto another

<span class="function"><span class="title">get_pos</span><span class="params">(...)</span></span>
    pygame<span class="class">.mouse</span><span class="class">.get_pos</span>(): return (x, y)
    get the mouse <span class="attribute">cursor</span> <span class="attribute">position</span>

<span class="function"><span class="title">get_width</span><span class="params">(...)</span></span>
    Surface.<span class="function"><span class="title">get_width</span><span class="params">()</span></span>: return <span class="attribute">width</span>
    get the <span class="attribute">width</span> of the Surface

<span class="function"><span class="title">get_height</span><span class="params">(...)</span></span>
    Surface.<span class="function"><span class="title">get_height</span><span class="params">()</span></span>: return <span class="attribute">height</span>
    get the <span class="attribute">height</span> of the Surface

<span class="function"><span class="title">update</span><span class="params">(...)</span></span>
    pygame<span class="class">.display</span><span class="class">.update</span>(rectangle=None): return None
    pygame<span class="class">.display</span><span class="class">.update</span>(rectangle_list): return None
    update portions of the screen <span class="keyword">for</span> software displays
</code></pre><h1 id="理解事件">理解事件</h1><p>事件可以在任何时候产生，不管程序当前在做什么。因为你不能对发生的事件立刻做出反应，Pygame将事件存入一个队列，逐个处理。</p>
<h3 id="事件检索">事件检索</h3><p>上个程序中，使用<strong>pygame.event.get()</strong>来处理所有的事件，这就像打开大门让所有的人进入。如果我们使用<strong>pygame.event.wait()</strong>，Pygame就会等到一个事件发生才继续下去，就好像等在门口，直到有人来。这个函数不太常用，因为它会挂起程序直到有事情发生；而另外一个方法<strong>pygame.event.poll()</strong>就好一些，一旦调用，它会根据现在的情形返回一个真实的事件，否则返回一个类型为NOEVENT的假事件。</p>
<p>每隔一段固定的时间调用事件处理函数很有必要，这样Pygame才能在内部处理事件。如果不使用任何事件处理函数，也可以调用<strong>pygame.event.pump()</strong>替代事件循环。</p>
<p>事件对象包含一些描述事件发生的成员变量。所有事件对象都有一个事件类型。</p>
<table>
<thead>
<tr>
<th>事件</th>
<th style="text-align:left">产生途径</th>
<th style="text-align:left">参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>QUIT</td>
<td style="text-align:left">用户点击关闭按钮</td>
<td style="text-align:left">none</td>
</tr>
<tr>
<td>ACTIVEEVENT</td>
<td style="text-align:left">Pygame被激活或隐藏</td>
<td style="text-align:left">gain,state</td>
</tr>
<tr>
<td>KEYDOWN</td>
<td style="text-align:left">键盘按下</td>
<td style="text-align:left">unicode,key,mod</td>
</tr>
<tr>
<td>KEYUP</td>
<td style="text-align:left">键盘松开</td>
<td style="text-align:left">key,mod</td>
</tr>
<tr>
<td>MOUSEMOTION</td>
<td style="text-align:left">鼠标移动</td>
<td style="text-align:left">pos,rel,buttons</td>
</tr>
<tr>
<td>MOUSEBUTTONDOWN</td>
<td style="text-align:left">鼠标按下</td>
<td style="text-align:left">pos,button</td>
</tr>
<tr>
<td>MOUSEBUTTONUP</td>
<td style="text-align:left">鼠标松开</td>
<td style="text-align:left">pos,button</td>
</tr>
<tr>
<td>JOYAXISMOTION</td>
<td style="text-align:left">游戏手柄(Joystick or pad)移动</td>
<td style="text-align:left">joy,axis,value</td>
</tr>
<tr>
<td>JOYBALLMOTION</td>
<td style="text-align:left">游戏球(Joy ball)移动</td>
<td style="text-align:left">joy,ball,rel</td>
</tr>
<tr>
<td>JOYHATMOTION</td>
<td style="text-align:left">游戏手柄(Joystick)移动</td>
<td style="text-align:left">joy,hat,value</td>
</tr>
<tr>
<td>JOYBUTTONDOWN</td>
<td style="text-align:left">游戏手柄按下</td>
<td style="text-align:left">joy,button</td>
</tr>
<tr>
<td>JOYBUTTONUP</td>
<td style="text-align:left">游戏手柄放开</td>
<td style="text-align:left">joy,button</td>
</tr>
<tr>
<td>VIDEORESIZE</td>
<td style="text-align:left">Pygame窗口缩放</td>
<td style="text-align:left">size,w,h</td>
</tr>
<tr>
<td>VIDEOEXPOSE</td>
<td style="text-align:left">部分或所有Pygame窗口暴露</td>
<td style="text-align:left">none</td>
</tr>
<tr>
<td>USEREVENT</td>
<td style="text-align:left">触发一个用户事件</td>
<td style="text-align:left">code</td>
</tr>
</tbody>
</table>
<pre><code>import pygame
<span class="keyword">from</span> pygame.locals import *
<span class="keyword">from</span> sys import <span class="keyword">exit</span>

pygame.init()
SCREEN_SIZE = (<span class="number">800</span>, <span class="number">600</span>)
screen = pygame.display.set_mode(SCREEN_SIZE, <span class="number">0</span>, <span class="number">32</span>)

font = pygame.font.SysFont(<span class="comment">'arial', 16)</span>
font_height = font.get_linesize()
event_text = []

<span class="keyword">while</span> <span class="literal">True</span>:
    <span class="keyword">event</span> = pygame.<span class="keyword">event</span>.wait()
    event_text.append(str(<span class="keyword">event</span>))
    event_text = event_text[-SCREEN_SIZE[<span class="number">1</span>]/font_height:]

    <span class="keyword">if</span> <span class="keyword">event</span>.type == QUIT:
        <span class="keyword">exit</span>()

    screen.fill((<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))

    y = SCREEN_SIZE[<span class="number">1</span>] - font_height
    <span class="keyword">for</span> <span class="keyword">text</span> <span class="keyword">in</span> reversed(event_text):
        screen.blit(font.render(<span class="keyword">text</span>, <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)), (<span class="number">0</span>, y))
        y -= font_height

    pygame.display.update()
</code></pre><p><strong>pygame.font.SysFont</strong>返回一个pygame.font.Font对象。</p>
<pre><code><span class="function"><span class="title">SysFont</span><span class="params">(name, size, bold=False, italic=False)</span></span>
    pygame<span class="class">.font</span><span class="class">.SysFont</span>(name, size, bold=False, italic=False) -&gt; Font
    create <span class="tag">a</span> pygame Font from system <span class="attribute">font</span> resources

    This will search the system fonts <span class="keyword">for</span> the given <span class="attribute">font</span>
    name. You can also enable bold or italic styles, and
    the appropriate system <span class="attribute">font</span> will be selected <span class="keyword">if</span> available.

    This will always return <span class="tag">a</span> valid Font <span class="tag">object</span>, and will
    fallback on the builtin pygame <span class="attribute">font</span> <span class="keyword">if</span> the given <span class="attribute">font</span>
    is not found.

    Name can also be <span class="tag">a</span> comma separated list of names, <span class="keyword">in</span>
    which case set of names will be searched <span class="keyword">in</span> <span class="attribute">order</span>. Pygame
    uses <span class="tag">a</span> small set of common <span class="attribute">font</span> aliases, <span class="keyword">if</span> the specific
    <span class="attribute">font</span> you ask <span class="keyword">for</span> is not available, <span class="tag">a</span> reasonable alternative
    may be used.

<span class="function"><span class="title">get_linesize</span><span class="params">(...)</span></span>
    Font.<span class="function"><span class="title">get_linesize</span><span class="params">()</span></span>: return int
    get the line space of the <span class="attribute">font</span> text

<span class="function"><span class="title">wait</span><span class="params">(...)</span></span>
    pygame<span class="class">.event</span><span class="class">.wait</span>(): return Event
    wait <span class="keyword">for</span> <span class="tag">a</span> single event from the queue

<span class="function"><span class="title">render</span><span class="params">(...)</span></span>
    Font.<span class="function"><span class="title">render</span><span class="params">(text, antialias, color, background=None)</span></span>: return Surface
    draw text on <span class="tag">a</span> new Surface

<span class="function"><span class="title">fill</span><span class="params">(...)</span></span>
    Surface.<span class="function"><span class="title">fill</span><span class="params">(color, rect=None, special_flags=<span class="number">0</span>)</span></span>: return Rect
    fill Surface with <span class="tag">a</span> solid <span class="attribute">color</span>

<span class="function"><span class="title">pump</span><span class="params">(...)</span></span>
    pygame<span class="class">.event</span><span class="class">.pump</span>(): return None
    internally process pygame event handlers
</code></pre><h3 id="处理鼠标移动事件">处理鼠标移动事件</h3><p>当鼠标移动时，<strong>MOUSEMOTION</strong>事件发生。包含下面三个值：</p>
<ul>
<li>buttons-一个对应鼠标按钮的元组。buttons[0]是鼠标左按钮，buttons[1]是鼠标中间按钮，buttons[2]是鼠标右按钮。如果按钮被按下，则值为1，反之为0。多个按钮可以同时按下。</li>
<li>pos-一个元组，包含事件发生时鼠标所在位置。</li>
<li>rel-一个元祖，包含现在距离上次产生鼠标事件时的距离。</li>
</ul>
<h3 id="处理鼠标按钮事件">处理鼠标按钮事件</h3><p>除了鼠标移动事件，鼠标还能产生<strong>MOUSEBUTTONDOWN</strong>和<strong>MOUSEBUTTONUP</strong>事件。包含下面2个值：</p>
<ul>
<li>button-被按下的按钮的数字。1为鼠标左按钮，2为鼠标中间按钮，3为鼠标右按钮。</li>
<li>pos-一个元组，包含事件发生时鼠标所在位置。</li>
</ul>
<h3 id="处理键盘事件">处理键盘事件</h3><p>键盘和游戏手柄的事件类似。当一个键被按下<strong>KEYDOWN</strong>事件发生。当一个键松开<strong>KEYUP</strong>事件发生。</p>
<pre><code>bg_file = <span class="comment">'sushiplate.jpg'</span>

import pygame
<span class="keyword">from</span> pygame.locals import *
<span class="keyword">from</span> sys import <span class="keyword">exit</span>

pygame.init()
screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), FULLSCREEN, <span class="number">32</span>)
background = pygame.image.load(bg_file).convert()

x, y = <span class="number">0</span>, <span class="number">0</span>
move_x, move_y = <span class="number">0</span>, <span class="number">0</span>

<span class="keyword">while</span> <span class="literal">True</span>:
    <span class="keyword">for</span> <span class="keyword">event</span> <span class="keyword">in</span> pygame.<span class="keyword">event</span>.<span class="keyword">get</span>():
        <span class="keyword">if</span> <span class="keyword">event</span>.type == QUIT:
            <span class="keyword">exit</span>()
        <span class="keyword">if</span> <span class="keyword">event</span>.type == KEYDOWN:
            <span class="keyword">if</span> <span class="keyword">event</span>.<span class="keyword">key</span> == K_LEFT:
                move_x = -<span class="number">1</span>
            elif <span class="keyword">event</span>.<span class="keyword">key</span> == K_RIGHT:
                move_x = <span class="number">1</span>
            elif <span class="keyword">event</span>.<span class="keyword">key</span> == K_UP:
                move_y = -<span class="number">1</span>
            elif <span class="keyword">event</span>.<span class="keyword">key</span> == K_DOWN:
                move_y = <span class="number">1</span>
        elif <span class="keyword">event</span>.type == KEYUP:
            <span class="keyword">if</span> <span class="keyword">event</span>.<span class="keyword">key</span> == K_LEFT <span class="keyword">or</span> <span class="keyword">event</span>.<span class="keyword">key</span> == K_RIGHT:
                move_x = <span class="number">0</span>
            elif <span class="keyword">event</span>.<span class="keyword">key</span> == K_UP <span class="keyword">or</span> <span class="keyword">event</span>.<span class="keyword">key</span> == K_DOWN:
                move_y = <span class="number">0</span>
    x += move_x
    y += move_y

    screen.fill((<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))
    screen.blit(background, (x, y))

    pygame.display.update()
</code></pre><p><strong>KEYDOWN</strong>和<strong>KEYUP</strong>事件包含下面三个值：</p>
<ul>
<li>key-这是一个代表按下或松开的键值的数字。每一个键盘上的物理按钮都有一个以K_开头的常量。字母键为K_a到K_z，其它的如K_SPACE和K_RETURN。</li>
<li>mod-这个值代表和key组合使用的其它键，比如Shift，Alt和Ctrl。每一个组合键以KMOD_开头，比如KMOD_SHIFT，KMOD_ALT和KMOD_CTRL。如果mod &amp; KMOD_CTRL为真，则表示按下了Ctrl键。</li>
<li>unicode-这个是被按下的键的Unicode值。每一个符号都有一个Unicode值与它对应。</li>
</ul>
<h3 id="过滤事件">过滤事件</h3><p>一个游戏不是所有的事件都需要处理，而且通常存在其它方式获取某个事件可能提供的信息。比如，使用<strong>pygame.mouse.get_pos()</strong>就不需要响应<strong>MOUSEMOTION</strong>事件了。</p>
<p>使用<strong>pygame.event.set_blocked</strong>函数可以屏蔽事件，阻止事件进入事件队列。比如：</p>
<pre><code>pygame<span class="class">.event</span><span class="class">.set_blocked</span>(MOUSEMOTION)
pygame<span class="class">.event</span><span class="class">.set_blocked</span>([KEYDOWN, KEYUP])
pygame<span class="class">.event</span><span class="class">.set_blocked</span>(None)

<span class="function"><span class="title">set_blocked</span><span class="params">(...)</span></span>
    pygame<span class="class">.event</span><span class="class">.set_blocked</span>(type): return None
    pygame<span class="class">.event</span><span class="class">.set_blocked</span>(typelist): return None
    pygame<span class="class">.event</span><span class="class">.set_blocked</span>(None): return None
    control which events are allowed on the queue
</code></pre><p>与之相对的，<strong>pygame.event.set_allowed</strong>设定允许的事件。</p>
<pre><code><span class="function"><span class="title">set_allowed</span><span class="params">(...)</span></span>
    pygame<span class="class">.event</span><span class="class">.set_allowed</span>(type): return None
    pygame<span class="class">.event</span><span class="class">.set_allowed</span>(typelist): return None
    pygame<span class="class">.event</span><span class="class">.set_allowed</span>(None): return None
    control which events are allowed on the queue
</code></pre><p><strong>pygame.event.get_blocked</strong>可以查询一个事件是否被屏蔽。</p>
<pre><code><span class="function"><span class="title">get_blocked</span><span class="params">(...)</span></span>
    pygame<span class="class">.event</span><span class="class">.get_blocked</span>(type): return bool
    test <span class="keyword">if</span> <span class="tag">a</span> type of event is blocked from the queue
</code></pre><h3 id="产生事件">产生事件</h3><p>通常Pygame为你产生相应的事件，但是你也可以产生自己的事件。为了产生一个事件，必须首先使用<strong>pygame.event.Event</strong>创建一个事件对象，然后使用<strong>pygame.event.post</strong>发送到事件队列尾端。</p>
<pre><code>my_event = pygame.event.Event(KEYDOWN, key=K_SPACE, mod=<span class="number">0</span>, unicode=<span class="string">u' '</span>)
pgame.event.post(my_event)
</code></pre><p>事件构造函数接收事件类型和事件值参数。</p>
<pre><code><span class="function"><span class="title">Event</span><span class="params">(...)</span></span>
    pygame<span class="class">.event</span><span class="class">.Event</span>(type, dict): return Event
    pygame<span class="class">.event</span><span class="class">.Event</span>(type, **attributes): return Event
    create <span class="tag">a</span> new event <span class="tag">object</span>

<span class="function"><span class="title">post</span><span class="params">(...)</span></span>
    pygame<span class="class">.event</span><span class="class">.post</span>(Event): return None
    place <span class="tag">a</span> new event on the queue
</code></pre><p>除了模拟Pygame产生的事件，也可以创建新的事件。你只需使用一个大于<strong>USEREVENT</strong>的值作为事件的值。</p>
<pre><code>CATONKEYBOARD = USEREVENT + <span class="number">1</span>
my_event = pygame<span class="class">.event</span><span class="class">.Event</span>(CATONKEYBOARD, message=<span class="string">"Bad cat!"</span>)
pgame<span class="class">.event</span><span class="class">.post</span>(my_event)

<span class="keyword">for</span> event <span class="keyword">in</span> pygame<span class="class">.event</span><span class="class">.get</span>():
    <span class="keyword">if</span> event<span class="class">.type</span> == CATONKEYBOARD:
        print event.message
</code></pre><h1 id="打开一个显示">打开一个显示</h1><h3 id="全屏显示">全屏显示</h3><p><strong>pygame.display.set_mode</strong>第二个参数设置为<strong>FULLSCREEN</strong>，就能得到一个全屏窗口了。</p>
<pre><code>screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), FULLSCREEN, <span class="number">32</span>)
</code></pre><blockquote>
<p><strong>注意</strong><br>如果在全屏模式下出问题，有时候非常难回到桌面。因此进入全屏模式前，需要先在窗口模式下测试。同时提供一个退出程序方法，因为全屏模式下关闭按钮看不到。</p>
</blockquote>
<p>当进入全屏时，你的显卡可能会切换到不同的显示模式，这将改变显示的宽度，高度和一次显示颜色的数量。显卡只支持几种大小和颜色数量的组合。如果显示的大小不支持，Pygame将选择下一个大小，并居中显示。<strong>pygame.display.list_modes</strong>可以查看显卡支持的分辨率。</p>
<pre><code>&gt;&gt;&gt; import pygame
&gt;&gt;&gt; pygame.<span class="function"><span class="title">init</span><span class="params">()</span></span>
&gt;&gt;&gt; pygame<span class="class">.display</span><span class="class">.list_modes</span>()

<span class="function"><span class="title">list_modes</span><span class="params">(...)</span></span>
    pygame<span class="class">.display</span><span class="class">.list_modes</span>(depth=<span class="number">0</span>, flags=pygame.FULLSCREEN): return list
    get list of available fullscreen modes
</code></pre><p>如果显卡不支持你想要的颜色数量，Pygame将自动转换以适应当前显示设备。</p>
<pre><code>background_image_filename = <span class="string">'sushiplate.jpg'</span>

import pygame
<span class="keyword">from</span> pygame.locals import *
<span class="keyword">from</span> sys import <span class="keyword">exit</span>

pygame.init()
screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)
background = pygame.image.load(background_image_filename).convert()

Fullscreen = <span class="keyword">False</span>

<span class="keyword">while</span> <span class="keyword">True</span>:
    <span class="keyword">for</span> <span class="keyword">event</span> <span class="keyword">in</span> pygame.<span class="keyword">event</span>.get():
        <span class="keyword">if</span> <span class="keyword">event</span>.<span class="keyword">type</span> == QUIT:
            <span class="keyword">exit</span>()

    <span class="keyword">if</span> <span class="keyword">event</span>.<span class="keyword">type</span> == KEYDOWN:
        <span class="keyword">if</span> <span class="keyword">event</span>.key == K_f:
            Fullscreen = <span class="keyword">not</span> Fullscreen
            <span class="keyword">if</span> Fullscreen:
                screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), FULLSCREEN, <span class="number">32</span>)
            <span class="keyword">else</span>:
                screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

    screen.blit(background, (<span class="number">0</span>, <span class="number">0</span>))
    pygame.display.update()
</code></pre><h3 id="可变尺寸的Pygame窗口">可变尺寸的Pygame窗口</h3><p>有时候用户想要能够改变窗口大小，调用<strong>pygame.display.set_mode</strong>时使用<strong>RESIZABLE</strong>标志位，可以达到这个目的。Pygame通过发送包含新宽高的<strong>VIDEORESIZE</strong>事件告诉用户窗口大小改变了。当收到这个事件时，我们应该再次调用<strong>pygame.display.set_mode</strong>。</p>
<pre><code>background_image_filename = <span class="string">'sushiplate.jpg'</span>

import pygame
<span class="keyword">from</span> pygame.locals import *
<span class="keyword">from</span> sys import <span class="keyword">exit</span>

SCREEN_SIZE = (<span class="number">640</span>, <span class="number">480</span>)

pygame.init()
screen = pygame.display.set_mode(SCREEN_SIZE, RESIZABLE, <span class="number">32</span>)

background = pygame.image.load(background_image_filename).convert()

<span class="keyword">while</span> <span class="keyword">True</span>:
    <span class="keyword">event</span> = pygame.<span class="keyword">event</span>.wait()
    <span class="keyword">if</span> <span class="keyword">event</span>.<span class="keyword">type</span> == QUIT:
        <span class="keyword">exit</span>()
    <span class="keyword">if</span> <span class="keyword">event</span>.<span class="keyword">type</span> == VIDEORESIZE:
        SCREEN_SIZE = <span class="keyword">event</span>.size
        screen = pygame.display.set_mode(SCREEN_SIZE, RESIZABLE, <span class="number">32</span>)
        pygame.display.set_caption(<span class="string">'Window resized to '</span> + str(<span class="keyword">event</span>.size))

    screen_width, screen_height = SCREEN_SIZE
    <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">0</span>, screen_height, background.get_height()):
        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, screen_width, background.get_width()):
            screen.blit(background, (x, y))

    pygame.display.update()
</code></pre><p><strong>VIDEORESIZE</strong>事件包含下面的值：</p>
<ul>
<li>size-一个元组，包含更改后窗口的尺寸。size[0]代表宽度，size[1]代表高度。</li>
<li>w-宽度，和size[0]一样，但是更方便</li>
<li>h-高度，和size[1]一样，但是更方便</li>
</ul>
<h3 id="无边框窗口">无边框窗口</h3><p>当调用<strong>set_mode</strong>时使用<strong>NOFRAME</strong>标志可以设置一个无边框窗口。</p>
<h3 id="其它显示标志">其它显示标志</h3><p>通常最好是使用0显示窗口而使用<strong>FULLSCREEN</strong>全屏以保证程序在所有平台都能运行。其它高级标志也许会有兼容问题。<br>如果设置了<strong>HWSURFACE</strong>标志，将创建一个硬件显示，存储在显存里面，只能和<strong>FULLSCREEN</strong>一起使用。</p>
<pre><code>screen = pygame.display.set_mode(SCREEN_SIZE, HWSURFACE <span class="string">| FULLSCREEN, 32)</span>
</code></pre><p>硬件显示比常规显示更快，因为它能够利用显卡的特性加速显示，缺点是兼容性不够好。硬件显示也能从<strong>DOUBLEBUF</strong>标志受益。这个有效地创建2个硬件显示，但是一次只能看见一个。</p>
<pre><code>screen = pygame.display.set_mode(SCREEN_SIZE, DOUBLEBUF |<span class="string"> HWSURFACE </span>|<span class="string"> FULLSCREEN, 32)</span>
</code></pre><p>通常当你调用<strong>pygame.display.update()</strong>时，整个屏幕从内存拷贝到显示设备，这会花费一些时间。而双缓冲允许你立刻切换到新的屏幕，使你的程序运行更快。</p>
<blockquote>
<p><strong>注意</strong><br>如果使用双缓冲显示，应该调用<strong>pygame.display.flip()</strong>而不是<strong>pygame.display.update()</strong>。这个做立即显示切换而不是拷贝屏幕数据。</p>
</blockquote>
<pre><code><span class="function"><span class="title">flip</span><span class="params">(...)</span></span>
    pygame<span class="class">.display</span><span class="class">.flip</span>(): return None
    update the full <span class="attribute">display</span> Surface to the screen
</code></pre><p>最后一个显示标志是<strong>OPENGL</strong>，它能够使用3D加速显示。</p>
<h1 id="使用字体模块">使用字体模块</h1><p>字体模块使用TrueType字体(TTFs)。必须先创建一个Font对象才能使用字体。最简单的方式就是使用<strong>pygame.font.SysFont</strong>，它会使用系统自带的一个字体。</p>
<pre><code>my_font = pygame<span class="class">.font</span><span class="class">.SysFont</span>(<span class="string">"arial"</span>, <span class="number">16</span>)
</code></pre><p>第一个参数是你想要创建字体的名字，第二个参数指定了字体的大小。Pygame会在系统字体里面查找，如果没找到则返回一个默认字体。<strong>pygame.font.get_fonts()</strong>可以获得当前系统所有可用字体。也可以使用<strong>pygame.font.Font</strong>直接从.ttf文件创建字体。</p>
<pre><code>my_font = pygame.font.Font(<span class="string">"my_font.ttf"</span>, <span class="number">16</span>)

class Font(__builtin__.object)
 |  pygame.font.Font(filename, size): <span class="constant">return</span> Font
 |  pygame.font.Font(object, size): <span class="constant">return</span> Font
 |  <span class="built_in">create</span> <span class="operator">a</span> <span class="built_in">new</span> Font object <span class="built_in">from</span> <span class="operator">a</span> <span class="built_in">file</span>

get_fonts()
    pygame.font.get_fonts() -&gt; list
    <span class="built_in">get</span> <span class="operator">a</span> list <span class="operator">of</span> <span class="keyword">system</span> font names

    Returns <span class="operator">the</span> list <span class="operator">of</span> all found <span class="keyword">system</span> fonts. Note that
    <span class="operator">the</span> names <span class="operator">of</span> <span class="operator">the</span> fonts will be all lowercase <span class="operator">with</span> spaces
    removed. This is how pygame internally stores <span class="operator">the</span> font
    names <span class="keyword">for</span> matching.
</code></pre><p>一旦创建了Font对象，就可以使用Font对象的<strong>render</strong>函数来渲染文字。它创建一个新的包含文字的Surface，可以输出到显示设备。</p>
<pre><code>text_surface = my_font.<span class="function"><span class="title">render</span><span class="params">(<span class="string">"Pygame is cool!"</span>, True, (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))

<span class="function"><span class="title">render</span><span class="params">(...)</span></span>
    Font.<span class="function"><span class="title">render</span><span class="params">(text, antialias, color, background=None)</span></span>: return Surface
    draw text on <span class="tag">a</span> new Surface
</code></pre><p><strong>render</strong>的第一个参数是你想渲染的文字，它必须是一行。如果有多行，必须使用多个<strong>render</strong>调用。第二个参数是一个布尔值，用来开启抗锯齿。如果设置为True，则文字看起来会比较平滑。后面两个参数是文字的颜色和背景颜色。背景色是可选的，默认为透明的。</p>
<pre><code>import pygame
pygame.<span class="function"><span class="title">init</span><span class="params">()</span></span>

my_name = <span class="string">'Smith'</span>
my_font = pygame<span class="class">.font</span><span class="class">.SysFont</span>(<span class="string">'arial'</span>, <span class="number">64</span>)
name_surface = my_font.<span class="function"><span class="title">render</span><span class="params">(my_name, True, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))
pygame<span class="class">.image</span><span class="class">.save</span>(name_surface, <span class="string">'name.png'</span>)
</code></pre><p>font模块详尽参考见<a href="http://www.pygame.org/docs/ref/font.html" target="_blank" rel="external">http://www.pygame.org/docs/ref/font.html</a></p>
<blockquote>
<p><strong>注意</strong><br>安装的字体因机各异，不能保证某个字体一定存在。解决方法是.ttf文件同游戏一起发布，但必须得到字体作者的许可。</p>
</blockquote>
<h1 id="当Pygame出错">当Pygame出错</h1><p>当<strong>pygame.image.load</strong>不能读取图片时，Pygame会抛出<strong>pygame.error</strong>异常。</p>
<pre><code>&gt;&gt;&gt; import pygame
&gt;&gt;&gt; screen = pygame.<span class="keyword">display</span>.set_mode((640, 0))
Traceback (most recent call last):
<span class="keyword">File</span> <span class="string">"&lt;interactive input&gt;"</span>, <span class="keyword">line</span> 1, <span class="keyword">in</span> ?
pygame.<span class="keyword">error</span>: Cannot <span class="keyword">set</span> 0 sized <span class="keyword">display</span> mode

<span class="keyword">class</span> <span class="keyword">error</span>(exceptions.RuntimeError)
 |  Method resolution <span class="keyword">order</span>:
 |      <span class="keyword">error</span>
 |      exceptions.RuntimeError
 |      exceptions.StandardError
 |      exceptions.Exception
 |      exceptions.BaseException
 |      __builtin__.object
</code></pre><p>一般而言，当你碰到<strong>pygame.error</strong>异常时，你也做不了什么事，因为这说明一个比较大的故障发生了。通常你能做的就是指导用户怎么做。在一个大的项目里面，检查错误很重要。</p>
<pre><code>try:
    screen = pygame<span class="class">.display</span><span class="class">.set_mode</span>(SCREEN_SIZE)
except pygame<span class="class">.error</span>, e:
    print <span class="string">"Can't create the display :-("</span>
    print e
    <span class="function"><span class="title">exit</span><span class="params">()</span></span>
</code></pre><h1 id="Pygame动起来">Pygame动起来</h1><pre><code>background_image_filename = <span class="comment">'sushiplate.jpg'</span>
SCREEN_SIZE = (<span class="number">640</span>, <span class="number">480</span>)
message = <span class="comment">'    This is a demonstration of the scrolly message script.    '</span>

import pygame
<span class="keyword">from</span> pygame.locals import *
<span class="keyword">from</span> sys import <span class="keyword">exit</span>

pygame.init()
screen = pygame.display.set_mode(SCREEN_SIZE)

font = pygame.font.SysFont(<span class="comment">'arial', 80)</span>
text_surface = font.render(message, <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>))

x = <span class="number">0</span>
y = (SCREEN_SIZE[<span class="number">1</span>] - text_surface.get_height()) / <span class="number">2</span>

background = pygame.image.load(background_image_filename).convert()

<span class="keyword">while</span> <span class="literal">True</span>:
    <span class="keyword">for</span> <span class="keyword">event</span> <span class="keyword">in</span> pygame.<span class="keyword">event</span>.<span class="keyword">get</span>():
        <span class="keyword">if</span> <span class="keyword">event</span>.type == QUIT:
            <span class="keyword">exit</span>()

    screen.blit(background, (<span class="number">0</span>, <span class="number">0</span>))

    x -= <span class="number">2</span>
    <span class="keyword">if</span> x &lt; -text_surface.get_width():
        x = <span class="number">0</span>

    screen.blit(text_surface, (x, y))
    screen.blit(text_surface, (x + text_surface.get_width(), y))

    pygame.display.update()
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="安装Pygame">安装Pygame</h1><p>Ubuntu下安装Pygame:</p>
<pre><code>sudo apt-<span class="built_in">get</span> install <span class="keyword">p]]>
    </summary>
    
      <category term="Pygame" scheme="https://opensvn.github.io/tags/Pygame/"/>
    
      <category term="Python" scheme="https://opensvn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PyQt编程第八章 数据处理和自定义文件类型]]></title>
    <link href="https://opensvn.github.io/2015/10/30/pyqt-8/"/>
    <id>https://opensvn.github.io/2015/10/30/pyqt-8/</id>
    <published>2015-10-30T04:40:00.000Z</published>
    <updated>2015-10-30T05:11:35.842Z</updated>
    <content type="html"><![CDATA[<h1 id="主窗口的职责">主窗口的职责</h1><p>主窗口的职责通常是为用户提供高级文件处理动作和展示程序数据。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="主窗口的职责">主窗口的职责</h1><p>主窗口的职责通常是为用户提供高级文件处理动作和展示程序数据。</p>
]]>
    </summary>
    
      <category term="PyQt" scheme="https://opensvn.github.io/tags/PyQt/"/>
    
      <category term="Python" scheme="https://opensvn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PyQt编程第七章 使用Qt Designer]]></title>
    <link href="https://opensvn.github.io/2015/10/28/pyqt-7/"/>
    <id>https://opensvn.github.io/2015/10/28/pyqt-7/</id>
    <published>2015-10-28T00:50:57.000Z</published>
    <updated>2015-10-30T00:20:27.590Z</updated>
    <content type="html"><![CDATA[<p>用户界面保存在.ui文件中，包含一个窗口部件和布局的详细情况。<strong>Qt Designer</strong>能够关联标签和它的伙伴，<br>设置tab顺序(这个也可以用<code>QWidget.setTabOrder()</code>完成)。<strong>Qt Designer</strong>也能够关联信号和槽，<br>但是只能是内置的信号和槽。</p>
<p>一旦用户界面设计完成并保存在.ui文件，必须转化为代码才能使用。这个可以用<code>pyuic4</code>完成，比如：</p>
<pre><code>$ pyuic4 -o ui_findandreplacedlg<span class="class">.py</span> findandreplacedlg.ui
</code></pre><h1 id="设计用户界面">设计用户界面</h1><p>使用<strong>Qt Designer</strong>通用步骤：</p>
<ol>
<li>拖动一个部件到窗体合适的位置，通常只有容器部件需要改变大小。</li>
<li>设置部件的属性。如果部件会在代码里面用到，设置一个有意义的名字。</li>
<li>重复1和2直到所有部件都在窗体上。</li>
<li>如果存在大的间隙，添加间隔器。</li>
<li>选择2个或多个部件进行布局(Shift+Click)，使用一个布局管理器布局。</li>
<li>重复5直到所有部件已经布局完毕。</li>
<li>点击窗体(不选择任何部件)，使用一个布局管理器布局窗体。</li>
<li>创建标签的伙伴。</li>
<li>设置窗体的tab顺序，如果顺序错误。</li>
<li>创建合适的内置信号和槽的关联。</li>
<li>预览窗体，检查所有东西都按照自己的意图工作。</li>
<li>设置窗体的对象名字和标题并保存。</li>
</ol>
<p>尽管可以先将布局拖进窗体，然后再添加部件到布局，但是最好是先将部件添加到窗体，然后再进行布局。</p>
<p><code>addStretch()</code>和插入<code>QSpacerItem</code>一样。</p>
<p>预览窗口点击Form-&gt;Preview或者Ctrl+R。如果想预览不同风格，点击Form-&gt;Preview in</p>
<h1 id="实现对话框">实现对话框</h1><p>当使用<strong>Qt Designer</strong>创建一个用户界面时，我们使用多继承创建一个子类。第一个父类是<code>QDialog</code>，<br>第二个父类是用<strong>Qt Designer</strong>设计的界面。</p>
<pre><code><span class="import"><span class="keyword">import</span> re</span>
<span class="title">from</span> <span class="type">PyQt4</span>.<span class="type">QtCore</span> <span class="import"><span class="keyword">import</span> *</span>
<span class="title">from</span> <span class="type">PyQt4</span>.<span class="type">QtGui</span> <span class="import"><span class="keyword">import</span> *</span>
<span class="import"><span class="keyword">import</span> ui_findandreplacedlg</span>
<span class="class">
<span class="keyword">class</span> <span class="type">FindAndReplaceDlg</span><span class="container">(<span class="type">QDialog</span>,
    <span class="title">ui_findandreplacedlg</span>.<span class="type">Ui_FindAndReplaceDlg</span>)</span>:
    def __init__<span class="container">(<span class="title">self</span>, <span class="title">text</span>, <span class="title">parent</span>=<span class="type">None</span>)</span>:
        super<span class="container">(<span class="type">FindAndReplaceDlg</span>, <span class="title">self</span>)</span>.__init__<span class="container">(<span class="title">parent</span>)</span>
        self.__text = unicode<span class="container">(<span class="title">text</span>)</span>
        self.__index = 0
        self.setupUi<span class="container">(<span class="title">self</span>)</span>
        if not <span class="type">MAC</span>:
            self.findButton.setFocusPolicy<span class="container">(<span class="type">Qt</span>.<span class="type">NoFocus</span>)</span>
            self.replaceButton.setFocusPolicy<span class="container">(<span class="type">Qt</span>.<span class="type">NoFocus</span>)</span>
            self.replaceAllButton.setFocusPolicy<span class="container">(<span class="type">Qt</span>.<span class="type">NoFocus</span>)</span>
            self.closeButton.setFocusPolicy<span class="container">(<span class="type">Qt</span>.<span class="type">NoFocus</span>)</span>
        self.updateUi<span class="container">()</span></span>
</code></pre><p><code>setupUi()</code>方法由生成的ui模块提供，调用这个方法创建用户界面。<br><code>setupUi()</code>方法调用<code>QtCore.QMetaObject.connectSlotsByName()</code>创建信号和槽之间的联系。<br>任何具有形式<code>on_widgetName_signalName</code>的槽都有一个信号连接到它。</p>
<pre><code><span class="decorator">@pyqtSignature('QString')</span>
<span class="function"><span class="keyword">def</span> <span class="title">on_findLineText_textEdited</span><span class="params">(self, text)</span>:</span>
    self.__index = <span class="number">0</span>
    self.updateUi()
</code></pre><p>多亏<code>setupUi()</code>，这个方法自动连接到findLineEdit的<code>textEdited()</code>信号。当需要自动连接到指定<br>信号，使用<code>@pyqtSignature</code>装饰指定信号参数。装饰的作用是区分同名但参数不同的信号。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">updateUi</span><span class="params">(self)</span>:</span>
    enable = <span class="keyword">not</span> self.findLineEdit.text().isEmpty()
    self.findButton.setEnabled(enable)
    self.replaceButton.setEnabled(enable)
    self.replaceAllButton.setEnabled(enable)

<span class="function"><span class="keyword">def</span> <span class="title">text</span><span class="params">(self)</span>:</span>
    <span class="keyword">return</span> self.__text

<span class="decorator">@pyqtSignature('')</span>
<span class="function"><span class="keyword">def</span> <span class="title">on_findButton_clicked</span><span class="params">(self)</span>:</span>
    regex = self.makeRegex()
    match = regex.search(self.__text, self.__index)
    <span class="keyword">if</span> match <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:
        self.__index = match.end()
        self.emit(SIGNAL(<span class="string">'found'</span>), match.start())
    <span class="keyword">else</span>:
        self.emit(SIGNAL(<span class="string">'notfound'</span>))

<span class="function"><span class="keyword">def</span> <span class="title">makeRegex</span><span class="params">(self)</span>:</span>
    findText = unicode(self.findLineEdit.text())
    <span class="keyword">if</span> unicode(self.syntaxComboBox.currentText()) == <span class="string">'Literal'</span>:
        findText = re.escape(findText)
    flags = re.MULTILINE|re.DOTALL|re.UNICODE
    <span class="keyword">if</span> <span class="keyword">not</span> self.caseCheckBox.isChecked():
        flags |= re.IGNORECASE
    <span class="keyword">if</span> self.wholeCheckBox.isChecked():
        findText = <span class="string">r'\b%s\b'</span> % findText
    <span class="keyword">return</span> re.compile(findText, flags)
</code></pre><p>如果被搜索的文本是<code>QString</code>而不是<code>unicode</code>，则选择<code>QRegExp</code>更好。</p>
<pre><code><span class="decorator">@pyqtSignature('')</span>
<span class="function"><span class="keyword">def</span> <span class="title">on_replaceButton_clicked</span><span class="params">(self)</span>:</span>
    regex = self.makeRegex()
    self.__text = regex.sub(unicode(self.replaceLineEdit.text()),
        self.__text, <span class="number">1</span>)

<span class="decorator">@pyqtSignature('')</span>
<span class="function"><span class="keyword">def</span> <span class="title">on_replaceAllButton_clicked</span><span class="params">(self)</span>:</span>
    regex = self.makeRegex()
    self.__text = regex.sub(unicode(self.replaceLineEdit.text()),
        self.__text)
</code></pre><h1 id="测试对话框">测试对话框</h1><pre><code><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>
    <span class="keyword">import</span> sys

    text = <span class="string">"""US experience shows that, unlike traditional patents,
software patents do not encourage innovation and R&amp;D, quite the
contrary. In particular they hurt small and medium-sized enterprises
and generally newcomers in the market. They will just weaken the market
and increase spending on patents and litigation, at the expense of
technological innovation and research. Especially dangerous are
attempts to abuse the patent system by preventing interoperability as a
means of avoiding competition with technological ability.
--- Extract quoted from Linus Torvalds and Alan Cox's letter
to the President of the European Parliament
http://www.effi.org/patentit/patents_torvalds_cox.html"""</span>

    <span class="function"><span class="keyword">def</span> <span class="title">found</span><span class="params">(where)</span>:</span>
        <span class="keyword">print</span> <span class="string">'Found at %d'</span> % where

    <span class="function"><span class="keyword">def</span> <span class="title">nomore</span><span class="params">()</span>:</span>
        <span class="keyword">print</span> <span class="string">'No more found'</span>

    app = QApplication(sys.argv)
    form = FindAndReplaceDlg(text)
    form.connect(form, SIGNAL(<span class="string">'found'</span>), found)
    form.connect(form, SIGNAL(<span class="string">'notfound'</span>), nomore)
    form.show()
    app.exec_()
    <span class="keyword">print</span> form.text()
</code></pre><h1 id="总结">总结</h1><p>使用<strong>Qt Designer</strong>和手工创建界面最大的不同是在初始化的时候，我们简单地调用<code>setupUi()</code>创建界面，<br>布局，信号和槽的关联。槽的命名惯例是<code>on_widgetName_signalName</code>，连同<code>@pyqtSignature</code>装饰<br>就可以利用<code>setupUi()</code>自动关联信号和槽。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>用户界面保存在.ui文件中，包含一个窗口部件和布局的详细情况。<strong>Qt Designer</strong>能够关联标签和它的伙伴，<br>设置tab顺序(这个也可以用<code>QWidget.setTabOrder()</code>完成)。<strong>Qt]]>
    </summary>
    
      <category term="PyQt" scheme="https://opensvn.github.io/tags/PyQt/"/>
    
      <category term="Python" scheme="https://opensvn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Project Euler Problem 1]]></title>
    <link href="https://opensvn.github.io/2015/10/23/project-euler-1/"/>
    <id>https://opensvn.github.io/2015/10/23/project-euler-1/</id>
    <published>2015-10-23T08:30:00.000Z</published>
    <updated>2015-10-23T09:14:57.827Z</updated>
    <content type="html"><![CDATA[<h1 id="Multiples_of_3_and_5">Multiples of 3 and 5</h1><p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.</p>
<p>Find the sum of all the multiples of 3 or 5 below 1000.</p>
<pre><code>sum = <span class="number">3</span> * (<span class="number">1</span> + <span class="number">999</span> / <span class="number">3</span>) * (<span class="number">999</span> / <span class="number">3</span>) / <span class="number">2</span> + \
      <span class="number">5</span> * (<span class="number">1</span> + <span class="number">999</span> / <span class="number">5</span>) * (<span class="number">999</span> / <span class="number">5</span>) / <span class="number">2</span> - \
      <span class="number">15</span> * (<span class="number">1</span> + <span class="number">999</span> / <span class="number">15</span>) * (<span class="number">999</span> / <span class="number">15</span>) / <span class="number">2</span>
print sum
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Multiples_of_3_and_5">Multiples of 3 and 5</h1><p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3]]>
    </summary>
    
      <category term="Project Euler" scheme="https://opensvn.github.io/tags/Project-Euler/"/>
    
      <category term="Python" scheme="https://opensvn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PyQt编程第六章 主窗口]]></title>
    <link href="https://opensvn.github.io/2015/10/21/pyqt-6/"/>
    <id>https://opensvn.github.io/2015/10/21/pyqt-6/</id>
    <published>2015-10-21T03:25:57.000Z</published>
    <updated>2015-10-27T11:12:35.816Z</updated>
    <content type="html"><![CDATA[<h1 id="创建一个主窗口">创建一个主窗口</h1><pre><code><span class="preprocessor"><span class="keyword">import</span> os</span>
<span class="preprocessor"><span class="keyword">import</span> platform</span>
<span class="preprocessor"><span class="keyword">import</span> sys</span>
from PyQt4.QtCore <span class="preprocessor"><span class="keyword">import</span> *</span>
from PyQt4.QtGui <span class="preprocessor"><span class="keyword">import</span> *</span>
<span class="preprocessor"><span class="keyword">import</span> helpform</span>
<span class="preprocessor"><span class="keyword">import</span> newimagedlg</span>
<span class="preprocessor"><span class="keyword">import</span> qrc_resources</span>
__version__ = <span class="string">"1.0.0"</span>
</code></pre><p><code>import</code>的顺序：先Python标准模块，然后第三方模块(比如PyQt)，最后自己定义的模块。<br>一个程序通常有一个版本字符串，按照惯例称为<code>__version__</code>。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span><span class="params">(QMainWindow)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent=None)</span>:</span>
        super(MainWindow, self).__init__(parent)
        self.image = QImage()
        self.dirty = <span class="keyword">False</span>
        self.filename = <span class="keyword">None</span>
        self.mirroredvertically = <span class="keyword">False</span>
        self.mirroredhorizontally = <span class="keyword">False</span>
</code></pre><p><code>QImage</code>并不是继承自<code>QObject</code>，不需要<code>parent</code>。</p>
<pre><code>self<span class="class">.imageLabel</span> = <span class="function"><span class="title">QLabel</span><span class="params">()</span></span>
self<span class="class">.imageLabel</span><span class="class">.setMinimumSize</span>(<span class="number">200</span>, <span class="number">200</span>)
self<span class="class">.imageLabel</span><span class="class">.setAlignment</span>(Qt.AlignCenter)
self<span class="class">.imageLabel</span><span class="class">.setContextMenuPolicy</span>(Qt.ActionsContextMenu)
self.<span class="function"><span class="title">setCentralWidget</span><span class="params">(self.imageLabel)</span></span>
</code></pre><p>PyQt提供许多种方式创建右键菜单，我们使用最简单和最常见的方式。首先必须设置部件的右键菜单策略，然后<br>给部件添加一些操作。</p>
<p>和对话框不一样，在一个主窗口风格的程序中，只有一个中心部件，尽管它可以是组合而成的。我么只需要调用<br><code>setCentralWidget</code>就好了。</p>
<p>在PyQt中，悬浮窗口是<code>QDockWidget</code>类的实例。我们可以添加一个部件到悬浮部件。</p>
<pre><code><span class="keyword">log</span>DockWidget = QDockWidget(<span class="string">"Log"</span>, <span class="literal">self</span>)
<span class="keyword">log</span>DockWidget.<span class="built_in">set</span>ObjectName(<span class="string">"LogDockWidget"</span>)
<span class="keyword">log</span>DockWidget.<span class="built_in">set</span>AllowedAreas(Qt.LeftDockWidgetArea|
                              Qt.RightDockWidgetArea)
<span class="literal">self</span>.listWidget = QListWidget()
<span class="keyword">log</span>DockWidget.<span class="built_in">set</span>Widget(<span class="literal">self</span>.listWidget)
<span class="literal">self</span>.addDockWidget(Qt.RightDockWidgetArea, <span class="keyword">log</span>DockWidget)
</code></pre><p>悬浮部件不会被加入布局，所以当创建它们时，需要指定<code>parent</code>。</p>
<p>每一个PyQt对象都可以指定一个对象名字。PyQt使用对象名字区分悬浮部件。<br><code>setFeatures</code>方法控制悬浮部件能否移动，悬浮或关闭。</p>
<p><code>QPrinter</code>对象管理打印机操作。</p>
<pre><code><span class="literal">self</span>.sizeLabel = QLabel()
<span class="literal">self</span>.sizeLabel.<span class="built_in">set</span>FrameStyle(QFrame.StyledPanel|QFrame.Sunken)
status = <span class="literal">self</span>.statusBar()
status.<span class="built_in">set</span>SizeGripEnabled(False)
status.addPermanentWidget(<span class="literal">self</span>.sizeLabel)
status.showMessage(<span class="string">"Ready"</span>, <span class="number">5000</span>)
</code></pre><p>状态栏由<code>QMainWindow</code>第一次调用<code>statusBar</code>创建。<code>showMessage</code>在状态栏显示信息直到另一个<br><code>showMessage</code>被调用或<code>clearMessage</code>被调用。</p>
<h1 id="动作和键序列">动作和键序列</h1><p>PyQt用<code>QAction</code>封装用户动作。</p>
<pre><code>fileNewAction = <span class="function"><span class="title">QAction</span><span class="params">(QIcon(<span class="string">"images/filenew.png"</span>)</span></span>, <span class="string">"&amp;New"</span>, self)
fileNewAction.<span class="function"><span class="title">setShortcut</span><span class="params">(QKeySequence.New)</span></span>
helpText = <span class="string">"Create a new image"</span>
fileNewAction.<span class="function"><span class="title">setToolTip</span><span class="params">(helpText)</span></span>
fileNewAction.<span class="function"><span class="title">setStatusTip</span><span class="params">(helpText)</span></span>
self.<span class="function"><span class="title">connect</span><span class="params">(fileNewAction, SIGNAL(<span class="string">"triggered()"</span>)</span></span>, self.fileNew)
</code></pre><p>许多键序列都标准化了，有些甚至跨平台。比如<code>Ctrl+N</code>对应新建，<code>Ctrl+S</code>对应保存。<br><code>QKeySequence</code>提供标准化的键序列常量，如<code>QKeySequence.New</code>，<code>QKeySequence.Paste</code><br>对于还未标准化的键序列(或向后兼容的原因)，可以用字符串作为快捷键，setShortcut(“Ctrl+Q”)。</p>
<p>注意我们给<code>QAction</code>一个self作为父亲。每一个<code>QObject</code>子类(除了顶级窗口)都有一个父亲。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>a.data()</td>
<td style="text-align:left">返回QAction a的数据，作为QVariant</td>
</tr>
<tr>
<td>a.setData(v)</td>
<td style="text-align:left">设置QAction a的数据为QVariant v</td>
</tr>
<tr>
<td>a.isChecked()</td>
<td style="text-align:left">返回True如果QAction a被确认过</td>
</tr>
<tr>
<td>a.setChecked(b)</td>
<td style="text-align:left">选与不选QAction a取决于bool b</td>
</tr>
<tr>
<td>a.isEnabled()</td>
<td style="text-align:left">返回True如果QAction a生效</td>
</tr>
<tr>
<td>a.setEnabled(b)</td>
<td style="text-align:left">生效或失效QAction a取决于bool b</td>
</tr>
<tr>
<td>a.setSeparator(b)</td>
<td style="text-align:left">设置QAction a为正常动作或分隔符取决于bool b</td>
</tr>
<tr>
<td>a.setShortcut(k)</td>
<td style="text-align:left">设置QAction a的快捷键为QKeySequence k</td>
</tr>
<tr>
<td>a.setStatusTip(s)</td>
<td style="text-align:left">设置QAction a的状态提示为string s</td>
</tr>
<tr>
<td>a.setText(s)</td>
<td style="text-align:left">设置QAction a的文本为string s</td>
</tr>
<tr>
<td>a.setToolTip(s)</td>
<td style="text-align:left">设置QAction a的工具提示为string s</td>
</tr>
<tr>
<td>a.setWhatsThis(s)</td>
<td style="text-align:left">设置QAction a的What’s This?文本为string s</td>
</tr>
<tr>
<td>a.toggled(b)</td>
<td style="text-align:left">这个信号被发射当QAction a的选中状态改变；bool b为True如果动作被选中</td>
</tr>
<tr>
<td>a.triggered(b)</td>
<td style="text-align:left">这个信号被发射QAction a被调用；bool b为True如果a被选中</td>
</tr>
</tbody>
</table>
<p>一旦创建了动作，我们就能把它添加到菜单或工具栏。</p>
<pre><code>fileMenu.<span class="function"><span class="title">addAction</span><span class="params">(fileNewAction)</span></span>
fileToolbar.<span class="function"><span class="title">addAction</span><span class="params">(fileNewAction)</span></span>
</code></pre><h1 id="资源文件">资源文件</h1><p>创建一个资源模块需要做两件事情。第一创建一个<code>.qrc</code>的文件，包含程序详细的资源。然后运行<code>pyrcc4</code><br>读取<code>.qrc</code>文件生成资源模块。<code>.qrc</code>是一个XML格式的文件。</p>
<pre><code><span class="doctype">&lt;!DOCTYPE RCC&gt;</span><span class="tag">&lt;<span class="title">RCC</span> <span class="attribute">version</span>=<span class="value">"1.0"</span>&gt;</span>
<span class="tag">&lt;<span class="title">qresource</span>&gt;</span>
<span class="tag">&lt;<span class="title">file</span> <span class="attribute">alias</span>=<span class="value">"filenew.png"</span>&gt;</span>images/filenew.png<span class="tag">&lt;/<span class="title">file</span>&gt;</span>
<span class="tag">&lt;<span class="title">file</span> <span class="attribute">alias</span>=<span class="value">"fileopen.png"</span>&gt;</span>images/fileopen.png<span class="tag">&lt;/<span class="title">file</span>&gt;</span>
···
<span class="tag">&lt;<span class="title">file</span> <span class="attribute">alias</span>=<span class="value">"icon.png"</span>&gt;</span>images/icon.png<span class="tag">&lt;/<span class="title">file</span>&gt;</span>
<span class="tag">&lt;<span class="title">file</span>&gt;</span>help/editmenu.html<span class="tag">&lt;/<span class="title">file</span>&gt;</span>
<span class="tag">&lt;<span class="title">file</span>&gt;</span>help/filemenu.html<span class="tag">&lt;/<span class="title">file</span>&gt;</span>
<span class="tag">&lt;<span class="title">file</span>&gt;</span>help/index.html<span class="tag">&lt;/<span class="title">file</span>&gt;</span>
<span class="tag">&lt;/<span class="title">qresource</span>&gt;</span>
<span class="tag">&lt;/<span class="title">RCC</span>&gt;</span>
</code></pre><p>现在使用一个新建文件的图片，我们可以写成<code>QIcon(&quot;:/images/filenew.png&quot;)</code>，多亏了别名，<br>也可以缩写为<code>QIcon(&quot;:/filenew.png&quot;)</code>。前面的:/告诉PyQt文件是一个资源。在使用资源之前，<br>必须生成资源模块并导入进程序。</p>
<pre><code>C:\pyqt\chap06&gt;pyrcc4 -o qrc_resources<span class="class">.py</span> resources.qrc
</code></pre><h1 id="创建和使用动作">创建和使用动作</h1><p>一个辅助创建动作的函数：</p>
<pre><code>def createAction(self, text, slot=None, shortcut=None, <span class="attribute">icon</span>=None,
                 tip=None, checkable=False, signal=<span class="string">"triggered()"</span>):
    action = <span class="function"><span class="title">QAction</span><span class="params">(text, self)</span></span>
    <span class="keyword">if</span> <span class="attribute">icon</span> is not None:
        action.<span class="function"><span class="title">setIcon</span><span class="params">(QIcon(<span class="string">":/%s.png"</span> % icon)</span></span>)
    <span class="keyword">if</span> shortcut is not None:
        action.<span class="function"><span class="title">setShortcut</span><span class="params">(shortcut)</span></span>
    <span class="keyword">if</span> tip is not None:
        action.<span class="function"><span class="title">setToolTip</span><span class="params">(tip)</span></span>
        action.<span class="function"><span class="title">setStatusTip</span><span class="params">(tip)</span></span>
    <span class="keyword">if</span> slot is not None:
        self.<span class="function"><span class="title">connect</span><span class="params">(action, SIGNAL(signal)</span></span>, slot)
    <span class="keyword">if</span> checkable:
        action.<span class="function"><span class="title">setCheckable</span><span class="params">(True)</span></span>
    return action
fileNewAction = self.createAction(<span class="string">"&amp;New..."</span>, self<span class="class">.fileNew</span>,
        QKeySequence<span class="class">.New</span>, <span class="string">"filenew"</span>, <span class="string">"Create an image file"</span>)
fileQuitAction = self.createAction(<span class="string">"&amp;Quit"</span>, self<span class="class">.close</span>,
        <span class="string">"Ctrl+Q"</span>, <span class="string">"filequit"</span>, <span class="string">"Close the application"</span>)
editZoomAction = self.createAction(<span class="string">"&amp;Zoom..."</span>, self<span class="class">.editZoom</span>,
        <span class="string">"Alt+Z"</span>, <span class="string">"editzoom"</span>, <span class="string">"Zoom the image"</span>)
editInvertAction = self.createAction(<span class="string">"&amp;Invert"</span>,
        self<span class="class">.editInvert</span>, <span class="string">"Ctrl+I"</span>, <span class="string">"editinvert"</span>,
        <span class="string">"Invert the image's colors"</span>, True, <span class="string">"toggled(bool)"</span>)
</code></pre><p><code>toggled(bool)</code>信号不仅告诉我们动作被调用，而且返回动作是否被选中。</p>
<p>一个动作组管理一组动作使得任何时候只有一个动作被选中。</p>
<pre><code>mirrorGroup = <span class="function"><span class="title">QActionGroup</span><span class="params">(self)</span></span>
editUnMirrorAction = self.createAction(<span class="string">"&amp;Unmirror"</span>,
        self<span class="class">.editUnMirror</span>, <span class="string">"Ctrl+U"</span>, <span class="string">"editunmirror"</span>,
        <span class="string">"Unmirror the image"</span>, True, <span class="string">"toggled(bool)"</span>)
mirrorGroup.<span class="function"><span class="title">addAction</span><span class="params">(editUnMirrorAction)</span></span>
editUnMirrorAction.<span class="function"><span class="title">setChecked</span><span class="params">(True)</span></span>
</code></pre><p>可选中的动作默认是未选中状态，所以在动作组中初始时必须选择一个为选中状态。</p>
<p>虽然所有动作已经创建好，但是它们还不能工作。只有当动作加进菜单或工具栏才能起作用。</p>
<pre><code>editMenu = self.<span class="function"><span class="title">menuBar</span><span class="params">()</span></span>.<span class="function"><span class="title">addMenu</span><span class="params">(<span class="string">"&amp;Edit"</span>)</span></span>
self.addActions(editMenu, (editInvertAction,
        editSwapRedAndBlueAction, editZoomAction))
def <span class="function"><span class="title">addActions</span><span class="params">(self, target, actions)</span></span>:
    <span class="keyword">for</span> action <span class="keyword">in</span> actions:
        <span class="keyword">if</span> action is None:
            target.<span class="function"><span class="title">addSeparator</span><span class="params">()</span></span>
        <span class="keyword">else</span>:
            target.<span class="function"><span class="title">addAction</span><span class="params">(action)</span></span>
</code></pre><p>也可以使用<code>QWidget.addActions</code>添加多个动作到菜单或工具栏。</p>
<pre><code>mirrorMenu = editMenu.<span class="function"><span class="title">addMenu</span><span class="params">(QIcon(<span class="string">":/editmirror.png"</span>)</span></span>,
                              <span class="string">"&amp;Mirror"</span>)
self.addActions(mirrorMenu, (editUnMirrorAction,
        editMirrorHorizontalAction, editMirrorVerticalAction))
</code></pre><p>子目录的创建和其它目录一样，不同的是使用<code>QMenu.addMenu</code>加进父目录。</p>
<pre><code>self<span class="class">.fileMenu</span> = self.<span class="function"><span class="title">menuBar</span><span class="params">()</span></span>.<span class="function"><span class="title">addMenu</span><span class="params">(<span class="string">"&amp;File"</span>)</span></span>
self<span class="class">.fileMenuActions</span> = (fileNewAction, fileOpenAction,
        fileSaveAction, fileSaveAsAction, None,
        filePrintAction, fileQuitAction)
self.<span class="function"><span class="title">connect</span><span class="params">(self.fileMenu, SIGNAL(<span class="string">"aboutToShow()"</span>)</span></span>,
             self.updateFileMenu)

fileToolbar = self.<span class="function"><span class="title">addToolBar</span><span class="params">(<span class="string">"File"</span>)</span></span>
fileToolbar.<span class="function"><span class="title">setObjectName</span><span class="params">(<span class="string">"FileToolBar"</span>)</span></span>
self.addActions(fileToolbar, (fileNewAction, fileOpenAction,
                              fileSaveAsAction))
</code></pre><p><code>addToolBar</code>创建一个<code>QToolBar</code>对象。</p>
<pre><code>editToolbar = self.<span class="function"><span class="title">addToolBar</span><span class="params">(<span class="string">"Edit"</span>)</span></span>
editToolbar.<span class="function"><span class="title">setObjectName</span><span class="params">(<span class="string">"EditToolBar"</span>)</span></span>
self.addActions(editToolbar, (editInvertAction,
        editSwapRedAndBlueAction, editUnMirrorAction,
        editMirrorVerticalAction,
        editMirrorHorizontalAction))
</code></pre><p>添加部件到工具栏都一样： 创建部件，配置好部件，连接信号，然后把部件添加到工具栏</p>
<pre><code>self<span class="class">.zoomSpinBox</span> = <span class="function"><span class="title">QSpinBox</span><span class="params">()</span></span>
self<span class="class">.zoomSpinBox</span><span class="class">.setRange</span>(<span class="number">1</span>, <span class="number">400</span>)
self<span class="class">.zoomSpinBox</span><span class="class">.setSuffix</span>(<span class="string">" %"</span>)
self<span class="class">.zoomSpinBox</span><span class="class">.setValue</span>(<span class="number">100</span>)
self<span class="class">.zoomSpinBox</span><span class="class">.setToolTip</span>(<span class="string">"Zoom the image"</span>)
self<span class="class">.zoomSpinBox</span><span class="class">.setStatusTip</span>(self<span class="class">.zoomSpinBox</span><span class="class">.toolTip</span>())
self<span class="class">.zoomSpinBox</span><span class="class">.setFocusPolicy</span>(Qt.NoFocus)
self.connect(self<span class="class">.zoomSpinBox</span>,
             <span class="function"><span class="title">SIGNAL</span><span class="params">(<span class="string">"valueChanged(int)"</span>)</span></span>, self.showImage)
editToolbar.<span class="function"><span class="title">addWidget</span><span class="params">(self.zoomSpinBox)</span></span>
</code></pre><p>之前有一行这样的代码：</p>
<pre><code><span class="tag">self</span><span class="class">.imageLabel</span><span class="class">.setContextMenuPolicy</span>(<span class="tag">Qt</span><span class="class">.ActionsContextMenu</span>)
</code></pre><p>它告诉PyQt，如果动作被加进imageLabel部件，它们也被用作右键菜单。</p>
<pre><code><span class="keyword">self</span>.addActions(<span class="keyword">self</span>.imageLabel, (editInvertAction,
        editSwapRedAndBlueAction, editUnMirrorAction,
        editMirrorVerticalAction, editMirrorHorizontalAction))
</code></pre><p><code>QWidget</code>类有一个<code>addAction</code>方法，因此<code>QMenu</code>，<code>QMenuBar</code>，<code>QToolBar</code>都继承了这个方法。<br>尽管<code>QWidget</code>没有<code>addSeparator</code>方法，为了方便，<code>QMenu</code>，<code>QMenuBar</code>，<code>QToolBar</code>都提供了。<br>如果要添加一个分隔符到右键菜单，则必须添加一个分隔动作。</p>
<pre><code>separator = <span class="function"><span class="title">QAction</span><span class="params">(self)</span></span>
separator.<span class="function"><span class="title">setSeparator</span><span class="params">(True)</span></span>
self.addActions(editToolbar, (editInvertAction,
        editSwapRedAndBlueAction, separator, editUnMirrorAction,
        editMirrorVerticalAction, editMirrorHorizontalAction))
</code></pre><h1 id="恢复和保存主窗口状态">恢复和保存主窗口状态</h1><pre><code>def <span class="function"><span class="title">main</span><span class="params">()</span></span>:
    app = <span class="function"><span class="title">QApplication</span><span class="params">(sys.argv)</span></span>
    app.<span class="function"><span class="title">setOrganizationName</span><span class="params">(<span class="string">"Qtrac Ltd."</span>)</span></span>
    app.<span class="function"><span class="title">setOrganizationDomain</span><span class="params">(<span class="string">"qtrac.eu"</span>)</span></span>
    app.<span class="function"><span class="title">setApplicationName</span><span class="params">(<span class="string">"Image Changer"</span>)</span></span>
    app.<span class="function"><span class="title">setWindowIcon</span><span class="params">(QIcon(<span class="string">":/icon.png"</span>)</span></span>)
    <span class="tag">form</span> = <span class="function"><span class="title">MainWindow</span><span class="params">()</span></span>
    <span class="tag">form</span>.<span class="function"><span class="title">show</span><span class="params">()</span></span>
    app.<span class="function"><span class="title">exec_</span><span class="params">()</span></span>
</code></pre><p>函数main的第二行到第四行的主要作用就是程序配置的加载和保存。如果不传任何参数给<code>QSettings</code>对象，<br>则它会使用这三行代码设定的名字。这些名字使得程序配置保存在合适的地方，比如Windows的注册表，Linux<br>的$HOME/.config</p>
<pre><code>settings = <span class="function"><span class="title">QSettings</span><span class="params">()</span></span>
self<span class="class">.recentFiles</span> = settings.<span class="function"><span class="title">value</span><span class="params">(<span class="string">"RecentFiles"</span>)</span></span>.<span class="function"><span class="title">toStringList</span><span class="params">()</span></span>
size = settings.value(<span class="string">"MainWindow/Size"</span>,
                      <span class="function"><span class="title">QVariant</span><span class="params">(QSize(<span class="number">600</span>, <span class="number">500</span>)</span></span>)).<span class="function"><span class="title">toSize</span><span class="params">()</span></span>
self.<span class="function"><span class="title">resize</span><span class="params">(size)</span></span>
<span class="attribute">position</span> = settings.value(<span class="string">"MainWindow/Position"</span>,
                          <span class="function"><span class="title">QVariant</span><span class="params">(QPoint(<span class="number">0</span>, <span class="number">0</span>)</span></span>)).<span class="function"><span class="title">toPoint</span><span class="params">()</span></span>
self.<span class="function"><span class="title">move</span><span class="params">(position)</span></span>
self.restoreState(
        settings.<span class="function"><span class="title">value</span><span class="params">(<span class="string">"MainWindow/State"</span>)</span></span>.<span class="function"><span class="title">toByteArray</span><span class="params">()</span></span>)
self.<span class="function"><span class="title">setWindowTitle</span><span class="params">(<span class="string">"Image Changer"</span>)</span></span>
self.<span class="function"><span class="title">updateFileMenu</span><span class="params">()</span></span>
QTimer.<span class="function"><span class="title">singleShot</span><span class="params">(<span class="number">0</span>, self.loadInitialFile)</span></span>
</code></pre><p><code>QSettings.value()</code>返回一个<code>QVariant</code>，因此必须转换为我们期望的数据类型。<br>带2个参数形式的<code>value()</code>方法，第二个参数是默认值。</p>
<p><code>resize()</code>和<code>move()</code>并不会造成窗口抖动，因为这些操作是在窗口显示之前已经完成。<br>Qt4.2引入2个新的方法保存和恢复一个顶层窗口的几何位置。</p>
<pre><code>self.<span class="function"><span class="title">restoreGeometry</span><span class="params">(settings.value(<span class="string">"Geometry"</span>)</span></span>.<span class="function"><span class="title">toByteArray</span><span class="params">()</span></span>)
</code></pre><p><code>QMainWindow</code>类提供<code>restoreState()</code>和<code>saveState()</code>方法，来恢复自或保存到一个<code>QByteArray</code>。<br>它们只保存拥有唯一对象名的悬浮窗口的大小和位置以及工具栏的位置。</p>
<blockquote>
<p><strong>启动时做大量处理</strong><br>如果我们需要在启动时做大量处理，比如加载许多大文件，我们经常用一个独立的加载方法来做此事。<br>想象一下，比如这个方法是loadInitialFiles()，加载许多大文件。则在show()和事件循环(exec_())<br>开始之前，用户将体验到一个非常长的启动延迟。<br>我们希望窗口尽可能快的出现，使用户知道启动成功，并能够看到长时间运行的进程。这些通过0延迟的<br>singleShot计时器完成。因为它并不会立即执行连接的槽，相反它简单地将槽放到事件队列就返回。<br>0延迟计时器意思是，“当事件队列没有其它事件处理时处理这个事件”</p>
</blockquote>
<pre><code>def <span class="function"><span class="title">loadInitialFile</span><span class="params">(self)</span></span>:
    settings = <span class="function"><span class="title">QSettings</span><span class="params">()</span></span>
    fname = <span class="function"><span class="title">unicode</span><span class="params">(settings.value(<span class="string">"LastFile"</span>)</span></span>.<span class="function"><span class="title">toString</span><span class="params">()</span></span>)
    <span class="keyword">if</span> fname and QFile.<span class="function"><span class="title">exists</span><span class="params">(fname)</span></span>:
        self.<span class="function"><span class="title">loadFile</span><span class="params">(fname)</span></span>
</code></pre><p>如果用户试图关闭程序，不管什么方式，<code>closeEvent()</code>被调用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">closeEvent</span><span class="params">(self, event)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.okToContinue():</span><br><span class="line">        settings = QSettings()</span><br><span class="line">        filename = QVariant(QString(self.filename)) \</span><br><span class="line">                <span class="keyword">if</span> self.filename <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">else</span> QVariant()</span><br><span class="line">        settings.setValue(<span class="string">"LastFile"</span>, filename)</span><br><span class="line">        recentFiles = QVariant(self.recentFiles) \</span><br><span class="line">                <span class="keyword">if</span> self.recentFiles <span class="keyword">else</span> QVariant()</span><br><span class="line">        settings.setValue(<span class="string">"RecentFiles"</span>, recentFiles)</span><br><span class="line">        settings.setValue(<span class="string">"MainWindow/Size"</span>, QVariant(self.size()))</span><br><span class="line">        settings.setValue(<span class="string">"MainWindow/Position"</span>,</span><br><span class="line">                QVariant(self.pos()))</span><br><span class="line">        settings.setValue(<span class="string">"MainWindow/State"</span>,</span><br><span class="line">                QVariant(self.saveState()))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        event.ignore()</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>语法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>m.addDockWidget(a, d)</td>
<td style="text-align:left">在QMainWindow m中添加QDockWidget d到Qt.QDockWidgetArea a</td>
</tr>
<tr>
<td>m.addToolBar(s)</td>
<td style="text-align:left">添加并返回一个名叫string s的QToolBar</td>
</tr>
<tr>
<td>m.menuBar()</td>
<td style="text-align:left">返回QMainWindow m的QMenuBar(第一次调用创建目录)</td>
</tr>
<tr>
<td>m.restoreGeometry(ba)</td>
<td style="text-align:left">根据QByteArray ba恢复QMainWindow m的位置和大小(Qt4.3)</td>
</tr>
<tr>
<td>m.restoreState(ba)</td>
<td style="text-align:left">根据QByteArray ba恢复QMainWindow m的悬浮窗和工具栏的状态</td>
</tr>
<tr>
<td>m.saveGeometry()</td>
<td style="text-align:left">返回封装在QByteArray中QMainWindow m的位置和大小(Qt4.3)</td>
</tr>
<tr>
<td>m.saveState()</td>
<td style="text-align:left">返回封装在QByteArray中QMainWindow m的悬浮窗和工具栏的状态</td>
</tr>
<tr>
<td>m.setCentralWidget(w)</td>
<td style="text-align:left">设置QMainWindow m的中央部件为QWidget w</td>
</tr>
<tr>
<td>m.statusBar()</td>
<td style="text-align:left">返回QMainWindow的QStatusBar(第一次调用创建状态栏)</td>
</tr>
<tr>
<td>m.setWindowIcon(i)</td>
<td style="text-align:left">设置QMainWindow m的图标为QIcon i；这个方法继承自QWidget</td>
</tr>
<tr>
<td>m.setWindowTitle(s)</td>
<td style="text-align:left">设置QMainWindow m的标题为string s；这个方法继承自QWidget</td>
</tr>
</tbody>
</table>
<p>如果我们使用Qt4，使用<code>QWidget.restoreGeometry()</code>恢复窗口的几何位置，那么我们可以如此保存几何状态：</p>
<pre><code>settings.<span class="function"><span class="title">setValue</span><span class="params">(<span class="string">"Geometry"</span>, QVariant(self.saveGeometry()</span></span>))
</code></pre><p>使用这种方法，不需要单独保存主窗口的大小和位置。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">okToContinue</span><span class="params">(self)</span>:</span>
    <span class="keyword">if</span> self.dirty:
    reply = QMessageBox.question(self,
                    <span class="string">"Image Changer - Unsaved Changes"</span>,
                    <span class="string">"Save unsaved changes?"</span>,
                    QMessageBox.Yes|QMessageBox.No|
                    QMessageBox.Cancel)
    <span class="keyword">if</span> reply == QMessageBox.Cancel:
        <span class="keyword">return</span> <span class="keyword">False</span>
    <span class="keyword">elif</span> reply == QMessageBox.Yes:
        self.fileSave()
    <span class="keyword">return</span> <span class="keyword">True</span>
</code></pre><p>有些开发者使用<code>QMessageBox.Save</code>和<code>QMessageBox.Discard</code>。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">updateFileMenu</span><span class="params">(<span class="keyword">self</span>)</span>:</span>
    <span class="keyword">self</span>.fileMenu.clear()
    <span class="keyword">self</span>.addActions(<span class="keyword">self</span>.fileMenu, <span class="keyword">self</span>.fileMenuActions[<span class="symbol">:-</span><span class="number">1</span>])
    current = <span class="constant">QString</span>(<span class="keyword">self</span>.filename) \
            <span class="keyword">if</span> <span class="keyword">self</span>.filename is <span class="keyword">not</span> <span class="constant">None</span> <span class="keyword">else</span> <span class="constant">None</span>
    recentFiles = []
    <span class="keyword">for</span> fname <span class="keyword">in</span> <span class="keyword">self</span>.<span class="symbol">recentFiles:</span>
        <span class="keyword">if</span> fname != current <span class="keyword">and</span> <span class="constant">QFile</span>.exists(fname)<span class="symbol">:</span>
            recentFiles.append(fname)
    <span class="keyword">if</span> <span class="symbol">recentFiles:</span>
        <span class="keyword">self</span>.fileMenu.addSeparator()
        <span class="keyword">for</span> i, fname <span class="keyword">in</span> enumerate(recentFiles)<span class="symbol">:</span>
            action = <span class="constant">QAction</span>(<span class="constant">QIcon</span>(<span class="string">":/icon.png"</span>), <span class="string">"&amp;%d %s"</span> % (
                    i + <span class="number">1</span>, <span class="constant">QFileInfo</span>(fname).fileName()), <span class="keyword">self</span>)
            action.setData(<span class="constant">QVariant</span>(fname))
            <span class="keyword">self</span>.connect(action, <span class="constant">SIGNAL</span>(<span class="string">"triggered()"</span>),
                         <span class="keyword">self</span>.loadFile)
            <span class="keyword">self</span>.fileMenu.addAction(action)
    <span class="keyword">self</span>.fileMenu.addSeparator()
    <span class="keyword">self</span>.fileMenu.addAction(<span class="keyword">self</span>.fileMenuActions[-<span class="number">1</span>])
</code></pre><blockquote>
<p><strong>QMessageBox的静态方法</strong><br>QMessageBox类提供多个方便的静态方法，这些方法弹出一个有合适图标和按钮的模式对话框。<br>最常用的方法为critical()，information()，question()和waring()。这些方法携带参数<br>父类部件，窗口标题，消息文本(可以是纯文本或HTML)，0个或多个按钮。如果未指定按钮，则为OK按钮。<br>Qt4.0和Qt4.1中，OK按钮或Yes按钮位或QMessageBox.Default，Cancel按钮或No按钮位或<br>  QMessageBox.Escape很常见。<br>    reply = QMessageBox.question(self,<br>            “Image Changer - Unsaved Changes”, “Save unsaved changes?”,<br>            QMessageBox.Yes|QMessageBox.Default,<br>            QMessageBox.No|QMessageBox.Escape)<br>4.2中则自动绑定默认动作到相应的按钮上。<br>如果我们想创建自定义的消息框，可以创建一个QMessageBox实例，然后使用QMessageBox.addButton()<br>QMessageBox.setIcon()添加按钮，再调用QMessageBox.exec_()弹出消息框。</p>
</blockquote>
<pre><code>def <span class="function"><span class="title">addRecentFile</span><span class="params">(self, fname)</span></span>:
    <span class="keyword">if</span> fname is None:
        return
    <span class="keyword">if</span> not self<span class="class">.recentFiles</span><span class="class">.contains</span>(fname):
        self<span class="class">.recentFiles</span><span class="class">.prepend</span>(<span class="function"><span class="title">QString</span><span class="params">(fname)</span></span>)
        while self<span class="class">.recentFiles</span><span class="class">.count</span>() &gt; <span class="number">9</span>:
            self<span class="class">.recentFiles</span><span class="class">.takeLast</span>()
</code></pre><h1 id="处理文件动作">处理文件动作</h1><pre><code><span class="function"><span class="keyword">def</span> <span class="title">fileNew</span><span class="params">(self)</span>:</span>
    <span class="keyword">if</span> <span class="keyword">not</span> self.okToContinue():
        <span class="keyword">return</span>
    dialog = newimagedlg.NewImageDlg(self)
    <span class="keyword">if</span> dialog.exec_():
        self.addRecentFile(self.filename)
        self.image = QImage()
        <span class="keyword">for</span> action, check <span class="keyword">in</span> self.resetableActions:
            action.setChecked(check)
        self.image = dialog.image()
        self.filename = <span class="keyword">None</span>
        self.dirty = <span class="keyword">True</span>
        self.showImage()
        self.sizeLabel.setText(<span class="string">"%d x %d"</span> % (self.image.width(),
                                            self.image.height()))
        self.updateStatus(<span class="string">"Created new image"</span>)

<span class="function"><span class="keyword">def</span> <span class="title">updateStatus</span><span class="params">(self, message)</span>:</span>
    self.statusBar().showMessage(message, <span class="number">5000</span>)
    self.listWidget.addItem(message)
    <span class="keyword">if</span> self.filename <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:
        self.setWindowTitle(<span class="string">"Image Changer - %s[*]"</span> % \
                            os.path.basename(self.filename))
    <span class="keyword">elif</span> <span class="keyword">not</span> self.image.isNull():
        self.setWindowTitle(<span class="string">"Image Changer - Unnamed[*]"</span>)
    <span class="keyword">else</span>:
        self.setWindowTitle(<span class="string">"Image Changer[*]"</span>)
    self.setWindowModified(self.dirty)

<span class="function"><span class="keyword">def</span> <span class="title">fileOpen</span><span class="params">(self)</span>:</span>
    <span class="keyword">if</span> <span class="keyword">not</span> self.okToContinue():
        <span class="keyword">return</span>
    dir = os.path.dirname(self.filename) \
            <span class="keyword">if</span> self.filename <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">else</span> <span class="string">"."</span>
    formats = [<span class="string">"*.%s"</span> % unicode(format).lower() \
               <span class="keyword">for</span> format <span class="keyword">in</span> QImageReader.supportedImageFormats()]
    fname = unicode(QFileDialog.getOpenFileName(self,
                        <span class="string">"Image Changer - Choose Image"</span>, dir,
                        <span class="string">"Image files (%s)"</span> % <span class="string">" "</span>.join(formats)))
    <span class="keyword">if</span> fname:
        self.loadFile(fname)
</code></pre><p><code>QFileDialog.getOpenFileName()</code>返回一个<code>QString</code>保存文件名的绝对路径，或者返回空。</p>
<pre><code>fname = unicode(QFileDialog.getOpenFileName(self,
                <span class="string">"%s - Choose Image"</span> % QApplication.applicationName(),
                dir, <span class="string">"Image files (%s)"</span> % <span class="string">" "</span>.join(formats)))

<span class="function"><span class="keyword">def</span> <span class="title">loadFile</span><span class="params">(self, fname=None)</span>:</span>
    <span class="keyword">if</span> fname <span class="keyword">is</span> <span class="keyword">None</span>:
        action = self.sender()
        <span class="keyword">if</span> isinstance(action, QAction):
            fname = unicode(action.data().toString())
            <span class="keyword">if</span> <span class="keyword">not</span> self.okToContinue():
                <span class="keyword">return</span>
        <span class="keyword">else</span>:
            <span class="keyword">return</span>
    <span class="keyword">if</span> fname:
        self.filename = <span class="keyword">None</span>
        image = QImage(fname)
        <span class="keyword">if</span> image.isNull():
            message = <span class="string">"Failed to read %s"</span> % fname
        <span class="keyword">else</span>:
            self.addRecentFile(fname)
            self.image = QImage()
            <span class="keyword">for</span> action, check <span class="keyword">in</span> self.resetableActions:
                action.setChecked(check)
            self.image = image
            self.filename = fname
            self.showImage()
            self.dirty = <span class="keyword">False</span>
            self.sizeLabel.setText(<span class="string">"%d x %d"</span> % (
                        image.width(), image.height()))
            message = <span class="string">"Loaded %s"</span> % os.path.basename(fname)
        self.updateStatus(message)

<span class="function"><span class="keyword">def</span> <span class="title">fileSave</span><span class="params">(self)</span>:</span>
    <span class="keyword">if</span> self.image.isNull():
        <span class="keyword">return</span>
    <span class="keyword">if</span> self.filename <span class="keyword">is</span> <span class="keyword">None</span>:
        self.fileSaveAs()
    <span class="keyword">else</span>:
        <span class="keyword">if</span> self.image.save(self.filename, <span class="keyword">None</span>):
            self.updateStatus(<span class="string">"Saved as %s"</span> % self.filename)
            self.dirty = <span class="keyword">False</span>
        <span class="keyword">else</span>:
            self.updateStatus(<span class="string">"Failed to save %s"</span> % self.filename)

<span class="function"><span class="keyword">def</span> <span class="title">fileSaveAs</span><span class="params">(self)</span>:</span>
    <span class="keyword">if</span> self.image.isNull():
        <span class="keyword">return</span>
    fname = self.filename <span class="keyword">if</span> self.filename <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">else</span> <span class="string">"."</span>
    formats = [<span class="string">"*.%s"</span> % unicode(format).lower() \
               <span class="keyword">for</span> format <span class="keyword">in</span> QImageWriter.supportedImageFormats()]
    fname = unicode(QFileDialog.getSaveFileName(self,
                    <span class="string">"Image Changer - Save Image"</span>, fname,
                    <span class="string">"Image files (%s)"</span> % <span class="string">" "</span>.join(formats)))
    <span class="keyword">if</span> fname:
        <span class="keyword">if</span> <span class="string">"."</span> <span class="keyword">not</span> <span class="keyword">in</span> fname:
            fname += <span class="string">".png"</span>
        self.addRecentFile(fname)
        self.filename = fname
        self.fileSave()
</code></pre><p>QFileDialog.getSaveFileName()提示用户提供一个文件名用来保存当前文件。</p>
<h1 id="处理编辑动作">处理编辑动作</h1><pre><code>def <span class="function"><span class="title">editInvert</span><span class="params">(self, on)</span></span>:
    <span class="keyword">if</span> self<span class="class">.image</span><span class="class">.isNull</span>():
        return
    self<span class="class">.image</span><span class="class">.invertPixels</span>()
    self.<span class="function"><span class="title">showImage</span><span class="params">()</span></span>
    self<span class="class">.dirty</span> = True
    self.<span class="function"><span class="title">updateStatus</span><span class="params">(<span class="string">"Inverted"</span> if on else <span class="string">"Uninverted"</span>)</span></span>

def <span class="function"><span class="title">editMirrorHorizontal</span><span class="params">(self, on)</span></span>:
    <span class="keyword">if</span> self<span class="class">.image</span><span class="class">.isNull</span>():
        return
    self<span class="class">.image</span> = self<span class="class">.image</span><span class="class">.mirrored</span>(True, False)
    self.<span class="function"><span class="title">showImage</span><span class="params">()</span></span>
    self<span class="class">.mirroredhorizontally</span> = not self<span class="class">.mirroredhorizontally</span>
    self<span class="class">.dirty</span> = True
    self.updateStatus(<span class="string">"Mirrored Horizontally"</span> \
            <span class="keyword">if</span> on <span class="keyword">else</span> <span class="string">"Unmirrored Horizontally"</span>)

def <span class="function"><span class="title">editUnMirror</span><span class="params">(self, on)</span></span>:
    <span class="keyword">if</span> self<span class="class">.image</span><span class="class">.isNull</span>():
        return
    <span class="keyword">if</span> self<span class="class">.mirroredhorizontally</span>:
        self.<span class="function"><span class="title">editMirrorHorizontal</span><span class="params">(False)</span></span>
    <span class="keyword">if</span> self<span class="class">.mirroredvertically</span>:
        self.<span class="function"><span class="title">editMirrorVertical</span><span class="params">(False)</span></span>

def <span class="function"><span class="title">editZoom</span><span class="params">(self)</span></span>:
    <span class="keyword">if</span> self<span class="class">.image</span><span class="class">.isNull</span>():
        return
    percent, ok = QInputDialog.getInteger(self,
            <span class="string">"Image Changer - Zoom"</span>, <span class="string">"Percent:"</span>,
            self<span class="class">.zoomSpinBox</span><span class="class">.value</span>(), <span class="number">1</span>, <span class="number">400</span>)
    <span class="keyword">if</span> ok:
        self<span class="class">.zoomSpinBox</span><span class="class">.setValue</span>(percent)
</code></pre><p><code>QInputDialog</code>提供了一些其它方便的静态方法，<code>getDouble()</code>，<code>getItem()</code>，<code>getText()</code>。<br>所有这些方法返回一个tuple，包含一个指示用户是否输入的bool值和一个合法值。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">showImage</span><span class="params">(self, percent=None)</span>:</span>
    <span class="keyword">if</span> self.image.isNull():
        <span class="keyword">return</span>
    <span class="keyword">if</span> percent <span class="keyword">is</span> <span class="keyword">None</span>:
        percent = self.zoomSpinBox.value()
    factor = percent / <span class="number">100.0</span>
    width = self.image.width() * factor
    height = self.image.height() * factor
    image = self.image.scaled(width, height, Qt.KeepAspectRatio)
    self.imageLabel.setPixmap(QPixmap.fromImage(image))
</code></pre><p>根据PyQt的文档，<code>QPixmap</code>对屏幕显示做了优化，而<code>QImage</code>对编辑做了优化，因此我们用它保存图像数据。</p>
<h1 id="处理帮助动作">处理帮助动作</h1><pre><code><span class="function"><span class="keyword">def</span> <span class="title">helpAbout</span><span class="params">(self)</span>:</span>
    QMessageBox.about(self, <span class="string">"About Image Changer"</span>,
            <span class="string">"""&lt;b&gt;Image Changer&lt;/b&gt; v %s
            &lt;p&gt;Copyright &amp;copy; 2007 Qtrac Ltd. 
            All rights reserved.
            &lt;p&gt;This application can be used to perform
            simple image manipulations.
            &lt;p&gt;Python %s - Qt %s - PyQt %s on %s"""</span> % (
            __version__, platform.python_version(),
            QT_VERSION_STR, PYQT_VERSION_STR, platform.system()))
</code></pre><p><code>QMessageBox.about()</code>静态方法弹出一个给定标题和文本的只有OK按钮的模式对话框，其文本可以是HTML。</p>
<h1 id="总结">总结</h1><p>主窗口风格的程序由<code>QMainWindow</code>子类创建，其窗口只有一个单一的部件作为中央部件。</p>
<p>动作用来表示程序向用户提供的功能。这些动作保存在<code>QAction</code>对象中，包含文本(用于菜单)，图标(用于菜单<br>和工具栏)，工具栏提示和状态栏提示，以及所连接的槽。<br>通常所有的动作都会添加进菜单，而只有经常使用的一些加入工具栏。</p>
<p>动作，动作组和悬浮窗必须显式提供一个父亲，比如主窗口，以保证在合适的时候能被销毁。</p>
<p>程序通常使用资源(小文件，比如图标，和数据文件)，PyQt的资源机制使得访问和使用资源非常简单。使用<br><code>pyrcc4</code>将资源文件编程Python模块，再导入程序使用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="创建一个主窗口">创建一个主窗口</h1><pre><code><span class="preprocessor"><span class="keyword">import</span> os</span>
<span class="preprocessor">]]>
    </summary>
    
      <category term="PyQt" scheme="https://opensvn.github.io/tags/PyQt/"/>
    
      <category term="Python" scheme="https://opensvn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PyQt编程第五章 对话框]]></title>
    <link href="https://opensvn.github.io/2015/10/14/pyqt-5/"/>
    <id>https://opensvn.github.io/2015/10/14/pyqt-5/</id>
    <published>2015-10-14T08:20:56.000Z</published>
    <updated>2015-10-21T01:20:37.116Z</updated>
    <content type="html"><![CDATA[<p>对话框以“智力”分类为：哑巴，标准和聪明，取决于对话框知道程序数据的多少。<br>对话框以“模式”分类为：模式对话框和无模式对话框。</p>
<p>应用模式对话框一旦被调用，用户只能与其交互，不能使用程序其它部分。<br>窗口模式对话框和应用模式对话框类似，只是它仅仅阻止与其父窗口交互。<br>无模式对话框允许用户与程序其它部分交互。</p>
<p>编写对话框另一个重要方面是如何处理有效性检验。我们尽量挑选合适的部件并设置其属性来避免编写有效性<br>检验代码。<br>我们称应用到单个部件的检验为部件级确认。当部件之间有相互关系时，称为表级确认。</p>
<h1 id="“哑巴”对话框">“哑巴”对话框</h1><p>哑巴对话框不知道其部件使用的数据。哑巴对话框通常是带有<code>accept</code>和<code>reject</code>按钮的模式对话框。</p>
<pre><code>def <span class="function"><span class="title">setPenProperties</span><span class="params">(self)</span></span>:
    dialog = <span class="function"><span class="title">PenPropertiesDlg</span><span class="params">(self)</span></span>
    dialog<span class="class">.widthSpinBox</span><span class="class">.setValue</span>(self.<span class="attribute">width</span>)
    dialog<span class="class">.beveledCheckBox</span><span class="class">.setChecked</span>(self.beveled)
    dialog<span class="class">.styleComboBox</span><span class="class">.setCurrentIndex</span>(
            dialog<span class="class">.styleComboBox</span><span class="class">.findText</span>(self.style))
    <span class="keyword">if</span> dialog.<span class="function"><span class="title">exec_</span><span class="params">()</span></span>:
        self<span class="class">.width</span> = dialog<span class="class">.widthSpinBox</span><span class="class">.value</span>()
        self<span class="class">.beveled</span> = dialog<span class="class">.beveledCheckBox</span><span class="class">.isChecked</span>()
        self<span class="class">.style</span> = <span class="function"><span class="title">unicode</span><span class="params">(dialog.styleComboBox.currentText()</span></span>)
        self.<span class="function"><span class="title">updateData</span><span class="params">()</span></span>
</code></pre><p>当我们调用一个对话框的<code>exec_</code>时，则以模式对话框显示。当用户点击<code>accept</code>，<code>exec_</code>返回<code>True</code>，<br>否则返回<code>False</code>。</p>
<pre><code>class <span class="function">PenPropertiesDlg</span>(QDialog)<span class="value">:
    def __<span class="function">init__</span>(self, parent=None):
        <span class="function">super</span>(PenPropertiesDlg, self).__<span class="function">init__</span>(parent)
        widthLabel = <span class="function">QLabel</span>(<span class="string">"&amp;Width:"</span>)
        self.widthSpinBox = <span class="function">QSpinBox</span>()
        widthLabel.<span class="function">setBuddy</span>(self.widthSpinBox)
        self.widthSpinBox.<span class="function">setAlignment</span>(Qt.AlignRight|Qt.AlignVCenter)
        self.widthSpinBox.<span class="function">setRange</span>(<span class="number">0</span>, <span class="number">24</span>)
        self.beveledCheckBox = <span class="function">QCheckBox</span>(<span class="string">"&amp;Beveled edges"</span>)
        styleLabel = <span class="function">QLabel</span>(<span class="string">"&amp;Style:"</span>)
        self.styleComboBox = <span class="function">QComboBox</span>()
        styleLabel.<span class="function">setBuddy</span>(self.styleComboBox)
        self.styleComboBox.<span class="function">addItems</span>([<span class="string">"Solid"</span>, <span class="string">"Dashed"</span>, <span class="string">"Dotted"</span>,
                                     <span class="string">"DashDotted"</span>, <span class="string">"DashDotDotted"</span>])
        okButton = <span class="function">QPushButton</span>(<span class="string">"&amp;OK"</span>)
        cancelButton = <span class="function">QPushButton</span>(<span class="string">"Cancel"</span>)

        buttonLayout = <span class="function">QHBoxLayout</span>()
        buttonLayout.<span class="function">addStretch</span>()
        buttonLayout.<span class="function">addWidget</span>(okButton)
        buttonLayout.<span class="function">addWidget</span>(cancelButton)
        layout = <span class="function">QGridLayout</span>()
        layout.<span class="function">addWidget</span>(widthLabel, <span class="number">0</span>, <span class="number">0</span>)
        layout.<span class="function">addWidget</span>(self.widthSpinBox, <span class="number">0</span>, <span class="number">1</span>)
        layout.<span class="function">addWidget</span>(self.beveledCheckBox, <span class="number">0</span>, <span class="number">2</span>)
        layout.<span class="function">addWidget</span>(styleLabel, <span class="number">1</span>, <span class="number">0</span>)
        layout.<span class="function">addWidget</span>(self.styleComboBox, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)
        layout.<span class="function">addLayout</span>(buttonLayout, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>)
        self.<span class="function">setLayout</span>(layout)

        self.<span class="function">connect</span>(okButton, <span class="function">SIGNAL</span>(<span class="string">"clicked()"</span>),
                     self, <span class="function">SLOT</span>(<span class="string">"accept()"</span>))
        self.<span class="function">connect</span>(cancelButton, <span class="function">SIGNAL</span>(<span class="string">"clicked()"</span>),
                     self, <span class="function">SLOT</span>(<span class="string">"reject()"</span>))
        self.<span class="function">setWindowTitle</span>(<span class="string">"Pen Properties"</span>)</span>
</code></pre><p>在标签文字中的引号(<code>&amp;</code>)有2个可能的含义，一个简单地为字符引号。另一个指示引号后面的字母为键盘<br>加速键，可以使用Alt+字母快速定位。字符引号和加速键的区别是标签有没有一个“伙伴”。</p>
<p><strong>对话框按钮布局</strong></p>
<pre><code>buttonBox = QDialogButtonBox(QDialogButtonBox.<span class="built_in">Ok</span>
                             | QDialogButtonBox.Cancel)
buttonBox.button(QDialogButtonBox.<span class="built_in">Ok</span>).setDefault(True)
layout.addWidget(buttonBox, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>)
<span class="keyword">self</span>.connect(buttonBox, SIGNAL(<span class="string">"accepted()"</span>),
             <span class="keyword">self</span>, SLOT(<span class="string">"accept()"</span>))
<span class="keyword">self</span>.connect(buttonBox, SIGNAL(<span class="string">"rejected()"</span>),
             <span class="keyword">self</span>, SLOT(<span class="string">"reject()"</span>))
</code></pre><p><code>QDialogButtonBox</code>自动处理不同平台的默认外观。<br><code>QDialogButtonBox</code>默认是水平布局，可以传递<code>Qt.Vertical</code>给它构造器设置垂直布局，或者调用<br><code>setOrientation</code>函数。</p>
<p><code>QGridLayout.addWidget</code>方法的参数是部件，所在行，所在列，和可选的行扩展数，列扩展数。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>b.addLayout(l)</td>
<td style="text-align:left">添加QLayout l到QBoxLayout b中, b通常是QHBoxLayout或QVBoxLayout</td>
</tr>
<tr>
<td>b.addSpacing(i)</td>
<td style="text-align:left">添加一个指定数量为i的QSpacerItem到QBoxLayout b中</td>
</tr>
<tr>
<td>b.addStretch(i)</td>
<td style="text-align:left">添加一个最小为0且伸展系数为i的QSpacerItem到QBoxLayout b中</td>
</tr>
<tr>
<td>b.addWidget(w)</td>
<td style="text-align:left">添加QWidget w到QBoxLayout b中</td>
</tr>
<tr>
<td>b.setStretchFactor(x, i)</td>
<td style="text-align:left">设置QBoxLayout b的伸展系数或QWidget x为i</td>
</tr>
<tr>
<td>g.addLayout(l, r, c)</td>
<td style="text-align:left">在行r列c添加QLayout l到QGridLayout g; 可以提供附加的行扩展和列扩展参数</td>
</tr>
<tr>
<td>g.addWidget(w, r, c)</td>
<td style="text-align:left">在行r列c添加QWidget w到QGridLayout g; 可以提供附加的行扩展和列扩展参数</td>
</tr>
<tr>
<td>g.setRowStretch(r, i)</td>
<td style="text-align:left">设置QGridLayout g行r的伸展为i</td>
</tr>
<tr>
<td>g.setColumnStretch(c, i)</td>
<td style="text-align:left">设置QGridLayout g列c的伸展为i</td>
</tr>
</tbody>
</table>
<h1 id="标准对话框">标准对话框</h1><p>我们认为一个对话框是标准对话框，如果它访问部件都是通过类方法，而不是部件本身。</p>
<h2 id="模式OK/Cancel风格对话框">模式OK/Cancel风格对话框</h2><pre><code>def <span class="function"><span class="title">setNumberFormat1</span><span class="params">(self)</span></span>:
    dialog = numberformatdlg1.<span class="function"><span class="title">NumberFormatDlg</span><span class="params">(self.format, self)</span></span>
    <span class="keyword">if</span> dialog.<span class="function"><span class="title">exec_</span><span class="params">()</span></span>:
        self<span class="class">.format</span> = dialog.<span class="function"><span class="title">numberFormat</span><span class="params">()</span></span>
        self.<span class="function"><span class="title">refreshTable</span><span class="params">()</span></span>
</code></pre><table>
<thead>
<tr>
<th>语法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>d.addButton(b, r)</td>
<td style="text-align:left">添加具有QDialogButtonBox.ButtonRole r的QPushButton b到QDialogButtonBox d中</td>
</tr>
<tr>
<td>d.addButton(t, r)</td>
<td style="text-align:left">添加具有QDialogButtonBox.ButtonRole r且名字为t的QPushButton到QDialogButtonBox d中，返回所添加的按钮</td>
</tr>
<tr>
<td>d.addButton(s)</td>
<td style="text-align:left">添加由QDialogButtonBox.StandardButton s指定的按钮QDialogButtonBox d中，返回所添加的按钮</td>
</tr>
<tr>
<td>d.setOrientation(o)</td>
<td style="text-align:left">设置QDialogButtonBox d的方向为Qt.Orientation o(垂直或水平)</td>
</tr>
<tr>
<td>d.button(s)</td>
<td style="text-align:left">返回QDialogButtonBox d中由StandardButton s指定的按钮，或None</td>
</tr>
<tr>
<td>d.accepted()</td>
<td style="text-align:left">当角色为QDialogButtonBox.Accept的按钮被点击，发射该信号</td>
</tr>
<tr>
<td>d.rejected()</td>
<td style="text-align:left">当角色为QDialogButtonBox.Reject的按钮被点击，发射该信号</td>
</tr>
</tbody>
</table>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">accept</span><span class="params">(self)</span>:</span>
    <span class="class"><span class="keyword">class</span> <span class="title">ThousandsError</span><span class="params">(Exception)</span>:</span> <span class="keyword">pass</span>
    <span class="class"><span class="keyword">class</span> <span class="title">DecimalError</span><span class="params">(Exception)</span>:</span> <span class="keyword">pass</span>
    QMessageBox.warning(self, <span class="string">"Decimal Marker Error"</span>, unicode(e))
    QDialog.accept(self)
</code></pre><p>为什么这里不使用<code>super</code>来调用基类的<code>accept</code>而是显式使用<code>QDialog</code>？因为在这个环境下使用<code>super</code><br>不起作用。PyQt为了尽可能效率高，使用懒惰属性查找，结果就是此处的<code>super</code>在PyQt的子类中不会像预期<br>那样工作。(见pyqt4ref.html文档，”super and PyQt classes”)</p>
<h1 id="智能对话框">智能对话框</h1><p>智能对话框通常是无模式的，带有<code>apply</code>和<code>close</code>按钮。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>d.accept()</td>
<td style="text-align:left">关闭(隐藏)QDialog d，停止事件循环，并导致exec_()返回True。如果设置了Qt.WA_DeleteOnClose，则对话框被删除</td>
</tr>
<tr>
<td>d.reject()</td>
<td style="text-align:left">关闭(隐藏)QDialog d，停止事件循环，并导致exec_()返回False。</td>
</tr>
<tr>
<td>d.done(i)</td>
<td style="text-align:left">关闭(隐藏)QDialog d，停止事件循环，并导致exec_()返回i。</td>
</tr>
<tr>
<td>d.exec_()</td>
<td style="text-align:left">模式显示QDialog d，阻塞直到对话框关闭</td>
</tr>
<tr>
<td>d.show()</td>
<td style="text-align:left">无模式显示QDialog d；继承自QWidget</td>
</tr>
<tr>
<td>d.setSizeGripEnabled(b)</td>
<td style="text-align:left">显示或隐藏QDialog d的size grip，基于bool b</td>
</tr>
</tbody>
</table>
<h2 id="无模式Apply/Close风格对话框">无模式Apply/Close风格对话框</h2><pre><code><span class="function"><span class="keyword">def</span> <span class="title">setNumberFormat2</span><span class="params">(self)</span>:</span>
    dialog = numberformatdlg2.NumberFormatDlg(self.format, self)
    self.connect(dialog, SIGNAL(<span class="string">"changed"</span>), self.refreshTable)
    dialog.show()
</code></pre><p>尽管dialog超出范围，PyQt足够聪明地保存了一个无模式对话框的引用，因此dialog继续存在。可以设置<br>dialog的属性为Qt.WA_DeleteOnClose，则每次都删除对话框而不是隐藏。</p>
<pre><code>def __init__(<span class="literal">self</span>, format, parent=None):
    super(NumberFormatDlg, <span class="literal">self</span>).__init__(parent)
    <span class="literal">self</span>.<span class="built_in">set</span>Attribute(Qt.WA_DeleteOnClose)
    punctuationRe = QRegExp(r<span class="string">"[ ,;:.]"</span>)
    thousandsLabel = QLabel(<span class="string">"&amp;Thousands separator"</span>)
    <span class="literal">self</span>.thousandsEdit = QLineEdit(format[<span class="string">"thousandsseparator"</span>])
    thousandsLabel.<span class="built_in">set</span>Buddy(<span class="literal">self</span>.thousandsEdit)
    <span class="literal">self</span>.thousandsEdit.<span class="built_in">set</span>MaxLength(<span class="number">1</span>)
    <span class="literal">self</span>.thousandsEdit.<span class="built_in">set</span>Validator(
            QRegExpValidator(punctuationRe, <span class="literal">self</span>))
    decimalMarkerLabel = QLabel(<span class="string">"Decimal &amp;marker"</span>)
    <span class="literal">self</span>.decimalMarkerEdit = QLineEdit(format[<span class="string">"decimalmarker"</span>])
    decimalMarkerLabel.<span class="built_in">set</span>Buddy(<span class="literal">self</span>.decimalMarkerEdit)
    <span class="literal">self</span>.decimalMarkerEdit.<span class="built_in">set</span>MaxLength(<span class="number">1</span>)
    <span class="literal">self</span>.decimalMarkerEdit.<span class="built_in">set</span>Validator(
            QRegExpValidator(punctuationRe, <span class="literal">self</span>))
    <span class="literal">self</span>.decimalMarkerEdit.<span class="built_in">set</span>InputMask(<span class="string">"X"</span>)
    decimalPlacesLabel = QLabel(<span class="string">"&amp;Decimal places"</span>)
    <span class="literal">self</span>.decimalPlacesSpinBox = QSpinBox()
    decimalPlacesLabel.<span class="built_in">set</span>Buddy(<span class="literal">self</span>.decimalPlacesSpinBox)
    <span class="literal">self</span>.decimalPlacesSpinBox.<span class="built_in">set</span>Range(<span class="number">0</span>, <span class="number">6</span>)
    <span class="literal">self</span>.decimalPlacesSpinBox.<span class="built_in">set</span>Value(format[<span class="string">"decimalplaces"</span>])
    <span class="literal">self</span>.redNegativesCheckBox = QCheckBox(<span class="string">"&amp;Red negative numbers"</span>)
    <span class="literal">self</span>.redNegativesCheckBox.<span class="built_in">set</span>Checked(format[<span class="string">"rednegatives"</span>])
    buttonBox = QDialogButtonBox(QDialogButtonBox.Apply|
                                 QDialogButtonBox.Close)
    <span class="literal">self</span>.connect(buttonBox.button(QDialogButtonBox.Apply),
                 SIGNAL(<span class="string">"clicked()"</span>), <span class="literal">self</span>.apply)
    <span class="literal">self</span>.connect(buttonBox, SIGNAL(<span class="string">"rejected()"</span>),
                 <span class="literal">self</span>, SLOT(<span class="string">"reject()"</span>))
    <span class="literal">self</span>.<span class="built_in">set</span>WindowTitle(<span class="string">"Set Number Format (Modeless)"</span>)
</code></pre><p><code>QRegExpValidator</code>初始化式需要一个正则表达式和一个<code>parent</code>。<br>一个掩饰“X”说明需要任意一个字符，格式掩饰在<code>QLineEdit.inputMask</code>文档中说明。</p>
<h2 id="无模式“Live”对话框">无模式“Live”对话框</h2><pre><code>def <span class="function"><span class="title">setNumberFormat3</span><span class="params">(self)</span></span>:
    <span class="keyword">if</span> self<span class="class">.numberFormatDlg</span> is None:
        self<span class="class">.numberFormatDlg</span> = numberformatdlg3.NumberFormatDlg(
                self<span class="class">.format</span>, self<span class="class">.refreshTable</span>, self)
    self<span class="class">.numberFormatDlg</span><span class="class">.show</span>()
    self<span class="class">.numberFormatDlg</span><span class="class">.raise_</span>()
    self<span class="class">.numberFormatDlg</span><span class="class">.activateWindow</span>()
</code></pre><p><code>raise_</code>将对话框置于其它窗口之上<br><code>activateWindow</code>聚焦于对话框</p>
<pre><code>self.connect(self<span class="class">.thousandsEdit</span>,
             <span class="function"><span class="title">SIGNAL</span><span class="params">(<span class="string">"textEdited(QString)"</span>)</span></span>, self.checkAndFix)
self.connect(self<span class="class">.decimalMarkerEdit</span>,
             <span class="function"><span class="title">SIGNAL</span><span class="params">(<span class="string">"textEdited(QString)"</span>)</span></span>, self.checkAndFix)
self.connect(self<span class="class">.decimalPlacesSpinBox</span>,
             <span class="function"><span class="title">SIGNAL</span><span class="params">(<span class="string">"valueChanged(int)"</span>)</span></span>, self.apply)
self.connect(self<span class="class">.redNegativesCheckBox</span>,
             <span class="function"><span class="title">SIGNAL</span><span class="params">(<span class="string">"toggled(bool)"</span>)</span></span>, self.apply)
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>对话框以“智力”分类为：哑巴，标准和聪明，取决于对话框知道程序数据的多少。<br>对话框以“模式”分类为：模式对话框和无模式对话框。</p>
<p>应用模式对话框一旦被调用，用户只能与其交互，不能使用程序其它部分。<br>窗口模式对话框和应用模式对话框类似，只是它仅仅阻止与]]>
    </summary>
    
      <category term="PyQt" scheme="https://opensvn.github.io/tags/PyQt/"/>
    
      <category term="Python" scheme="https://opensvn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PyQt编程第四章 GUI编程介绍]]></title>
    <link href="https://opensvn.github.io/2015/10/12/pyqt-4/"/>
    <id>https://opensvn.github.io/2015/10/12/pyqt-4/</id>
    <published>2015-10-12T12:34:55.000Z</published>
    <updated>2015-10-14T05:57:31.771Z</updated>
    <content type="html"><![CDATA[<h1 id="一个25行的弹出警告">一个25行的弹出警告</h1><pre><code><span class="keyword">import</span> sys
<span class="keyword">import</span> time
<span class="keyword">from</span> PyQt4.QtCore <span class="keyword">import</span> *
<span class="keyword">from</span> PyQt4.QtGui <span class="keyword">import</span> *

app = QApplication(sys.argv)

<span class="keyword">try</span>:
    due = QTime.currentTime()
    message = <span class="string">"Alert!"</span>
    <span class="keyword">if</span> len(sys.argv) &lt; <span class="number">2</span>:
        <span class="keyword">raise</span> ValueError
    hours, mins = sys.argv[<span class="number">1</span>].split(<span class="string">":"</span>)
    due = QTime(int(hours), int(mins))
    <span class="keyword">if</span> <span class="keyword">not</span> due.isValid():
        <span class="keyword">raise</span> ValueError
    <span class="keyword">if</span> len(sys.argv) &gt; <span class="number">2</span>:
        message = <span class="string">" "</span>.join(sys.argv[<span class="number">2</span>:])
<span class="keyword">except</span> ValueError:
    message = <span class="string">"Usage: alert.pyw HH:MM [optional message]"</span> <span class="comment"># 24hr clock</span>

<span class="keyword">while</span> QTime.currentTime() &lt; due:
    time.sleep(<span class="number">20</span>) <span class="comment"># 20 seconds</span>

label = QLabel(<span class="string">"&lt;font color=red size=72&gt;&lt;b&gt;"</span> + message + <span class="string">"&lt;/b&gt;&lt;/font&gt;"</span>)
label.setWindowFlags(Qt.SplashScreen)
label.show()
QTimer.singleShot(<span class="number">60000</span>, app.quit) <span class="comment"># 1 minute</span>
app.exec_()
</code></pre><p>每一个PyQt图形程序必须有一个<code>QApplication</code>对象，因为它能识别一些命令行的参数，接受<code>sys.argv</code>作为<br>参数。</p>
<p>PyQt中任何部件都能用作顶级窗口，比如一个按钮或一个标签。当部件如此使用时，PyQt自动给它一个标题栏。<br>一旦窗口设置好后，就可以调用<code>show</code>方法，这个时候窗口没有显示。<code>show</code>方法仅仅是将一个画图事件加入<br><code>QApplication</code>对象的事件队列。</p>
<p><code>app.exec_</code>开始<code>QApplication</code>对象事件循环。第一个事件是画图事件，因此标签窗口弹出。一分钟后超时<br>事件触发，<code>app.quit</code>被调用。这个方法执行图形程序的结束清理工作，关闭窗口，释放资源。</p>
<p>图形程序的事件循环，伪代码如下：</p>
<pre><code><span class="keyword">while</span> <span class="keyword">True</span>:
    <span class="keyword">event</span> = getNextEvent()
    <span class="keyword">if</span> <span class="keyword">event</span>:
        <span class="keyword">if</span> <span class="keyword">event</span> == Terminate:
            <span class="keyword">break</span>
        processEvent(<span class="keyword">event</span>)
</code></pre><h1 id="一个30行的表达式求值程序">一个30行的表达式求值程序</h1><pre><code><span class="keyword">from</span> __future__ <span class="keyword">import</span> division
<span class="keyword">import</span> sys
<span class="keyword">from</span> math <span class="keyword">import</span> *
<span class="keyword">from</span> PyQt4.QtCore <span class="keyword">import</span> *
<span class="keyword">from</span> PyQt4.QtGui <span class="keyword">import</span> *

<span class="class"><span class="keyword">class</span> <span class="title">Form</span><span class="params">(QDialog)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent=None)</span>:</span>
        super(Form, self).__init__(parent)
        self.browser = QTextBrowser()
        self.lineedit = QLineEdit(<span class="string">"Type an expression and press Enter"</span>)
        self.lineedit.selectAll()
        layout = QVBoxLayout()
        layout.addWidget(self.browser)
        layout.addWidget(self.lineedit)
        self.setLayout(layout)
        self.lineedit.setFocus()
        self.connect(self.lineedit, SIGNAL(<span class="string">"returnPressed()"</span>),
                     self.updateUi)
        self.setWindowTitle(<span class="string">"Calculate"</span>)

    <span class="function"><span class="keyword">def</span> <span class="title">updateUi</span><span class="params">(self)</span>:</span>
        <span class="keyword">try</span>:
            text = unicode(self.lineedit.text())
            self.browser.append(<span class="string">"%s = &lt;b&gt;%s&lt;/b&gt;"</span> % (text, eval(text)))
        <span class="keyword">except</span>:
            self.browser.append(
                    <span class="string">"&lt;font color=red&gt;%s is invalid!&lt;/font&gt;"</span> % text)

app = QApplication(sys.argv)
form = Form()
form.show()
app.exec_()
</code></pre><p>所有PyQt的部件，都继承自<code>QWidget</code>，并且都是新风格的类。默认地，当一个部件被关闭时，它仅仅是被隐藏了。<br>当一个窗体隐藏了，如果PyQt检查到程序没有可见窗体，而且进一步交互也不可能，PyQt会执行程序的结束清理工作。</p>
<blockquote>
<p><strong>对象所有权</strong></p>
<ul>
<li>所有PyQt类继承自<code>QObject</code>，包括所有的部件。没有父亲的部件是一个顶级窗口，孩子部件被包含在父亲部件<br>里面。父亲部件对孩子部件拥有所有权。</li>
<li>PyQt使用父子所有权模型来保证当一个父亲部件被销毁，所有它的孩子部件也被自动销毁。</li>
<li>为避免内存泄漏，除了顶级窗口，我们应该保证所有部件都有父亲。</li>
<li>布局管理器自动将部件重新绑定到正确的父亲部件上。</li>
</ul>
</blockquote>
<p>PyQt提供3种布局管理器：垂直布局，水平布局，网格布局。布局可以嵌套。<br>每一个部件通过发射信号声明状态改变。</p>
<h1 id="一个70行的汇率转换器">一个70行的汇率转换器</h1><pre><code>import sys
import urllib2
<span class="keyword">from</span> PyQt4.QtCore import *
<span class="keyword">from</span> PyQt4.QtGui import *

class Form(QDialog):
    def __init__(<span class="literal">self</span>, parent=None):
        super(Form, <span class="literal">self</span>).__init__(parent)

        date = <span class="literal">self</span>.getdata()
        rates = sorted(<span class="literal">self</span>.rates.keys())

        dateLabel = QLabel(date)
        <span class="literal">self</span>.<span class="keyword">from</span>ComboBox = QComboBox()
        <span class="literal">self</span>.<span class="keyword">from</span>ComboBox.addItems(rates)
        <span class="literal">self</span>.<span class="keyword">from</span>SpinBox = QDoubleSpinBox()
        <span class="literal">self</span>.<span class="keyword">from</span>SpinBox.<span class="built_in">set</span>Range(<span class="number">0.01</span>, <span class="number">10000000.00</span>)
        <span class="literal">self</span>.<span class="keyword">from</span>SpinBox.<span class="built_in">set</span>Value(<span class="number">1.00</span>)
        <span class="literal">self</span>.<span class="keyword">to</span>ComboBox = QComboBox()
        <span class="literal">self</span>.<span class="keyword">to</span>ComboBox.addItems(rates)
        <span class="literal">self</span>.<span class="keyword">to</span>Label = QLabel(<span class="string">"1.00"</span>)
        grid = QGridLayout()
        grid.addWidget(dateLabel, <span class="number">0</span>, <span class="number">0</span>)
        grid.addWidget(<span class="literal">self</span>.<span class="keyword">from</span>ComboBox, <span class="number">1</span>, <span class="number">0</span>)
        grid.addWidget(<span class="literal">self</span>.<span class="keyword">from</span>SpinBox, <span class="number">1</span>, <span class="number">1</span>)
        grid.addWidget(<span class="literal">self</span>.<span class="keyword">to</span>ComboBox, <span class="number">2</span>, <span class="number">0</span>)
        grid.addWidget(<span class="literal">self</span>.<span class="keyword">to</span>Label, <span class="number">2</span>, <span class="number">1</span>)
        <span class="literal">self</span>.<span class="built_in">set</span>Layout(grid)
        <span class="literal">self</span>.connect(<span class="literal">self</span>.<span class="keyword">from</span>ComboBox,
                SIGNAL(<span class="string">"currentIndexChanged(int)"</span>), <span class="literal">self</span>.updateUi)
        <span class="literal">self</span>.connect(<span class="literal">self</span>.<span class="keyword">to</span>ComboBox,
                SIGNAL(<span class="string">"currentIndexChanged(int)"</span>), <span class="literal">self</span>.updateUi)
        <span class="literal">self</span>.connect(<span class="literal">self</span>.<span class="keyword">from</span>SpinBox,
                SIGNAL(<span class="string">"valueChanged(double)"</span>), <span class="literal">self</span>.updateUi)
        <span class="literal">self</span>.<span class="built_in">set</span>WindowTitle(<span class="string">"Currency"</span>)

    def updateUi(<span class="literal">self</span>):
        <span class="keyword">to</span> = unicode(<span class="literal">self</span>.<span class="keyword">to</span>ComboBox.currentText())
        from_ = unicode(<span class="literal">self</span>.<span class="keyword">from</span>ComboBox.currentText())
        amount = (<span class="literal">self</span>.rates[from_] / <span class="literal">self</span>.rates[<span class="keyword">to</span>]) * \
                 <span class="literal">self</span>.<span class="keyword">from</span>SpinBox.value()
        <span class="literal">self</span>.<span class="keyword">to</span>Label.<span class="built_in">set</span>Text(<span class="string">"%0.2f"</span> % amount)

    def getdata(<span class="literal">self</span>): <span class="comment"># Idea taken from the Python Cookbook</span>
        <span class="literal">self</span>.rates = {}
        try:
            date = <span class="string">"Unknown"</span>
            fh = urllib2.urlopen(<span class="string">"http://www.bankofcanada.ca"</span>
                                 <span class="string">"/en/markets/csv/exchange_eng.csv"</span>)
            <span class="keyword">for</span> line <span class="keyword">in</span> fh:
                line = line.rstrip()
                if not line or line.startswith((<span class="string">"#"</span>, <span class="string">"Closing "</span>)):
                    continue
                fields = line.split(<span class="string">","</span>)
                if line.startswith(<span class="string">"Date "</span>):
                    date = fields[-<span class="number">1</span>]
                else:
                    try:
                        value = float(fields[-<span class="number">1</span>])
                        <span class="literal">self</span>.rates[unicode(fields[<span class="number">0</span>])] = value
                    except ValueError:
                        <span class="built_in">pass</span>
            return <span class="string">"Exchange Rates Date: "</span> + date
        except Exception, e:
            return <span class="string">"Failed to download:\n%s"</span> % e

app = QApplication(sys.argv)
form = Form()
form.show()
app.exec_()
</code></pre><h1 id="信号和槽">信号和槽</h1><p>每一个<code>QObject</code>支持信号和槽机制。所有的PyQt部件都有一组预定义的信号。不管什么时候一个信号发射，PyQt<br>默认简单地将其丢掉。必须将信号连接到槽来捕捉信号。在PyQt中，槽是任何可调用的对象。大多数部件也有预定义<br>好的槽。</p>
<p><code>connect</code>的语法，s通常是<code>self</code>，w是部件：</p>
<pre><code>s.<span class="function"><span class="title">connect</span><span class="params">(w, SIGNAL(<span class="string">"signalSignature"</span>)</span></span>, functionName)
s.<span class="function"><span class="title">connect</span><span class="params">(w, SIGNAL(<span class="string">"signalSignature"</span>)</span></span>, instance.methodName)
s.<span class="function"><span class="title">connect</span><span class="params">(w, SIGNAL(<span class="string">"signalSignature"</span>)</span></span>, instance, <span class="function"><span class="title">SLOT</span><span class="params">(<span class="string">"slotSignature"</span>)</span></span>)
</code></pre><p>signalSignature是信号的名字，并带一个逗号隔开的参数列表。如果是Qt信号，则参数类型必须是C++类型。<br>当书写信号的C++参数类型时，可以丢弃<code>const</code>和<code>&amp;</code>，但是必须保留<code>*</code>。</p>
<p>PyQt信号发射时被定义，它们可以有任意数量，任意类型的参数。</p>
<p>slotSignature和signalSignature有着一样的形式。一个槽的参数可能比信号少。相应的信号和槽的参数必须类型相同。<br>如果是Qt槽而不是Python方法时，使用<code>SLOT</code>语法效率更高。</p>
<pre><code>self.<span class="function"><span class="title">connect</span><span class="params">(dial, SIGNAL(<span class="string">"valueChanged(int)"</span>)</span></span>, spinbox, <span class="function"><span class="title">SLOT</span><span class="params">(<span class="string">"setValue(int)"</span>)</span></span>)
self.<span class="function"><span class="title">connect</span><span class="params">(spinbox, SIGNAL(<span class="string">"valueChanged(int)"</span>)</span></span>, dial, <span class="function"><span class="title">SLOT</span><span class="params">(<span class="string">"setValue(int)"</span>)</span></span>)
</code></pre><p>可以将多个信号连接到同一个槽，也可以将一个信号连接到多个槽。尽管很罕见，我们也可以将一个信号连接到另一个<br>信号，这样当第一个信号发射时，将会引起它连接的信号发射。</p>
<p>通过<code>QObject.connect</code>建立连接，<code>QObject.disconnect</code>解除连接。实际上，我们很少需要自己解除连接，<br>PyQt会自动解除已经销毁的对象相关的连接。</p>
<p>使用<code>QObject.emit</code>发射自定义的信号。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">ZeroSpinBox</span><span class="params">(QSpinBox)</span>:</span>
    zeros = <span class="number">0</span>

    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent=None)</span>:</span>
        super(ZeroSpinBox, self).__init__(parent)
        self.connect(self, SIGNAL(<span class="string">'valueChanged(int)'</span>), self.checkzero)

    <span class="function"><span class="keyword">def</span> <span class="title">checkzero</span><span class="params">(self)</span>:</span>
        <span class="keyword">if</span> self.value() == <span class="number">0</span>:
            self.zeros += <span class="number">1</span>
            self.emit(SIGNAL(<span class="string">'atzero'</span>), self.zeros)
</code></pre><p>一个没有参数(没有括号)的信号是一个短路Python信号。当这种信号被发射，任何数据都可以当作额外的参数传给<br><code>emit</code>方法，这些参数被当作Python对象传递。<br>至少有一个参数的信号是Qt信号或非短路Python信号，其参数都将转换为C++数据类型。</p>
<p>PyQt的信号和槽机制并不局限于GUI类，任何<code>QObject</code>的子类都可以使用信号和槽。</p>
<pre><code><span class="keyword">from</span> PyQt4.QtCore <span class="keyword">import</span> *

<span class="class"><span class="keyword">class</span> <span class="title">TaxRate</span><span class="params">(QObject)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>
        super(TaxRate, self).__init__()
        self.__rate = <span class="number">17.5</span>

    <span class="function"><span class="keyword">def</span> <span class="title">rate</span><span class="params">(self)</span>:</span>
        <span class="keyword">return</span> self.__rate

    <span class="function"><span class="keyword">def</span> <span class="title">setRate</span><span class="params">(self, rate)</span>:</span>
        <span class="keyword">if</span> rate != self.__rate:
            self.__rate = rate
            self.emit(SIGNAL(<span class="string">'rateChanged'</span>), self.__rate)

<span class="function"><span class="keyword">def</span> <span class="title">rateChanged</span><span class="params">(value)</span>:</span>
    <span class="keyword">print</span> <span class="string">'TaxRate changed to %.2f%%'</span> % value

vat = TaxRate()
vat.connect(vat, SIGNAL(<span class="string">'rateChanged'</span>), rateChanged)
vat.setRate(<span class="number">17.5</span>)
vat.setRate(<span class="number">8.5</span>)
</code></pre><p>多个信号连接到同一个槽时，如何确定谁调用了槽。</p>
<pre><code><span class="literal">self</span>.connect(button2, SIGNAL(<span class="string">"clicked()"</span>),
             partial(<span class="literal">self</span>.<span class="literal">any</span>Button, <span class="string">"Two"</span>)) <span class="comment"># WRONG for PyQt 4.0-4.2</span>
<span class="literal">self</span>.connect(button3, SIGNAL(<span class="string">"clicked()"</span>),
             lambda who=<span class="string">"Three"</span>: <span class="literal">self</span>.<span class="literal">any</span>Button(who)) <span class="comment"># WRONG before 4.1.1</span>
</code></pre><p>在PyQt4.3之前，在<code>connect</code>中创建的函数，在<code>connect</code>返回时被垃圾回收。因此需要保存一个引用到该函数。<br>在PyQt4.1.1之前，在<code>connect</code>中创建的<code>lambda</code>也会被垃圾回收，同样需要保存一个引用。</p>
<pre><code>self<span class="class">.button2callback</span> = <span class="function"><span class="title">partial</span><span class="params">(self.anyButton, <span class="string">"Two"</span>)</span></span>
self.<span class="function"><span class="title">connect</span><span class="params">(button2, SIGNAL(<span class="string">"clicked()"</span>)</span></span>, self.button2callback)

self<span class="class">.button3callback</span> = lambda who=<span class="string">"Three"</span>: self.<span class="function"><span class="title">anyButton</span><span class="params">(who)</span></span>
self.<span class="function"><span class="title">connect</span><span class="params">(button3, SIGNAL(<span class="string">"clicked()"</span>)</span></span>, self.button3callback)
</code></pre><p>另外一种方法是使用<code>sender</code>告诉我们是哪个对象。</p>
<pre><code>self.connect(button4, SIGNAL(<span class="string">"clicked()"</span>), self.clicked)
self.connect(button5, SIGNAL(<span class="string">"clicked()"</span>), self.clicked)
<span class="function"><span class="keyword">def</span> <span class="title">clicked</span><span class="params">(self)</span>:</span>
    button = self.sender()
    <span class="keyword">if</span> button <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> <span class="keyword">not</span> isinstance(button, QPushButton):
        <span class="keyword">return</span>
    self.label.setText(<span class="string">"You clicked button '%s'"</span> % button.text())
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="一个25行的弹出警告">一个25行的弹出警告</h1><pre><code><span class="keyword">import</span> sys
<span class="keyword">import</span> time
<span class="]]>
    </summary>
    
      <category term="PyQt" scheme="https://opensvn.github.io/tags/PyQt/"/>
    
      <category term="Python" scheme="https://opensvn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PyQt编程第一章 数据类型和数据结构]]></title>
    <link href="https://opensvn.github.io/2015/10/12/pyqt-1/"/>
    <id>https://opensvn.github.io/2015/10/12/pyqt-1/</id>
    <published>2015-10-12T10:57:23.000Z</published>
    <updated>2015-10-14T03:34:21.602Z</updated>
    <content type="html"><![CDATA[<h1 id="执行Python代码">执行Python代码</h1><pre><code><span class="built_in">print</span> <span class="string">'Hello world'</span>
</code></pre><p><code>Python</code>读取<code>.py</code>或<code>.pyw</code>文件到内存，解析文件，生成字节码，然后运行。<br>对于<code>import</code>的模块，<code>Python</code>首先检查是否存在预编译的字节码(<code>pyo</code>或<code>pyc</code>)，根据时间戳判断<br>是否需要重新编译。在大多数<code>Python</code>的安装过程中，提供的模块都被编译了，来避免使用时编译。</p>
<h1 id="变量和对象">变量和对象</h1><p><code>Python</code>变量没有类型限制(动态类型)，而且它们也不需要声明。</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; x = <span class="number">71</span>
<span class="prompt">&gt;&gt;</span>&gt; y = <span class="string">'Dove'</span>
</code></pre><p>变量是对象的引用，并不是对象本身。</p>
<blockquote>
<p><strong>函数，方法和操作符</strong><br>函数是可以独立执行的子例程。方法是只能绑定到一个对象执行的函数。操作符可以独立或绑定到对象，<br>但是不需要括号。</p>
</blockquote>
<p><code>Python</code>有两种比较对象的方式：通过<strong>身份</strong>和通过<strong>值</strong>。一个对象的身份是内存中的有效地址，<br>这也是对象引用所保存的值。如果使用比较操作符，如<code>==</code>和<code>&lt;</code>，是值的比较。如果使用<code>is</code>，则是<br>身份的比较，这种比较很快。一个对象的身份可以通过<code>id()</code>获取。</p>
<p><code>Python</code>有一个特殊对象<code>None</code>，可以赋值给任何变量，意思是没有值。<code>None</code>对象只有一个实例，<br>因此<code>is</code>和<code>is not</code>比较<code>None</code>总是很快。</p>
<p>将一个值赋值给一个变量称为绑定。如果赋值给一个已经存在的变量，称为重新绑定。一旦一个对象没有<br>名字绑定，则加入垃圾回收进程。</p>
<p><code>Python</code>变量名由<code>ASCII</code>字母，数字和下划线组成。变量名不应该与<code>Python</code>的关键字或内置常量<br>如<code>None</code>，<code>True</code>，<code>False</code>相同。</p>
<h1 id="数字和字符串">数字和字符串</h1><p><code>Python</code>提供了几种数字类型和两种字符串类型。这些类型都是不可变的。</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; x = <span class="number">5</span>
<span class="prompt">&gt;&gt;</span>&gt; y = x
<span class="prompt">&gt;&gt;</span>&gt; x, y
(<span class="number">5</span>, <span class="number">5</span>)
<span class="prompt">&gt;&gt;</span>&gt; y += <span class="number">1</span>
<span class="prompt">&gt;&gt;</span>&gt; x, y
(<span class="number">5</span>, <span class="number">6</span>)
</code></pre><p>增量赋值操作符应用到不可变对象只是一个语法糖：它并没有改变对象，而是创建了一个新对象，并重新<br>绑定到新对象。</p>
<p>我们需要记住<code>=</code>操作符执行绑定操作而不是赋值。</p>
<h2 id="整数和长整数">整数和长整数</h2><p><code>Python</code>提供3种整数类型：<code>bool</code>，<code>int</code>，<code>long</code>。<br><code>bool</code>类型的值只能是<code>True</code>和<code>False</code>。当用于数字环境时，被当作1和0。<br><code>long</code>类型的长度只局限于机器的可用内存。<br><code>int</code>类型的长度和大多数语言的一样。当<code>int</code>类型有溢出危险时，自动提升为<code>long</code>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="执行Python代码">执行Python代码</h1><pre><code><span class="built_in">print</span> <span class="string">'Hello world'</span>
</code></pre><p>]]>
    </summary>
    
      <category term="PyQt" scheme="https://opensvn.github.io/tags/PyQt/"/>
    
      <category term="Python" scheme="https://opensvn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[面向对象编程]]></title>
    <link href="https://opensvn.github.io/2015/09/21/cpp_primer_15/"/>
    <id>https://opensvn.github.io/2015/09/21/cpp_primer_15/</id>
    <published>2015-09-21T01:04:53.000Z</published>
    <updated>2015-10-14T08:23:00.082Z</updated>
    <content type="html"><![CDATA[<p>面向对象编程是基于三个基本概念：数据抽象，继承和动态绑定。</p>
<h1 id="OOP概述">OOP概述</h1><h2 id="继承">继承</h2><p>通过继承联系的类构成一个层级关系。典型地，有一个基类在层级的顶端，其它类直接或间接继承这个类。<br>这些继承类被称为派生类。基类定义层级中共同的成员。每一个派生类定义它自己特定的成员。</p>
<pre><code><span class="keyword">class</span> Quote {
<span class="keyword">public</span>:
    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span></span>;
    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::size_t n)</span> <span class="keyword">const</span></span>;
};
</code></pre><p>派生类必须指定继承自哪个（或哪些）基类。继承列表是逗号分隔的包含可选访问限定符的基类列表。</p>
<pre><code><span class="keyword">class</span> Bulk_quote : <span class="keyword">public</span> Quote { <span class="comment">// Bulk_quote继承自Quote</span>
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::size_t)</span> <span class="keyword">const</span> override</span>;
};
</code></pre><p>派生类必须在类定义里面包含所有它想定义的虚函数的声明。派生类可以声明这些函数为virtual，但没有<br>要求这么做。新标准让派生类可以显式指定想要覆盖的虚函数，在参数列表后面指定<code>override</code>就可以。</p>
<h2 id="动态绑定">动态绑定</h2><pre><code><span class="function"><span class="keyword">double</span> <span class="title">print_total</span><span class="params">(ostream &amp;os,
                   <span class="keyword">const</span> Quote &amp;item, size_t n)</span>
</span>{
    <span class="comment">// 取决于绑定到item参数的类型调用Quote::net_price或Bulk_quote::net_price</span>
    <span class="keyword">double</span> ret = item.net_price(n);
    os &lt;&lt; <span class="string">"ISBN: "</span> &lt;&lt; item.isbn() <span class="comment">// 调用Quote::isbn</span>
       &lt;&lt; <span class="string">" # sold: "</span> &lt;&lt; n &lt;&lt; <span class="string">" total due: "</span> &lt;&lt; ret &lt;&lt; endl;
     <span class="keyword">return</span> ret;
}

<span class="comment">// basic是Quote类型; bulk是Bulk_quote类型</span>
print_total(<span class="built_in">cout</span>, basic, <span class="number">20</span>); <span class="comment">// 调用Quote::net_price</span>
print_total(<span class="built_in">cout</span>, bulk, <span class="number">20</span>);  <span class="comment">// 调用Bulk_quote::net_price</span>
</code></pre><p>因为运行哪个函数取决于参数的类型的决定直到运行时才能确定，因此动态绑定又叫运行时绑定。</p>
<blockquote>
<p><strong>注解</strong><br>在C++中，动态绑定发生在通过基类的引用或指针调用虚函数时。</p>
</blockquote>
<h1 id="定义基类和派生类">定义基类和派生类</h1><h2 id="定义一个基类">定义一个基类</h2><pre><code><span class="keyword">class</span> Quote {
<span class="keyword">public</span>:
    Quote() = <span class="keyword">default</span>;
    Quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;book, <span class="keyword">double</span> sales_price):
                     bookNo(book), price(sales_price) { }
    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> bookNo; }
    <span class="comment">// 派生类将覆盖和应用不同的打折策略</span>
    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::size_t n)</span> <span class="keyword">const</span>
               </span>{ <span class="keyword">return</span> n * price; }
    <span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>; <span class="comment">// 析构函数动态绑定</span>
<span class="keyword">private</span>:
    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;
<span class="keyword">protected</span>:
    <span class="keyword">double</span> price = <span class="number">0.0</span>;
};
</code></pre><blockquote>
<p><strong>注解</strong><br>基类通常应该定义一个虚析构函数，即使没有什么工作要做。</p>
</blockquote>
<h3 id="成员函数和继承">成员函数和继承</h3><p>基类将那些期望派生类覆盖的函数定义为虚函数。<br>任何非<code>static</code>的成员函数，除了构造函数，可以为虚函数。关键字<code>virtual</code>仅仅出现在类里面声明处，<br>在类外面函数定义处不需要出现。基类中声明为<code>virtual</code>的函数，在派生类中隐式为<code>virtual</code>。</p>
<h3 id="访问控制和继承">访问控制和继承</h3><p>派生类继承基类的成员，但是派生类的成员函数不能访问基类的私有成员。有时候基类允许派生类访问而又<br>禁止其他用户使用，我们指定这类成员为<code>protected</code>。</p>
<h2 id="定义一个派生类">定义一个派生类</h2><p>派生类必须指定继承自哪个类，子类在类继承列表中指定基类。类继承列表由逗号分隔的基类名组成，每个<br>基类名前面可能有<code>public</code>，<code>protected</code>，<code>private</code>其中一个。<br>派生类必须声明每一个想要覆盖的成员函数。</p>
<pre><code><span class="keyword">class</span> Bulk_quote : <span class="keyword">public</span> Quote { <span class="comment">// Bulk_quote继承自Quote</span>
    Bulk_quote() = <span class="keyword">default</span>;
    Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;, <span class="keyword">double</span>, <span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="keyword">double</span>);
    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::size_t)</span> <span class="keyword">const</span> override</span>;
<span class="keyword">private</span>:
    <span class="built_in">std</span>::<span class="keyword">size_t</span> min_qty = <span class="number">0</span>; <span class="comment">// 打折需要的最小购买量</span>
    <span class="keyword">double</span> discount = <span class="number">0.0</span>;   <span class="comment">// 折扣</span>
};
</code></pre><p>当继承为<code>public</code>时，基类的<code>public</code>成员成为派生类的接口。另外，我们能将<code>public</code>继承的派生<br>类对象绑定到基类的指针或引用。</p>
<p>大多数类直接继承一个基类，这种继承称为单继承，继承超过一个基类称为多继承。</p>
<h3 id="派生类中的虚函数">派生类中的虚函数</h3><p>派生类经常但不总是覆盖它们继承的虚函数。如果派生类不覆盖虚函数，则像其它成员一样，继承基类的版本。<br>参数列表后面，或<code>const</code>或引用限定符后面指定<code>override</code>覆盖虚函数。</p>
<h3 id="派生类对象和派生类到基类的转换">派生类对象和派生类到基类的转换</h3><p>派生类对象包含了多个部分：一个子对象包含派生类自己定义的非<code>static</code>成员，加上一个从基类继承而来<br>的相应的子对象。</p>
<p>因为派生类对象包含对应于基类的子部分，我们可以使用子类就好像它是基类一样。特别地，我们可以将子类<br>对象绑定到基类的引用或指针。</p>
<pre><code><span class="label">Quote</span> <span class="keyword">item; </span>       // 基类对象
<span class="keyword">Bulk_quote </span><span class="keyword">bulk; </span>  // 子类对象
<span class="label">Quote</span> *p = &amp;<span class="keyword">item; </span> // 指向基类的指针
p = &amp;<span class="keyword">bulk; </span>        // p指向<span class="keyword">bulk的Quote部分
</span><span class="label">Quote</span> &amp;r = <span class="keyword">bulk; </span>  // r绑定到<span class="keyword">bulk的Quote部分</span>
</code></pre><p>这种转换称为派生类到基类的转换。和其它转换一样，编译器隐式应用派生类到基类的转换。</p>
<blockquote>
<p><strong>注解</strong><br>派生类对象包含基类的子对象是继承如何工作的关键。</p>
</blockquote>
<h3 id="派生类构造函数">派生类构造函数</h3><p>尽管派生类对象包含从基类继承的成员，但是派生类不能直接初始化这些成员。派生类必须使用基类的构造函数<br>初始化基类部分。</p>
<blockquote>
<p><strong>注解</strong><br>每一个类控制它的成员如何初始化。</p>
</blockquote>
<pre><code>Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> p,
           <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc) :
           Quote(book, p), min_qty(qty), discount(disc) { }
    <span class="comment">// as before</span>
};
</code></pre><blockquote>
<p><strong>注解</strong><br>基类成员先初始化，然后按声明的顺序初始化派生类的成员。</p>
</blockquote>
<h3 id="在派生类中使用基类的成员">在派生类中使用基类的成员</h3><p>派生类可以使用基类的<code>public</code>和<code>protected</code>成员：</p>
<pre><code><span class="comment">// 如果购买了指定数量的商品，使用折扣价格</span>
<span class="keyword">double</span> Bulk_quote::net_price(<span class="keyword">size_t</span> cnt) <span class="keyword">const</span>
{
    <span class="keyword">if</span> (cnt &gt;= min_qty)
        <span class="keyword">return</span> cnt * (<span class="number">1</span> - discount) * price;
    <span class="keyword">else</span>
        <span class="keyword">return</span> cnt * price;
}
</code></pre><p>值得知道的是派生类的作用域嵌套在基类作用域里面。因此派生类使用基类和自己的成员没有差别。</p>
<blockquote>
<p><strong>关键概念</strong>:尊重基类的接口<br>派生类构造函数可以对基类的<code>public</code>和<code>protected</code>成员赋值。尽管如此，通常不应该这么做。像基类<br>的其他用户一样，派生类应该尊重基类的接口，使用基类的构造函数初始化基类部分成员。</p>
</blockquote>
<h3 id="继承和static成员">继承和static成员</h3><p>如果基类定义了<code>static</code>成员，那么在整个继承层次中只有一个这样的成员。不管有多少个派生类，每一个<br><code>static</code>成员只有一个实例。</p>
<pre><code><span class="keyword">class</span> Base {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">statmem</span><span class="params">()</span></span>;
};
<span class="keyword">class</span> Derived : <span class="keyword">public</span> Base {
    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Derived&amp;)</span></span>;
};
<span class="keyword">void</span> Derived::f(<span class="keyword">const</span> Derived &amp;derived_obj)
{
    Base::statmem();    <span class="comment">// ok: Base定义了statmem</span>
    Derived::statmem(); <span class="comment">// ok: Derived继承类statmem</span>
    <span class="comment">// ok: 派生类对象可以访问基类的static成员</span>
    derived_obj.statmem();
    statmem();
}
</code></pre><h3 id="派生类的声明">派生类的声明</h3><p>派生类的声明和其它类一样。声明包含类名字但不包括派生列表：</p>
<pre><code><span class="keyword">class</span> <span class="title">Bulk_quote</span> : <span class="title">public</span> <span class="title">Quote</span>; <span class="comment">// error: 派生列表不能出现在这</span>
<span class="keyword">class</span> <span class="title">Bulk_quote</span>; <span class="comment">// ok: 声明派生类的正确方式</span>
</code></pre><h3 id="作为基类使用的类">作为基类使用的类</h3><p>在使用类作为基类前，一个类必须定义，而不仅仅是声明：</p>
<pre><code><span class="keyword">class</span> <span class="title">Quote</span>;   <span class="comment">// 声明但是未定义</span>
<span class="comment">// error: Quote必须定义</span>
<span class="keyword">class</span> <span class="title">Bulk_quote</span> : <span class="title">public</span> <span class="title">Quote</span> { ... };
</code></pre><p>这个规则暗示我们一个类不可能继承自己。</p>
<h3 id="阻止继承">阻止继承</h3><p>在新标准下，我们可以在类名后面跟着<code>final</code>阻止类被继承：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">NoDerived</span> <span class="title">final</span> </span>{ <span class="comment">/*  */</span> }; <span class="comment">// NoDerived不能作为基类</span>
<span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>{ <span class="comment">/*  */</span> };
<span class="class"><span class="keyword">class</span> <span class="title">Last</span> <span class="title">final</span> : <span class="title">Base</span> </span>{ <span class="comment">/*  */</span> }; <span class="comment">// Last不能作为基类</span>
<span class="class"><span class="keyword">class</span> <span class="title">Bad</span> : <span class="title">NoDerived</span> </span>{ <span class="comment">/*  */</span> };   <span class="comment">// error: NoDerived is final</span>
<span class="class"><span class="keyword">class</span> <span class="title">Bad2</span> : <span class="title">Last</span> </span>{ <span class="comment">/*  */</span> };       <span class="comment">// error: Last is final</span>
</code></pre><h2 id="转换和继承">转换和继承</h2><blockquote>
<p><strong>警告</strong><br>理解基类和派生类之间的转换是理解C++面向对象编程如何工作的基础</p>
</blockquote>
<p>通常我们只能绑定指针或引用到相同类型的对象上或者需要一个可接受的转换。<br>可以将基类的引用或指针绑定到一个派生类对象的事实暗示：当我们使用基类的指针或引用时，我们不知道指针<br>或引用绑定的对象的实际类型。这个对象可以是基类对象或派生类对象。</p>
<blockquote>
<p><strong>注解</strong><br>像内置指针一样，智能指针支持派生类到基类的转换。</p>
</blockquote>
<h3 id="静态类型和动态类型">静态类型和动态类型</h3><p>静态类型是变量声明的类型或表达式产生的类型，在编译期间就已经知道了。<br>动态类型是变量或表达式表示的内存中对象的类型，运行时才知道。</p>
<p>不是指针或引用的表达式的动态类型总是和静态类型一样。</p>
<blockquote>
<p><strong>注解</strong><br>理解基类的指针或引用的静态类型与动态类型可能不一样很重要。</p>
</blockquote>
<h3 id="没有基类到派生类的隐式转换">没有基类到派生类的隐式转换</h3><pre><code><span class="label">Quote</span> <span class="keyword">base;
</span><span class="keyword">Bulk_quote* </span><span class="keyword">bulkP </span>= &amp;<span class="keyword">base; </span> // error: can<span class="string">'t convert base to derived
Bulk_quote&amp; bulkRef = base; // error: can'</span>t convert <span class="keyword">base </span>to derived
</code></pre><p>令人惊讶地是，我们也不能将基类转换到派生类，即使基类指针或引用绑定的是派生类对象：</p>
<pre><code><span class="keyword">Bulk_quote </span><span class="keyword">bulk;
</span><span class="label">Quote</span> *<span class="keyword">itemP </span>= &amp;<span class="keyword">bulk; </span>       // ok: dynamic type is <span class="keyword">Bulk_quote
</span><span class="keyword">Bulk_quote </span>*<span class="keyword">bulkP </span>= <span class="keyword">itemP; </span>  // error: can<span class="string">'t convert base to derived</span>
</code></pre><h3 id="也没有对象间的转换">也没有对象间的转换</h3><p>派生类到基类的自动转换只发生在引用或指针类型的转换。派生类和基类之间没有这种转换。</p>
<pre><code>Bulk_quote bulk;  <span class="comment"> // object of derived type</span>
Quote <span class="keyword">item</span>(bulk); <span class="comment"> // uses the Quote::Quote(const Quote&amp;) constructor</span>
<span class="keyword">item</span> = bulk;      <span class="comment"> // calls Quote::operator=(const Quote&amp;)</span>
</code></pre><blockquote>
<p><strong>警告</strong><br>当我们用一个派生类对象给一个基类对象初始化或赋值时，只有基类部分复制，移动或赋值了，派生类部分被<br>忽略了。</p>
<p><strong>关键概念</strong>：继承相关的类型转换</p>
<ul>
<li>继承类到基类的转换只发生在指针或引用类型</li>
<li>没有基类到继承类的隐式转换</li>
<li>像其它成员一样，继承类到基类的转换可能因为访问控制的原因不能访问。</li>
</ul>
</blockquote>
<h1 id="虚函数">虚函数</h1><p>因为运行之前我们不知道哪个函数会调用，虚函数必须总是定义了的。</p>
<h2 id="虚函数调用可能在运行时确定">虚函数调用可能在运行时确定</h2><p>动态绑定仅仅发生在通过指针或引用调用虚函数。</p>
<pre><code><span class="keyword">base</span> = derived;         <span class="comment">// 从derived拷贝Quote部分到base </span>
<span class="keyword">base</span>.net_price(<span class="number">20</span>);     <span class="comment">// 调用Quote::net_price</span>
</code></pre><p>当我们在一个表达式中用一个非引用且非指针的普通类型调用虚函数时，绑定发生在编译期间。</p>
<blockquote>
<p><strong>关键概念</strong>：C++中的多态<br>指针和引用的动态类型和静态类型可以不同是C++支持多态的基石。</p>
<p><strong>注解</strong><br>运行期间确定虚函数仅当通过指针或引用的调用。只有这些情况下，对象的动态类型才可能和静态类型不同。</p>
</blockquote>
<h2 id="派生类的虚函数">派生类的虚函数</h2><p>当派生类覆盖了一个虚函数时，声明时可以重复<code>virtual</code>关键字，但是没有要求这样做。一旦一个函数被<br>声明为<code>virtual</code>，这个函数在所有继承类中都是<code>virtual</code>。</p>
<p>派生类中的虚函数必须和基类中虚函数参数一样。除了一个例外，派生类虚函数的返回类型也必须和基类一样。<br>这个例外就是返回类型为和继承相关的指针或引用。</p>
<blockquote>
<p><strong>注解</strong><br>基类中的虚函数在继承类中隐式为<code>virtual</code>。当派生类覆盖一个虚函数，参数必须和基类一样。</p>
</blockquote>
<h2 id="final和override限定符">final和override限定符</h2><p>继承类定义一个和基类虚函数同名但是参数不同的函数是合法的。编译器认为这样的函数独立于基类的虚函数。</p>
<p>新标准下我们可以在继承类中指定虚函数为<code>override</code>。编译器会拒绝程序如果函数标为<code>override</code>却<br>没有覆盖一个已存在的虚函数。</p>
<pre><code><span class="keyword">struct</span> B {
    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span>(<span class="params"><span class="keyword">int</span></span>) <span class="keyword">const</span></span>;
    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span>(<span class="params"></span>)</span>;
    <span class="function"><span class="keyword">void</span> <span class="title">f3</span>(<span class="params"></span>)</span>;
};
<span class="keyword">struct</span> D1 : B {
    <span class="function"><span class="keyword">void</span> <span class="title">f1</span>(<span class="params"><span class="keyword">int</span></span>) <span class="keyword">const</span> <span class="keyword">override</span></span>; <span class="comment">// ok: f1 matches f1 in the base</span>
    <span class="function"><span class="keyword">void</span> <span class="title">f2</span>(<span class="params"><span class="keyword">int</span></span>) <span class="keyword">override</span></span>; <span class="comment">// error: B has no f2(int) function</span>
    <span class="function"><span class="keyword">void</span> <span class="title">f3</span>(<span class="params"></span>) <span class="keyword">override</span></span>;    <span class="comment">// error: f3 not virtual</span>
    <span class="function"><span class="keyword">void</span> <span class="title">f4</span>(<span class="params"></span>) <span class="keyword">override</span></span>;    <span class="comment">// error: B doesn't have a function named f4</span>
};
</code></pre><p>我们也可以将一个函数指定为<code>final</code>。任何试图覆盖一个被定义为<code>final</code>的函数都被视为错误：</p>
<pre><code><span class="keyword">struct</span> D2 : B {
    <span class="comment">// inherits f2() and f3() from B and overrides f1(int)</span>
    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> final</span>; <span class="comment">// 后续子类不能覆盖f1(int)</span>
};
<span class="keyword">struct</span> D3 : D2 {
    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>; <span class="comment">// ok: overrides f2 inherited from the indirect base, B</span>
    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>; <span class="comment">// error: D2 declared f2 as final</span>
};
</code></pre><p><code>final</code>和<code>override</code>限定符出现在参数列表（包含const或引用修饰符）和尾返回之后。</p>
<h2 id="虚函数和默认实参">虚函数和默认实参</h2><p>如果一个函数调用使用默认实参，被使用的值是函数定义的静态类型的值。</p>
<blockquote>
<p><strong>最佳实践</strong><br>包含默认实参的虚函数应该在基类和派生类中使用相同的默认实参。</p>
</blockquote>
<h2 id="避开虚机制">避开虚机制</h2><p>我们可以使用<code>::</code>操作符强制调用指定版本的虚函数。</p>
<pre><code><span class="comment">// 调用基类版本，不管baseP的动态类型</span>
<span class="keyword">double</span> undiscounted = baseP-&gt;Quote::net_price(<span class="number">42</span>);
</code></pre><blockquote>
<p><strong>注解</strong><br>通常，只有成员函数或友元函数里面的代码应该使用作用域操作符来避开虚机制。</p>
<p><strong>警告</strong><br>如果继承类虚函数想要调用基类版本的虚函数，却忽略了作用域操作符，将会导致无限递归。</p>
</blockquote>
<h1 id="虚基类">虚基类</h1><h2 id="纯虚函数">纯虚函数</h2><p>和普通的虚函数不一样的是，纯虚函数没有必要定义。虚函数写上<code>= 0</code>替代函数体成为纯虚函数。<code>= 0</code>只<br>出现在类里面函数声明处。</p>
<pre><code><span class="comment">// class to hold the discount rate and quantity</span>
<span class="comment">// derived classes will implement pricing strategies using these data</span>
<span class="keyword">class</span> Disc_quote : <span class="keyword">public</span> Quote {
<span class="keyword">public</span>:
    Disc_quote() = <span class="keyword">default</span>;
    Disc_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> price,
              <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc):
                 Quote(book, price),
                 quantity(qty), discount(disc) { }
    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::size_t)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;
<span class="keyword">protected</span>:
    <span class="built_in">std</span>::<span class="keyword">size_t</span> quantity = <span class="number">0</span>; <span class="comment">//  purchase size for the discount to apply</span>
    <span class="keyword">double</span> discount = <span class="number">0.0</span>;    <span class="comment">//  fractional discount to apply</span>
};
</code></pre><p>值得注意的是我们可以提供纯虚函数的定义，但是必须定义在类外面。</p>
<h2 id="有纯虚函数的类为虚基类">有纯虚函数的类为虚基类</h2><p>包含纯虚函数的类（或继承而没有覆盖）是虚基类。虚基类为后续的子类定义了可覆盖的接口。不能直接创建<br>虚基类的对象。</p>
<pre><code>// Disc_quote定义了<span class="keyword">Bulk_quote将要覆盖的纯虚函数
</span><span class="label">Disc_quote</span> discounted<span class="comment">; // error: can't define a Disc_quote object</span>
<span class="keyword">Bulk_quote </span><span class="keyword">bulk; </span>      // ok: <span class="keyword">Bulk_quote </span>has no pure virtual functions
</code></pre><h2 id="派生类构造函数只初始化其直接基类">派生类构造函数只初始化其直接基类</h2><p>每一个类控制自己类对象的初始化。</p>
<blockquote>
<p><strong>关键概念：重构</strong><br>重构在面向对象程序里面很常见。</p>
</blockquote>
<h1 id="访问控制和继承-1">访问控制和继承</h1><h2 id="protected成员">protected成员</h2><p><code>protected</code>限定符可以被认为是<code>private</code>和<code>public</code>的混合：</p>
<ul>
<li>像<code>private</code>，<code>protected</code>成员对类用户是不可访问的。</li>
<li>像<code>public</code>，<code>protected</code>成员对派生类的成员和友元是可访问的。</li>
</ul>
<p>另外，<code>protected</code>有一个重要性质：</p>
<ul>
<li>派生类成员或友元只能通过派生类对象访问基类的<code>protected</code>成员。派生类没有权限访问基类<br><code>protected</code>成员。</li>
</ul>
<pre><code><span class="keyword">class</span> Base {
<span class="keyword">protected</span>:
    <span class="keyword">int</span> prot_mem;     <span class="comment">// protected member</span>
};
<span class="keyword">class</span> Sneaky : <span class="keyword">public</span> Base  {
    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;  <span class="comment">// can access Sneaky::prot_mem</span>
    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base&amp;)</span></span>;    <span class="comment">// can't access Base::prot_mem</span>
    <span class="keyword">int</span> j;                          <span class="comment">// j is private by default</span>
};
<span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span> </span>{ s.j = s.prot_mem = <span class="number">0</span>; } <span class="comment">// ok</span>
<span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span> </span>{ b.prot_mem = <span class="number">0</span>; } <span class="comment">// error</span>
</code></pre><h2 id="public，private和protected继承">public，private和protected继承</h2><p>继承类成员的访问由基类中该成员访问控制符和派生列表访问控制符共同控制。</p>
<pre><code><span class="keyword">class</span> <span class="title">Base</span> {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">void</span> <span class="title">pub_mem</span>(<span class="params"></span>)</span>;   <span class="comment">// public member</span>
<span class="keyword">protected</span>:
    <span class="keyword">int</span> prot_mem;     <span class="comment">// protected member</span>
<span class="keyword">private</span>:
    <span class="keyword">char</span> priv_mem;    <span class="comment">// private member</span>
};
<span class="keyword">struct</span> Pub_Derv : <span class="keyword">public</span> Base {
    <span class="comment">// ok: derived classes can access protected members</span>
    <span class="function"><span class="keyword">int</span> <span class="title">f</span>(<span class="params"></span>) </span>{ <span class="keyword">return</span> prot_mem; }
    <span class="comment">// error: private members are inaccessible to derived classes</span>
    <span class="function"><span class="keyword">char</span> <span class="title">g</span>(<span class="params"></span>) </span>{ <span class="keyword">return</span> priv_mem; }
};
<span class="keyword">struct</span> Priv_Derv : <span class="keyword">private</span> Base {
    <span class="comment">// private derivation doesn't affect access in the derived class</span>
    <span class="function"><span class="keyword">int</span> <span class="title">f1</span>(<span class="params"></span>) <span class="keyword">const</span> </span>{ <span class="keyword">return</span> prot_mem; }
};
</code></pre><p>派生类的访问控制符对派生类访问其直接基类的成员没有影响。基类成员的访问只由基类的访问控制符控制。<br>派生类的访问控制符是用来控制派生类使用者及子类对其成员的使用。</p>
<pre><code>Pub_Derv d1;   <span class="comment">//  members inherited from Base are public</span>
Priv_Derv d2;  <span class="comment">//  members inherited from Base are private</span>
d1.pub_mem();  <span class="comment">//  ok: pub_mem is public in the derived class</span>
d2.pub_mem();  <span class="comment">//  error: pub_mem is private in the derived class</span>

<span class="keyword">struct</span> Derived_from_Public : <span class="keyword">public</span> Pub_Derv {
    <span class="comment">// ok: Base::prot_mem remains protected in Pub_Derv</span>
    <span class="function"><span class="keyword">int</span> <span class="title">use_base</span><span class="params">()</span> </span>{ <span class="keyword">return</span> prot_mem; }
};
<span class="keyword">struct</span> Derived_from_Private : <span class="keyword">public</span> Priv_Derv {
    <span class="comment">// error: Base::prot_mem is private in Priv_Derv</span>
    <span class="function"><span class="keyword">int</span> <span class="title">use_base</span><span class="params">()</span> </span>{ <span class="keyword">return</span> prot_mem; }
};
</code></pre><h2 id="派生类到基类的转换的可访问性">派生类到基类的转换的可访问性</h2><p>假设D继承B：</p>
<ul>
<li>用户代码可以使用派生类到基类的转换当D公开继承B，私有继承或保护继承都不行。</li>
<li>D的成员函数和友元可以使用派生类到基类的转换而不管是如何继承的。派生类到直接基类的转换对于<br>派生类的成员和友元总是可以访问的。</li>
<li>从D派生的成员函数和友元能使用派生类到基类的转换当D公开或保护继承B，私有继承不行。</li>
</ul>
<blockquote>
<p><strong>提示</strong><br>在代码的任何地方，如果基类的<code>public</code>成员能够访问，则派生类到基类的转换可以访问，反过来不行。</p>
</blockquote>
<h2 id="友元和继承">友元和继承</h2><p>就像友元不能传递，友元也不能继承。</p>
<pre><code><span class="keyword">class</span> <span class="title">Base</span> {
    <span class="comment">// added friend declaration; other members as before</span>
    friend <span class="keyword">class</span> <span class="title">Pal</span>; <span class="comment">// Pal has no access to classes derived from Base</span>
};
<span class="keyword">class</span> <span class="title">Pal</span> {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">int</span> <span class="title">f</span>(<span class="params">Base b</span>) </span>{ <span class="keyword">return</span> b.prot_mem; } <span class="comment">// ok: Pal is a friend of</span>
<span class="function">Base
    <span class="keyword">int</span> <span class="title">f2</span>(<span class="params">Sneaky s</span>) </span>{ <span class="keyword">return</span> s.j; } <span class="comment">// error: Pal not friend of</span>
Sneaky
    <span class="comment">// access to a base class is controlled by the base class, even inside a derived</span>
<span class="function"><span class="keyword">object</span>
    <span class="keyword">int</span> <span class="title">f3</span>(<span class="params">Sneaky s</span>) </span>{ <span class="keyword">return</span> s.prot_mem; } <span class="comment">// ok: Pal is a friend</span>
};
</code></pre><p>当类A将类B作为友元时，只有类B被授予了友元关系。类B的基类或子类都没有A的特殊访问权限。</p>
<pre><code><span class="comment">// D2 has no access to protected or private members in Base</span>
<span class="keyword">class</span> D2 : <span class="keyword">public</span> Pal {
<span class="keyword">public</span>:
   <span class="function"><span class="keyword">int</span> <span class="title">mem</span><span class="params">(Base b)</span>
       </span>{ <span class="keyword">return</span> b.prot_mem; } <span class="comment">// error: friendship doesn't inherit</span>
};
</code></pre><blockquote>
<p><strong>注解</strong><br>友元关系不能继承，每一个类控制自己成员的访问。</p>
</blockquote>
<h2 id="免除个别成员访问规则">免除个别成员访问规则</h2><p>有时候需要改变派生类中成员的访问级别，可以使用<code>using</code>声明。</p>
<pre><code><span class="keyword">class</span> Base {
<span class="keyword">public</span>:
    <span class="built_in">std</span>::<span class="keyword">size_t</span> size() <span class="keyword">const</span> { <span class="keyword">return</span> n; }
<span class="keyword">protected</span>:
    <span class="built_in">std</span>::<span class="keyword">size_t</span> n;
};
<span class="keyword">class</span> Derived : <span class="keyword">private</span> Base {    <span class="comment">//  <span class="doctag">note:</span> private inheritance</span>
<span class="keyword">public</span>:
    <span class="comment">// maintain access levels for members related to the size of the object</span>
    <span class="keyword">using</span> Base::size;
<span class="keyword">protected</span>:
    <span class="keyword">using</span> Base::n;
};
</code></pre><p>因为Derived使用<code>private</code>继承，则继承的成员默认为<code>private</code>成员。<code>using</code>声明调整了这些成员的<br>可访问级别。</p>
<p><code>using</code>声明可以命名任何可访问的直接或间接基类的成员。访问由<code>using</code>声明的名字取决于<code>using</code>声明<br>之前的访问限定符。</p>
<blockquote>
<p><strong>注解</strong><br>派生类只为允许访问的名字提供<code>using</code>声明。</p>
</blockquote>
<h2 id="默认继承保护级别">默认继承保护级别</h2><p>默认地，<code>class</code>关键字定义的派生类使用<code>private</code>继承，<code>struct</code>定义的派生类使用<code>public</code>继承。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>{ <span class="comment">/* ...   */</span> };
<span class="class"><span class="keyword">struct</span> <span class="title">D1</span> : <span class="title">Base</span> </span>{ <span class="comment">/* ...   */</span> };   <span class="comment">// public inheritance by default</span>
<span class="class"><span class="keyword">class</span> <span class="title">D2</span> : <span class="title">Base</span> </span>{ <span class="comment">/* ...   */</span> };    <span class="comment">// private inheritance by default</span>
</code></pre><p>一个常见的误解是使用<code>struct</code>和<code>class</code>定义的类有深层次的不同。仅有的不同就是成员的默认访问级别<br>和派生类默认访问不同。没有其它差别。</p>
<blockquote>
<p><strong>最佳实践</strong><br>类私有继承必须显式指定<code>private</code>而不是依赖默认行为。显式指定可以清晰的说明<code>private</code>继承是有意<br>的而不是疏忽。</p>
</blockquote>
<h1 id="继承下的类作用域">继承下的类作用域</h1><p>每一个类定义自己的作用域，作用域里面定义其成员。在继承下，派生类的作用域嵌套在基类作用域里面。如果<br>一个名字在派生类作用域找不到，则搜索外围基类作用域。正是这种分层嵌套的类作用域允许派生类成员使用<br>基类成员就好像这些成员是派生类的一部分一样。</p>
<pre><code><span class="keyword">Bulk_quote </span><span class="keyword">bulk;
</span><span class="label">cout</span> &lt;&lt; <span class="keyword">bulk.isbn();</span>
</code></pre><p>isbn的名字查找如下：</p>
<ul>
<li>因为isbn被Bulk_quote对象调用，查找从类Bulk_quote开始，没有找到。</li>
<li>因为Bulk_quote继承自Disc_quote，接下来查找Disc_quote，还是没找到。</li>
<li>因为Disc_quote继承自Quote，接下来查找Quote，找到了。</li>
</ul>
<h2 id="名字查找发生在编译时">名字查找发生在编译时</h2><p>对象，引用或指针的静态类型决定了对象的哪个成员可见，甚至当静态类型和动态类型不一样时。</p>
<pre><code><span class="keyword">class</span> Disc_quote : <span class="keyword">public</span> Quote {
<span class="keyword">public</span>:
    <span class="built_in">std</span>::pair&lt;<span class="keyword">size_t</span>, <span class="keyword">double</span>&gt; discount_policy() <span class="keyword">const</span>
        { <span class="keyword">return</span> {quantity, discount}; }
    <span class="comment">// other members as before</span>
};

Bulk_quote bulk;
Bulk_quote *bulkP = &amp;bulk; <span class="comment">//  static and dynamic types are the same</span>
Quote *itemP = &amp;bulk;      <span class="comment">//  static and dynamic types differ</span>
bulkP-&gt;discount_policy();  <span class="comment">//  ok: bulkP has type Bulk_quote*</span>
itemP-&gt;discount_policy();  <span class="comment">//  error: itemP has type Quote*</span>
</code></pre><blockquote>
<p><strong>关键概念</strong>：名字查找和继承<br>给定调用p-&gt;mem()或obj.mem()</p>
<ul>
<li>首先确定p的静态类型。因为调用了一个成员，p一定指向一个类类型。</li>
<li>查找p静态类型相应的成员mem，如果没找到，则继续在继承层级中找。如果基类中都没找到，编译错误。</li>
<li>一旦mem找到了，执行正常的类型检查以确认调用是否合法。</li>
<li>假设调用合法，编译器再根据调用是否为虚函数来产生代码。</li>
</ul>
</blockquote>
<h2 id="名字冲突和继承">名字冲突和继承</h2><p>和其它作用域一样，继承类可以重用其直接或间接基类中的一个名字。和往常一样，定义在内部作用域的名字，<br>隐藏了外部作用域名字的使用。</p>
<pre><code><span class="keyword">struct</span> Base {
    Base(): mem(<span class="number">0</span>) { }
<span class="keyword">protected</span>:
    <span class="keyword">int</span> mem;
};
<span class="keyword">struct</span> Derived : Base {
    Derived(<span class="keyword">int</span> i): mem(i) { } <span class="comment">// initializes Derived::mem to i</span>
                               <span class="comment">// Base::mem is default initialized</span>
    <span class="function"><span class="keyword">int</span> <span class="title">get_mem</span><span class="params">()</span> </span>{ <span class="keyword">return</span> mem; }  <span class="comment">// returns Derived::mem</span>
<span class="keyword">protected</span>:
    <span class="keyword">int</span> mem;   <span class="comment">// hides mem in the base</span>
};
</code></pre><blockquote>
<p><strong>注解</strong><br>与基类成员同名的派生类成员隐藏了基类成员的直接使用。</p>
</blockquote>
<h2 id="使用作用域操作符使用隐藏成员">使用作用域操作符使用隐藏成员</h2><pre><code><span class="keyword">struct</span> Derived : Base {
    <span class="function"><span class="keyword">int</span> <span class="title">get_base_mem</span><span class="params">()</span> </span>{ <span class="keyword">return</span> Base::mem; }
    <span class="comment">// ...</span>
};
</code></pre><blockquote>
<p><strong>最佳实践</strong><br>除了覆盖继承的虚函数，基类通常不应该重用已经在基类中定义过的名字。</p>
</blockquote>
<h2 id="名字查找发生在类型检查之前">名字查找发生在类型检查之前</h2><p>定义在派生类的同名函数不重载基类的函数。基类成员被隐藏了，即使参数列表不一样。</p>
<pre><code><span class="keyword">struct</span> Base {
    <span class="function"><span class="keyword">int</span> <span class="title">memfcn</span><span class="params">()</span></span>;
};
<span class="keyword">struct</span> Derived : Base {
    <span class="function"><span class="keyword">int</span> <span class="title">memfcn</span><span class="params">(<span class="keyword">int</span>)</span></span>;   <span class="comment">// hides memfcn in the base</span>
};
Derived d; Base b;
b.memfcn();       <span class="comment">//  calls Base::memfcn</span>
d.memfcn(<span class="number">10</span>);     <span class="comment">//  calls Derived::memfcn</span>
d.memfcn();       <span class="comment">//  error: memfcn with no arguments is hidden</span>
d.Base::memfcn(); <span class="comment">//  ok: calls Base::memfcn</span>
</code></pre><h2 id="虚函数和作用域">虚函数和作用域</h2><p>我们现在可以理解为什么派生类和基类中的虚函数必须有一样的参数列表。如果基类和派生类中虚函数参数不<br>一样，那么没有办法通过基类的引用或指针调用派生类虚函数。</p>
<pre><code><span class="keyword">class</span> Base {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span></span>;
};
<span class="keyword">class</span> D1 : <span class="keyword">public</span> Base {
<span class="keyword">public</span>:
    <span class="comment">// hides fcn in the base; this fcn is not virtual</span>
    <span class="comment">// D1 inherits the definition of Base::fcn()</span>
    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span></span>;      <span class="comment">// parameter list differs from fcn in Base</span>
    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>; <span class="comment">// new virtual function that does not exist in Base</span>
};
<span class="keyword">class</span> D2 : <span class="keyword">public</span> D1 {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// nonvirtual function hides D1::fcn(int)</span>
    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span></span>;    <span class="comment">// overrides virtual fcn from Base</span>
    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;    <span class="comment">// overrides virtual f2 from D1</span>
};

Base bobj;  D1 d1obj; D2 d2obj;
Base *bp1 = &amp;bobj, *bp2 = &amp;d1obj, *bp3 = &amp;d2obj;
bp1-&gt;fcn(); <span class="comment">// virtual call, will call Base::fcn at run time</span>
bp2-&gt;fcn(); <span class="comment">// virtual call, will call Base::fcn at run time</span>
bp3-&gt;fcn(); <span class="comment">// virtual call, will call D2::fcn at run time</span>
D1 *d1p = &amp;d1obj; D2 *d2p = &amp;d2obj;
bp2-&gt;f2(); <span class="comment">// error: Base has no member named f2</span>
d1p-&gt;f2(); <span class="comment">// virtual call, will call D1::f2() at run time</span>
d2p-&gt;f2(); <span class="comment">// virtual call, will call D2::f2() at run time</span>

Base *p1 = &amp;d2obj; D1 *p2 = &amp;d2obj; D2 *p3 =  &amp;d2obj;
p1-&gt;fcn(<span class="number">42</span>);  <span class="comment">// error: Base has no version of fcn that takes an int</span>
p2-&gt;fcn(<span class="number">42</span>);  <span class="comment">// statically bound, calls D1::fcn(int)</span>
p3-&gt;fcn(<span class="number">42</span>);  <span class="comment">// statically bound, calls D2::fcn(int)</span>
</code></pre><h2 id="覆盖重载函数">覆盖重载函数</h2><p>派生类可以覆盖0个或多个继承的重载函数。如果派生类想要使所有重载版本可用，则必须覆盖所有的函数或<br>所有函数不覆盖。</p>
<p>有时候只想覆盖一些重载函数，派生类可以提供一个<code>using</code>声明给重载的成员。一个<code>using</code>声明指示指定<br>一个名字，不带参数列表。因此，<code>using</code>声明将基类的重载函数都加到派生类的作用域。派生类只需定义<br>那些想要覆盖的函数。</p>
<h1 id="构造函数和复制控制">构造函数和复制控制</h1><h2 id="虚析构函数">虚析构函数</h2><p>继承给基类的复制控制主要的直接影响是基类通常应该定义一个虚析构函数。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> </span>{
<span class="keyword">public</span>:
    <span class="comment">// virtual destructor needed if a base pointer pointing to a derived object is deleted</span>
    virtual ~Quote() = <span class="keyword">default</span>; <span class="comment">// dynamic binding for the destructor</span>
};

Quote *itemP = <span class="keyword">new</span> Quote;   <span class="comment">//  same static and dynamic type</span>
<span class="keyword">delete</span> itemP;               <span class="comment">//  destructor for Quote called</span>
itemP = <span class="keyword">new</span> Bulk_quote;     <span class="comment">//  static and dynamic types differ</span>
<span class="keyword">delete</span> itemP;               <span class="comment">//  destructor for Bulk_quote called</span>
</code></pre><blockquote>
<p><strong>警告</strong><br>如果基类析构函数不是<code>virtual</code>的， <code>delete</code>基类指针指向派生类对象是<code>undefined</code>。</p>
</blockquote>
<h3 id="虚析构函数关闭了合成的Move">虚析构函数关闭了合成的Move</h3><p>如果一个类定义了虚析构函数，即使是<code>= default</code>使用合成版本，则编译器不会合成<code>move</code>操作。</p>
<h2 id="合成复制控制和继承">合成复制控制和继承</h2><p>基类或派生类中合成的复制控制成员和任何其它合成的复制控制成员一样：逐个初始化，复制或销毁类成员。<br>另外，这些成员使用基类的相应操作初始化，复制或销毁其对象的直接基类部分。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>面向对象编程是基于三个基本概念：数据抽象，继承和动态绑定。</p>
<h1 id="OOP概述">OOP概述</h1><h2 id="继承">继承</h2><p>通过继承联系的类构成一个层级关系。典型地，有一个基类在层级的顶端，其它类直接或间接继承这个类。<br>这些继承类]]>
    </summary>
    
      <category term="C++" scheme="https://opensvn.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[重载操作和转换]]></title>
    <link href="https://opensvn.github.io/2015/09/20/cpp_primer_14/"/>
    <id>https://opensvn.github.io/2015/09/20/cpp_primer_14/</id>
    <published>2015-09-20T02:47:02.000Z</published>
    <updated>2015-10-14T08:22:48.446Z</updated>
    <content type="html"><![CDATA[<p>这是C++ primer第五版第14章的读书笔记。</p>
<h1 id="基本概念">基本概念</h1><p>重载操作符是具有特殊名字的函数：关键字<code>operator</code>后面跟着需要被定义的操作符的符号。<br>像其它函数一样，重载操作符有返回值，参数列表和函数体。</p>
<p>重载操作符的参数和操作符的操作数一样多。除了函数调用操作符，<code>operator()</code>，重载操作符<br>没有默认实参。</p>
<blockquote>
<p><strong>注意</strong><br>当重载操作符是成员函数时，<code>this</code>绑定到左操作数。因此，成员操作符函数少一个操作数。</p>
</blockquote>
<p>操作符函数必须为类的成员或至少有一个类类型参数：</p>
<pre><code><span class="comment">// error: cannot redefine the built-in operator for ints</span>
<span class="keyword">int</span> <span class="keyword">operator</span>+(<span class="keyword">int</span>, <span class="keyword">int</span>);
</code></pre><p>我们可以重载大多数操作符，而且只能重载已经存在的操作符：</p>
<pre><code>                可以重载的操作符
+       -       *       /       %       ^
&amp;       |       ~       !       ,       =
&lt;       &gt;       &lt;=      &gt;=      ++      --
&lt;&lt;      &gt;&gt;      ==      !=      &amp;&amp;      ||
+=      -=      /=      %=      ^=      &amp;=
|=      *=      &lt;&lt;=     &gt;&gt;=     []      <span class="function"><span class="params">()</span>
-&gt;</span><span class="function">      -&gt;*</span>     <span class="keyword">new</span>     <span class="keyword">new</span>[]   <span class="keyword">delete</span>  <span class="keyword">delete</span>[]
                不能重载的操作符
        ::      .*      .       ?:
</code></pre><p>重载操作符和相应的内置操作符有相同的优先级和结合性。</p>
<h2 id="直接调用重载操作符函数">直接调用重载操作符函数</h2><pre><code><span class="keyword">data</span>1 + <span class="keyword">data</span>2;           // 表达式调用
operator+(<span class="keyword">data</span>1, <span class="keyword">data</span>2); // 等价的函数调用
<span class="keyword">data</span>1 += <span class="keyword">data</span>2;          // 表达式调用
<span class="keyword">data</span>1.operator+=(<span class="keyword">data</span>2); // 等价的成员函数调用
</code></pre><h2 id="有些操作符不应该重载">有些操作符不应该重载</h2><p>重载操作符不保留求值顺序或短路求值。</p>
<blockquote>
<p><strong>最佳实践</strong><br>通常，逗号（,），取地址（&amp;），逻辑与（&amp;&amp;）和逻辑或（||）不应该重载。</p>
</blockquote>
<h2 id="使用和内置操作符意思一致的定义">使用和内置操作符意思一致的定义</h2><ul>
<li>如果类使用IO，定义与内置类型IO操作一致的<code>shift</code>操作符</li>
<li>如果类有测试相等的操作，定义<code>operator==</code>。如果类有<code>operator==</code>，通常也应该定义<code>operator!=</code>。</li>
<li>如果类有单一的，自然顺序的操作，定义<code>operator&lt;</code>。如果类有<code>operator&lt;</code>，通常也应该定义其它关系操作符。</li>
<li>重载操作符的返回类型应该和内置操作符的返回类型兼容：逻辑操作符和关系操作符应该返回<code>bool</code>，算术操作符<br>应该返回类的值，赋值操作符应该返回左操作数的引用。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：明智地使用操作符重载<br>当内置操作符和类的操作有逻辑映射的时候，操作符重载最有用。</p>
</blockquote>
<h2 id="选择成员或非成员实现">选择成员或非成员实现</h2><p>以下指导方针能够帮助我们决定是否将一个操作符定义为成员函数或普通的非成员函数：</p>
<ul>
<li>赋值操作符（=），下标操作符（[]），调用操作符（()），成员访问操作符（-&gt;）必须定义为成员。</li>
<li>复合赋值操作符通常应该定义为成员，但是没有要求一定这样。</li>
<li>改变对象状态或与类对象联系紧密的操作符，通常应该定义为成员。比如++，–和解引用（*）。</li>
<li>那些可能转换操作数的对称的操作符，比如算术操作符，关系操作符，位操作符，通常应该定义为非成员。</li>
</ul>
<h1 id="输入输出操作符">输入输出操作符</h1><h2 id="重载输出操作符_&lt;&lt;">重载输出操作符 &lt;&lt;</h2><pre><code>ostream &amp;operator&lt;&lt;(ostream &amp;os, const Sales_data &amp;<span class="property">item</span>)
{
    os &lt;&lt; <span class="property">item</span>.isbn() &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="property">item</span>.units_sold &lt;&lt; <span class="string">" "</span>
       &lt;&lt; <span class="property">item</span>.revenue &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="property">item</span>.avg_price();
<span class="command">    return</span> os;
}
</code></pre><blockquote>
<p><strong>最佳实践</strong><br>通常输出操作符应该最小格式化输出对象的内容，不应该打印换行。</p>
</blockquote>
<h2 id="IO操作符必须是非成员函数">IO操作符必须是非成员函数</h2><p>输入输出操作符遵循库<code>iostream</code>的惯例必须为普通的非成员函数。</p>
<pre><code><span class="type">Sales_data</span> <span class="typedef"><span class="keyword">data</span>;</span>
<span class="typedef"><span class="keyword">data</span> &lt;&lt; cout; // 如果operator&lt;&lt;是<span class="type">Sales_data</span>的一个成员</span>
</code></pre><p>如果这些操作符是任意一个类的成员，那它们应该是<code>istream</code>或<code>ostream</code>的成员，但是我们无法给标准库添加成员。<br>输入输出操作符通常需要读或写非公开的数据成员。因此，IO操作符通常必须声明为<code>friend</code>。</p>
<h2 id="重载输入操作符_&gt;&gt;">重载输入操作符 &gt;&gt;</h2><pre><code>istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;<span class="keyword">is</span>, Sales_data &amp;item)
{
    <span class="keyword">double</span> price;
    <span class="keyword">is</span> &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;
    <span class="keyword">if</span> (<span class="keyword">is</span>)        <span class="comment">// 检查输入是否成功</span>
        item.revenue = item.units_sold * price;
    <span class="keyword">else</span>
        item = Sales_data(); <span class="comment">// 输入失败：给对象一个默认值</span>
    <span class="keyword">return</span> <span class="keyword">is</span>;
}
</code></pre><blockquote>
<p><strong>注意</strong><br>输入操作符必须处理输入失败的可能性。输出操作符通常没有这个困扰。</p>
</blockquote>
<p>我们选择在读取了所有数据之后，使用数据之前来检查流状态。</p>
<blockquote>
<p><strong>最佳实践</strong><br>输入操作符应该决定做什么错误恢复。当错误发生时，使对象处于一个合法状态尤其重要，因为对象可能被部分修改。</p>
</blockquote>
<p>通常输入操作符应该只设置<code>failbit</code>。<code>eofbit</code>和<code>badbit</code>最好是留给IO库去指示。</p>
<h1 id="算术和关系操作符">算术和关系操作符</h1><p>通常我们将算术和关系操作符定义为非成员函数，以允许转换左右操作符中的一个。这些操作符不需要修改<br>操作数的状态，所以参数通常为<code>const</code>引用。<br>定义了算术操作符的类通常也要定义相应的复合赋值操作符。</p>
<pre><code>Sales_data
operator+(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)
{
    Sales_data <span class="keyword">sum</span> = lhs;
    <span class="keyword">sum</span> += rhs;
    <span class="keyword">return</span> <span class="keyword">sum</span>;
}
</code></pre><blockquote>
<p><strong>提示</strong><br>定义了算术操作符和相应的复合赋值操作符的类，应该使用复合赋值操作符来实现算术操作符。</p>
</blockquote>
<h2 id="相等操作符">相等操作符</h2><pre><code><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)
{
    <span class="keyword">return</span> lhs.isbn() == rhs.isbn() &amp;&amp;
           lhs.units_sold == rhs.units_sold &amp;&amp;
           lhs.revenue == rhs.revenue;
}
<span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)
{
    <span class="keyword">return</span> !(lhs == rhs);
}
</code></pre><p>相等操作符的设计原理：</p>
<ul>
<li>如果一个类有一个确定2个对象是否相等的操作，那么该类应该定义<code>operator==</code>，而不是命名函数。<br>而且可以容易使用标准库容器和算法。</li>
<li>如果一个类定义了<code>operator==</code>，这个操作符通常应该确定给定的对象是否包含相同的数据。</li>
<li>通常地，相等操作符应该是可传递的， <code>if a == b and b == c, then a == c</code>。</li>
<li>如果一个类定义了<code>operator==</code>，那也应该定义<code>operator!=</code>，反之也一样。</li>
<li>相等或不等操作符应该将实际工作委托给另一个。</li>
</ul>
<blockquote>
<p><strong>最佳实践</strong><br>相等性具有逻辑意义的类通常应该定义<code>operator==</code>，定义了<code>operator==</code>的类使得用户容易使用标准库算法。</p>
</blockquote>
<h2 id="关系操作符">关系操作符</h2><p>定义了相等操作符的类通常（不总是）也会定义关系操作符。特别地，关系容器和有些算法使用<code>&lt;</code>操作符，<br>定义<code>operator&lt;</code>会很有用。</p>
<p>通常关系操作符应该：</p>
<ul>
<li>定义一个顺序关系和关联容器的key的需求一致。</li>
<li>定义一个关系和<code>==</code>一致，如果类2种操作符都定义了。特别地，如果2个对象<code>!=</code>，则其中一个应该<code>&lt;</code>另一个。</li>
</ul>
<blockquote>
<p><strong>最佳实践</strong><br>如果只有一个逻辑定义<code>&lt;</code>存在，类通常应该定义<code>&lt;</code>操作符。然而，如果类也有<code>==</code>，只有当<code>&lt;</code>和<code>==</code>产生<br>的结果一致时，定义<code>&lt;</code>。</p>
</blockquote>
<h1 id="赋值操作符">赋值操作符</h1><p>除了<code>copy-</code>和<code>move-</code>赋值操作符之外，类还可以定义其它的赋值操作符允许其它类型作为右操作数。</p>
<pre><code><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;
v = {<span class="string">"a"</span>, <span class="string">"an"</span>, <span class="string">"the"</span>};
<span class="keyword">class</span> StrVec {
<span class="keyword">public</span>:
    StrVec &amp;<span class="keyword">operator</span>=(<span class="built_in">std</span>::initializer_list&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;);
};
StrVec &amp;StrVec::<span class="keyword">operator</span>=(initializer_list&lt;<span class="built_in">string</span>&gt; il)
{
    <span class="keyword">auto</span> data = alloc_n_copy(il.begin(), il.end());
    <span class="built_in">free</span>();
    elements = data.first;
    first_free = cap = data.second;
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
</code></pre><p>不像<code>copy-</code>和<code>move-</code>赋值操作符，这个操作符不需要检查自我赋值。</p>
<blockquote>
<p><strong>注意</strong><br>赋值操作符可以被重载。不管参数类型是什么，赋值操作符必须定义为成员函数。</p>
</blockquote>
<p>复合赋值操作符不需要是类成员。然而，我们倾向于定义所有的赋值操作符，包括复合赋值操作符为类成员。</p>
<pre><code>Sales_data&amp; Sales_data::<span class="keyword">operator</span>+=(<span class="keyword">const</span> Sales_data &amp;rhs)
{
    units_sold += rhs.units_sold;
    revenue += rhs.revenue;
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
</code></pre><blockquote>
<p><strong>最佳实践</strong><br>赋值操作符必须，而且通常复合赋值操作符应该，定义为成员。这些操作符应该返回左操作数的引用。</p>
</blockquote>
<h1 id="下标操作符">下标操作符</h1><p>可以通过位置来获取元素的代表容器的类，通常定义下标操作符，<code>operater[]</code>。</p>
<blockquote>
<p><strong>注意</strong><br>下标操作符必须为成员函数。</p>
<p><strong>最佳实践</strong><br>如果一个类有下标操作符，它通常应该定义2个版本：一个返回普通引用，一个返回const引用。</p>
</blockquote>
<pre><code><span class="keyword">class</span> StrVec {
<span class="keyword">public</span>:
    <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n)
        { <span class="keyword">return</span> elements[n]; }
    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n) <span class="keyword">const</span>
        { <span class="keyword">return</span> elements[n]; }
<span class="keyword">private</span>:
    <span class="built_in">std</span>::<span class="built_in">string</span> *elements; <span class="comment">// 指向数组第一个元素</span>
};

<span class="keyword">const</span> StrVec cvec = svec;
<span class="keyword">if</span> (svec.size() &amp;&amp; svec[<span class="number">0</span>].empty())  {
    svec[<span class="number">0</span>] = <span class="string">"zero"</span>; <span class="comment">// ok: 返回一个普通引用</span>
    cvec[<span class="number">0</span>] = <span class="string">"Zip"</span>;  <span class="comment">// error: 返回一个const引用</span>
}
</code></pre><h1 id="自增和自减操作符">自增和自减操作符</h1><p>自增和自减操作符最常被迭代器类实现。语言并没要要求这些操作符是成员，但是由于这些操作符改变它们操作<br>的对象的状态，我们选择将它们定义为成员。</p>
<blockquote>
<p><strong>最佳实践</strong><br>定义自增或自减操作符的类应该定义<code>prefix</code>和<code>postfix</code>版本。这些操作符应该定义为成员。</p>
</blockquote>
<pre><code><span class="keyword">class</span> StrBlobPtr {
<span class="keyword">public</span>:
    StrBlobPtr&amp; <span class="keyword">operator</span>++(); <span class="comment">// 前自增操作符</span>
    StrBlobPtr&amp; <span class="keyword">operator</span>--(); <span class="comment">// 前自减操作符</span>
};

StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>++()
{
    check(curr, <span class="string">"increment past end of StrBlobPtr"</span>);
    ++curr;
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>--()
{
    --curr;
    check(-<span class="number">1</span>, <span class="string">"decrement past begin of StrBlobPtr"</span>);
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
</code></pre><blockquote>
<p><strong>最佳实践</strong><br>为了和内置操作符一致，前置操作符应该返回自增过或自减过的对象的引用。</p>
</blockquote>
<pre><code><span class="keyword">class</span> StrBlobPtr {
<span class="keyword">public</span>:
    StrBlobPtr <span class="keyword">operator</span>++(<span class="keyword">int</span>);    <span class="comment">// 后置操作符</span>
    StrBlobPtr <span class="keyword">operator</span>--(<span class="keyword">int</span>);
};

StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>++(<span class="keyword">int</span>)
{
    StrBlobPtr ret = *<span class="keyword">this</span>;
    ++*<span class="keyword">this</span>;
    <span class="keyword">return</span> ret;
}
StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>--(<span class="keyword">int</span>)
{
    StrBlobPtr ret = *<span class="keyword">this</span>;
    --*<span class="keyword">this</span>;
    <span class="keyword">return</span> ret;
}
</code></pre><blockquote>
<p><strong>最佳实践</strong><br>为了和内置操作符一致，后置操作符应该返回旧的（未自增或自减）值，而不是引用。</p>
<p><strong>注意</strong><br><code>int</code>参数没有用到，所以没有给它一个名字。</p>
</blockquote>
<pre><code><span class="function">StrBlobPtr <span class="title">p</span><span class="params">(a1)</span></span>;
p.<span class="keyword">operator</span>++(<span class="number">0</span>);  <span class="comment">// 调用后自增操作符</span>
p.<span class="keyword">operator</span>++();   <span class="comment">// 调用前自增操作符</span>
</code></pre><h1 id="成员访问操作符">成员访问操作符</h1><p>解引用（*）和箭头（-&gt;）操作符经常使用在迭代器类和智能指针类中。</p>
<pre><code><span class="keyword">class</span> StrBlobPtr {
<span class="keyword">public</span>:
    <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>
    { 
        <span class="keyword">auto</span> p = check(curr, <span class="string">"dereference past end"</span>);
        <span class="keyword">return</span> (*p)[curr];  <span class="comment">// (*p)是这个对象指向的vector</span>
    }
    <span class="built_in">std</span>::<span class="built_in">string</span>* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>
    {
        <span class="keyword">return</span> &amp; <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*(); <span class="comment">// 将实际工作委托给解引用操作符</span>
    }
};
</code></pre><blockquote>
<p><strong>注意</strong><br>箭头操作符必须定义为成员，没有要求解引用为成员但通常也应该为成员。</p>
</blockquote>
<p>值得注意的是我们定义这些操作符为<code>const</code>成员，获取一个元素不会改变这个对象的状态。</p>
<pre><code>StrBlob a1 = {<span class="string">"hi"</span>, <span class="string">"bye"</span>, <span class="string">"now"</span>};
<span class="function">StrBlobPtr <span class="title">p</span><span class="params">(a1)</span></span>;            <span class="comment">// p指向a1里面的vector</span>
*p = <span class="string">"okay"</span>;                 <span class="comment">// 给a1中第一个元素赋值</span>
<span class="built_in">cout</span> &lt;&lt; p-&gt;size() &lt;&lt; endl;   <span class="comment">// 第一个元素的size()</span>
<span class="built_in">cout</span> &lt;&lt; (*p).size() &lt;&lt; endl; <span class="comment">// 等价于p-&gt;size()</span>
</code></pre><p>当我们写<code>point-&gt;mem</code>时，<code>point</code>必须是指向一个类对象的指针或是一个重载了<code>operator-&gt;</code>的类<br>的对象。取决于<code>point</code>的类型，<code>point-&gt;mem</code>等价于：</p>
<pre><code>(*<span class="built_in">point</span>).mem;          <span class="comment">// point是一个内置指针类型</span>
<span class="built_in">point</span>.operator()-&gt;mem; <span class="comment">// point是一个类的对象</span>
</code></pre><blockquote>
<p><strong>注意</strong><br>箭头操作符必须返回一个指向类类型的指针或一个定义了自己的箭头操作符的类类型的对象。</p>
</blockquote>
<h1 id="函数调用操作符">函数调用操作符</h1><p>重载了函数调用操作符的类允许它的对象像函数一样使用。因为这种类可以保存状态，它们比普通函数更灵活。</p>
<pre><code><span class="keyword">struct</span> absInt {
    <span class="built_in">int</span> operator<span class="literal">()</span>(<span class="built_in">int</span> <span class="keyword">val</span>) const {
        return <span class="keyword">val</span> &lt; <span class="number">0</span> ? -<span class="keyword">val</span> : <span class="keyword">val</span>;
    }
};
</code></pre><p>定义了函数调用操作符的类的对象被称为函数对象，我们可以像函数调用一样提供一个参数列表给函数对象：</p>
<pre><code><span class="keyword">int</span> i = -<span class="number">42</span>;
absInt absObj;
<span class="keyword">int</span> ui = absObj(i);
</code></pre><blockquote>
<p><strong>注意</strong><br>函数调用操作符必须是成员函数。一个类可以定义多个版本的调用操作符，每一个参数类型或数量必须不一样。</p>
</blockquote>
<p>和其他类一样，一个函数对象类除了<code>operator()</code>，还可以有其它成员。函数对象类通常包含其它成员用来<br>调整函数调用操作符的操作。</p>
<pre><code><span class="keyword">class</span> PrintString {
<span class="keyword">public</span>:
    PrintString(ostream &amp;o = <span class="built_in">cout</span>, <span class="keyword">char</span> c = <span class="string">' '</span>):
        os(o), sep(c) { }
    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> <span class="keyword">const</span> </span>{ os &lt;&lt; s &lt;&lt; sep;}
<span class="keyword">private</span>:
    ostream &amp;os;   <span class="comment">// stream on which to write</span>
    <span class="keyword">char</span> sep;      <span class="comment">// character to print after each output</span>
};

PrintString printer;   <span class="comment">// uses the defaults; prints to cout</span>
printer(s);            <span class="comment">// prints s followed by a space on cout</span>
<span class="function">PrintString <span class="title">errors</span><span class="params">(<span class="built_in">cerr</span>, <span class="string">'\n'</span>)</span></span>;
errors(s);             <span class="comment">// prints s followed by a newline on cerr</span>
</code></pre><p>函数对象最常用于泛型算法的参数：</p>
<pre><code>for_each<span class="list">(<span class="keyword">vs</span>.begin<span class="list">()</span>, vs.end<span class="list">()</span>, PrintString<span class="list">(<span class="keyword">cerr</span>, '\n')</span>)</span><span class="comment">;</span>
</code></pre><h2 id="Lambdas是函数对象">Lambdas是函数对象</h2><p>当我们写一个<code>lambda</code>时，编译器将表达式翻译成一个匿名类的匿名对象。由<code>lambda</code>生成的类<br>包含了一个重载的函数调用操作符。</p>
<pre><code>stable_sort<span class="list">(<span class="keyword">words</span>.begin<span class="list">()</span>, words.end<span class="list">()</span>,
            []<span class="list">(<span class="keyword">const</span> string <span class="keyword">&amp;a</span>, const string <span class="keyword">&amp;b</span>)</span>
              { return a.size<span class="list">()</span> &lt; b.size<span class="list">()</span><span class="comment">;});</span></span>
</code></pre><p>行为就像一个匿名对象的类，看起来像：</p>
<pre><code><span class="keyword">class</span> <span class="title">ShorterString</span> {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span>(<span class="params"></span>)(<span class="params"><span class="keyword">const</span> <span class="keyword">string</span> &amp;s1, <span class="keyword">const</span> <span class="keyword">string</span> &amp;s2</span>) <span class="keyword">const</span>
    </span>{ <span class="keyword">return</span> s1.size() &lt; s2.size(); }
};

stable_sort(words.begin(), words.end(), ShorterString());
</code></pre><h2 id="类表示Lambdas带捕获成员">类表示Lambdas带捕获成员</h2><pre><code>auto wc = find_if<span class="list">(<span class="keyword">words</span>.begin<span class="list">()</span>, words.end<span class="list">()</span>,
            [sz]<span class="list">(<span class="keyword">const</span> string <span class="keyword">&amp;a</span>)</span>{ return a.size<span class="list">()</span> &gt;= sz<span class="comment">;});</span></span>
</code></pre><p>会生成像这样的类：</p>
<pre><code><span class="keyword">class</span> SizeComp {
<span class="keyword">public</span>:
    SizeComp(<span class="keyword">size_t</span> n): sz(n) { } <span class="comment">// parameter for each captured variable</span>
    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> <span class="keyword">const</span>
        </span>{ <span class="keyword">return</span> s.size() &gt;= sz; }
<span class="keyword">private</span>:
    <span class="keyword">size_t</span> sz; <span class="comment">// a data member for each variable captured by value</span>
};

<span class="keyword">auto</span> wc = find_if(words.begin(), words.end(), SizeComp(sz));
</code></pre><p>由lambda表达式生成的类有一个<code>deleted</code>默认构造函数，<code>deleted</code>赋值操作符和一个默认析构函数。<br>是否有默认的或<code>deleted``copy/move</code>构造函数取决于捕获的数据成员。</p>
<h2 id="标准库定义的函数对象">标准库定义的函数对象</h2><p>标准库定义了一个类集合，表示算术，关系和逻辑运算符。<br><code>plus</code>类有一个函数调用操作符，应用<code>+</code>操作符。<br><code>modulus</code>类有一个函数调用操作符，应用<code>%</code>操作符。<br><code>equal_to</code>类有一个函数调用操作符，应用<code>==</code>操作符。</p>
<pre><code>plus&lt;<span class="built_in">int</span>&gt; intAdd;       // <span class="function"><span class="keyword">function</span></span> object that can add two <span class="built_in">int</span> values
negate&lt;<span class="built_in">int</span>&gt; intNegate;  // <span class="function"><span class="keyword">function</span></span> object that can negate an <span class="built_in">int</span> <span class="keyword">value</span>
<span class="built_in">int</span> <span class="built_in">sum</span> = intAdd(<span class="number">10</span>, <span class="number">20</span>);         // <span class="built_in">sum</span> = <span class="number">30</span>
<span class="built_in">sum</span> = intNegate(intAdd(<span class="number">10</span>, <span class="number">20</span>));  // <span class="built_in">sum</span> = -<span class="number">30</span>
<span class="built_in">sum</span> = intAdd(<span class="number">10</span>, intNegate(<span class="number">10</span>));  // <span class="built_in">sum</span> = <span class="number">0</span>
</code></pre><h2 id="算法中使用标准库函数对象">算法中使用标准库函数对象</h2><pre><code><span class="comment">// passes a temporary function object that applies the &lt; operator to two strings</span>
sort(svec.<span class="keyword">begin</span>(), svec.<span class="keyword">end</span>(), greater&lt;<span class="keyword">string</span>&gt;());
</code></pre><p>标准库函数对象保证对指针也有作用。</p>
<pre><code>vector&lt;<span class="keyword">string</span> *&gt; nameTable;  <span class="comment">// vector of pointers</span>
<span class="comment">// error: the pointers in nameTable are unrelated, so &lt; is undefined</span>
sort(nameTable.<span class="keyword">begin</span>(), nameTable.<span class="keyword">end</span>(),
     [](<span class="keyword">string</span> *a, <span class="keyword">string</span> *b) <span class="comment">{ return a &lt; b; }</span>);
<span class="comment">// ok: library guarantees that less on pointer types is well defined</span>
sort(nameTable.<span class="keyword">begin</span>(), nameTable.<span class="keyword">end</span>(), less&lt;<span class="keyword">string</span>*&gt;());
</code></pre><p>值得注意的是关联容器使用<code>less&lt;key_type&gt;</code>排序它们的元素。因此，我们能定义一个指针集合，或者使用<br>一个指针作为<code>key</code>的<code>map</code>容器而不用直接指定<code>less</code>。</p>
<h2 id="可调用对象和函数">可调用对象和函数</h2><p>C++有几种可调用对象：函数和函数指针，lambdas，由<code>bind</code>创建的对象和重载了函数调用操作符的类。</p>
<p>不同类型可以有相同的调用签名：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{ <span class="keyword">return</span> i + j; } <span class="comment">// 普通函数</span>
<span class="keyword">auto</span> mod = [](<span class="keyword">int</span> i, <span class="keyword">int</span> j) { <span class="keyword">return</span> i % j; }; <span class="comment">// 匿名函数</span>
<span class="comment">// 函数对象类</span>
<span class="keyword">struct</span> div {
    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> denominator, <span class="keyword">int</span> divisor)</span> </span>{
        <span class="keyword">return</span> denominator / divisor;
    }
};

<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>(*)(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; binops;

binops.insert({<span class="string">"+"</span>, add}); <span class="comment">// ok: add是一个指向合适类型的函数指针</span>
binops.insert({<span class="string">"%"</span>, mod}); <span class="comment">// error: mod不是一个指向函数的指针</span>
</code></pre><h3 id="标准库function类型">标准库function类型</h3><pre><code><span class="comment">#include &lt;functional&gt;</span>

<span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt; <span class="title">f</span></span>;          空函数对象。
<span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt; <span class="title">f</span><span class="params">(nullptr)</span></span>; 显式构造空函数对象。
<span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt; <span class="title">f</span><span class="params">(obj)</span></span>;     保存一个obj的副本。
f                       <span class="keyword">true</span>当f拥有一个可调用对象，否则<span class="keyword">false</span>。
f(args)                 传递参数args，调用函数。

定义为<span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;的成员的类型
<span class="title">result_type</span>             可调用对象的返回类型。
<span class="title">argument_type</span>           当参数为1个或2个时的类型。
<span class="title">first_argument_type</span>
<span class="title">second_argument_type</span></span>
</code></pre><p><code>function</code>是一个模板。和其它模板一样，我们必须指定<code>function</code>的函数类型。</p>
<pre><code>function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f1 = add;    <span class="comment">// 函数指针</span>
function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f2 = div();  <span class="comment">// 函数对象</span>
function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f3 = [](<span class="keyword">int</span> i, <span class="keyword">int</span> j) { <span class="keyword">return</span> i * j;}; <span class="comment">// 匿名函数</span>
<span class="built_in">cout</span> &lt;&lt; f1(<span class="number">4</span>,<span class="number">2</span>) &lt;&lt; endl; <span class="comment">// prints 6</span>
<span class="built_in">cout</span> &lt;&lt; f2(<span class="number">4</span>,<span class="number">2</span>) &lt;&lt; endl; <span class="comment">// prints 2</span>
<span class="built_in">cout</span> &lt;&lt; f3(<span class="number">4</span>,<span class="number">2</span>) &lt;&lt; endl; <span class="comment">// prints 8</span>

<span class="built_in">map</span>&lt;<span class="built_in">string</span>, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; binops = {
    {<span class="string">"+"</span>, add},                  <span class="comment">// function pointer</span>
    {<span class="string">"-"</span>, <span class="built_in">std</span>::minus&lt;<span class="keyword">int</span>&gt;()},    <span class="comment">// library function object</span>
    {<span class="string">"/"</span>,  div()},               <span class="comment">// user-defined function object</span>
    {<span class="string">"*"</span>, [](<span class="keyword">int</span> i, <span class="keyword">int</span> j) { <span class="keyword">return</span> i * j; }}, <span class="comment">// unnamed lambda</span>
    {<span class="string">"%"</span>, mod} };                <span class="comment">// named lambda object</span>

binops[<span class="string">"+"</span>](<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// calls add(10, 5)</span>
binops[<span class="string">"-"</span>](<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// uses the call operator of the minus&lt;int&gt; object</span>
binops[<span class="string">"/"</span>](<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// uses the call operator of the div object</span>
binops[<span class="string">"*"</span>](<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// calls the lambda function object</span>
binops[<span class="string">"%"</span>](<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// calls the lambda function object</span>
</code></pre><h3 id="重载函数和function">重载函数和function</h3><p>我们不能直接保存一个重载函数的函数名：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{ <span class="keyword">return</span> i + j; }
<span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;
<span class="built_in">map</span>&lt;<span class="built_in">string</span>, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; binops;
binops.insert({<span class="string">"+"</span>, add}); <span class="comment">// error: which add?</span>
</code></pre><p>解决二义性的一个方法是存储函数指针：</p>
<pre><code><span class="built_in">int</span> (*fp)(<span class="built_in">int</span>,<span class="built_in">int</span>) = <span class="built_in">add</span>;
binops.insert({<span class="string">"+"</span>, fp});
</code></pre><p>或者使用lambda消除歧义：</p>
<pre><code>binops.insert({<span class="string">"+"</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) {<span class="function"><span class="keyword">return</span> <span class="title">add</span><span class="params">(a, b)</span></span>;}});
</code></pre><h1 id="重载，转换和操作符">重载，转换和操作符</h1><p>转换构造函数和转换操作符定义了类类型的转换。这种转换又叫做用户定义的转换。</p>
<h2 id="转换操作符">转换操作符</h2><p>转换操作符是一种特殊的成员函数，将一个类类型的值转换为其它类型的值。一个典型的转换函数具有形式：</p>
<pre><code><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">const</span></span>;
</code></pre><p>转换操作符可以为任意（除了<code>void</code>）函数返回的类型定义转换。不允许转换为数组或函数类型。<br>允许转换为指针（数据指针和函数指针）和引用。</p>
<blockquote>
<p><strong>注意</strong><br>转换函数必须是一个成员函数，不能指定返回类型，参数列表必须为空，通常为const。</p>
</blockquote>
<h3 id="定义一个具有转换操作符的类">定义一个具有转换操作符的类</h3><pre><code><span class="keyword">class</span> SmallInt {
<span class="keyword">public</span>:
    SmallInt(<span class="keyword">int</span> i = <span class="number">0</span>): val(i)
    {
        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; <span class="number">255</span>)
            <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">"Bad SmallInt value"</span>);
    }
    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> val; }
<span class="keyword">private</span>:
    <span class="built_in">std</span>::<span class="keyword">size_t</span> val;
};

SmallInt si;
si = <span class="number">4</span>; <span class="comment">// implicitly converts 4 to SmallInt then calls SmallInt::operator=</span>
si + <span class="number">3</span>; <span class="comment">// implicitly converts si to int followed by integer addition</span>
</code></pre><p>尽管编译器每次只应用一个用户定义的转换操作，隐式调用用户定义的转换可以在之前或之后跟着一个标准转换。</p>
<pre><code>SmallInt si = <span class="number">3.14</span>;
si + <span class="number">3.14</span>;
</code></pre><p>因为转换操作符是隐式调用的，没有办法给它们传递参数。因此，转换操作符不带参数。尽管转换函数没有<br>指定返回值，每一个转换函数必须返回相应的转换类型。</p>
<pre><code><span class="keyword">class</span> SmallInt {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">int</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>;            <span class="comment">// error: return type</span>
    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">(<span class="keyword">int</span> = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;         <span class="comment">// error: parameter list</span>
    <span class="keyword">operator</span> <span class="keyword">int</span>*() <span class="keyword">const</span> { <span class="keyword">return</span> <span class="number">42</span>; } <span class="comment">// error: 42 is not a pointer</span>
};
<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">(SmallInt&amp;)</span></span>;                 <span class="comment">// error: nonmember</span>
</code></pre><blockquote>
<p><strong>警告</strong><br>避免滥用转换函数。</p>
</blockquote>
<h3 id="转换操作符可以产生惊人的结果">转换操作符可以产生惊人的结果</h3><p>实际上，类很少定义转换操作符。然而一个例外是：类定义转换为bool类型并不罕见。</p>
<pre><code><span class="keyword">int</span> i = <span class="number">42</span>;
<span class="built_in">cin</span> &lt;&lt; i; <span class="comment">// this code would be legal if the conversion to bool were not explicit!</span>
</code></pre><h3 id="explicit转换操作符">explicit转换操作符</h3><p>为了防止前面的问题，新标准引入<code>explicit</code>转换。</p>
<pre><code><span class="keyword">class</span> SmallInt {
<span class="keyword">public</span>:
    <span class="comment">// the compiler won't automatically apply this conversion</span>
    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> val; }
};

SmallInt si = <span class="number">3</span>;  <span class="comment">// ok: the SmallInt constructor is not explicit</span>
si + <span class="number">3</span>; <span class="comment">// error: implicit conversion is required, but operator int is explicit</span>
<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(si) + <span class="number">3</span>; <span class="comment">// ok: explicitly request the conversion</span>
</code></pre><p>如果转换操作符是<code>explicit</code>的，我们只能通过<code>cast</code>来显式转换。一个例外是编译器会在条件测试中应用显式转换：</p>
<ul>
<li><code>if</code>，<code>while</code>或<code>do while</code>条件测试</li>
<li><code>for</code>的条件表达式</li>
<li>逻辑非<code>!</code>，逻辑与<code>&amp;&amp;</code>或逻辑或<code>||</code>的操作数</li>
<li>条件运算符<code>?:</code>条件测试</li>
</ul>
<h3 id="转换为bool类型">转换为bool类型</h3><p>当我们在条件测试中使用流对象，我们使用定义在IO类型里面的<code>operator bool</code>转换操作：</p>
<pre><code><span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; value)
</code></pre><blockquote>
<p><strong>最佳实践</strong><br>通常转换为<code>bool</code>是有意用于条件测试的。因此，<code>operator bool</code>通常应该定义为<code>explicit</code>。</p>
</blockquote>
<h2 id="避免歧义的转换">避免歧义的转换</h2><p>有两种方法会发生多个转换路径的情况。第一个就是当2个类提供了相互的转换。第二个就是定义了多个转换，<br>转换类型之间也可以转换。</p>
<blockquote>
<p><strong>警告</strong><br>通常，类定义相互转换或定义了多个从算术类型或到算术类型的转换是个坏主意。</p>
</blockquote>
<h3 id="参数匹配和相互转换">参数匹配和相互转换</h3><pre><code><span class="keyword">struct</span> B;
<span class="keyword">struct</span> A {
    A() = <span class="keyword">default</span>;
    A(<span class="keyword">const</span> B&amp;);        <span class="comment">// converts a B to an A</span>
};
<span class="keyword">struct</span> B {
    <span class="function"><span class="keyword">operator</span> <span class="title">A</span>(<span class="params"></span>) <span class="keyword">const</span></span>; <span class="comment">// also converts a B to an A</span>
};

<span class="function">A <span class="title">f</span>(<span class="params"><span class="keyword">const</span> A&amp;</span>)</span>;
B b;
A a = f(b); <span class="comment">// error ambiguous: f(B::operator A())</span>
            <span class="comment">//          or f(A::A(const B&amp;))</span>

A a1 = f(b.<span class="function"><span class="keyword">operator</span> <span class="title">A</span>(<span class="params"></span>))</span>; <span class="comment">// ok: use B's conversion operator</span>
A a2 = f(A(b));           <span class="comment">// ok: use A's constructor</span>
</code></pre><p>需要注意的是我们不能通过<code>cast</code>来解决这个二义性，因为<code>cast</code>有着一样的歧义。</p>
<h3 id="内置类型的多个转换和歧义">内置类型的多个转换和歧义</h3><pre><code><span class="keyword">struct</span> A {
    A(<span class="keyword">int</span> = <span class="number">0</span>);   <span class="comment">// usually a bad idea to have two</span>
    A(<span class="keyword">double</span>);    <span class="comment">// conversions from arithmetic types</span>
    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>;    <span class="comment">// usually a bad idea to have two</span>
    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// conversions to arithmetic types</span>
};

<span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span>)</span></span>;
A a;
f2(a); <span class="comment">// error ambiguous: f(A::operator int())</span>
       <span class="comment">//          or f(A::operator double())</span>
<span class="keyword">long</span> lg;
<span class="function">A <span class="title">a2</span><span class="params">(lg)</span></span>; <span class="comment">// error ambiguous: A::A(int) or A::A(double)</span>

<span class="keyword">short</span> s = <span class="number">42</span>;
<span class="comment">// promoting short to int is better than converting short to double</span>
<span class="function">A <span class="title">a3</span><span class="params">(s)</span></span>;  <span class="comment">// uses A::A(int)</span>
</code></pre><blockquote>
<p><strong>注意</strong><br>当使用2个用户定义的转换时，如果有标准转换，使用标准转换的级别来选择最佳匹配。</p>
<p>转换和操作符：</p>
<ul>
<li>不要定义类之间的相互转换</li>
<li>避免定义多个到内置算术类型的转换。</li>
</ul>
<p>最简单的规则就是：除了显式转换为<code>bool</code>类型外，避免定义转换函数和限制那些看起来对的隐式构造函数。</p>
</blockquote>
<h3 id="重载函数和转换构造函数">重载函数和转换构造函数</h3><pre><code><span class="keyword">struct</span> C {
    C(<span class="keyword">int</span>);
};
<span class="keyword">struct</span> D {
    D(<span class="keyword">int</span>);
};

<span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">(<span class="keyword">const</span> C&amp;)</span></span>;
<span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">(<span class="keyword">const</span> D&amp;)</span></span>;

manip(<span class="number">10</span>); <span class="comment">// error ambiguous: manip(C(10)) or manip(D(10))</span>
manip(C(<span class="number">10</span>)); <span class="comment">// ok: calls manip(const C&amp;)</span>
</code></pre><blockquote>
<p><strong>警告</strong><br>需要频繁地在函数调用中使用构造函数或强制转换来转换参数一个坏设计的表现。</p>
</blockquote>
<h3 id="重载函数和用户定义的转换">重载函数和用户定义的转换</h3><p>在重载函数调用中，如果有2个或更多用户定义的转换提供可行的匹配，转换被认为是一样好。</p>
<pre><code><span class="keyword">struct</span> E {
    E(<span class="keyword">double</span>);
};
<span class="function"><span class="keyword">void</span> <span class="title">manip2</span><span class="params">(<span class="keyword">const</span> C&amp;)</span></span>;
<span class="function"><span class="keyword">void</span> <span class="title">manip2</span><span class="params">(<span class="keyword">const</span> E&amp;)</span></span>;
<span class="comment">// error ambiguous: two different user-defined conversions could be used</span>
manip2(<span class="number">10</span>); <span class="comment">// manip2(C(10) or manip2(E(double(10)))</span>
</code></pre><blockquote>
<p><strong>注意</strong><br>在重载函数调用中，附加的标准转换级别有作用仅当可行函数是同一个用户定义的转换。如果是不同的用户<br>定义的转换，则调用有歧义。</p>
</blockquote>
<h2 id="函数匹配和操作符重载">函数匹配和操作符重载</h2><p>如果a是一个类类型，a sym b表达式可能是：</p>
<pre><code>a.operatorsym<span class="comment">(b)</span>; <span class="comment">// a has operatorsym as a member function</span>
operatorsym<span class="comment">(a, b)</span>; <span class="comment">// operatorsym is an ordinary function</span>
</code></pre><blockquote>
<p><strong>注意</strong><br>在候选函数集中表达式中的操作符可以是成员或非成员函数。</p>
</blockquote>
<pre><code><span class="keyword">class</span> SmallInt {
    <span class="keyword">friend</span> SmallInt <span class="keyword">operator</span>+(<span class="keyword">const</span> SmallInt&amp;, <span class="keyword">const</span> SmallInt&amp;);
<span class="keyword">public</span>:
    SmallInt(<span class="keyword">int</span> = <span class="number">0</span>);                   <span class="comment">// conversion from int</span>
    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> val; } <span class="comment">// conversion to int</span>
<span class="keyword">private</span>:
    <span class="built_in">std</span>::<span class="keyword">size_t</span> val;
};

SmallInt s1, s2;
SmallInt s3 = s1 + s2;  <span class="comment">// uses overloaded operator+</span>
<span class="keyword">int</span> i = s3 + <span class="number">0</span>;         <span class="comment">// error: ambiguous</span>
</code></pre><blockquote>
<p><strong>警告</strong><br>既提供了到算术类型的转换，又重载了相应的算术操作符，可能会导致二义性。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是C++ primer第五版第14章的读书笔记。</p>
<h1 id="基本概念">基本概念</h1><p>重载操作符是具有特殊名字的函数：关键字<code>operator</code>后面跟着需要被定义的操作符的符号。<br>像其它函数一样，重载操作符有返回值，参数]]>
    </summary>
    
      <category term="C++" scheme="https://opensvn.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <link href="https://opensvn.github.io/2015/09/19/syntax/"/>
    <id>https://opensvn.github.io/2015/09/19/syntax/</id>
    <published>2015-09-19T11:47:02.000Z</published>
    <updated>2015-10-14T08:23:39.126Z</updated>
    <content type="html"><![CDATA[<p>原文拷贝自<a href="https://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/syntax.md" target="_blank" rel="external">这里</a>.</p>
<p><a href="http://wowubuntu.com/" target="_blank" rel="external">访问 Wow!Ubuntu</a></p>
<p><strong>NOTE</strong>: This is Simplelified Chinese Edition Document of Markdown Syntax. If you are seeking for English Edition Document. Please refer to <a href="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="external">Markdown: Syntax</a>.</p>
<p><strong>声明</strong>： 这份文档派生(fork)于<a href="http://markdown.tw/" target="_blank" rel="external">繁体中文版</a>，在此基础上进行了繁体转简体工作，并进行了适当的润色。此文档用 Markdown 语法编写，你可以到这里<a href="https://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/syntax.md" target="_blank" rel="external">查看它的源文件</a>。「繁体中文版的原始文件可以<a href="https://github.com/othree/markdown-syntax-zhtw/blob/master/syntax.md" target="_blank" rel="external">查看这里</a> 。」–By @<a href="http://twitter.com/riku" target="_blank" rel="external">riku</a></p>
<p><strong>注</strong>： 本项目托管于 <a href="http://gitcafe.com/riku/Markdown-Syntax-CN/" target="_blank" rel="external">GitCafe</a>上，请通过”派生”和”合并请求”来帮忙改进本项目。</p>
<h1 id="Markdown_语法说明_(简体中文版)_/_(点击查看快速入门)">Markdown 语法说明 (简体中文版) / (<a href="https://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/basic.html" target="_blank" rel="external">点击查看快速入门</a>)</h1><ul>
<li><a href="#overview">概述</a><ul>
<li><a href="#philosophy">宗旨</a></li>
<li><a href="#html">兼容 HTML</a></li>
<li><a href="#autoescape">特殊字符自动转换</a></li>
</ul>
</li>
<li><a href="#block">区块元素</a><ul>
<li><a href="#p">段落和换行</a></li>
<li><a href="#header">标题</a></li>
<li><a href="#blockquote">区块引用</a></li>
<li><a href="#list">列表</a></li>
<li><a href="#precode">代码区块</a></li>
<li><a href="#hr">分隔线</a></li>
</ul>
</li>
<li><a href="#span">区段元素</a><ul>
<li><a href="#link">链接</a></li>
<li><a href="#em">强调</a></li>
<li><a href="#code">代码</a></li>
<li><a href="#img">图片</a></li>
</ul>
</li>
<li><a href="#misc">其它</a><ul>
<li><a href="#backslash">反斜杠</a></li>
<li><a href="#autolink">自动链接</a></li>
</ul>
</li>
<li><a href="#acknowledgement">感谢</a></li>
<li><a href="#editor">Markdown 免费编辑器</a></li>
</ul>
<hr>
<h2 id="overview">概述</h2>

<h3 id="philosophy">宗旨</h3>

<p>Markdown 的目标是实现「易读易写」。</p>
<p>可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 <a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="external">Setext</a>、<a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="external">atx</a>、<a href="http://textism.com/tools/textile/" target="_blank" rel="external">Textile</a>、<a href="http://docutils.sourceforge.net/rst.html" target="_blank" rel="external">reStructuredText</a>、<a href="http://www.triptico.com/software/grutatxt.html" target="_blank" rel="external">Grutatext</a> 和 <a href="http://ettext.taint.org/doc/" target="_blank" rel="external">EtText</a>，而最大灵感来源其实是纯文本电子邮件的格式。</p>
<p>总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像*强调*。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。</p>
<h3 id="html">兼容 HTML</h3>

<p>Markdown 语法的目标是：成为一种适用于网络的书写语言。</p>
<p>Markdown 并不是想取代 HTML的地位，甚至接近它。它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想<em>不是</em>要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种<em>发布</em>的格式，Markdown 是一种<em>书写</em>的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。</p>
<p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。</p>
<p>要制约的只有一些 HTML 区块元素――比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 <code>&lt;p&gt;</code> 标签。</p>
<p>例子如下，在 Markdown 文件里加上一段 HTML 表格：</p>
<pre><code>这是一个普通段落。

<span class="tag">&lt;<span class="title">table</span>&gt;</span>
    <span class="tag">&lt;<span class="title">tr</span>&gt;</span>
        <span class="tag">&lt;<span class="title">td</span>&gt;</span>Foo<span class="tag">&lt;/<span class="title">td</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">tr</span>&gt;</span>
<span class="tag">&lt;/<span class="title">table</span>&gt;</span>

这是另一个普通段落。
</code></pre><p>请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的<code>*强调*</code>会没有效果。</p>
<p>HTML 的区段（行内）标签如 <code>&lt;span&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;del&gt;</code> 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 <code>&lt;a&gt;</code> 或 <code>&lt;img&gt;</code> 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。</p>
<p>和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。</p>
<h3 id="autoescape">特殊字符自动转换</h3>

<p>在 HTML 文件中，有两个字符需要特殊处理： <code>&lt;</code> 和 <code>&amp;</code> 。 <code>&lt;</code> 符号用于起始标签，<code>&amp;</code> 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 <code>&amp;lt;</code> 和 <code>&amp;amp;</code>。</p>
<p><code>&amp;</code> 字符尤其让网络文档编写者受折磨，如果你要打「<code>AT&amp;T</code>」 ，你必须要写成「<code>AT&amp;amp;T</code>」。而网址中的 <code>&amp;</code> 字符也要转换。比如你要链接到：</p>
<pre><code><span class="string">http:</span><span class="comment">//images.google.com/images?num=30&amp;q=larry+bird</span>
</code></pre><p>你必须要把网址转换写为：</p>
<pre><code><span class="string">http:</span><span class="comment">//images.google.com/images?num=30&amp;amp;q=larry+bird</span>
</code></pre><p>才能放到链接标签的 <code>href</code> 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。</p>
<p>Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 <code>&amp;</code> 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 <code>&amp;amp;</code>。</p>
<p>所以你如果要在文档中插入一个版权符号 <code>©</code>，你可以这样写：</p>
<pre><code>&amp;<span class="keyword">copy</span>;
</code></pre><p>Markdown 会保留它不动。而若你写：</p>
<pre><code><span class="built_in">AT</span>&amp;T
</code></pre><p>Markdown 就会将它转为：</p>
<pre><code>AT&amp;amp<span class="comment">;T</span>
</code></pre><p>类似的状况也会发生在 <code>&lt;</code> 符号上，因为 Markdown 允许 <a href="#html">兼容 HTML</a> ，如果你是把 <code>&lt;</code> 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写：</p>
<pre><code><span class="number">4</span> &lt; <span class="number">5</span>
</code></pre><p>Markdown 将会把它转换为：</p>
<pre><code><span class="number">4</span> &amp;lt; <span class="number">5</span>
</code></pre><p>不过需要注意的是，code 范围内，不论是行内还是区块， <code>&lt;</code> 和 <code>&amp;</code> 两个符号都一定会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 <code>&lt;</code> 和 <code>&amp;</code> 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。）</p>
<hr>
<h2 id="block">区块元素</h2>

<h3 id="p">段落和换行</h3>

<p>一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。</p>
<p>「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 <code>&lt;br /&gt;</code> 标签。</p>
<p>如果你<em>确实</em>想要依赖 Markdown 来插入 <code>&lt;br /&gt;</code> 标签的话，在插入处先按入两个以上的空格然后回车。</p>
<p>的确，需要多费点事（多加空格）来产生 <code>&lt;br /&gt;</code> ，但是简单地「每个换行都转换为 <code>&lt;br /&gt;</code>」的方法在 Markdown 中并不适合， Markdown 中 email 式的 <a href="#blockquote">区块引用</a> 和多段落的 <a href="#list">列表</a> 在使用换行来排版的时候，不但更好用，还更方便阅读。</p>
<h3 id="header">标题</h3>

<p>Markdown 支持两种标题的语法，类 <a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="external">Setext</a> 和类 <a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="external">atx</a> 形式。</p>
<p>类 Setext 形式是用底线的形式，利用 <code>=</code> （最高阶标题）和 <code>-</code> （第二阶标题），例如：</p>
<pre><code><span class="header">This is an H1
=============</span>

<span class="header">This is an H2
-------------</span>
</code></pre><p>任何数量的 <code>=</code> 和 <code>-</code> 都可以有效果。</p>
<p>类 Atx 形式则是在行首插入 1 到 6 个 <code>#</code> ，对应到标题 1 到 6 阶，例如：</p>
<pre><code><span class="preprocessor"># 这是 H1</span>

<span class="preprocessor">## 这是 H2</span>

<span class="preprocessor">###### 这是 H6</span>
</code></pre><p>你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 <code>#</code>，而行尾的 <code>#</code> 数量也不用和开头一样（行首的井字符数量决定标题的阶数）：</p>
<pre><code><span class="preprocessor"># 这是 H1 #</span>

<span class="preprocessor">## 这是 H2 ##</span>

<span class="preprocessor">### 这是 H3 ######</span>
</code></pre><h3 id="blockquote">区块引用 Blockquotes</h3>

<p>Markdown 标记区块引用是使用类似 email 中用 <code>&gt;</code> 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 <code>&gt;</code> ：</p>
<pre><code>&gt; This is a blockquote with two paragraphs. Lo<span class="comment">rem ipsum dolor sit amet,</span>
&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
&gt; Vestibulum enim wisi, viverra nec, fringilla <span class="flow">in</span>, laoreet vitae, risus.
&gt; 
&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
&gt; id sem consectetuer libero luctus adipiscing.
</code></pre><p>Markdown 也允许你偷懒只在整个段落的第一行最前面加上 <code>&gt;</code> ：</p>
<pre><code>&gt; This is a blockquote with two paragraphs. Lo<span class="comment">rem ipsum dolor sit amet,</span>
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla <span class="flow">in</span>, laoreet vitae, risus.

&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.
</code></pre><p>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 <code>&gt;</code> ：</p>
<pre><code>&gt; This <span class="keyword">is</span> <span class="keyword">the</span> <span class="keyword">first</span> level <span class="keyword">of</span> quoting.
&gt;
&gt; &gt; This <span class="keyword">is</span> nested blockquote.
&gt;
&gt; Back <span class="keyword">to</span> <span class="keyword">the</span> <span class="keyword">first</span> level.
</code></pre><p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：</p>
<pre><code>&gt; <span class="comment">## 这是一个标题。</span>
&gt; 
&gt; <span class="number">1</span>.   这是第一行列表项。
&gt; <span class="number">2</span>.   这是第二行列表项。
&gt; 
&gt; 给出一些例子代码：
&gt; 
&gt;     <span class="built_in">return</span> shell_<span class="built_in">exec</span>(<span class="string">"echo <span class="variable">$input</span> | <span class="variable">$markdown_script</span>"</span>);
</code></pre><p>任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择<em>增加引用阶层</em>。</p>
<h3 id="list">列表</h3>

<p>Markdown 支持有序列表和无序列表。</p>
<p>无序列表使用星号、加号或是减号作为列表标记：</p>
<pre><code><span class="bullet">*   </span>Red
<span class="bullet">*   </span>Green
<span class="bullet">*   </span>Blue
</code></pre><p>效果就是</p>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<p>等同于：</p>
<pre><code><span class="bullet">+   </span>Red
<span class="bullet">+   </span>Green
<span class="bullet">+   </span>Blue
</code></pre><p>也等同于：</p>
<pre><code>-<span class="ruby">   <span class="constant">Red</span>
</span>-<span class="ruby">   <span class="constant">Green</span>
</span>-<span class="ruby">   <span class="constant">Blue</span></span>
</code></pre><p>有序列表则使用数字接着一个英文句点：</p>
<pre><code><span class="number">1.</span>  Bird
<span class="number">2.</span>  McHale
<span class="number">3.</span>  Parish
</code></pre><p>很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：</p>
<pre><code><span class="tag">&lt;<span class="title">ol</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span>Bird<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span>McHale<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span>Parish<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ol</span>&gt;</span>
</code></pre><p>如果你的列表标记写成：</p>
<pre><code><span class="number">1.</span>  Bird
<span class="number">1.</span>  McHale
<span class="number">1.</span>  Parish
</code></pre><p>或甚至是：</p>
<pre><code><span class="number">3.</span> Bird
<span class="number">1.</span> McHale
<span class="number">8.</span> Parish
</code></pre><p>你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。</p>
<p>如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。</p>
<p>列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。</p>
<p>要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：</p>
<pre><code>*   Lo<span class="comment">rem ipsum dolor sit amet, consectetuer adipiscing elit.</span>
    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
    viverra nec, fringilla <span class="flow">in</span>, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
    Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre><p>但是如果你懒，那也行：</p>
<pre><code>*   Lo<span class="comment">rem ipsum dolor sit amet, consectetuer adipiscing elit.</span>
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla <span class="flow">in</span>, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre><p>如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 <code>&lt;p&gt;</code><br>标签包起来，举例来说：</p>
<pre><code><span class="bullet">*   </span>Bird
<span class="bullet">*   </span>Magic
</code></pre><p>会被转换为：</p>
<pre><code><span class="tag">&lt;<span class="title">ul</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span>Bird<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span>Magic<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
</code></pre><p>但是这个：</p>
<pre><code><span class="bullet">*   </span>Bird

<span class="bullet">*   </span>Magic
</code></pre><p>会被转换为：</p>
<pre><code><span class="tag">&lt;<span class="title">ul</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">p</span>&gt;</span>Bird<span class="tag">&lt;/<span class="title">p</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">p</span>&gt;</span>Magic<span class="tag">&lt;/<span class="title">p</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
</code></pre><p>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：</p>
<pre><code><span class="number">1</span>.  This is a list item with two paragraphs. Lo<span class="comment">rem ipsum dolor</span>
    sit amet, consectetuer adipiscing elit. Aliquam hendrerit
    mi posuere lectus.

    Vestibulum enim wisi, viverra nec, fringilla <span class="flow">in</span>, laoreet
    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
    sit amet velit.

<span class="number">2</span>.  Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre><p>如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：</p>
<pre><code>*   This <span class="keyword">is</span> a <span class="type">list</span> <span class="property">item</span> <span class="keyword">with</span> two <span class="property">paragraphs</span>.

    This <span class="keyword">is</span> <span class="keyword">the</span> <span class="keyword">second</span> <span class="property">paragraph</span> <span class="keyword">in</span> <span class="keyword">the</span> <span class="type">list</span> <span class="property">item</span>. You're
only required <span class="keyword">to</span> indent <span class="keyword">the</span> <span class="keyword">first</span> line. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit.

*   Another <span class="property">item</span> <span class="keyword">in</span> <span class="keyword">the</span> same <span class="type">list</span>.
</code></pre><p>如果要在列表项目内放进引用，那 <code>&gt;</code> 就需要缩进：</p>
<pre><code>*   A <span class="type">list</span> <span class="property">item</span> <span class="keyword">with</span> a blockquote:

    &gt; This <span class="keyword">is</span> a blockquote
    &gt; inside a <span class="type">list</span> <span class="property">item</span>.
</code></pre><p>如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：</p>
<pre><code><span class="keyword">*</span>   一列表项包含一个列表区块：

        <span class="variable">&lt;代码写在这&gt;</span>
</code></pre><p>当然，项目列表很可能会不小心产生，像是下面这样的写法：</p>
<pre><code><span class="number">1986</span>. What <span class="tag">a</span> great season.
</code></pre><p>换句话说，也就是在行首出现<em>数字-句点-空白</em>，要避免这样的状况，你可以在句点前面加上反斜杠。</p>
<pre><code><span class="number">1986</span>\. What <span class="tag">a</span> great season.
</code></pre><h3 id="precode">代码区块</h3>

<p>和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 <code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 标签来把代码区块包起来。</p>
<p>要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：</p>
<pre><code>这是一个普通段落：

    这是一个代码区块。
</code></pre><p>Markdown 会转换成：</p>
<pre><code><span class="tag">&lt;<span class="title">p</span>&gt;</span>这是一个普通段落：<span class="tag">&lt;/<span class="title">p</span>&gt;</span>

<span class="tag">&lt;<span class="title">pre</span>&gt;</span><span class="tag">&lt;<span class="title">code</span>&gt;</span>这是一个代码区块。
<span class="tag">&lt;/<span class="title">code</span>&gt;</span><span class="tag">&lt;/<span class="title">pre</span>&gt;</span>
</code></pre><p>这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：</p>
<pre><code>Here <span class="keyword">is</span> an example <span class="keyword">of</span> <span class="constant">AppleScript</span>:

    <span class="keyword">tell</span> <span class="type">application</span> <span class="string">"Foo"</span>
        <span class="command">beep</span>
    <span class="keyword">end</span> <span class="keyword">tell</span>
</code></pre><p>会被转换为：</p>
<pre><code>&lt;p&gt;Here <span class="keyword">is</span> an example <span class="keyword">of</span> <span class="constant">AppleScript</span>:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;<span class="keyword">tell</span> <span class="type">application</span> <span class="string">"Foo"</span>
    <span class="command">beep</span>
<span class="keyword">end</span> <span class="keyword">tell</span>
&lt;/code&gt;&lt;/pre&gt;
</code></pre><p>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。</p>
<p>在代码区块里面， <code>&amp;</code> 、 <code>&lt;</code> 和 <code>&gt;</code> 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"footer"</span>&gt;
    &amp;<span class="keyword">copy</span>; <span class="number">2004</span> Foo Corporation
&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>会被转换为：</p>
<pre><code>&lt;<span class="keyword">pre</span>&gt;&lt;code&gt;&amp;<span class="keyword">lt</span>;div class=<span class="string">"footer"</span>&amp;gt;
    &amp;amp;<span class="built_in">copy</span>; <span class="number">2004</span> Foo Corporation
&amp;<span class="keyword">lt</span>;/div&amp;gt;
&lt;/code&gt;&lt;/<span class="keyword">pre</span>&gt;
</code></pre><p>代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。</p>
<h3 id="hr">分隔线</h3>

<p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<pre><code>- <span class="keyword">*</span> <span class="keyword">*</span>

<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>

<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>

+ - -

---------------------------------------
</code></pre><hr>
<h2 id="span">区段元素</h2>

<h3 id="link">链接</h3>

<p>Markdown 支持两种形式的链接语法： <em>行内式</em>和<em>参考式</em>两种形式。</p>
<p>不管是哪一种，链接文字都是用 [方括号] 来标记。</p>
<p>要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：</p>
<pre><code>This is [<span class="link_label">an example</span>](<span class="link_url">http://example.com/ "Title"</span>) inline link.

[<span class="link_label">This link</span>](<span class="link_url">http://example.net/</span>) has no title attribute.
</code></pre><p>会产生：</p>
<pre><code><span class="tag">&lt;<span class="title">p</span>&gt;</span>This is <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"http://example.com/"</span> <span class="attribute">title</span>=<span class="value">"Title"</span>&gt;</span>
an example<span class="tag">&lt;/<span class="title">a</span>&gt;</span> inline link.<span class="tag">&lt;/<span class="title">p</span>&gt;</span>

<span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"http://example.net/"</span>&gt;</span>This link<span class="tag">&lt;/<span class="title">a</span>&gt;</span> has no
title attribute.<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
</code></pre><p>如果你是要链接到同样主机的资源，你可以使用相对路径：</p>
<pre><code>See my [<span class="link_label">About</span>](<span class="link_url">/about/</span>) page for details.  
</code></pre><p>参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：</p>
<pre><code>This is [<span class="link_label">an example</span>][<span class="link_reference">id</span>] reference-style link.
</code></pre><p>你也可以选择性地在两个方括号中间加上一个空格：</p>
<pre><code>This <span class="keyword">is</span> [an example] [<span class="property">id</span>] <span class="keyword">reference</span>-style link.
</code></pre><p>接着，在文件的任意处，你可以把这个标记的链接内容定义出来：</p>
<pre><code><span class="attr_selector">[id]</span>: <span class="rule"><span class="attribute">http</span>:<span class="value">//example.com/  <span class="string">"Optional Title Here"</span></span></span>
</code></pre><p>链接内容定义的形式为：</p>
<ul>
<li>方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字</li>
<li>接着一个冒号</li>
<li>接着一个以上的空格或制表符</li>
<li>接着链接的网址</li>
<li>选择性地接着 title 内容，可以用单引号、双引号或是括弧包着</li>
</ul>
<p>下面这三种链接的定义都是相同：</p>
<pre><code>[<span class="link_reference">foo</span>]:<span class="link_url"> http://example.com/  "Optional Title Here"</span>
[<span class="link_reference">foo</span>]:<span class="link_url"> http://example.com/  'Optional Title Here'</span>
[<span class="link_reference">foo</span>]:<span class="link_url"> http://example.com/  (Optional Title Here)</span>
</code></pre><p><strong>请注意</strong>：**有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。</p>
<p>链接网址也可以用尖括号包起来：</p>
<pre><code><span class="attr_selector">[id]</span>: &lt;<span class="rule"><span class="attribute">http</span>:<span class="value">//example.com/&gt;  <span class="string">"Optional Title Here"</span></span></span>
</code></pre><p>你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：</p>
<pre><code>[id]<span class="symbol">:</span> <span class="symbol">http:</span>/<span class="regexp">/example.com/longish</span><span class="regexp">/path/to</span><span class="regexp">/resource/here</span>
    <span class="string">"Optional Title Here"</span>
</code></pre><p>网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。</p>
<p>链接辨别标签可以有字母、数字、空白和标点符号，但是并<em>不</em>区分大小写，因此下面两个链接是一样的：</p>
<pre><code>[<span class="link_label">link text</span>][<span class="link_reference">a</span>]
[<span class="link_label">link text</span>][<span class="link_reference">A</span>]
</code></pre><p>隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成：</p>
<pre><code>[<span class="link_label">Google</span>][<span class="link_reference"></span>]
</code></pre><p>然后定义链接内容：</p>
<pre><code>[<span class="link_reference">Google</span>]:<span class="link_url"> http://google.com/</span>
</code></pre><p>由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：</p>
<pre><code>Visit [<span class="link_label">Daring Fireball</span>][<span class="link_reference"></span>] for more information.
</code></pre><p>然后接着定义链接：</p>
<pre><code>[<span class="link_reference">Daring Fireball</span>]:<span class="link_url"> http://daringfireball.net/</span>
</code></pre><p>链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。</p>
<p>下面是一个参考式链接的范例：</p>
<pre><code><span class="name">I</span> <span class="atom">get</span> <span class="number">10</span> <span class="atom">times</span> <span class="atom">more</span> <span class="atom">traffic</span> <span class="atom">from</span> [<span class="name">Google</span>] [<span class="number">1</span>] <span class="atom">than</span> <span class="atom">from</span>
[<span class="name">Yahoo</span>] [<span class="number">2</span>] <span class="atom">or</span> [<span class="name">MSN</span>] [<span class="number">3</span>].

  [<span class="number">1</span>]: <span class="atom">http</span>://<span class="atom">google</span>.<span class="atom">com</span>/        <span class="string">"Google"</span>
  [<span class="number">2</span>]: <span class="atom">http</span>://<span class="atom">search</span>.<span class="atom">yahoo</span>.<span class="atom">com</span>/  <span class="string">"Yahoo Search"</span>
  [<span class="number">3</span>]: <span class="atom">http</span>://<span class="atom">search</span>.<span class="atom">msn</span>.<span class="atom">com</span>/    <span class="string">"MSN Search"</span>
</code></pre><p>如果改成用链接名称的方式写：</p>
<pre><code>I get 10 times more traffic from [<span class="link_label">Google</span>][<span class="link_reference"></span>] than from
[<span class="link_label">Yahoo</span>][<span class="link_reference"></span>] or [<span class="link_label">MSN</span>][<span class="link_reference"></span>].

  [google]: http://google.com/        "Google"
  [yahoo]:  http://search.yahoo.com/  "Yahoo Search"
  [msn]:    http://search.msn.com/    "MSN Search"
</code></pre><p>上面两种写法都会产生下面的 HTML。</p>
<pre><code>&lt;p&gt;I <span class="built_in">get</span> <span class="number">10</span> times more traffic <span class="built_in">from</span> &lt;<span class="operator">a</span> href=<span class="string">"http://google.com/"</span>
title=<span class="string">"Google"</span>&gt;Google&lt;/<span class="operator">a</span>&gt; than <span class="built_in">from</span>
&lt;<span class="operator">a</span> href=<span class="string">"http://search.yahoo.com/"</span> title=<span class="string">"Yahoo Search"</span>&gt;Yahoo&lt;/<span class="operator">a</span>&gt;
<span class="operator">or</span> &lt;<span class="operator">a</span> href=<span class="string">"http://search.msn.com/"</span> title=<span class="string">"MSN Search"</span>&gt;MSN&lt;/<span class="operator">a</span>&gt;.&lt;/p&gt;
</code></pre><p>下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用</p>
<pre><code>I get 10 times more traffic from [<span class="link_label">Google</span>](<span class="link_url">http://google.com/ "Google"</span>)
than from [<span class="link_label">Yahoo</span>](<span class="link_url">http://search.yahoo.com/ "Yahoo Search"</span>) or
[<span class="link_label">MSN</span>](<span class="link_url">http://search.msn.com/ "MSN Search"</span>).
</code></pre><p>参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。</p>
<p>使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。</p>
<h3 id="em">强调</h3>

<p>Markdown 使用星号（<code>*</code>）和底线（<code>_</code>）作为标记强调字词的符号，被 <code>*</code> 或 <code>_</code> 包围的字词会被转成用 <code>&lt;em&gt;</code> 标签包围，用两个 <code>*</code> 或 <code>_</code> 包起来的话，则会被转成 <code>&lt;strong&gt;</code>，例如：</p>
<pre><code><span class="keyword">*</span>single asterisks<span class="keyword">*</span>

_single underscores_

<span class="keyword">*</span><span class="keyword">*</span>double asterisks<span class="keyword">*</span><span class="keyword">*</span>

__double underscores__
</code></pre><p>会转成：</p>
<pre><code><span class="tag">&lt;<span class="title">em</span>&gt;</span>single asterisks<span class="tag">&lt;/<span class="title">em</span>&gt;</span>

<span class="tag">&lt;<span class="title">em</span>&gt;</span>single underscores<span class="tag">&lt;/<span class="title">em</span>&gt;</span>

<span class="tag">&lt;<span class="title">strong</span>&gt;</span>double asterisks<span class="tag">&lt;/<span class="title">strong</span>&gt;</span>

<span class="tag">&lt;<span class="title">strong</span>&gt;</span>double underscores<span class="tag">&lt;/<span class="title">strong</span>&gt;</span>
</code></pre><p>你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。</p>
<p>强调也可以直接插在文字中间：</p>
<pre><code>un<span class="keyword">*</span>frigging<span class="keyword">*</span>believable
</code></pre><p>但是<strong>如果你的 <code>*</code> 和 <code>_</code> 两边都有空白的话，它们就只会被当成普通的符号</strong>。</p>
<p>如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：</p>
<pre><code><span class="string">\*this</span> text <span class="keyword">is</span> surrounded <span class="keyword">by</span> literal asterisks<span class="string">\*</span>
</code></pre><h3 id="code">代码</h3>

<p>如果要标记一小段行内代码，你可以用反引号把它包起来（<code>` </code>），例如：</p>
<pre><code><span class="keyword">Use</span> the `printf()` <span class="function"><span class="keyword">function</span>.</span>
</code></pre><p>会产生：</p>
<pre><code><span class="tag">&lt;<span class="title">p</span>&gt;</span>Use the <span class="tag">&lt;<span class="title">code</span>&gt;</span>printf()<span class="tag">&lt;/<span class="title">code</span>&gt;</span> function.<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
</code></pre><p>如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：</p>
<pre><code><span class="escape">``</span>There is <span class="literal">a</span> literal backtick (<span class="escape">`)</span> here.<span class="escape">``</span>
</code></pre><p>这段语法会产生：</p>
<pre><code><span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">code</span>&gt;</span>There is a literal backtick (`) here.<span class="tag">&lt;/<span class="title">code</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span>
</code></pre><p>代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：</p>
<pre><code>A single backtick <span class="keyword">in</span> <span class="tag">a</span> <span class="tag">code</span> <span class="tag">span</span>: `` ` ``

A backtick-delimited string <span class="keyword">in</span> <span class="tag">a</span> <span class="tag">code</span> <span class="tag">span</span>: `` `foo` ``
</code></pre><p>会产生：</p>
<pre><code>&lt;p&gt;A single backtick <span class="keyword">in</span> <span class="tag">a</span> <span class="tag">code</span> <span class="tag">span</span>: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A backtick-delimited string <span class="keyword">in</span> <span class="tag">a</span> <span class="tag">code</span> <span class="tag">span</span>: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt;
</code></pre><p>在代码区段内，<code>&amp;</code> 和尖括号<strong>都</strong>会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段：</p>
<pre><code>Please don't <span class="operator"><span class="keyword">use</span> <span class="keyword">any</span> <span class="string">`&lt;blink&gt;`</span> tags.</span>
</code></pre><p>转为：</p>
<pre><code><span class="variable">&lt;p&gt;</span>Please don't use <span class="literal">any</span> <span class="variable">&lt;code&gt;</span>&amp;lt;blink&amp;gt;<span class="variable">&lt;/code&gt;</span> tags.<span class="variable">&lt;/p&gt;</span>
</code></pre><p>你也可以这样写：</p>
<pre><code>`<span class="javascript">&amp;#<span class="number">8212</span>;</span>` <span class="keyword">is</span> the decimal-encoded equivalent <span class="keyword">of</span> `<span class="javascript">&amp;mdash;</span>`.
</code></pre><p>以产生：</p>
<pre><code><span class="variable">&lt;p&gt;</span><span class="variable">&lt;code&gt;</span>&amp;amp;<span class="comment">#8212;&lt;/code&gt; is the decimal-encoded</span>
equivalent of <span class="variable">&lt;code&gt;</span>&amp;amp;mdash;<span class="variable">&lt;/code&gt;</span>.<span class="variable">&lt;/p&gt;</span>
</code></pre><h3 id="img">图片</h3>

<p>很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。</p>
<p>Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： <em>行内式</em>和<em>参考式</em>。</p>
<p>行内式的图片语法看起来像是：</p>
<pre><code>![<span class="link_label">Alt text</span>](<span class="link_url">/path/to/img.jpg</span>)

![<span class="link_label">Alt text</span>](<span class="link_url">/path/to/img.jpg "Optional title"</span>)
</code></pre><p>详细叙述如下：</p>
<ul>
<li>一个惊叹号 <code>!</code></li>
<li>接着一个方括号，里面放上图片的替代文字</li>
<li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上<br>选择性的 ‘title’ 文字。</li>
</ul>
<p>参考式的图片语法则长得像这样：</p>
<pre><code>![<span class="link_label">Alt text</span>][<span class="link_reference">id</span>]
</code></pre><p>「id」是图片参考的名称，图片参考的定义方式则和链接参考一样：</p>
<pre><code>[<span class="property">id</span>]: url/<span class="keyword">to</span>/image  <span class="string">"Optional title attribute"</span>
</code></pre><p>到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code> 标签。</p>
<hr>
<h2 id="misc">其它</h2>

<h3 id="autolink">自动链接</h3>

<p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p>
<pre><code>&lt;<span class="string">http:</span><span class="comment">//example.com/&gt;</span>
</code></pre><p>Markdown 会转为：</p>
<pre><code>&lt;<span class="tag">a</span> href=<span class="string">"http://example.com/"</span>&gt;http:<span class="comment">//example.com/&lt;/a&gt;</span>
</code></pre><p>邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：</p>
<pre><code><span class="tag">&lt;address@example.com&gt;</span>
</code></pre><p>Markdown 会转成：</p>
<pre><code>&lt;a href=<span class="string">"&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;
&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;
&amp;#109;"</span>&gt;&amp;<span class="title">#x61</span>;&amp;<span class="title">#x64</span>;&amp;<span class="title">#x64</span>;&amp;<span class="title">#x72</span>;&amp;<span class="title">#x65</span>;&amp;<span class="title">#115</span>;&amp;<span class="title">#115</span>;&amp;<span class="title">#64</span>;&amp;<span class="title">#101</span>;&amp;<span class="title">#120</span>;&amp;<span class="title">#x61</span>;
&amp;<span class="title">#109</span>;&amp;<span class="title">#x70</span>;&amp;<span class="title">#x6</span>C;e&amp;<span class="title">#x2</span>E;&amp;<span class="title">#99</span>;&amp;<span class="title">#111</span>;&amp;<span class="title">#109</span>;&lt;/a&gt;
</code></pre><p>在浏览器里面，这段字串（其实是 <code>&lt;a href=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt;</code>）会变成一个可以点击的「address@example.com」链接。</p>
<p>（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）</p>
<h3 id="backslash">反斜杠</h3>

<p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 <code>&lt;em&gt;</code> 标签），你可以在星号的前面加上反斜杠：</p>
<pre><code>\<span class="keyword">*</span>literal asterisks\<span class="keyword">*</span>
</code></pre><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p>
<pre><code>\   反斜线
`   反引号
<span class="bullet">-   </span>星号
_   底线
{}  花括号
[]  方括号
()  括弧
<span class="header">#   井字号</span>
<span class="bullet">*   </span>加号
<span class="bullet">+   </span>减号
.   英文句点
!   惊叹号
</code></pre><h2 id="acknowledgement">感谢</h2>

<p>感谢 <a href="https://twitter.com/#!/leafy7382" target="_blank" rel="external">leafy7382</a> 协助翻译，<a href="http://iamhlb.com/" target="_blank" rel="external">hlb</a>、<a href="http://twitter.com/randylien" target="_blank" rel="external">Randylien</a> 帮忙润稿，<a href="https://twitter.com/#!/ethantw" target="_blank" rel="external">ethantw</a> 的<a href="http://ethantw.net/projects/han/" target="_blank" rel="external">汉字标准格式・CSS Reset</a>， <a href="http://kidwm.net/" target="_blank" rel="external">WM</a> 回报文字错误。</p>
<p>感谢 <a href="https://github.com/fenprace" target="_blank" rel="external">fenprace</a>，<a href="https://github.com/addv" target="_blank" rel="external">addv</a>。</p>
<hr>
<h2 id="editor">Markdown 免费编辑器</h2>

<p>Windows 平台</p>
<ul>
<li><a href="http://markdownpad.com/" target="_blank" rel="external">MarkdownPad</a></li>
<li><a href="http://code52.org/DownmarkerWPF/" target="_blank" rel="external">MarkPad</a></li>
</ul>
<p>Linux 平台</p>
<ul>
<li><a href="http://sourceforge.net/p/retext/home/ReText/" target="_blank" rel="external">ReText</a></li>
</ul>
<p>Mac 平台</p>
<ul>
<li><a href="http://mouapp.com/" target="_blank" rel="external">Mou</a></li>
</ul>
<p>在线编辑器</p>
<ul>
<li><a href="http://markable.in/" target="_blank" rel="external">Markable.in</a></li>
<li><a href="http://dillinger.io/" target="_blank" rel="external">Dillinger.io</a></li>
</ul>
<p>浏览器插件</p>
<ul>
<li><a href="https://chrome.google.com/webstore/detail/oknndfeeopgpibecfjljjfanledpbkog" target="_blank" rel="external">MaDe</a> (Chrome)</li>
</ul>
<p>高级应用</p>
<ul>
<li><a href="http://www.sublimetext.com/2" target="_blank" rel="external">Sublime Text 2</a> + <a href="http://ttscoff.github.com/MarkdownEditing/" target="_blank" rel="external">MarkdownEditing</a> / <a href="http://lucifr.com/2012/07/12/markdownediting-for-sublime-text-2/" target="_blank" rel="external">教程</a></li>
</ul>
<p>*** 如有更好的 Markdown 免费编辑器推荐，请到<a href="https://gitcafe.com/riku/Markdown-Syntax-CN/tickets/1" target="_blank" rel="external">这里反馈</a>，谢谢！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文拷贝自<a href="https://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/syntax.md" target="_blank" rel="external">这里</a>.</p>
<p><a href="h]]>
    </summary>
    
      <category term="Markdown" scheme="https://opensvn.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="https://opensvn.github.io/2015/09/19/hello-world/"/>
    <id>https://opensvn.github.io/2015/09/19/hello-world/</id>
    <published>2015-09-19T02:47:02.000Z</published>
    <updated>2015-11-07T01:59:19.227Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io]]>
    </summary>
    
      <category term="Hexo" scheme="https://opensvn.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
