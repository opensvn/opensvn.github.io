<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[opensvn]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="https://opensvn.github.io/"/>
  <updated>2015-09-22T01:25:23.903Z</updated>
  <id>https://opensvn.github.io/</id>
  
  <author>
    <name><![CDATA[opensvn]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[重载操作和转换]]></title>
    <link href="https://opensvn.github.io/2015/09/20/cpp_primer_14/"/>
    <id>https://opensvn.github.io/2015/09/20/cpp_primer_14/</id>
    <published>2015-09-20T02:47:02.000Z</published>
    <updated>2015-09-22T01:25:23.903Z</updated>
    <content type="html"><![CDATA[<p>这是C++ primer第五版第14章的读书笔记。</p>
<h1 id="基本概念">基本概念</h1><p>重载操作符是具有特殊名字的函数：关键字<code>operator</code>后面跟着需要被定义的操作符的符号。<br>像其它函数一样，重载操作符有返回值，参数列表和函数体。</p>
<p>重载操作符的参数和操作符的操作数一样多。除了函数调用操作符，<code>operator()</code>，重载操作符<br>没有默认实参。</p>
<blockquote>
<p><strong>注意</strong><br>当重载操作符是成员函数时，<code>this</code>绑定到左操作数。因此，成员操作符函数少一个操作数。</p>
</blockquote>
<p>操作符函数必须为类的成员或至少有一个类类型参数：</p>
<pre><code><span class="comment">// error: cannot redefine the built-in operator for ints</span>
<span class="keyword">int</span> <span class="keyword">operator</span>+(<span class="keyword">int</span>, <span class="keyword">int</span>);
</code></pre><p>我们可以重载大多数操作符，而且只能重载已经存在的操作符：</p>
<pre><code>                可以重载的操作符
+       -       *       /       %       ^
&amp;       |       ~       !       ,       =
&lt;       &gt;       &lt;=      &gt;=      ++      --
&lt;&lt;      &gt;&gt;      ==      !=      &amp;&amp;      ||
+=      -=      /=      %=      ^=      &amp;=
|=      *=      &lt;&lt;=     &gt;&gt;=     []      <span class="function"><span class="params">()</span>
-&gt;</span><span class="function">      -&gt;*</span>     <span class="keyword">new</span>     <span class="keyword">new</span>[]   <span class="keyword">delete</span>  <span class="keyword">delete</span>[]
                不能重载的操作符
        ::      .*      .       ?:
</code></pre><p>重载操作符和相应的内置操作符有相同的优先级和结合性。</p>
<h2 id="直接调用重载操作符函数">直接调用重载操作符函数</h2><pre><code><span class="keyword">data</span>1 + <span class="keyword">data</span>2;           // 表达式调用
operator+(<span class="keyword">data</span>1, <span class="keyword">data</span>2); // 等价的函数调用
<span class="keyword">data</span>1 += <span class="keyword">data</span>2;          // 表达式调用
<span class="keyword">data</span>1.operator+=(<span class="keyword">data</span>2); // 等价的成员函数调用
</code></pre><h2 id="有些操作符不应该重载">有些操作符不应该重载</h2><p>重载操作符不保留求值顺序或短路求值。</p>
<blockquote>
<p><strong>最佳实践</strong><br>通常，逗号（,），取地址（&amp;），逻辑与（&amp;&amp;）和逻辑或（||）不应该重载。</p>
</blockquote>
<h2 id="使用和内置操作符意思一致的定义">使用和内置操作符意思一致的定义</h2><ul>
<li>如果类使用IO，定义与内置类型IO操作一致的<code>shift</code>操作符</li>
<li>如果类有测试相等的操作，定义<code>operator==</code>。如果类有<code>operator==</code>，通常也应该定义<code>operator!=</code>。</li>
<li>如果类有单一的，自然顺序的操作，定义<code>operator&lt;</code>。如果类有<code>operator&lt;</code>，通常也应该定义其它关系操作符。</li>
<li>重载操作符的返回类型应该和内置操作符的返回类型兼容：逻辑操作符和关系操作符应该返回<code>bool</code>，算术操作符<br>应该返回类的值，赋值操作符应该返回左操作数的引用。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：明智地使用操作符重载<br>当内置操作符和类的操作有逻辑映射的时候，操作符重载最有用。</p>
</blockquote>
<h2 id="选择成员或非成员实现">选择成员或非成员实现</h2><p>以下指导方针能够帮助我们决定是否将一个操作符定义为成员函数或普通的非成员函数：</p>
<ul>
<li>赋值操作符（=），下标操作符（[]），调用操作符（()），成员访问操作符（-&gt;）必须定义为成员。</li>
<li>复合赋值操作符通常应该定义为成员，但是没有要求一定这样。</li>
<li>改变对象状态或与类对象联系紧密的操作符，通常应该定义为成员。比如++，–和解引用（*）。</li>
<li>那些可能转换操作数的对称的操作符，比如算术操作符，关系操作符，位操作符，通常应该定义为非成员。</li>
</ul>
<h1 id="输入输出操作符">输入输出操作符</h1><h2 id="重载输出操作符_&lt;&lt;">重载输出操作符 &lt;&lt;</h2><pre><code>ostream &amp;operator&lt;&lt;(ostream &amp;os, const Sales_data &amp;<span class="property">item</span>)
{
    os &lt;&lt; <span class="property">item</span>.isbn() &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="property">item</span>.units_sold &lt;&lt; <span class="string">" "</span>
       &lt;&lt; <span class="property">item</span>.revenue &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="property">item</span>.avg_price();
<span class="command">    return</span> os;
}
</code></pre><blockquote>
<p><strong>最佳实践</strong><br>通常输出操作符应该最小格式化输出对象的内容，不应该打印换行。</p>
</blockquote>
<h2 id="IO操作符必须是非成员函数">IO操作符必须是非成员函数</h2><p>输入输出操作符遵循库<code>iostream</code>的惯例必须为普通的非成员函数。</p>
<pre><code><span class="type">Sales_data</span> <span class="typedef"><span class="keyword">data</span>;</span>
<span class="typedef"><span class="keyword">data</span> &lt;&lt; cout; // 如果operator&lt;&lt;是<span class="type">Sales_data</span>的一个成员</span>
</code></pre><p>如果这些操作符是任意一个类的成员，那它们应该是<code>istream</code>或<code>ostream</code>的成员，但是我们无法给标准库添加成员。<br>输入输出操作符通常需要读或写非公开的数据成员。因此，IO操作符通常必须声明为<code>friend</code>。</p>
<h2 id="重载输入操作符_&gt;&gt;">重载输入操作符 &gt;&gt;</h2><pre><code>istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;<span class="keyword">is</span>, Sales_data &amp;item)
{
    <span class="keyword">double</span> price;
    <span class="keyword">is</span> &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;
    <span class="keyword">if</span> (<span class="keyword">is</span>)        <span class="comment">// 检查输入是否成功</span>
        item.revenue = item.units_sold * price;
    <span class="keyword">else</span>
        item = Sales_data(); <span class="comment">// 输入失败：给对象一个默认值</span>
    <span class="keyword">return</span> <span class="keyword">is</span>;
}
</code></pre><blockquote>
<p><strong>注意</strong><br>输入操作符必须处理输入失败的可能性。输出操作符通常没有这个困扰。</p>
</blockquote>
<p>我们选择在读取了所有数据之后，使用数据之前来检查流状态。</p>
<blockquote>
<p><strong>最佳实践</strong><br>输入操作符应该决定做什么错误恢复。当错误发生时，使对象处于一个合法状态尤其重要，因为对象可能被部分修改。</p>
</blockquote>
<p>通常输入操作符应该只设置<code>failbit</code>。<code>eofbit</code>和<code>badbit</code>最好是留给IO库去指示。</p>
<h1 id="算术和关系操作符">算术和关系操作符</h1><p>通常我们将算术和关系操作符定义为非成员函数，以允许转换左右操作符中的一个。这些操作符不需要修改<br>操作数的状态，所以参数通常为<code>const</code>引用。<br>定义了算术操作符的类通常也要定义相应的复合赋值操作符。</p>
<pre><code>Sales_data
operator+(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)
{
    Sales_data <span class="keyword">sum</span> = lhs;
    <span class="keyword">sum</span> += rhs;
    <span class="keyword">return</span> <span class="keyword">sum</span>;
}
</code></pre><blockquote>
<p><strong>提示</strong><br>定义了算术操作符和相应的复合赋值操作符的类，应该使用复合赋值操作符来实现算术操作符。</p>
</blockquote>
<h2 id="相等操作符">相等操作符</h2><pre><code><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)
{
    <span class="keyword">return</span> lhs.isbn() == rhs.isbn() &amp;&amp;
           lhs.units_sold == rhs.units_sold &amp;&amp;
           lhs.revenue == rhs.revenue;
}
<span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)
{
    <span class="keyword">return</span> !(lhs == rhs);
}
</code></pre><p>相等操作符的设计原理：</p>
<ul>
<li>如果一个类有一个确定2个对象是否相等的操作，那么该类应该定义<code>operator==</code>，而不是命名函数。<br>而且可以容易使用标准库容器和算法。</li>
<li>如果一个类定义了<code>operator==</code>，这个操作符通常应该确定给定的对象是否包含相同的数据。</li>
<li>通常地，相等操作符应该是可传递的， <code>if a == b and b == c, then a == c</code>。</li>
<li>如果一个类定义了<code>operator==</code>，那也应该定义<code>operator!=</code>，反之也一样。</li>
<li>相等或不等操作符应该将实际工作委托给另一个。</li>
</ul>
<blockquote>
<p><strong>最佳实践</strong><br>相等性具有逻辑意义的类通常应该定义<code>operator==</code>，定义了<code>operator==</code>的类使得用户容易使用标准库算法。</p>
</blockquote>
<h2 id="关系操作符">关系操作符</h2><p>定义了相等操作符的类通常（不总是）也会定义关系操作符。特别地，关系容器和有些算法使用<code>&lt;</code>操作符，<br>定义<code>operator&lt;</code>会很有用。</p>
<p>通常关系操作符应该：</p>
<ul>
<li>定义一个顺序关系和关联容器的key的需求一致。</li>
<li>定义一个关系和<code>==</code>一致，如果类2种操作符都定义了。特别地，如果2个对象<code>!=</code>，则其中一个应该<code>&lt;</code>另一个。</li>
</ul>
<blockquote>
<p><strong>最佳实践</strong><br>如果只有一个逻辑定义<code>&lt;</code>存在，类通常应该定义<code>&lt;</code>操作符。然而，如果类也有<code>==</code>，只有当<code>&lt;</code>和<code>==</code>产生<br>的结果一致时，定义<code>&lt;</code>。</p>
</blockquote>
<h1 id="赋值操作符">赋值操作符</h1><p>除了<code>copy-</code>和<code>move-</code>赋值操作符之外，类还可以定义其它的赋值操作符允许其它类型作为右操作数。</p>
<pre><code><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;
v = {<span class="string">"a"</span>, <span class="string">"an"</span>, <span class="string">"the"</span>};
<span class="keyword">class</span> StrVec {
<span class="keyword">public</span>:
    StrVec &amp;<span class="keyword">operator</span>=(<span class="built_in">std</span>::initializer_list&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;);
};
StrVec &amp;StrVec::<span class="keyword">operator</span>=(initializer_list&lt;<span class="built_in">string</span>&gt; il)
{
    <span class="keyword">auto</span> data = alloc_n_copy(il.begin(), il.end());
    <span class="built_in">free</span>();
    elements = data.first;
    first_free = cap = data.second;
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
</code></pre><p>不像<code>copy-</code>和<code>move-</code>赋值操作符，这个操作符不需要检查自我赋值。</p>
<blockquote>
<p><strong>注意</strong><br>赋值操作符可以被重载。不管参数类型是什么，赋值操作符必须定义为成员函数。</p>
</blockquote>
<p>复合赋值操作符不需要是类成员。然而，我们倾向于定义所有的赋值操作符，包括复合赋值操作符为类成员。</p>
<pre><code>Sales_data&amp; Sales_data::<span class="keyword">operator</span>+=(<span class="keyword">const</span> Sales_data &amp;rhs)
{
    units_sold += rhs.units_sold;
    revenue += rhs.revenue;
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
</code></pre><blockquote>
<p><strong>最佳实践</strong><br>赋值操作符必须，而且通常复合赋值操作符应该，定义为成员。这些操作符应该返回左操作数的引用。</p>
</blockquote>
<h1 id="下标操作符">下标操作符</h1><p>可以通过位置来获取元素的代表容器的类，通常定义下标操作符，<code>operater[]</code>。</p>
<blockquote>
<p><strong>注意</strong><br>下标操作符必须为成员函数。</p>
<p><strong>最佳实践</strong><br>如果一个类有下标操作符，它通常应该定义2个版本：一个返回普通引用，一个返回const引用。</p>
</blockquote>
<pre><code><span class="keyword">class</span> StrVec {
<span class="keyword">public</span>:
    <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n)
        { <span class="keyword">return</span> elements[n]; }
    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n) <span class="keyword">const</span>
        { <span class="keyword">return</span> elements[n]; }
<span class="keyword">private</span>:
    <span class="built_in">std</span>::<span class="built_in">string</span> *elements; <span class="comment">// 指向数组第一个元素</span>
};

<span class="keyword">const</span> StrVec cvec = svec;
<span class="keyword">if</span> (svec.size() &amp;&amp; svec[<span class="number">0</span>].empty())  {
    svec[<span class="number">0</span>] = <span class="string">"zero"</span>; <span class="comment">// ok: 返回一个普通引用</span>
    cvec[<span class="number">0</span>] = <span class="string">"Zip"</span>;  <span class="comment">// error: 返回一个const引用</span>
}
</code></pre><h1 id="自增和自减操作符">自增和自减操作符</h1><p>自增和自减操作符最常被迭代器类实现。语言并没要要求这些操作符是成员，但是由于这些操作符改变它们操作<br>的对象的状态，我们选择将它们定义为成员。</p>
<blockquote>
<p><strong>最佳实践</strong><br>定义自增或自减操作符的类应该定义<code>prefix</code>和<code>postfix</code>版本。这些操作符应该定义为成员。</p>
</blockquote>
<pre><code><span class="keyword">class</span> StrBlobPtr {
<span class="keyword">public</span>:
    StrBlobPtr&amp; <span class="keyword">operator</span>++(); <span class="comment">// 前自增操作符</span>
    StrBlobPtr&amp; <span class="keyword">operator</span>--(); <span class="comment">// 前自减操作符</span>
};

StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>++()
{
    check(curr, <span class="string">"increment past end of StrBlobPtr"</span>);
    ++curr;
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>--()
{
    --curr;
    check(-<span class="number">1</span>, <span class="string">"decrement past begin of StrBlobPtr"</span>);
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
</code></pre><blockquote>
<p><strong>最佳实践</strong><br>为了和内置操作符一致，前置操作符应该返回自增过或自减过的对象的引用。</p>
</blockquote>
<pre><code><span class="keyword">class</span> StrBlobPtr {
<span class="keyword">public</span>:
    StrBlobPtr <span class="keyword">operator</span>++(<span class="keyword">int</span>);    <span class="comment">// 后置操作符</span>
    StrBlobPtr <span class="keyword">operator</span>--(<span class="keyword">int</span>);
};

StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>++(<span class="keyword">int</span>)
{
    StrBlobPtr ret = *<span class="keyword">this</span>;
    ++*<span class="keyword">this</span>;
    <span class="keyword">return</span> ret;
}
StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>--(<span class="keyword">int</span>)
{
    StrBlobPtr ret = *<span class="keyword">this</span>;
    --*<span class="keyword">this</span>;
    <span class="keyword">return</span> ret;
}
</code></pre><blockquote>
<p><strong>最佳实践</strong><br>为了和内置操作符一致，后置操作符应该返回旧的（未自增或自减）值，而不是引用。</p>
<p><strong>注意</strong><br><code>int</code>参数没有用到，所以没有给它一个名字。</p>
</blockquote>
<pre><code><span class="function">StrBlobPtr <span class="title">p</span><span class="params">(a1)</span></span>;
p.<span class="keyword">operator</span>++(<span class="number">0</span>);  <span class="comment">// 调用后自增操作符</span>
p.<span class="keyword">operator</span>++();   <span class="comment">// 调用前自增操作符</span>
</code></pre><h1 id="成员访问操作符">成员访问操作符</h1><p>解引用（*）和箭头（-&gt;）操作符经常使用在迭代器类和智能指针类中。</p>
<pre><code><span class="keyword">class</span> StrBlobPtr {
<span class="keyword">public</span>:
    <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>
    { 
        <span class="keyword">auto</span> p = check(curr, <span class="string">"dereference past end"</span>);
        <span class="keyword">return</span> (*p)[curr];  <span class="comment">// (*p)是这个对象指向的vector</span>
    }
    <span class="built_in">std</span>::<span class="built_in">string</span>* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>
    {
        <span class="keyword">return</span> &amp; <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*(); <span class="comment">// 将实际工作委托给解引用操作符</span>
    }
};
</code></pre><blockquote>
<p><strong>注意</strong><br>箭头操作符必须定义为成员，没有要求解引用为成员但通常也应该为成员。</p>
</blockquote>
<p>值得注意的是我们定义这些操作符为<code>const</code>成员，获取一个元素不会改变这个对象的状态。</p>
<pre><code>StrBlob a1 = {<span class="string">"hi"</span>, <span class="string">"bye"</span>, <span class="string">"now"</span>};
<span class="function">StrBlobPtr <span class="title">p</span><span class="params">(a1)</span></span>;            <span class="comment">// p指向a1里面的vector</span>
*p = <span class="string">"okay"</span>;                 <span class="comment">// 给a1中第一个元素赋值</span>
<span class="built_in">cout</span> &lt;&lt; p-&gt;size() &lt;&lt; endl;   <span class="comment">// 第一个元素的size()</span>
<span class="built_in">cout</span> &lt;&lt; (*p).size() &lt;&lt; endl; <span class="comment">// 等价于p-&gt;size()</span>
</code></pre><p>当我们写<code>point-&gt;mem</code>时，<code>point</code>必须是指向一个类对象的指针或是一个重载了<code>operator-&gt;</code>的类<br>的对象。取决于<code>point</code>的类型，<code>point-&gt;mem</code>等价于：</p>
<pre><code>(*<span class="built_in">point</span>).mem;          <span class="comment">// point是一个内置指针类型</span>
<span class="built_in">point</span>.operator()-&gt;mem; <span class="comment">// point是一个类的对象</span>
</code></pre><blockquote>
<p><strong>注意</strong><br>箭头操作符必须返回一个指向类类型的指针或一个定义了自己的箭头操作符的类类型的对象。</p>
</blockquote>
<h1 id="函数调用操作符">函数调用操作符</h1><p>重载了函数调用操作符的类允许它的对象像函数一样使用。因为这种类可以保存状态，它们比普通函数更灵活。</p>
<pre><code><span class="keyword">struct</span> absInt {
    <span class="built_in">int</span> operator<span class="literal">()</span>(<span class="built_in">int</span> <span class="keyword">val</span>) const {
        return <span class="keyword">val</span> &lt; <span class="number">0</span> ? -<span class="keyword">val</span> : <span class="keyword">val</span>;
    }
};
</code></pre><p>定义了函数调用操作符的类的对象被称为函数对象，我们可以像函数调用一样提供一个参数列表给函数对象：</p>
<pre><code><span class="keyword">int</span> i = -<span class="number">42</span>;
absInt absObj;
<span class="keyword">int</span> ui = absObj(i);
</code></pre><blockquote>
<p><strong>注意</strong><br>函数调用操作符必须是成员函数。一个类可以定义多个版本的调用操作符，每一个参数类型或数量必须不一样。</p>
</blockquote>
<p>和其他类一样，一个函数对象类除了<code>operator()</code>，还可以有其它成员。函数对象类通常包含其它成员用来<br>调整函数调用操作符的操作。</p>
<pre><code><span class="keyword">class</span> PrintString {
<span class="keyword">public</span>:
    PrintString(ostream &amp;o = <span class="built_in">cout</span>, <span class="keyword">char</span> c = <span class="string">' '</span>):
        os(o), sep(c) { }
    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> <span class="keyword">const</span> </span>{ os &lt;&lt; s &lt;&lt; sep;}
<span class="keyword">private</span>:
    ostream &amp;os;   <span class="comment">// stream on which to write</span>
    <span class="keyword">char</span> sep;      <span class="comment">// character to print after each output</span>
};

PrintString printer;   <span class="comment">// uses the defaults; prints to cout</span>
printer(s);            <span class="comment">// prints s followed by a space on cout</span>
<span class="function">PrintString <span class="title">errors</span><span class="params">(<span class="built_in">cerr</span>, <span class="string">'\n'</span>)</span></span>;
errors(s);             <span class="comment">// prints s followed by a newline on cerr</span>
</code></pre><p>函数对象最常用于泛型算法的参数：</p>
<pre><code>for_each<span class="list">(<span class="keyword">vs</span>.begin<span class="list">()</span>, vs.end<span class="list">()</span>, PrintString<span class="list">(<span class="keyword">cerr</span>, '\n')</span>)</span><span class="comment">;</span>
</code></pre><h2 id="Lambdas是函数对象">Lambdas是函数对象</h2><p>当我们写一个<code>lambda</code>时，编译器将表达式翻译成一个匿名类的匿名对象。由<code>lambda</code>生成的类<br>包含了一个重载的函数调用操作符。</p>
<pre><code>stable_sort<span class="list">(<span class="keyword">words</span>.begin<span class="list">()</span>, words.end<span class="list">()</span>,
            []<span class="list">(<span class="keyword">const</span> string <span class="keyword">&amp;a</span>, const string <span class="keyword">&amp;b</span>)</span>
              { return a.size<span class="list">()</span> &lt; b.size<span class="list">()</span><span class="comment">;});</span></span>
</code></pre><p>行为就像一个匿名对象的类，看起来像：</p>
<pre><code><span class="keyword">class</span> <span class="title">ShorterString</span> {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span>(<span class="params"></span>)(<span class="params"><span class="keyword">const</span> <span class="keyword">string</span> &amp;s1, <span class="keyword">const</span> <span class="keyword">string</span> &amp;s2</span>) <span class="keyword">const</span>
    </span>{ <span class="keyword">return</span> s1.size() &lt; s2.size(); }
};

stable_sort(words.begin(), words.end(), ShorterString());
</code></pre><h2 id="类表示Lambdas带捕获成员">类表示Lambdas带捕获成员</h2><pre><code>auto wc = find_if<span class="list">(<span class="keyword">words</span>.begin<span class="list">()</span>, words.end<span class="list">()</span>,
            [sz]<span class="list">(<span class="keyword">const</span> string <span class="keyword">&amp;a</span>)</span>{ return a.size<span class="list">()</span> &gt;= sz<span class="comment">;});</span></span>
</code></pre><p>会生成像这样的类：</p>
<pre><code><span class="keyword">class</span> SizeComp {
<span class="keyword">public</span>:
    SizeComp(<span class="keyword">size_t</span> n): sz(n) { } <span class="comment">// parameter for each captured variable</span>
    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> <span class="keyword">const</span>
        </span>{ <span class="keyword">return</span> s.size() &gt;= sz; }
<span class="keyword">private</span>:
    <span class="keyword">size_t</span> sz; <span class="comment">// a data member for each variable captured by value</span>
};

<span class="keyword">auto</span> wc = find_if(words.begin(), words.end(), SizeComp(sz));
</code></pre><p>由lambda表达式生成的类有一个<code>deleted</code>默认构造函数，<code>deleted</code>赋值操作符和一个默认析构函数。<br>是否有默认的或<code>deleted``copy/move</code>构造函数取决于捕获的数据成员。</p>
<h2 id="标准库定义的函数对象">标准库定义的函数对象</h2><p>标准库定义了一个类集合，表示算术，关系和逻辑运算符。<br><code>plus</code>类有一个函数调用操作符，应用<code>+</code>操作符。<br><code>modulus</code>类有一个函数调用操作符，应用<code>%</code>操作符。<br><code>equal_to</code>类有一个函数调用操作符，应用<code>==</code>操作符。</p>
<pre><code>plus&lt;<span class="built_in">int</span>&gt; intAdd;       // <span class="function"><span class="keyword">function</span></span> object that can add two <span class="built_in">int</span> values
negate&lt;<span class="built_in">int</span>&gt; intNegate;  // <span class="function"><span class="keyword">function</span></span> object that can negate an <span class="built_in">int</span> <span class="keyword">value</span>
<span class="built_in">int</span> <span class="built_in">sum</span> = intAdd(<span class="number">10</span>, <span class="number">20</span>);         // <span class="built_in">sum</span> = <span class="number">30</span>
<span class="built_in">sum</span> = intNegate(intAdd(<span class="number">10</span>, <span class="number">20</span>));  // <span class="built_in">sum</span> = -<span class="number">30</span>
<span class="built_in">sum</span> = intAdd(<span class="number">10</span>, intNegate(<span class="number">10</span>));  // <span class="built_in">sum</span> = <span class="number">0</span>
</code></pre><h2 id="算法中使用标准库函数对象">算法中使用标准库函数对象</h2><pre><code><span class="comment">// passes a temporary function object that applies the &lt; operator to two strings</span>
sort(svec.<span class="keyword">begin</span>(), svec.<span class="keyword">end</span>(), greater&lt;<span class="keyword">string</span>&gt;());
</code></pre><p>标准库函数对象保证对指针也有作用。</p>
<pre><code>vector&lt;<span class="keyword">string</span> *&gt; nameTable;  <span class="comment">// vector of pointers</span>
<span class="comment">// error: the pointers in nameTable are unrelated, so &lt; is undefined</span>
sort(nameTable.<span class="keyword">begin</span>(), nameTable.<span class="keyword">end</span>(),
     [](<span class="keyword">string</span> *a, <span class="keyword">string</span> *b) <span class="comment">{ return a &lt; b; }</span>);
<span class="comment">// ok: library guarantees that less on pointer types is well defined</span>
sort(nameTable.<span class="keyword">begin</span>(), nameTable.<span class="keyword">end</span>(), less&lt;<span class="keyword">string</span>*&gt;());
</code></pre><p>值得注意的是关联容器使用<code>less&lt;key_type&gt;</code>排序它们的元素。因此，我们能定义一个指针集合，或者使用<br>一个指针作为<code>key</code>的<code>map</code>容器而不用直接指定<code>less</code>。</p>
<h2 id="可调用对象和函数">可调用对象和函数</h2><p>C++有几种可调用对象：函数和函数指针，lambdas，由<code>bind</code>创建的对象和重载了函数调用操作符的类。</p>
<p>不同类型可以有相同的调用签名：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{ <span class="keyword">return</span> i + j; } <span class="comment">// 普通函数</span>
<span class="keyword">auto</span> mod = [](<span class="keyword">int</span> i, <span class="keyword">int</span> j) { <span class="keyword">return</span> i % j; }; <span class="comment">// 匿名函数</span>
<span class="comment">// 函数对象类</span>
<span class="keyword">struct</span> div {
    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> denominator, <span class="keyword">int</span> divisor)</span> </span>{
        <span class="keyword">return</span> denominator / divisor;
    }
};

<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>(*)(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; binops;

binops.insert({<span class="string">"+"</span>, add}); <span class="comment">// ok: add是一个指向合适类型的函数指针</span>
binops.insert({<span class="string">"%"</span>, mod}); <span class="comment">// error: mod不是一个指向函数的指针</span>
</code></pre><h3 id="标准库function类型">标准库function类型</h3><pre><code><span class="comment">#include &lt;functional&gt;</span>

<span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt; <span class="title">f</span></span>;          空函数对象。
<span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt; <span class="title">f</span><span class="params">(nullptr)</span></span>; 显式构造空函数对象。
<span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt; <span class="title">f</span><span class="params">(obj)</span></span>;     保存一个obj的副本。
f                       <span class="keyword">true</span>当f拥有一个可调用对象，否则<span class="keyword">false</span>。
f(args)                 传递参数args，调用函数。

定义为<span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;的成员的类型
<span class="title">result_type</span>             可调用对象的返回类型。
<span class="title">argument_type</span>           当参数为1个或2个时的类型。
<span class="title">first_argument_type</span>
<span class="title">second_argument_type</span></span>
</code></pre><p><code>function</code>是一个模板。和其它模板一样，我们必须指定<code>function</code>的函数类型。</p>
<pre><code>function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f1 = add;    <span class="comment">// 函数指针</span>
function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f2 = div();  <span class="comment">// 函数对象</span>
function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f3 = [](<span class="keyword">int</span> i, <span class="keyword">int</span> j) { <span class="keyword">return</span> i * j;}; <span class="comment">// 匿名函数</span>
<span class="built_in">cout</span> &lt;&lt; f1(<span class="number">4</span>,<span class="number">2</span>) &lt;&lt; endl; <span class="comment">// prints 6</span>
<span class="built_in">cout</span> &lt;&lt; f2(<span class="number">4</span>,<span class="number">2</span>) &lt;&lt; endl; <span class="comment">// prints 2</span>
<span class="built_in">cout</span> &lt;&lt; f3(<span class="number">4</span>,<span class="number">2</span>) &lt;&lt; endl; <span class="comment">// prints 8</span>

<span class="built_in">map</span>&lt;<span class="built_in">string</span>, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; binops = {
    {<span class="string">"+"</span>, add},                  <span class="comment">// function pointer</span>
    {<span class="string">"-"</span>, <span class="built_in">std</span>::minus&lt;<span class="keyword">int</span>&gt;()},    <span class="comment">// library function object</span>
    {<span class="string">"/"</span>,  div()},               <span class="comment">// user-defined function object</span>
    {<span class="string">"*"</span>, [](<span class="keyword">int</span> i, <span class="keyword">int</span> j) { <span class="keyword">return</span> i * j; }}, <span class="comment">// unnamed lambda</span>
    {<span class="string">"%"</span>, mod} };                <span class="comment">// named lambda object</span>

binops[<span class="string">"+"</span>](<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// calls add(10, 5)</span>
binops[<span class="string">"-"</span>](<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// uses the call operator of the minus&lt;int&gt; object</span>
binops[<span class="string">"/"</span>](<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// uses the call operator of the div object</span>
binops[<span class="string">"*"</span>](<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// calls the lambda function object</span>
binops[<span class="string">"%"</span>](<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// calls the lambda function object</span>
</code></pre><h3 id="重载函数和function">重载函数和function</h3><p>我们不能直接保存一个重载函数的函数名：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{ <span class="keyword">return</span> i + j; }
<span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;
<span class="built_in">map</span>&lt;<span class="built_in">string</span>, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; binops;
binops.insert({<span class="string">"+"</span>, add}); <span class="comment">// error: which add?</span>
</code></pre><p>解决二义性的一个方法是存储函数指针：</p>
<pre><code><span class="built_in">int</span> (*fp)(<span class="built_in">int</span>,<span class="built_in">int</span>) = <span class="built_in">add</span>;
binops.insert({<span class="string">"+"</span>, fp});
</code></pre><p>或者使用lambda消除歧义：</p>
<pre><code>binops.insert({<span class="string">"+"</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) {<span class="function"><span class="keyword">return</span> <span class="title">add</span><span class="params">(a, b)</span></span>;}});
</code></pre><h1 id="重载，转换和操作符">重载，转换和操作符</h1><p>转换构造函数和转换操作符定义了类类型的转换。这种转换又叫做用户定义的转换。</p>
<h2 id="转换操作符">转换操作符</h2><p>转换操作符是一种特殊的成员函数，将一个类类型的值转换为其它类型的值。一个典型的转换函数具有形式：</p>
<pre><code><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">const</span></span>;
</code></pre><p>转换操作符可以为任意（除了<code>void</code>）函数返回的类型定义转换。不允许转换为数组或函数类型。<br>允许转换为指针（数据指针和函数指针）和引用。</p>
<blockquote>
<p><strong>注意</strong><br>转换函数必须是一个成员函数，不能指定返回类型，参数列表必须为空，通常为const。</p>
</blockquote>
<h3 id="定义一个具有转换操作符的类">定义一个具有转换操作符的类</h3><pre><code><span class="keyword">class</span> SmallInt {
<span class="keyword">public</span>:
    SmallInt(<span class="keyword">int</span> i = <span class="number">0</span>): val(i)
    {
        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; <span class="number">255</span>)
            <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">"Bad SmallInt value"</span>);
    }
    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> val; }
<span class="keyword">private</span>:
    <span class="built_in">std</span>::<span class="keyword">size_t</span> val;
};

SmallInt si;
si = <span class="number">4</span>; <span class="comment">// implicitly converts 4 to SmallInt then calls SmallInt::operator=</span>
si + <span class="number">3</span>; <span class="comment">// implicitly converts si to int followed by integer addition</span>
</code></pre><p>尽管编译器每次只应用一个用户定义的转换操作，隐式调用用户定义的转换可以在之前或之后跟着一个标准转换。</p>
<pre><code>SmallInt si = <span class="number">3.14</span>;
si + <span class="number">3.14</span>;
</code></pre><p>因为转换操作符是隐式调用的，没有办法给它们传递参数。因此，转换操作符不带参数。尽管转换函数没有<br>指定返回值，每一个转换函数必须返回相应的转换类型。</p>
<pre><code><span class="keyword">class</span> SmallInt {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">int</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>;            <span class="comment">// error: return type</span>
    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">(<span class="keyword">int</span> = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;         <span class="comment">// error: parameter list</span>
    <span class="keyword">operator</span> <span class="keyword">int</span>*() <span class="keyword">const</span> { <span class="keyword">return</span> <span class="number">42</span>; } <span class="comment">// error: 42 is not a pointer</span>
};
<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">(SmallInt&amp;)</span></span>;                 <span class="comment">// error: nonmember</span>
</code></pre><blockquote>
<p><strong>警告</strong><br>避免滥用转换函数。</p>
</blockquote>
<h3 id="转换操作符可以产生惊人的结果">转换操作符可以产生惊人的结果</h3><p>实际上，类很少定义转换操作符。然而一个例外是：类定义转换为bool类型并不罕见。</p>
<pre><code><span class="keyword">int</span> i = <span class="number">42</span>;
<span class="built_in">cin</span> &lt;&lt; i; <span class="comment">// this code would be legal if the conversion to bool were not explicit!</span>
</code></pre><h3 id="explicit转换操作符">explicit转换操作符</h3><p>为了防止前面的问题，新标准引入<code>explicit</code>转换。</p>
<pre><code><span class="keyword">class</span> SmallInt {
<span class="keyword">public</span>:
    <span class="comment">// the compiler won't automatically apply this conversion</span>
    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> val; }
};

SmallInt si = <span class="number">3</span>;  <span class="comment">// ok: the SmallInt constructor is not explicit</span>
si + <span class="number">3</span>; <span class="comment">// error: implicit conversion is required, but operator int is explicit</span>
<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(si) + <span class="number">3</span>; <span class="comment">// ok: explicitly request the conversion</span>
</code></pre><p>如果转换操作符是<code>explicit</code>的，我们只能通过<code>cast</code>来显式转换。一个例外是编译器会在条件测试中应用显式转换：</p>
<ul>
<li><code>if</code>，<code>while</code>或<code>do while</code>条件测试</li>
<li><code>for</code>的条件表达式</li>
<li>逻辑非<code>!</code>，逻辑与<code>&amp;&amp;</code>或逻辑或<code>||</code>的操作数</li>
<li>条件运算符<code>?:</code>条件测试</li>
</ul>
<h3 id="转换为bool类型">转换为bool类型</h3><p>当我们在条件测试中使用流对象，我们使用定义在IO类型里面的<code>operator bool</code>转换操作：</p>
<pre><code><span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; value)
</code></pre><blockquote>
<p><strong>最佳实践</strong><br>通常转换为<code>bool</code>是有意用于条件测试的。因此，<code>operator bool</code>通常应该定义为<code>explicit</code>。</p>
</blockquote>
<h2 id="避免歧义的转换">避免歧义的转换</h2><p>有两种方法会发生多个转换路径的情况。第一个就是当2个类提供了相互的转换。第二个就是定义了多个转换，<br>转换类型之间也可以转换。</p>
<blockquote>
<p><strong>警告</strong><br>通常，类定义相互转换或定义了多个从算术类型或到算术类型的转换是个坏主意。</p>
</blockquote>
<h3 id="参数匹配和相互转换">参数匹配和相互转换</h3><pre><code><span class="keyword">struct</span> B;
<span class="keyword">struct</span> A {
    A() = <span class="keyword">default</span>;
    A(<span class="keyword">const</span> B&amp;);        <span class="comment">// converts a B to an A</span>
};
<span class="keyword">struct</span> B {
    <span class="function"><span class="keyword">operator</span> <span class="title">A</span>(<span class="params"></span>) <span class="keyword">const</span></span>; <span class="comment">// also converts a B to an A</span>
};

<span class="function">A <span class="title">f</span>(<span class="params"><span class="keyword">const</span> A&amp;</span>)</span>;
B b;
A a = f(b); <span class="comment">// error ambiguous: f(B::operator A())</span>
            <span class="comment">//          or f(A::A(const B&amp;))</span>

A a1 = f(b.<span class="function"><span class="keyword">operator</span> <span class="title">A</span>(<span class="params"></span>))</span>; <span class="comment">// ok: use B's conversion operator</span>
A a2 = f(A(b));           <span class="comment">// ok: use A's constructor</span>
</code></pre><p>需要注意的是我们不能通过<code>cast</code>来解决这个二义性，因为<code>cast</code>有着一样的歧义。</p>
<h3 id="内置类型的多个转换和歧义">内置类型的多个转换和歧义</h3><pre><code><span class="keyword">struct</span> A {
    A(<span class="keyword">int</span> = <span class="number">0</span>);   <span class="comment">// usually a bad idea to have two</span>
    A(<span class="keyword">double</span>);    <span class="comment">// conversions from arithmetic types</span>
    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>;    <span class="comment">// usually a bad idea to have two</span>
    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// conversions to arithmetic types</span>
};

<span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span>)</span></span>;
A a;
f2(a); <span class="comment">// error ambiguous: f(A::operator int())</span>
       <span class="comment">//          or f(A::operator double())</span>
<span class="keyword">long</span> lg;
<span class="function">A <span class="title">a2</span><span class="params">(lg)</span></span>; <span class="comment">// error ambiguous: A::A(int) or A::A(double)</span>

<span class="keyword">short</span> s = <span class="number">42</span>;
<span class="comment">// promoting short to int is better than converting short to double</span>
<span class="function">A <span class="title">a3</span><span class="params">(s)</span></span>;  <span class="comment">// uses A::A(int)</span>
</code></pre><blockquote>
<p><strong>注意</strong><br>当使用2个用户定义的转换时，如果有标准转换，使用标准转换的级别来选择最佳匹配。</p>
<p>转换和操作符：</p>
<ul>
<li>不要定义类之间的相互转换</li>
<li>避免定义多个到内置算术类型的转换。</li>
</ul>
<p>最简单的规则就是：除了显式转换为<code>bool</code>类型外，避免定义转换函数和限制那些看起来对的隐式构造函数。</p>
</blockquote>
<h3 id="重载函数和转换构造函数">重载函数和转换构造函数</h3><pre><code><span class="keyword">struct</span> C {
    C(<span class="keyword">int</span>);
};
<span class="keyword">struct</span> D {
    D(<span class="keyword">int</span>);
};

<span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">(<span class="keyword">const</span> C&amp;)</span></span>;
<span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">(<span class="keyword">const</span> D&amp;)</span></span>;

manip(<span class="number">10</span>); <span class="comment">// error ambiguous: manip(C(10)) or manip(D(10))</span>
manip(C(<span class="number">10</span>)); <span class="comment">// ok: calls manip(const C&amp;)</span>
</code></pre><blockquote>
<p><strong>警告</strong><br>需要频繁地在函数调用中使用构造函数或强制转换来转换参数一个坏设计的表现。</p>
</blockquote>
<h3 id="重载函数和用户定义的转换">重载函数和用户定义的转换</h3><p>在重载函数调用中，如果有2个或更多用户定义的转换提供可行的匹配，转换被认为是一样好。</p>
<pre><code><span class="keyword">struct</span> E {
    E(<span class="keyword">double</span>);
};
<span class="function"><span class="keyword">void</span> <span class="title">manip2</span><span class="params">(<span class="keyword">const</span> C&amp;)</span></span>;
<span class="function"><span class="keyword">void</span> <span class="title">manip2</span><span class="params">(<span class="keyword">const</span> E&amp;)</span></span>;
<span class="comment">// error ambiguous: two different user-defined conversions could be used</span>
manip2(<span class="number">10</span>); <span class="comment">// manip2(C(10) or manip2(E(double(10)))</span>
</code></pre><blockquote>
<p><strong>注意</strong><br>在重载函数调用中，附加的标准转换级别有作用仅当可行函数是同一个用户定义的转换。如果是不同的用户<br>定义的转换，则调用有歧义。</p>
</blockquote>
<h2 id="函数匹配和操作符重载">函数匹配和操作符重载</h2><p>如果a是一个类类型，a sym b表达式可能是：</p>
<pre><code>a.operatorsym<span class="comment">(b)</span>; <span class="comment">// a has operatorsym as a member function</span>
operatorsym<span class="comment">(a, b)</span>; <span class="comment">// operatorsym is an ordinary function</span>
</code></pre><blockquote>
<p><strong>注意</strong><br>在候选函数集中表达式中的操作符可以是成员或非成员函数。</p>
</blockquote>
<pre><code><span class="keyword">class</span> SmallInt {
    <span class="keyword">friend</span> SmallInt <span class="keyword">operator</span>+(<span class="keyword">const</span> SmallInt&amp;, <span class="keyword">const</span> SmallInt&amp;);
<span class="keyword">public</span>:
    SmallInt(<span class="keyword">int</span> = <span class="number">0</span>);                   <span class="comment">// conversion from int</span>
    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> val; } <span class="comment">// conversion to int</span>
<span class="keyword">private</span>:
    <span class="built_in">std</span>::<span class="keyword">size_t</span> val;
};

SmallInt s1, s2;
SmallInt s3 = s1 + s2;  <span class="comment">// uses overloaded operator+</span>
<span class="keyword">int</span> i = s3 + <span class="number">0</span>;         <span class="comment">// error: ambiguous</span>
</code></pre><blockquote>
<p><strong>警告</strong><br>既提供了到算术类型的转换，又重载了相应的算术操作符，可能会导致二义性。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是C++ primer第五版第14章的读书笔记。</p>
<h1 id="基本概念">基本概念</h1><p>重载操作符是具有特殊名字的函数：关键字<code>operator</code>后面跟着需要被定义的操作符的符号。<br>像其它函数一样，重载操作符有返回值，参数]]>
    </summary>
    
      <category term="C++" scheme="https://opensvn.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <link href="https://opensvn.github.io/2015/09/19/syntax/"/>
    <id>https://opensvn.github.io/2015/09/19/syntax/</id>
    <published>2015-09-19T11:47:02.000Z</published>
    <updated>2015-09-22T01:25:19.127Z</updated>
    <content type="html"><![CDATA[<p>原文拷贝自<a href="https://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/syntax.md" target="_blank" rel="external">这里</a>.</p>
<p><a href="http://wowubuntu.com/" target="_blank" rel="external">访问 Wow!Ubuntu</a></p>
<p><strong>NOTE</strong>: This is Simplelified Chinese Edition Document of Markdown Syntax. If you are seeking for English Edition Document. Please refer to <a href="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="external">Markdown: Syntax</a>.</p>
<p><strong>声明</strong>： 这份文档派生(fork)于<a href="http://markdown.tw/" target="_blank" rel="external">繁体中文版</a>，在此基础上进行了繁体转简体工作，并进行了适当的润色。此文档用 Markdown 语法编写，你可以到这里<a href="https://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/syntax.md" target="_blank" rel="external">查看它的源文件</a>。「繁体中文版的原始文件可以<a href="https://github.com/othree/markdown-syntax-zhtw/blob/master/syntax.md" target="_blank" rel="external">查看这里</a> 。」–By @<a href="http://twitter.com/riku" target="_blank" rel="external">riku</a></p>
<p><strong>注</strong>： 本项目托管于 <a href="http://gitcafe.com/riku/Markdown-Syntax-CN/" target="_blank" rel="external">GitCafe</a>上，请通过”派生”和”合并请求”来帮忙改进本项目。</p>
<h1 id="Markdown_语法说明_(简体中文版)_/_(点击查看快速入门)">Markdown 语法说明 (简体中文版) / (<a href="https://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/basic.html" target="_blank" rel="external">点击查看快速入门</a>)</h1><ul>
<li><a href="#overview">概述</a><ul>
<li><a href="#philosophy">宗旨</a></li>
<li><a href="#html">兼容 HTML</a></li>
<li><a href="#autoescape">特殊字符自动转换</a></li>
</ul>
</li>
<li><a href="#block">区块元素</a><ul>
<li><a href="#p">段落和换行</a></li>
<li><a href="#header">标题</a></li>
<li><a href="#blockquote">区块引用</a></li>
<li><a href="#list">列表</a></li>
<li><a href="#precode">代码区块</a></li>
<li><a href="#hr">分隔线</a></li>
</ul>
</li>
<li><a href="#span">区段元素</a><ul>
<li><a href="#link">链接</a></li>
<li><a href="#em">强调</a></li>
<li><a href="#code">代码</a></li>
<li><a href="#img">图片</a></li>
</ul>
</li>
<li><a href="#misc">其它</a><ul>
<li><a href="#backslash">反斜杠</a></li>
<li><a href="#autolink">自动链接</a></li>
</ul>
</li>
<li><a href="#acknowledgement">感谢</a></li>
<li><a href="#editor">Markdown 免费编辑器</a></li>
</ul>
<hr>
<h2 id="overview">概述</h2>

<h3 id="philosophy">宗旨</h3>

<p>Markdown 的目标是实现「易读易写」。</p>
<p>可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 <a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="external">Setext</a>、<a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="external">atx</a>、<a href="http://textism.com/tools/textile/" target="_blank" rel="external">Textile</a>、<a href="http://docutils.sourceforge.net/rst.html" target="_blank" rel="external">reStructuredText</a>、<a href="http://www.triptico.com/software/grutatxt.html" target="_blank" rel="external">Grutatext</a> 和 <a href="http://ettext.taint.org/doc/" target="_blank" rel="external">EtText</a>，而最大灵感来源其实是纯文本电子邮件的格式。</p>
<p>总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像*强调*。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。</p>
<h3 id="html">兼容 HTML</h3>

<p>Markdown 语法的目标是：成为一种适用于网络的书写语言。</p>
<p>Markdown 并不是想取代 HTML的地位，甚至接近它。它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想<em>不是</em>要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种<em>发布</em>的格式，Markdown 是一种<em>书写</em>的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。</p>
<p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。</p>
<p>要制约的只有一些 HTML 区块元素――比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 <code>&lt;p&gt;</code> 标签。</p>
<p>例子如下，在 Markdown 文件里加上一段 HTML 表格：</p>
<pre><code>这是一个普通段落。

<span class="tag">&lt;<span class="title">table</span>&gt;</span>
    <span class="tag">&lt;<span class="title">tr</span>&gt;</span>
        <span class="tag">&lt;<span class="title">td</span>&gt;</span>Foo<span class="tag">&lt;/<span class="title">td</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">tr</span>&gt;</span>
<span class="tag">&lt;/<span class="title">table</span>&gt;</span>

这是另一个普通段落。
</code></pre><p>请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的<code>*强调*</code>会没有效果。</p>
<p>HTML 的区段（行内）标签如 <code>&lt;span&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;del&gt;</code> 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 <code>&lt;a&gt;</code> 或 <code>&lt;img&gt;</code> 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。</p>
<p>和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。</p>
<h3 id="autoescape">特殊字符自动转换</h3>

<p>在 HTML 文件中，有两个字符需要特殊处理： <code>&lt;</code> 和 <code>&amp;</code> 。 <code>&lt;</code> 符号用于起始标签，<code>&amp;</code> 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 <code>&amp;lt;</code> 和 <code>&amp;amp;</code>。</p>
<p><code>&amp;</code> 字符尤其让网络文档编写者受折磨，如果你要打「<code>AT&amp;T</code>」 ，你必须要写成「<code>AT&amp;amp;T</code>」。而网址中的 <code>&amp;</code> 字符也要转换。比如你要链接到：</p>
<pre><code><span class="string">http:</span><span class="comment">//images.google.com/images?num=30&amp;q=larry+bird</span>
</code></pre><p>你必须要把网址转换写为：</p>
<pre><code><span class="string">http:</span><span class="comment">//images.google.com/images?num=30&amp;amp;q=larry+bird</span>
</code></pre><p>才能放到链接标签的 <code>href</code> 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。</p>
<p>Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 <code>&amp;</code> 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 <code>&amp;amp;</code>。</p>
<p>所以你如果要在文档中插入一个版权符号 <code>©</code>，你可以这样写：</p>
<pre><code>&amp;<span class="keyword">copy</span>;
</code></pre><p>Markdown 会保留它不动。而若你写：</p>
<pre><code><span class="built_in">AT</span>&amp;T
</code></pre><p>Markdown 就会将它转为：</p>
<pre><code>AT&amp;amp<span class="comment">;T</span>
</code></pre><p>类似的状况也会发生在 <code>&lt;</code> 符号上，因为 Markdown 允许 <a href="#html">兼容 HTML</a> ，如果你是把 <code>&lt;</code> 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写：</p>
<pre><code><span class="number">4</span> &lt; <span class="number">5</span>
</code></pre><p>Markdown 将会把它转换为：</p>
<pre><code><span class="number">4</span> &amp;lt; <span class="number">5</span>
</code></pre><p>不过需要注意的是，code 范围内，不论是行内还是区块， <code>&lt;</code> 和 <code>&amp;</code> 两个符号都一定会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 <code>&lt;</code> 和 <code>&amp;</code> 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。）</p>
<hr>
<h2 id="block">区块元素</h2>

<h3 id="p">段落和换行</h3>

<p>一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。</p>
<p>「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 <code>&lt;br /&gt;</code> 标签。</p>
<p>如果你<em>确实</em>想要依赖 Markdown 来插入 <code>&lt;br /&gt;</code> 标签的话，在插入处先按入两个以上的空格然后回车。</p>
<p>的确，需要多费点事（多加空格）来产生 <code>&lt;br /&gt;</code> ，但是简单地「每个换行都转换为 <code>&lt;br /&gt;</code>」的方法在 Markdown 中并不适合， Markdown 中 email 式的 <a href="#blockquote">区块引用</a> 和多段落的 <a href="#list">列表</a> 在使用换行来排版的时候，不但更好用，还更方便阅读。</p>
<h3 id="header">标题</h3>

<p>Markdown 支持两种标题的语法，类 <a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="external">Setext</a> 和类 <a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="external">atx</a> 形式。</p>
<p>类 Setext 形式是用底线的形式，利用 <code>=</code> （最高阶标题）和 <code>-</code> （第二阶标题），例如：</p>
<pre><code><span class="header">This is an H1
=============</span>

<span class="header">This is an H2
-------------</span>
</code></pre><p>任何数量的 <code>=</code> 和 <code>-</code> 都可以有效果。</p>
<p>类 Atx 形式则是在行首插入 1 到 6 个 <code>#</code> ，对应到标题 1 到 6 阶，例如：</p>
<pre><code><span class="preprocessor"># 这是 H1</span>

<span class="preprocessor">## 这是 H2</span>

<span class="preprocessor">###### 这是 H6</span>
</code></pre><p>你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 <code>#</code>，而行尾的 <code>#</code> 数量也不用和开头一样（行首的井字符数量决定标题的阶数）：</p>
<pre><code><span class="preprocessor"># 这是 H1 #</span>

<span class="preprocessor">## 这是 H2 ##</span>

<span class="preprocessor">### 这是 H3 ######</span>
</code></pre><h3 id="blockquote">区块引用 Blockquotes</h3>

<p>Markdown 标记区块引用是使用类似 email 中用 <code>&gt;</code> 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 <code>&gt;</code> ：</p>
<pre><code>&gt; This is a blockquote with two paragraphs. Lo<span class="comment">rem ipsum dolor sit amet,</span>
&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
&gt; Vestibulum enim wisi, viverra nec, fringilla <span class="flow">in</span>, laoreet vitae, risus.
&gt; 
&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
&gt; id sem consectetuer libero luctus adipiscing.
</code></pre><p>Markdown 也允许你偷懒只在整个段落的第一行最前面加上 <code>&gt;</code> ：</p>
<pre><code>&gt; This is a blockquote with two paragraphs. Lo<span class="comment">rem ipsum dolor sit amet,</span>
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla <span class="flow">in</span>, laoreet vitae, risus.

&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.
</code></pre><p>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 <code>&gt;</code> ：</p>
<pre><code>&gt; This <span class="keyword">is</span> <span class="keyword">the</span> <span class="keyword">first</span> level <span class="keyword">of</span> quoting.
&gt;
&gt; &gt; This <span class="keyword">is</span> nested blockquote.
&gt;
&gt; Back <span class="keyword">to</span> <span class="keyword">the</span> <span class="keyword">first</span> level.
</code></pre><p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：</p>
<pre><code>&gt; <span class="comment">## 这是一个标题。</span>
&gt; 
&gt; <span class="number">1</span>.   这是第一行列表项。
&gt; <span class="number">2</span>.   这是第二行列表项。
&gt; 
&gt; 给出一些例子代码：
&gt; 
&gt;     <span class="built_in">return</span> shell_<span class="built_in">exec</span>(<span class="string">"echo <span class="variable">$input</span> | <span class="variable">$markdown_script</span>"</span>);
</code></pre><p>任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择<em>增加引用阶层</em>。</p>
<h3 id="list">列表</h3>

<p>Markdown 支持有序列表和无序列表。</p>
<p>无序列表使用星号、加号或是减号作为列表标记：</p>
<pre><code><span class="bullet">*   </span>Red
<span class="bullet">*   </span>Green
<span class="bullet">*   </span>Blue
</code></pre><p>效果就是</p>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
<p>等同于：</p>
<pre><code><span class="bullet">+   </span>Red
<span class="bullet">+   </span>Green
<span class="bullet">+   </span>Blue
</code></pre><p>也等同于：</p>
<pre><code>-<span class="ruby">   <span class="constant">Red</span>
</span>-<span class="ruby">   <span class="constant">Green</span>
</span>-<span class="ruby">   <span class="constant">Blue</span></span>
</code></pre><p>有序列表则使用数字接着一个英文句点：</p>
<pre><code><span class="number">1.</span>  Bird
<span class="number">2.</span>  McHale
<span class="number">3.</span>  Parish
</code></pre><p>很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：</p>
<pre><code><span class="tag">&lt;<span class="title">ol</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span>Bird<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span>McHale<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span>Parish<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ol</span>&gt;</span>
</code></pre><p>如果你的列表标记写成：</p>
<pre><code><span class="number">1.</span>  Bird
<span class="number">1.</span>  McHale
<span class="number">1.</span>  Parish
</code></pre><p>或甚至是：</p>
<pre><code><span class="number">3.</span> Bird
<span class="number">1.</span> McHale
<span class="number">8.</span> Parish
</code></pre><p>你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。</p>
<p>如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。</p>
<p>列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。</p>
<p>要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：</p>
<pre><code>*   Lo<span class="comment">rem ipsum dolor sit amet, consectetuer adipiscing elit.</span>
    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
    viverra nec, fringilla <span class="flow">in</span>, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
    Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre><p>但是如果你懒，那也行：</p>
<pre><code>*   Lo<span class="comment">rem ipsum dolor sit amet, consectetuer adipiscing elit.</span>
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla <span class="flow">in</span>, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre><p>如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 <code>&lt;p&gt;</code><br>标签包起来，举例来说：</p>
<pre><code><span class="bullet">*   </span>Bird
<span class="bullet">*   </span>Magic
</code></pre><p>会被转换为：</p>
<pre><code><span class="tag">&lt;<span class="title">ul</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span>Bird<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span>Magic<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
</code></pre><p>但是这个：</p>
<pre><code><span class="bullet">*   </span>Bird

<span class="bullet">*   </span>Magic
</code></pre><p>会被转换为：</p>
<pre><code><span class="tag">&lt;<span class="title">ul</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">p</span>&gt;</span>Bird<span class="tag">&lt;/<span class="title">p</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">p</span>&gt;</span>Magic<span class="tag">&lt;/<span class="title">p</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
</code></pre><p>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：</p>
<pre><code><span class="number">1</span>.  This is a list item with two paragraphs. Lo<span class="comment">rem ipsum dolor</span>
    sit amet, consectetuer adipiscing elit. Aliquam hendrerit
    mi posuere lectus.

    Vestibulum enim wisi, viverra nec, fringilla <span class="flow">in</span>, laoreet
    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
    sit amet velit.

<span class="number">2</span>.  Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre><p>如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：</p>
<pre><code>*   This <span class="keyword">is</span> a <span class="type">list</span> <span class="property">item</span> <span class="keyword">with</span> two <span class="property">paragraphs</span>.

    This <span class="keyword">is</span> <span class="keyword">the</span> <span class="keyword">second</span> <span class="property">paragraph</span> <span class="keyword">in</span> <span class="keyword">the</span> <span class="type">list</span> <span class="property">item</span>. You're
only required <span class="keyword">to</span> indent <span class="keyword">the</span> <span class="keyword">first</span> line. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit.

*   Another <span class="property">item</span> <span class="keyword">in</span> <span class="keyword">the</span> same <span class="type">list</span>.
</code></pre><p>如果要在列表项目内放进引用，那 <code>&gt;</code> 就需要缩进：</p>
<pre><code>*   A <span class="type">list</span> <span class="property">item</span> <span class="keyword">with</span> a blockquote:

    &gt; This <span class="keyword">is</span> a blockquote
    &gt; inside a <span class="type">list</span> <span class="property">item</span>.
</code></pre><p>如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：</p>
<pre><code><span class="keyword">*</span>   一列表项包含一个列表区块：

        <span class="variable">&lt;代码写在这&gt;</span>
</code></pre><p>当然，项目列表很可能会不小心产生，像是下面这样的写法：</p>
<pre><code><span class="number">1986</span>. What <span class="tag">a</span> great season.
</code></pre><p>换句话说，也就是在行首出现<em>数字-句点-空白</em>，要避免这样的状况，你可以在句点前面加上反斜杠。</p>
<pre><code><span class="number">1986</span>\. What <span class="tag">a</span> great season.
</code></pre><h3 id="precode">代码区块</h3>

<p>和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 <code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 标签来把代码区块包起来。</p>
<p>要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：</p>
<pre><code>这是一个普通段落：

    这是一个代码区块。
</code></pre><p>Markdown 会转换成：</p>
<pre><code><span class="tag">&lt;<span class="title">p</span>&gt;</span>这是一个普通段落：<span class="tag">&lt;/<span class="title">p</span>&gt;</span>

<span class="tag">&lt;<span class="title">pre</span>&gt;</span><span class="tag">&lt;<span class="title">code</span>&gt;</span>这是一个代码区块。
<span class="tag">&lt;/<span class="title">code</span>&gt;</span><span class="tag">&lt;/<span class="title">pre</span>&gt;</span>
</code></pre><p>这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：</p>
<pre><code>Here <span class="keyword">is</span> an example <span class="keyword">of</span> <span class="constant">AppleScript</span>:

    <span class="keyword">tell</span> <span class="type">application</span> <span class="string">"Foo"</span>
        <span class="command">beep</span>
    <span class="keyword">end</span> <span class="keyword">tell</span>
</code></pre><p>会被转换为：</p>
<pre><code>&lt;p&gt;Here <span class="keyword">is</span> an example <span class="keyword">of</span> <span class="constant">AppleScript</span>:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;<span class="keyword">tell</span> <span class="type">application</span> <span class="string">"Foo"</span>
    <span class="command">beep</span>
<span class="keyword">end</span> <span class="keyword">tell</span>
&lt;/code&gt;&lt;/pre&gt;
</code></pre><p>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。</p>
<p>在代码区块里面， <code>&amp;</code> 、 <code>&lt;</code> 和 <code>&gt;</code> 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"footer"</span>&gt;
    &amp;<span class="keyword">copy</span>; <span class="number">2004</span> Foo Corporation
&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>会被转换为：</p>
<pre><code>&lt;<span class="keyword">pre</span>&gt;&lt;code&gt;&amp;<span class="keyword">lt</span>;div class=<span class="string">"footer"</span>&amp;gt;
    &amp;amp;<span class="built_in">copy</span>; <span class="number">2004</span> Foo Corporation
&amp;<span class="keyword">lt</span>;/div&amp;gt;
&lt;/code&gt;&lt;/<span class="keyword">pre</span>&gt;
</code></pre><p>代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。</p>
<h3 id="hr">分隔线</h3>

<p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<pre><code>- <span class="keyword">*</span> <span class="keyword">*</span>

<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>

<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>

+ - -

---------------------------------------
</code></pre><hr>
<h2 id="span">区段元素</h2>

<h3 id="link">链接</h3>

<p>Markdown 支持两种形式的链接语法： <em>行内式</em>和<em>参考式</em>两种形式。</p>
<p>不管是哪一种，链接文字都是用 [方括号] 来标记。</p>
<p>要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：</p>
<pre><code>This is [<span class="link_label">an example</span>](<span class="link_url">http://example.com/ "Title"</span>) inline link.

[<span class="link_label">This link</span>](<span class="link_url">http://example.net/</span>) has no title attribute.
</code></pre><p>会产生：</p>
<pre><code><span class="tag">&lt;<span class="title">p</span>&gt;</span>This is <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"http://example.com/"</span> <span class="attribute">title</span>=<span class="value">"Title"</span>&gt;</span>
an example<span class="tag">&lt;/<span class="title">a</span>&gt;</span> inline link.<span class="tag">&lt;/<span class="title">p</span>&gt;</span>

<span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"http://example.net/"</span>&gt;</span>This link<span class="tag">&lt;/<span class="title">a</span>&gt;</span> has no
title attribute.<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
</code></pre><p>如果你是要链接到同样主机的资源，你可以使用相对路径：</p>
<pre><code>See my [<span class="link_label">About</span>](<span class="link_url">/about/</span>) page for details.  
</code></pre><p>参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：</p>
<pre><code>This is [<span class="link_label">an example</span>][<span class="link_reference">id</span>] reference-style link.
</code></pre><p>你也可以选择性地在两个方括号中间加上一个空格：</p>
<pre><code>This <span class="keyword">is</span> [an example] [<span class="property">id</span>] <span class="keyword">reference</span>-style link.
</code></pre><p>接着，在文件的任意处，你可以把这个标记的链接内容定义出来：</p>
<pre><code><span class="attr_selector">[id]</span>: <span class="rule"><span class="attribute">http</span>:<span class="value">//example.com/  <span class="string">"Optional Title Here"</span></span></span>
</code></pre><p>链接内容定义的形式为：</p>
<ul>
<li>方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字</li>
<li>接着一个冒号</li>
<li>接着一个以上的空格或制表符</li>
<li>接着链接的网址</li>
<li>选择性地接着 title 内容，可以用单引号、双引号或是括弧包着</li>
</ul>
<p>下面这三种链接的定义都是相同：</p>
<pre><code>[<span class="link_reference">foo</span>]:<span class="link_url"> http://example.com/  "Optional Title Here"</span>
[<span class="link_reference">foo</span>]:<span class="link_url"> http://example.com/  'Optional Title Here'</span>
[<span class="link_reference">foo</span>]:<span class="link_url"> http://example.com/  (Optional Title Here)</span>
</code></pre><p><strong>请注意</strong>：**有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。</p>
<p>链接网址也可以用尖括号包起来：</p>
<pre><code><span class="attr_selector">[id]</span>: &lt;<span class="rule"><span class="attribute">http</span>:<span class="value">//example.com/&gt;  <span class="string">"Optional Title Here"</span></span></span>
</code></pre><p>你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：</p>
<pre><code>[id]<span class="symbol">:</span> <span class="symbol">http:</span>/<span class="regexp">/example.com/longish</span><span class="regexp">/path/to</span><span class="regexp">/resource/here</span>
    <span class="string">"Optional Title Here"</span>
</code></pre><p>网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。</p>
<p>链接辨别标签可以有字母、数字、空白和标点符号，但是并<em>不</em>区分大小写，因此下面两个链接是一样的：</p>
<pre><code>[<span class="link_label">link text</span>][<span class="link_reference">a</span>]
[<span class="link_label">link text</span>][<span class="link_reference">A</span>]
</code></pre><p>隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成：</p>
<pre><code>[<span class="link_label">Google</span>][<span class="link_reference"></span>]
</code></pre><p>然后定义链接内容：</p>
<pre><code>[<span class="link_reference">Google</span>]:<span class="link_url"> http://google.com/</span>
</code></pre><p>由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：</p>
<pre><code>Visit [<span class="link_label">Daring Fireball</span>][<span class="link_reference"></span>] for more information.
</code></pre><p>然后接着定义链接：</p>
<pre><code>[<span class="link_reference">Daring Fireball</span>]:<span class="link_url"> http://daringfireball.net/</span>
</code></pre><p>链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。</p>
<p>下面是一个参考式链接的范例：</p>
<pre><code><span class="name">I</span> <span class="atom">get</span> <span class="number">10</span> <span class="atom">times</span> <span class="atom">more</span> <span class="atom">traffic</span> <span class="atom">from</span> [<span class="name">Google</span>] [<span class="number">1</span>] <span class="atom">than</span> <span class="atom">from</span>
[<span class="name">Yahoo</span>] [<span class="number">2</span>] <span class="atom">or</span> [<span class="name">MSN</span>] [<span class="number">3</span>].

  [<span class="number">1</span>]: <span class="atom">http</span>://<span class="atom">google</span>.<span class="atom">com</span>/        <span class="string">"Google"</span>
  [<span class="number">2</span>]: <span class="atom">http</span>://<span class="atom">search</span>.<span class="atom">yahoo</span>.<span class="atom">com</span>/  <span class="string">"Yahoo Search"</span>
  [<span class="number">3</span>]: <span class="atom">http</span>://<span class="atom">search</span>.<span class="atom">msn</span>.<span class="atom">com</span>/    <span class="string">"MSN Search"</span>
</code></pre><p>如果改成用链接名称的方式写：</p>
<pre><code>I get 10 times more traffic from [<span class="link_label">Google</span>][<span class="link_reference"></span>] than from
[<span class="link_label">Yahoo</span>][<span class="link_reference"></span>] or [<span class="link_label">MSN</span>][<span class="link_reference"></span>].

  [google]: http://google.com/        "Google"
  [yahoo]:  http://search.yahoo.com/  "Yahoo Search"
  [msn]:    http://search.msn.com/    "MSN Search"
</code></pre><p>上面两种写法都会产生下面的 HTML。</p>
<pre><code>&lt;p&gt;I <span class="built_in">get</span> <span class="number">10</span> times more traffic <span class="built_in">from</span> &lt;<span class="operator">a</span> href=<span class="string">"http://google.com/"</span>
title=<span class="string">"Google"</span>&gt;Google&lt;/<span class="operator">a</span>&gt; than <span class="built_in">from</span>
&lt;<span class="operator">a</span> href=<span class="string">"http://search.yahoo.com/"</span> title=<span class="string">"Yahoo Search"</span>&gt;Yahoo&lt;/<span class="operator">a</span>&gt;
<span class="operator">or</span> &lt;<span class="operator">a</span> href=<span class="string">"http://search.msn.com/"</span> title=<span class="string">"MSN Search"</span>&gt;MSN&lt;/<span class="operator">a</span>&gt;.&lt;/p&gt;
</code></pre><p>下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用</p>
<pre><code>I get 10 times more traffic from [<span class="link_label">Google</span>](<span class="link_url">http://google.com/ "Google"</span>)
than from [<span class="link_label">Yahoo</span>](<span class="link_url">http://search.yahoo.com/ "Yahoo Search"</span>) or
[<span class="link_label">MSN</span>](<span class="link_url">http://search.msn.com/ "MSN Search"</span>).
</code></pre><p>参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。</p>
<p>使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。</p>
<h3 id="em">强调</h3>

<p>Markdown 使用星号（<code>*</code>）和底线（<code>_</code>）作为标记强调字词的符号，被 <code>*</code> 或 <code>_</code> 包围的字词会被转成用 <code>&lt;em&gt;</code> 标签包围，用两个 <code>*</code> 或 <code>_</code> 包起来的话，则会被转成 <code>&lt;strong&gt;</code>，例如：</p>
<pre><code><span class="keyword">*</span>single asterisks<span class="keyword">*</span>

_single underscores_

<span class="keyword">*</span><span class="keyword">*</span>double asterisks<span class="keyword">*</span><span class="keyword">*</span>

__double underscores__
</code></pre><p>会转成：</p>
<pre><code><span class="tag">&lt;<span class="title">em</span>&gt;</span>single asterisks<span class="tag">&lt;/<span class="title">em</span>&gt;</span>

<span class="tag">&lt;<span class="title">em</span>&gt;</span>single underscores<span class="tag">&lt;/<span class="title">em</span>&gt;</span>

<span class="tag">&lt;<span class="title">strong</span>&gt;</span>double asterisks<span class="tag">&lt;/<span class="title">strong</span>&gt;</span>

<span class="tag">&lt;<span class="title">strong</span>&gt;</span>double underscores<span class="tag">&lt;/<span class="title">strong</span>&gt;</span>
</code></pre><p>你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。</p>
<p>强调也可以直接插在文字中间：</p>
<pre><code>un<span class="keyword">*</span>frigging<span class="keyword">*</span>believable
</code></pre><p>但是<strong>如果你的 <code>*</code> 和 <code>_</code> 两边都有空白的话，它们就只会被当成普通的符号</strong>。</p>
<p>如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：</p>
<pre><code><span class="string">\*this</span> text <span class="keyword">is</span> surrounded <span class="keyword">by</span> literal asterisks<span class="string">\*</span>
</code></pre><h3 id="code">代码</h3>

<p>如果要标记一小段行内代码，你可以用反引号把它包起来（<code>` </code>），例如：</p>
<pre><code><span class="keyword">Use</span> the `printf()` <span class="function"><span class="keyword">function</span>.</span>
</code></pre><p>会产生：</p>
<pre><code><span class="tag">&lt;<span class="title">p</span>&gt;</span>Use the <span class="tag">&lt;<span class="title">code</span>&gt;</span>printf()<span class="tag">&lt;/<span class="title">code</span>&gt;</span> function.<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
</code></pre><p>如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：</p>
<pre><code><span class="escape">``</span>There is <span class="literal">a</span> literal backtick (<span class="escape">`)</span> here.<span class="escape">``</span>
</code></pre><p>这段语法会产生：</p>
<pre><code><span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">code</span>&gt;</span>There is a literal backtick (`) here.<span class="tag">&lt;/<span class="title">code</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span>
</code></pre><p>代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：</p>
<pre><code>A single backtick <span class="keyword">in</span> <span class="tag">a</span> <span class="tag">code</span> <span class="tag">span</span>: `` ` ``

A backtick-delimited string <span class="keyword">in</span> <span class="tag">a</span> <span class="tag">code</span> <span class="tag">span</span>: `` `foo` ``
</code></pre><p>会产生：</p>
<pre><code>&lt;p&gt;A single backtick <span class="keyword">in</span> <span class="tag">a</span> <span class="tag">code</span> <span class="tag">span</span>: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A backtick-delimited string <span class="keyword">in</span> <span class="tag">a</span> <span class="tag">code</span> <span class="tag">span</span>: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt;
</code></pre><p>在代码区段内，<code>&amp;</code> 和尖括号<strong>都</strong>会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段：</p>
<pre><code>Please don't <span class="operator"><span class="keyword">use</span> <span class="keyword">any</span> <span class="string">`&lt;blink&gt;`</span> tags.</span>
</code></pre><p>转为：</p>
<pre><code><span class="variable">&lt;p&gt;</span>Please don't use <span class="literal">any</span> <span class="variable">&lt;code&gt;</span>&amp;lt;blink&amp;gt;<span class="variable">&lt;/code&gt;</span> tags.<span class="variable">&lt;/p&gt;</span>
</code></pre><p>你也可以这样写：</p>
<pre><code>`<span class="javascript">&amp;#<span class="number">8212</span>;</span>` <span class="keyword">is</span> the decimal-encoded equivalent <span class="keyword">of</span> `<span class="javascript">&amp;mdash;</span>`.
</code></pre><p>以产生：</p>
<pre><code><span class="variable">&lt;p&gt;</span><span class="variable">&lt;code&gt;</span>&amp;amp;<span class="comment">#8212;&lt;/code&gt; is the decimal-encoded</span>
equivalent of <span class="variable">&lt;code&gt;</span>&amp;amp;mdash;<span class="variable">&lt;/code&gt;</span>.<span class="variable">&lt;/p&gt;</span>
</code></pre><h3 id="img">图片</h3>

<p>很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。</p>
<p>Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： <em>行内式</em>和<em>参考式</em>。</p>
<p>行内式的图片语法看起来像是：</p>
<pre><code>![<span class="link_label">Alt text</span>](<span class="link_url">/path/to/img.jpg</span>)

![<span class="link_label">Alt text</span>](<span class="link_url">/path/to/img.jpg "Optional title"</span>)
</code></pre><p>详细叙述如下：</p>
<ul>
<li>一个惊叹号 <code>!</code></li>
<li>接着一个方括号，里面放上图片的替代文字</li>
<li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上<br>选择性的 ‘title’ 文字。</li>
</ul>
<p>参考式的图片语法则长得像这样：</p>
<pre><code>![<span class="link_label">Alt text</span>][<span class="link_reference">id</span>]
</code></pre><p>「id」是图片参考的名称，图片参考的定义方式则和链接参考一样：</p>
<pre><code>[<span class="property">id</span>]: url/<span class="keyword">to</span>/image  <span class="string">"Optional title attribute"</span>
</code></pre><p>到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code> 标签。</p>
<hr>
<h2 id="misc">其它</h2>

<h3 id="autolink">自动链接</h3>

<p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p>
<pre><code>&lt;<span class="string">http:</span><span class="comment">//example.com/&gt;</span>
</code></pre><p>Markdown 会转为：</p>
<pre><code>&lt;<span class="tag">a</span> href=<span class="string">"http://example.com/"</span>&gt;http:<span class="comment">//example.com/&lt;/a&gt;</span>
</code></pre><p>邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：</p>
<pre><code><span class="tag">&lt;address@example.com&gt;</span>
</code></pre><p>Markdown 会转成：</p>
<pre><code>&lt;a href=<span class="string">"&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;
&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;
&amp;#109;"</span>&gt;&amp;<span class="title">#x61</span>;&amp;<span class="title">#x64</span>;&amp;<span class="title">#x64</span>;&amp;<span class="title">#x72</span>;&amp;<span class="title">#x65</span>;&amp;<span class="title">#115</span>;&amp;<span class="title">#115</span>;&amp;<span class="title">#64</span>;&amp;<span class="title">#101</span>;&amp;<span class="title">#120</span>;&amp;<span class="title">#x61</span>;
&amp;<span class="title">#109</span>;&amp;<span class="title">#x70</span>;&amp;<span class="title">#x6</span>C;e&amp;<span class="title">#x2</span>E;&amp;<span class="title">#99</span>;&amp;<span class="title">#111</span>;&amp;<span class="title">#109</span>;&lt;/a&gt;
</code></pre><p>在浏览器里面，这段字串（其实是 <code>&lt;a href=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt;</code>）会变成一个可以点击的「address@example.com」链接。</p>
<p>（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）</p>
<h3 id="backslash">反斜杠</h3>

<p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 <code>&lt;em&gt;</code> 标签），你可以在星号的前面加上反斜杠：</p>
<pre><code>\<span class="keyword">*</span>literal asterisks\<span class="keyword">*</span>
</code></pre><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p>
<pre><code>\   反斜线
`   反引号
<span class="bullet">-   </span>星号
_   底线
{}  花括号
[]  方括号
()  括弧
<span class="header">#   井字号</span>
<span class="bullet">*   </span>加号
<span class="bullet">+   </span>减号
.   英文句点
!   惊叹号
</code></pre><h2 id="acknowledgement">感谢</h2>

<p>感谢 <a href="https://twitter.com/#!/leafy7382" target="_blank" rel="external">leafy7382</a> 协助翻译，<a href="http://iamhlb.com/" target="_blank" rel="external">hlb</a>、<a href="http://twitter.com/randylien" target="_blank" rel="external">Randylien</a> 帮忙润稿，<a href="https://twitter.com/#!/ethantw" target="_blank" rel="external">ethantw</a> 的<a href="http://ethantw.net/projects/han/" target="_blank" rel="external">汉字标准格式・CSS Reset</a>， <a href="http://kidwm.net/" target="_blank" rel="external">WM</a> 回报文字错误。</p>
<p>感谢 <a href="https://github.com/fenprace" target="_blank" rel="external">fenprace</a>，<a href="https://github.com/addv" target="_blank" rel="external">addv</a>。</p>
<hr>
<h2 id="editor">Markdown 免费编辑器</h2>

<p>Windows 平台</p>
<ul>
<li><a href="http://markdownpad.com/" target="_blank" rel="external">MarkdownPad</a></li>
<li><a href="http://code52.org/DownmarkerWPF/" target="_blank" rel="external">MarkPad</a></li>
</ul>
<p>Linux 平台</p>
<ul>
<li><a href="http://sourceforge.net/p/retext/home/ReText/" target="_blank" rel="external">ReText</a></li>
</ul>
<p>Mac 平台</p>
<ul>
<li><a href="http://mouapp.com/" target="_blank" rel="external">Mou</a></li>
</ul>
<p>在线编辑器</p>
<ul>
<li><a href="http://markable.in/" target="_blank" rel="external">Markable.in</a></li>
<li><a href="http://dillinger.io/" target="_blank" rel="external">Dillinger.io</a></li>
</ul>
<p>浏览器插件</p>
<ul>
<li><a href="https://chrome.google.com/webstore/detail/oknndfeeopgpibecfjljjfanledpbkog" target="_blank" rel="external">MaDe</a> (Chrome)</li>
</ul>
<p>高级应用</p>
<ul>
<li><a href="http://www.sublimetext.com/2" target="_blank" rel="external">Sublime Text 2</a> + <a href="http://ttscoff.github.com/MarkdownEditing/" target="_blank" rel="external">MarkdownEditing</a> / <a href="http://lucifr.com/2012/07/12/markdownediting-for-sublime-text-2/" target="_blank" rel="external">教程</a></li>
</ul>
<p>*** 如有更好的 Markdown 免费编辑器推荐，请到<a href="https://gitcafe.com/riku/Markdown-Syntax-CN/tickets/1" target="_blank" rel="external">这里反馈</a>，谢谢！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文拷贝自<a href="https://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/syntax.md" target="_blank" rel="external">这里</a>.</p>
<p><a href="h]]>
    </summary>
    
      <category term="Markdown" scheme="https://opensvn.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="https://opensvn.github.io/2015/09/19/hello-world/"/>
    <id>https://opensvn.github.io/2015/09/19/hello-world/</id>
    <published>2015-09-19T02:47:02.000Z</published>
    <updated>2015-09-22T01:25:35.011Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io]]>
    </summary>
    
      <category term="Hexo" scheme="https://opensvn.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
