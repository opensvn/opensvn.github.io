<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[opensvn]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="https://opensvn.github.io/"/>
  <updated>2015-12-26T07:51:37.932Z</updated>
  <id>https://opensvn.github.io/</id>
  
  <author>
    <name><![CDATA[opensvn]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Python核心编程 第3章]]></title>
    <link href="https://opensvn.github.io/2015/12/25/cpp-3/"/>
    <id>https://opensvn.github.io/2015/12/25/cpp-3/</id>
    <published>2015-12-25T05:28:23.000Z</published>
    <updated>2015-12-26T07:51:37.932Z</updated>
    <content type="html"><![CDATA[<h2 id="3-1_语句和语法">3.1 语句和语法</h2><p>关于Python语句的一些规则和符号：</p>
<ul>
<li>井号（#）指示Python注释。</li>
<li>换行（\n）是标准行分隔符（一个语句一行）</li>
<li>反斜杠（\）延续一行</li>
<li>分号（;）将2个语句连接在一行</li>
<li>冒号（:）分隔标题行和其单元</li>
<li>单元通过缩进界定</li>
<li>Python文件组织成模块</li>
</ul>
<h3 id="3-1-1_注释（#）">3.1.1 注释（#）</h3><p>Python注释以井号开始。一个注释可以在一行的任何地方开始，所有跟在井号后面直到行尾的字符被解释器忽略。明智审慎地使用它们。</p>
<h3 id="3-1-2_延续（\）">3.1.2 延续（\）</h3><p>Python语句通常由换行界定，意思是一个语句一行。单一语句可以通过反斜杠分成多行。反斜杠可以放在换行符前面使当前语句延续到下一行。</p>
<pre><code><span class="preprocessor"># check conditions</span>
<span class="keyword">if</span> (weather_is_hot == <span class="number">1</span>) and \
   (shark_warnings == <span class="number">0</span>):
    send_goto_beach_mesg_to_pager()
</code></pre><p>有两种例外可以不使用反斜杠延续到下一行。被括号，方括号或花括号包围的单一语句和包围在三重引号的字符串。</p>
<pre><code><span class="comment"># display a string with triple quotes</span>
print '''hi there, this <span class="keyword">is</span> a long message <span class="keyword">for</span> you
<span class="keyword">that</span> goes <span class="keyword">over</span> multiple lines... you will find
out soon <span class="keyword">that</span> triple quotes <span class="keyword">in</span> Python allows
this kind <span class="keyword">of</span> fun! <span class="keyword">it</span> <span class="keyword">is</span> like a <span class="property">day</span> <span class="function_start"><span class="keyword">on</span></span> <span class="keyword">the</span> beach!'''
<span class="comment"># set some variables</span>
go_surf, get_a_tan_while, boat_size, toll_money = (<span class="number">1</span>,
    'windsurfing', <span class="number">40.0</span>, -<span class="number">2.00</span>)
</code></pre><h3 id="3-1-3_多个语句组成程序组（:）">3.1.3 多个语句组成程序组（:）</h3><p>多个语句组成一个代码块在Python中称为程序组（suites）。复合语句如if，while，def和class都需要一个标题行和一个程序组。标题行以关键字开始一行语句并以冒号结尾。</p>
<h3 id="3-1-4_通过缩进界定程序组">3.1.4 通过缩进界定程序组</h3><p>Python利用缩进作为一种界定代码块的方法。内层的代码通过空格或制表符缩进。一个程序组的所有代码行必须处在同样的缩进级别上。</p>
<blockquote>
<p><strong>核心风格：使用4个空格缩进并避免使用制表符</strong></p>
</blockquote>
<p>当缩进的数量增加时，一个新的代码块被识别。而一个代码块的结束由缩进的数量减少并匹配上一层的缩进。没有缩进的代码（最高层的代码）被认为是脚本的主要部分。</p>
<h3 id="3-1-5_多个语句在一行（;）">3.1.5 多个语句在一行（;）</h3><p>分号（;）允许多个语句在一行，这些语句都不开始一个新的代码块。</p>
<pre><code><span class="preprocessor"><span class="keyword">import</span> sys;</span> x = <span class="string">'foo'</span>; sys.stdout.write(x + <span class="string">'\n'</span>)
</code></pre><p>不要多行语句放在一行，因为它使得代码更难阅读。</p>
<h3 id="3-1-6_模块">3.1.6 模块</h3><p>每一个Python脚本都是一个模块。模块物理表现为硬盘文件。当一个模块变得足够大时，将一些代码移到另一个模块更合理。</p>
<h2 id="3-2_变量赋值">3.2 变量赋值</h2><h3 id="赋值操作符">赋值操作符</h3><p>等号是Python主要的赋值操作符，其它的是增量赋值操作符。</p>
<pre><code><span class="setting">anInt = <span class="value">-<span class="number">12</span></span></span>
<span class="setting">aString = <span class="value"><span class="string">'cart'</span></span></span>
<span class="setting">aFloat = <span class="value">-<span class="number">3.1415</span> * (<span class="number">5.0</span> ** <span class="number">2</span>)</span></span>
<span class="setting">anotherString = <span class="value"><span class="string">'shop'</span> + <span class="string">'ping'</span></span></span>
<span class="setting">aList = <span class="value">[<span class="number">3.14</span>e10, <span class="string">'2nd elmt of a list'</span>, <span class="number">8.82</span>-<span class="number">4.371</span>j]</span></span>
</code></pre><p>注意赋值并没有显式将一个值赋给一个变量。在Python中，对象都是被引用的。因此当赋值时，一个对象的引用被赋值给变量，不管对象是刚刚创建还是已经存在。</p>
<p>如果你熟悉C，赋值被当做表达式。Python中不是这样，下面这样的语句在Python中非法：</p>
<pre><code>&gt;&gt;&gt; x = <span class="number">1</span>
&gt;&gt;&gt; y = (x = x + <span class="number">1</span>) <span class="preprocessor"># assignments not expressions!</span>
  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>
    y = (x = x + <span class="number">1</span>)
           ^
SyntaxError: invalid syntax
</code></pre><p>赋值可以链接在一起：</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; y = x = x + <span class="number">1</span>
<span class="prompt">&gt;&gt;</span>&gt; x, y
(<span class="number">2</span>, <span class="number">2</span>)
</code></pre><h3 id="增量赋值操作符">增量赋值操作符</h3><p>从Python 2.0开始，等号可以和算术操作符一起使用，且产生的结果再赋值给原来的变量。比如：</p>
<pre><code>x = x + <span class="number">1</span> &lt;=&gt; x += <span class="number">1</span>
</code></pre><p>增量赋值操作符有，<strong>+=</strong>，<strong>-=</strong>，<strong>*=</strong>，<strong>/=</strong>，<strong>%=</strong>，<strong>**=</strong>，<strong>&lt;&lt;=</strong>，<strong>&gt;&gt;=</strong>，<strong>&amp;=</strong>，<strong>^=</strong>，<strong>|=</strong>。</p>
<p>除了明显的语法改变，最显著的不同是第一个对象只被检查一次。可变对象在原地改变，而不可变对象和可变对象有一样的效果（一个新对象被分配）。</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; m = <span class="number">12</span>
<span class="prompt">&gt;&gt;</span>&gt; m %= <span class="number">7</span>
<span class="prompt">&gt;&gt;</span>&gt; m
<span class="number">5</span>
<span class="prompt">&gt;&gt;</span>&gt; m **= <span class="number">2</span>
<span class="prompt">&gt;&gt;</span>&gt; m
<span class="number">25</span>
<span class="prompt">&gt;&gt;</span>&gt; aList = [<span class="number">123</span>, <span class="string">'xyz'</span>]
<span class="prompt">&gt;&gt;</span>&gt; aList += [<span class="number">45.6</span>e7]
<span class="prompt">&gt;&gt;</span>&gt; aList
[<span class="number">123</span>, <span class="string">'xyz'</span>, <span class="number">456000000.0</span>
</code></pre><p>Python不支持前/后自增操作符，也不支持前/后自减操作符。</p>
<h3 id="多个赋值">多个赋值</h3><pre><code><span class="prompt">&gt;&gt;</span>&gt; x = y = z = <span class="number">1</span>
</code></pre><p>上面这个例子中，一个整形对象被创建，且x，y，z都引用到这个整形对象。Python也可以将多个对象赋值给多个变量。</p>
<h3 id="元组赋值">元组赋值</h3><pre><code><span class="prompt">&gt;&gt;</span>&gt; x, y, z = <span class="number">1</span>, <span class="number">2</span>, <span class="string">'a string'</span>
</code></pre><p>上面这个例子中，2个整形对象和一个字符串对象被赋值给x，y，z。尽管括号是可选的，我们建议在任何使代码容易阅读的地方使用括号：</p>
<pre><code>&gt;&gt;&gt; <span class="list">(<span class="keyword">x</span>, y, z)</span> = <span class="list">(<span class="number">1</span>, <span class="number">2</span>, <span class="quoted">'a</span> string')</span>
</code></pre><p>Python元组赋值的一个有趣副作用是我们不再需要一个临时变量来交换2个变量的值：</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; x, y = y, x
</code></pre><p>显然，Python在赋值前执行计算。</p>
<h2 id="3-3_标识符">3.3 标识符</h2><p>标识符是一组合法的允许作为计算机语言里的名字的字符串。从这个包罗万象的列表中，我们分离出一些形成语言结构的关键字。这些标识符是不应该用作其它意图的保留字，否则将发生语法错误。</p>
<p>Python也有一组额外的标识符集被称为built-ins。尽管它们不是保留字，不推荐使用这些特殊名字。</p>
<h3 id="3-3-1_合法Python标识符">3.3.1 合法Python标识符</h3><p>Python标识符的规则和其它来自C世界的高级语言一样：</p>
<ul>
<li>第一个字符必须是字母或是下划线（_）。</li>
<li>任何其它的字符可以是字母，数字或下划线。</li>
<li>大小写敏感。</li>
</ul>
<h3 id="3-3-2_关键字">3.3.2 关键字</h3><p><strong>keyword</strong>模块包含关键字列表和一个<strong>iskeyword()</strong>函数。</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; import keyword
<span class="prompt">&gt;&gt;</span>&gt; keyword.kwlist
[<span class="string">'and'</span>, <span class="string">'as'</span>, <span class="string">'assert'</span>, <span class="string">'break'</span>, <span class="string">'class'</span>, <span class="string">'continue'</span>, <span class="string">'def'</span>, <span class="string">'del'</span>,
 <span class="string">'elif'</span>, <span class="string">'else'</span>, <span class="string">'except'</span>, <span class="string">'exec'</span>, <span class="string">'finally'</span>, <span class="string">'for'</span>, <span class="string">'from'</span>, <span class="string">'global'</span>,
 <span class="string">'if'</span>, <span class="string">'import'</span>, <span class="string">'in'</span>, <span class="string">'is'</span>, <span class="string">'lambda'</span>, <span class="string">'not'</span>, <span class="string">'or'</span>, <span class="string">'pass'</span>, <span class="string">'print'</span>,
 <span class="string">'raise'</span>, <span class="string">'return'</span>, <span class="string">'try'</span>, <span class="string">'while'</span>, <span class="string">'with'</span>, <span class="string">'yield'</span>]
</code></pre><h3 id="3-3-3_Built-ins">3.3.3 Built-ins</h3><p>除了关键字，Python还有一组内置名字集合。尽管不是关键字，内置名字应该被当做留给系统的，不应该用作任何其它意图。</p>
<p>内置名字都是<strong><strong>builtins</strong></strong>模块的成员，这个模块在程序开始前由解释器自动导入。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="3-1_语句和语法">3.1 语句和语法</h2><p>关于Python语句的一些规则和符号：</p>
<ul>
<li>井号（#）指示Python注释。</li>
<li>换行（\n）是标准行分隔符（一个语句一行）</li>
<li>反斜杠（\）延续一行</li]]>
    </summary>
    
      <category term="Python" scheme="https://opensvn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python核心编程 第2章]]></title>
    <link href="https://opensvn.github.io/2015/12/24/cpp-2/"/>
    <id>https://opensvn.github.io/2015/12/24/cpp-2/</id>
    <published>2015-12-24T01:46:13.000Z</published>
    <updated>2015-12-25T05:27:30.589Z</updated>
    <content type="html"><![CDATA[<h1 id="命令行选项">命令行选项</h1><p>-d      提供调试输出<br>-O      生成优化字节码（产生.pyo文件）<br>-S      启动时不要运行导入地址查询Python路径<br>-v      详细输出（详细追踪import语句）<br>-m      mod 将模块当脚本运行<br>-Q      opt 除法选项<br>-c      cmd 将cmd字符串当Python脚本执行<br>file    从指定文件运行Python脚本</p>
<h1 id="2-1_程序输出，print语句和”Hello_World!”">2.1 程序输出，print语句和”Hello World!”</h1><p>Python的<strong>print</strong>语句（2.x）或函数（3.x）给用户显示程序输出的工具，类似C语言的<strong>printf()</strong>和shell脚本的<strong>echo</strong>。实际上，它也支持<strong>printf()</strong>风格的字符串替换用法：</p>
<pre><code>&gt;&gt;&gt; <span class="keyword">print</span> <span class="string">"<span class="variable">%s</span> is number <span class="variable">%d</span>!"</span> % (<span class="string">"Python"</span>, <span class="number">1</span>)
Python is number <span class="number">1</span>!
</code></pre><blockquote>
<p><strong>核心笔记：在交互解释器中打印变量内容</strong><br>在交互解释器中，你可以提供变量的名字直接打印变量的内容。print语句使用str()打印内容，而交互解释器调用repr()显示对象。下划线（_）在交互解释器中也有特殊含义：上一个计算过的表达式。</p>
</blockquote>
<p><strong>print</strong>语句也可以将输出重定向到文件。</p>
<pre><code>import sys
print &gt;&gt; sys<span class="class">.stderr</span>, <span class="string">'Fatal error: invalid input!'</span>

logfile = <span class="function"><span class="title">open</span><span class="params">(<span class="string">'/tmp/mylog.txt'</span>, <span class="string">'a'</span>)</span></span>
print &gt;&gt; logfile, <span class="string">'Fatal error: invalid input!'</span>
logfile.<span class="function"><span class="title">close</span><span class="params">()</span></span>
</code></pre><p><strong>print</strong>在Python 3.0变成了函数[print()]。从Python 2.6开始，你可以通过添加这句特殊的import语句使用print函数：</p>
<pre><code>from __future__ import <span class="built_in">print</span>_<span class="keyword">function</span>
</code></pre><p>新函数的语法是：</p>
<pre><code><span class="function"><span class="title">print</span><span class="params">(*args, sep=<span class="string">' '</span>, end=<span class="string">'\n'</span>, file=None)</span></span>

<span class="function"><span class="title">print</span><span class="params">(<span class="string">'Fatal error: invalid input!'</span>, file=sys.stderr)</span></span>
</code></pre><h1 id="2-2_程序输入和内置raw_input()函数">2.2 程序输入和内置raw_input()函数</h1><p>从命令行获取用户输入最简单的方法是使用内置的<strong>raw_input()</strong>函数。它从标准输入读取输入并将字符串赋值给你指定的变量。</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; user = raw_input(<span class="string">'Enter login name: '</span>)
<span class="constant">Enter</span> login <span class="symbol">name:</span> root
<span class="prompt">&gt;&gt;</span>&gt; print <span class="string">'Your login is:'</span>, user
<span class="constant">Your</span> login <span class="symbol">is:</span> root

<span class="prompt">&gt;&gt;</span>&gt; num = raw_input(<span class="string">'Now enter a number: '</span>)
<span class="constant">Now</span> enter a <span class="symbol">number:</span> <span class="number">1024</span>
<span class="prompt">&gt;&gt;</span>&gt; print <span class="string">'Doubling your number: %d'</span> % (int(num) * <span class="number">2</span>)
<span class="constant">Doubling</span> your <span class="symbol">number:</span> <span class="number">2048</span>
</code></pre><p>内置的<strong>int()</strong>函数将字符串转换成整数。</p>
<blockquote>
<p><strong>核心笔记：在交互解释器中寻求帮助</strong><br>在学习Python的过程中，如果需要对一个你不熟悉的新函数的帮助文档，你可以调用help()内置函数寻求帮助，比如help(raw_input)。<br><strong>核心风格：用户交互放在函数外面</strong><br>我们建议函数应该保持干净，意思是函数应该只用来接收参数并返回值。</p>
</blockquote>
<h1 id="2-3_注释">2.3 注释</h1><p>和大多数脚本语言一样，井号（#）表示一个注释开始并持续到一行结尾。</p>
<pre><code><span class="prompt">&gt;&gt;&gt; </span><span class="comment"># one comment</span>
<span class="prompt">... </span><span class="keyword">print</span> <span class="string">'Hello World!'</span> <span class="comment"># another comment</span>
Hello World!
</code></pre><p>有一种特殊的注释被称为文档字符串。在一个模块，类或函数开头独立的字符串就是文档字符串。文档字符串可以在运行时访问并用来自动生成文档。可以使用object.<strong>doc</strong>访问注释文档。</p>
<h1 id="2-4_操作符">2.4 操作符</h1><p>你熟知的标准数学操作符在Python里面跟其它大多数语言一样工作。</p>
<pre><code>+   -   <span class="keyword">*</span>   /   //  %   <span class="keyword">*</span><span class="keyword">*</span>
</code></pre><p>Python有2个除法操作符，一个斜杠用来做经典除法而2个斜杠用来做截断除法。经典除法的意思是如果操作数都是整数，则执行截断除法，而对于浮点型执行真实除法。如果真实除法生效，则除法操作符总是执行真实除法，不管操作数类型。两个星号（**）是指数操作符。</p>
<p>Python也提供了标准比较操作符，这些操作符返回布尔值：</p>
<pre><code><span class="xml"><span class="tag">&lt;   &lt;=  &gt;</span>   &gt;=  ==  !=  <span class="tag">&lt;&gt;</span></span>
</code></pre><p>Python当前支持两种不等操作符，!=和&lt;&gt;。后面这个正逐渐被淘汰，推荐使用前面的。</p>
<p>Python也提供表达式连接操作符：<strong>and</strong>，<strong>or</strong>，<strong>not</strong>。</p>
<pre><code>&gt;&gt;&gt; <span class="number">3</span> &lt; <span class="number">4</span> &lt; <span class="number">5</span>
True
&gt;&gt;&gt; <span class="number">3</span> &lt; <span class="number">4</span> and <span class="number">4</span> &lt; <span class="number">5</span>
True
</code></pre><blockquote>
<p>核心风格：使用括号澄清<br>很多情况下，使用括号是个好主意。比如如果没有它们代码很难阅读，或如果没有它们容易造成混淆。</p>
</blockquote>
<h1 id="2-5_变量和赋值">2.5 变量和赋值</h1><p>Python中变量的规则和大多数其它高级语言一样。它们仅仅是以字母开头的标识符。Python是大小写敏感的。</p>
<p>Python是动态类型的，意味着变量类型的预先声明是不必要的。类型和值在赋值时初始化，使用等号进行赋值。</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; counter = <span class="number">0</span>
<span class="prompt">&gt;&gt;</span>&gt; miles = <span class="number">1000.0</span>
<span class="prompt">&gt;&gt;</span>&gt; name = <span class="string">'Bob'</span>
<span class="prompt">&gt;&gt;</span>&gt; counter = counter + <span class="number">1</span>
<span class="prompt">&gt;&gt;</span>&gt; kilometers = <span class="number">1.609</span> * miles
<span class="prompt">&gt;&gt;</span>&gt; print <span class="string">'%f miles is the same as %f km'</span> % (miles, kilometers)
<span class="number">1000.000000</span> miles is the same as <span class="number">1609.000000</span> km
</code></pre><p>Python支持增量赋值，比如n *= 10。Python不支持自增和自减操作符。</p>
<h1 id="2-6_数字">2.6 数字</h1><p>Python支持五种基本数字类型，其中三种是整形。</p>
<ul>
<li><strong>int</strong>（有符号整数）<ul>
<li><strong>long</strong>（long整形）</li>
<li><strong>bool</strong>（Boolean值）</li>
</ul>
</li>
<li><strong>float</strong>（浮点型实数）</li>
<li><strong>complex</strong>（复数）</li>
</ul>
<p>Python的long型没有范围限制，它只局限于系统的内存。如果你熟悉Java，Python的long型类似于BigInteger类型。未来int和long将被统一进一种整形。从2.3开始，溢出错误不再报告，其结果将自动转为long。Python 3中，int和long被统一为一个整形，且”L”不再是合法的Python语法。</p>
<p>Boolean值是整形的一个特殊情况。尽管由常量<strong>True</strong>和<strong>False</strong>表示，如果放进数值环境比如与其它数作加法，<strong>True</strong>被看作数字1，而<strong>False</strong>为0。</p>
<p>还有一种数值类型，decimal，代表十进制浮点数。但是它不是内置类型。你必须导入decimal模块才能使用。</p>
<h1 id="2-7_字符串">2.7 字符串</h1><p>字符串在Python中被表示为引号之间的一组连续的字符。Python允许使用一对单引号或一对双引号。三重引号（三个连续的单引号或双引号）可以用来转义特殊字符。可以使用下标（[]）和切片（[:]）获取子字符串。加号（+）是字符串连接操作符，星号（*）是重复操作符。</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; pystr = <span class="string">'Python'</span>
<span class="prompt">&gt;&gt;</span>&gt; iscool = <span class="string">'is cool!'</span>
<span class="prompt">&gt;&gt;</span>&gt; pystr[<span class="number">0</span>]
<span class="string">'P'</span>
<span class="prompt">&gt;&gt;</span>&gt; pystr[<span class="number">2</span><span class="symbol">:</span><span class="number">5</span>]
<span class="string">'tho'</span>
<span class="prompt">&gt;&gt;</span>&gt; iscool[<span class="symbol">:</span><span class="number">2</span>]
<span class="string">'is'</span>
<span class="prompt">&gt;&gt;</span>&gt; iscool[<span class="number">3</span><span class="symbol">:</span>]
<span class="string">'cool!'</span>
<span class="prompt">&gt;&gt;</span>&gt; iscool[-<span class="number">1</span>]
<span class="string">'!'</span>
<span class="prompt">&gt;&gt;</span>&gt; pystr + iscool
<span class="string">'Pythonis cool!'</span>
<span class="prompt">&gt;&gt;</span>&gt; pystr + <span class="string">' '</span> + iscool
<span class="string">'Python is cool!'</span>
<span class="prompt">&gt;&gt;</span>&gt; pystr * <span class="number">2</span>
<span class="string">'PythonPython'</span>
<span class="prompt">&gt;&gt;</span>&gt; <span class="string">'-'</span> * <span class="number">20</span>
<span class="string">'--------------------'</span>
<span class="prompt">&gt;&gt;</span>&gt; pystr = <span class="string">''</span><span class="string">'python
... is cool'</span><span class="string">''</span>
<span class="prompt">&gt;&gt;</span>&gt; pystr
<span class="string">'python\nis cool'</span>
<span class="prompt">&gt;&gt;</span>&gt; print pystr
python
is cool
<span class="prompt">&gt;&gt;</span>&gt;
</code></pre><h1 id="2-8_列表和元组">2.8 列表和元组</h1><p>列表和元组可以被认为是通用“数组”，使用它可以存放任意数量的任意Python对象，其元素顺序存放并通过下标访问。</p>
<p>列表和元组有一些主要的区别。列表由中括号（[]）括起来，其元素和大小可以改变。元组由括号（()）括起来且不能更新。元组可以认为是“只读”列表。像字符串一样可以使用切片操作符（[]和[:]）获取子集。</p>
<h1 id="2-9_字典">2.9 字典</h1><p>字典是Python的映射类型，像Perl里面的关联数组或哈希一样工作，它由键值对组成。键可以是几乎任何Python类型，但是通常是数字或字符串。另一方面，值可以是任意Python对象。字典由花括号（{}）括起来。</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; aDict = {<span class="string">'host'</span><span class="symbol">:</span> <span class="string">'earth'</span>} <span class="comment"># create dict</span>
<span class="prompt">&gt;&gt;</span>&gt; aDict[<span class="string">'port'</span>] = <span class="number">80</span> <span class="comment"># add to dict</span>
<span class="prompt">&gt;&gt;</span>&gt; aDict
{<span class="string">'host'</span><span class="symbol">:</span> <span class="string">'earth'</span>, <span class="string">'port'</span><span class="symbol">:</span> <span class="number">80</span>}
<span class="prompt">&gt;&gt;</span>&gt; aDict.keys()
[<span class="string">'host'</span>, <span class="string">'port'</span>]
<span class="prompt">&gt;&gt;</span>&gt; aDict[<span class="string">'host'</span>]
<span class="string">'earth'</span>
<span class="prompt">&gt;&gt;</span>&gt; for key in <span class="symbol">aDict:</span>
... print key, aDict[key]
...
host earth
port <span class="number">80</span>
</code></pre><h1 id="2-10_代码块使用缩进">2.10 代码块使用缩进</h1><p>代码块由缩进指定而不是用像花括号这样的符号。没有额外的符号，程序更容易阅读。同样，缩进清晰地指出代码属于哪一个代码块。当然代码块可以由单个语句组成。</p>
<h1 id="2-11_if语句">2.11 if语句</h1><p>标准<strong>if</strong>条件语句遵循下面语法：</p>
<pre><code><span class="keyword">if</span> expression:
    <span class="keyword">if</span>_suite
</code></pre><p>如果表达式非0或True，则if_suite被执行。</p>
<pre><code><span class="keyword">if</span> x &lt; .<span class="number">0</span>:
    <span class="built_in">print</span> <span class="string">'”x” must be at least 0!'</span>
</code></pre><p>Python支持<strong>else</strong>语句，和<strong>if</strong>一起使用：</p>
<pre><code><span class="keyword">if</span> expression:
    <span class="keyword">if</span>_suite
<span class="keyword">else</span>:
    <span class="keyword">else</span>_suite
</code></pre><p>Python有一个“else-if”书写为<strong>elif</strong>使用下面的语法：</p>
<pre><code><span class="keyword">if</span> expression1:
    <span class="keyword">if</span>_suite
<span class="keyword">elif</span> expression2:
    <span class="keyword">elif</span>_suite
<span class="keyword">else</span>:
    <span class="keyword">else</span>_suite
</code></pre><h1 id="2-12_while循环">2.12 while循环</h1><p>标准while条件循环语句类似<strong>if</strong>，语法如下：</p>
<pre><code><span class="keyword">while</span> expression:
    <span class="keyword">while</span>_suite
</code></pre><p>while_suite语句在循环里面一直被执行直到expression变为0或False。</p>
<pre><code>&gt;&gt;&gt; counter = <span class="number">0</span>
&gt;&gt;&gt; <span class="keyword">while</span> counter &lt; <span class="number">3</span>:
<span class="attribute">...</span>     print <span class="string">'loop #%d'</span> % (counter)
<span class="attribute">...</span>     counter += <span class="number">1</span>
<span class="keyword">loop</span> <span class="variable">#0</span>
<span class="keyword">loop</span> <span class="variable">#1</span>
<span class="keyword">loop</span> <span class="variable">#2</span>
</code></pre><h1 id="2-13_for循环和range()内置函数">2.13 for循环和range()内置函数</h1><p>Python中的for循环更像一个脚本语言中foreach迭代类型循环。Python的for接受一个iterable并遍历每一个元素。</p>
<pre><code><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> [<span class="string">'e-mail'</span>, <span class="string">'net-surfing'</span>, <span class="string">'homework'</span>,
<span class="string">'chat'</span>]:
<span class="prompt">... </span>    <span class="keyword">print</span> item
e-mail
net-surfing
homework
chat
</code></pre><p><strong>print</strong>语句默认在每一行结尾添加一个换行符。可以在<strong>print</strong>语句后面加一个逗号抑制这个默认行为。</p>
<pre><code><span class="built_in">print</span> <span class="string">'I like to use the Internet for:'</span>
<span class="keyword">for</span> item <span class="keyword">in</span> [<span class="string">'e-mail'</span>, <span class="string">'net-surfing'</span>, <span class="string">'homework'</span>, <span class="string">'chat'</span>]:
    <span class="built_in">print</span> item,
<span class="built_in">print</span>
</code></pre><p><strong>print</strong>语句中逗号分隔的元素当它们被显示时会自动包含一个分隔的空格。</p>
<p>Python提供<strong>range()</strong>内置函数为我们生成一个列表。</p>
<pre><code><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> eachNum <span class="keyword">in</span> range(<span class="number">3</span>):
<span class="prompt">... </span>    <span class="keyword">print</span> eachNum
<span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">'abc'</span>:
<span class="prompt">... </span>    <span class="keyword">print</span> c
<span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(len(<span class="string">'abc'</span>)):
<span class="prompt">... </span>    <span class="keyword">print</span> foo[i], <span class="string">'(%d)'</span> % i
<span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> i, ch <span class="keyword">in</span> enumerate(foo):s
<span class="prompt">... </span>    <span class="keyword">print</span> ch, <span class="string">'(%d)'</span> % i
</code></pre><h1 id="2-14_列表推导式">2.14 列表推导式</h1><p>列表推导式使用一个for循环生成一个列表：</p>
<pre><code><span class="prompt">&gt;&gt;&gt; </span>squared = [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">4</span>)]
<span class="prompt">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> squared:
<span class="prompt">... </span>    <span class="keyword">print</span> i
</code></pre><p>列表推导式甚至可以选择性的包含什么进新列表：</p>
<pre><code><span class="prompt">&gt;&gt;&gt; </span>sqdEvens = [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">8</span>) <span class="keyword">if</span> <span class="keyword">not</span> x % <span class="number">2</span>]
</code></pre><h1 id="2-15_文件和open()，file()内置函数">2.15 文件和open()，file()内置函数</h1><p>如何打开一个文件：</p>
<pre><code>handle = <span class="function"><span class="title">open</span><span class="params">(file_name, access_mode = <span class="string">'r'</span>)</span></span>
</code></pre><p>file_name变量包含字符串类型的文件名，access_mode可以是读（r），写（w），追加（a）。其它标志包括读写（+），二进制访问（b）。</p>
<p>如果open()成功，一个文件对象被返回。所有后续文件访问必须通过这个文件对象。</p>
<blockquote>
<p><strong>核心笔记：什么是属性？</strong><br>属性是关联到一块数据的项。属性可以是简单数据值或可执行对象比如函数或方法。通过点号访问属性：object.attribute。</p>
</blockquote>
<pre><code>filename = <span class="function"><span class="title">raw_input</span><span class="params">(<span class="string">'Enter file name: '</span>)</span></span>
fobj = <span class="function"><span class="title">open</span><span class="params">(filename, <span class="string">'r'</span>)</span></span>
data = fobj.<span class="function"><span class="title">readlines</span><span class="params">()</span></span>
fobj.<span class="function"><span class="title">close</span><span class="params">()</span></span>
<span class="keyword">for</span> eachLine <span class="keyword">in</span> data:
    print eachLine,
</code></pre><p><strong>file()</strong>内置函数最近才添加进Python。它和<strong>open()</strong>是相同的，但是这种命名指示它是一个工厂函数（生产文件对象），类似于<strong>int()</strong>生产整数对象和<strong>dict()</strong>生产字典对象。</p>
<h1 id="2-16_错误和异常">2.16 错误和异常</h1><p>语法错误在编译时检查，但是Python也允许程序运行期间发现错误。当一个错误被检测，Python解释器抛出一个异常。使用<strong>try-except</strong>语句添加错误检测或异常处理到你的代码。</p>
<pre><code>try:
    filename = <span class="function"><span class="title">raw_input</span><span class="params">(<span class="string">'Enter file name: '</span>)</span></span>
    fobj = <span class="function"><span class="title">open</span><span class="params">(filename, <span class="string">'r'</span>)</span></span>
    <span class="keyword">for</span> eachLine <span class="keyword">in</span> fobj:
        print eachLine,
    fobj.<span class="function"><span class="title">close</span><span class="params">()</span></span>
except IOError, e:
    print <span class="string">'file open error:'</span>, e
</code></pre><p>程序员可以显式使用<strong>raise</strong>抛出一个异常。</p>
<h1 id="2-17_函数">2.17 函数</h1><p>和其它语言一样，Python中的函数使用函数操作符（()）调用，函数必须在调用前声明。不需要声明函数返回类型或显式返回值，如果没有返回值，Python返回<strong>None</strong>。</p>
<p>Python可以被认为是“引用调用”。这意味着函数内任何对函数参数的改变会影响到原来的对象。然而在Python中，这实际上取决于传递的对象类型。如果这个对象允许更新，则它表现为我们预期的“引用调用”，但是如果对象的值不能改变，则它表现为“传值调用”。</p>
<h2 id="如何定义函数">如何定义函数</h2><pre><code><span class="function"><span class="keyword">def</span> <span class="title">function_name</span><span class="params">([arguments])</span>:</span>
    <span class="string">"optional documentation string"</span>
    function_suite
</code></pre><p>声明一个函数的语法由<strong>def</strong>关键字，跟着函数名和任意数量函数可能接收的参数组成。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">addMe2Me</span><span class="params">(x)</span>:</span>
    <span class="string">'apply + operation to argument'</span>
    <span class="keyword">return</span> (x + x)
</code></pre><h1 id="默认实参">默认实参</h1><p>函数可以有具有默认值的参数。如果参数的值没有提供，将会使用默认值：</p>
<pre><code><span class="prompt">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(debug=True)</span>:</span>
<span class="prompt">... </span>    <span class="string">'determine if in debug mode with default argument'</span>
<span class="prompt">... </span>    <span class="keyword">if</span> debug:
<span class="prompt">... </span>        <span class="keyword">print</span> <span class="string">'in debug mode'</span>
<span class="prompt">... </span>    <span class="keyword">print</span> <span class="string">'done'</span>
<span class="prompt">&gt;&gt;&gt; </span>foo()
<span class="keyword">in</span> debug mode
done
<span class="prompt">&gt;&gt;&gt; </span>foo(<span class="keyword">False</span>)
done
</code></pre><h1 id="2-18_类">2.18 类</h1><p>类是面向对象编程的核心部分，并作为一个“容器”服务相关的数据和逻辑。</p>
<h2 id="如何定义类">如何定义类</h2><pre><code><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span><span class="params">(base_class[es])</span>:</span>
    <span class="string">"optional documentation string"</span>
    static_member_declarations
    method_declarations
</code></pre><p>类使用<strong>class</strong>关键字声明。基类或父类可选，如果没有，使用object作为基类。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">FooClass</span><span class="params">(object)</span>:</span>
    <span class="string">"""my very first class: FooClass"""</span>
    version = <span class="number">0.1</span> <span class="comment"># class (data) attribute</span>

    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nm=<span class="string">'John Doe'</span>)</span>:</span>
        <span class="string">"""constructor"""</span>
        self.name = nm <span class="comment"># class instance (data) attribute</span>
        <span class="keyword">print</span> <span class="string">'Created a class instance for'</span>, nm

    <span class="function"><span class="keyword">def</span> <span class="title">showname</span><span class="params">(self)</span>:</span>
        <span class="string">"""display instance attribute and class name"""</span>
        <span class="keyword">print</span> <span class="string">'Your name is'</span>, self.name
        <span class="keyword">print</span> <span class="string">'My name is'</span>, self.__class__.__name__

    <span class="function"><span class="keyword">def</span> <span class="title">showver</span><span class="params">(self)</span>:</span>
        <span class="string">"""display class(static) attribute"""</span>
        <span class="keyword">print</span> self.version <span class="comment"># references FooClass.version</span>

    <span class="function"><span class="keyword">def</span> <span class="title">addMe2Me</span><span class="params">(self, x)</span>:</span> <span class="comment"># does not use 'self'</span>
        <span class="string">"""apply + operation to argument"""</span>
        <span class="keyword">return</span> x + x
</code></pre><p><strong><strong>init</strong>()</strong>方法一个默认提供的函数，当类实例创建的时候被调用，类似一个构造器并在对象实例化后被调用。<strong>self</strong>基本上是实例自己本身的句柄，其它面向对象语言通常使用<strong>this</strong>。</p>
<h2 id="如何创建实例">如何创建实例</h2><p>创建实例看起来像调用一个函数，并拥有一样的语法。</p>
<pre><code>&gt;&gt;&gt; foo1 = <span class="function"><span class="title">FooClass</span><span class="params">()</span></span>
Created <span class="tag">a</span> class instance <span class="keyword">for</span> John Doe
&gt;&gt;&gt; foo1.<span class="function"><span class="title">showname</span><span class="params">()</span></span>
Your name is John Doe
My name is FooClass
&gt;&gt;&gt; foo1.<span class="function"><span class="title">showver</span><span class="params">()</span></span>
<span class="number">0.1</span>
&gt;&gt;&gt; print foo1.<span class="function"><span class="title">addMe2Me</span><span class="params">(<span class="number">5</span>)</span></span>
<span class="number">10</span>
&gt;&gt;&gt; print foo1.<span class="function"><span class="title">addMe2Me</span><span class="params">(<span class="string">'xyz'</span>)</span></span>
xyzxyz
</code></pre><h1 id="2-19_模块">2.19 模块</h1><p>一个模块是物理组织和区分相关的Python代码到独立文件的逻辑方式。一个模块可以包含可执行代码，函数，类或所有任何以上的。</p>
<p>当你创建了一个Python源文件，模块名和文件名去除扩展名一样。一旦一个模块创建了，你可以使用<strong>import</strong>语句导入模块。</p>
<pre><code><span class="keyword">import</span> <span class="keyword">module</span><span class="number">_n</span>ame
</code></pre><p>一旦导入模块，模块的属性（函数和变量等）可以用点号访问：</p>
<pre><code><span class="class"><span class="keyword">module</span>.<span class="title">function</span>()</span>
<span class="class"><span class="keyword">module</span>.<span class="title">variable</span></span>

<span class="prompt">&gt;&gt;</span>&gt; import sys
<span class="prompt">&gt;&gt;</span>&gt; sys.stdout.write(<span class="string">'Hello World!\n'</span>)
<span class="constant">Hello</span> <span class="constant">World</span>!
<span class="prompt">&gt;&gt;</span>&gt; sys.platform
<span class="string">'win32'</span>
<span class="prompt">&gt;&gt;</span>&gt; sys.version
<span class="string">'2.4.2 (#67, Sep 28 2005, 10:51:12) [MSC v.1310 32 bit
(Intel)]'</span>
</code></pre><blockquote>
<p><strong>核心笔记：PEP是什么？</strong><br>PEP是Python Enhancement Proposal。它是新特性被引进到未来版本的Python的一种方式。<a href="http://python.org/dev/peps" target="_blank" rel="external">PEP链接</a></p>
</blockquote>
<h1 id="2-20_有用的函数">2.20 有用的函数</h1><table>
<thead>
<tr>
<th>函数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>dir([obj])</td>
<td style="text-align:left">显示obj的属性或全局变量的名字如果参数未提供</td>
</tr>
<tr>
<td>help([obj])</td>
<td style="text-align:left">显示obj的帮助文档或进入交互帮助界面如果参数未提供</td>
</tr>
<tr>
<td>int(obj)</td>
<td style="text-align:left">将obj转换为整形</td>
</tr>
<tr>
<td>len(obj)</td>
<td style="text-align:left">返回obj的长度</td>
</tr>
<tr>
<td>open(fn, mode)</td>
<td style="text-align:left">用mode打开文件fn（’r’读，’w’写）</td>
</tr>
<tr>
<td>range([start,]stop[,step])</td>
<td style="text-align:left">返回一个整形列表，从start开始到stop（不包括stop），每次增量step；start默认为0，step默认为1</td>
</tr>
<tr>
<td>raw_input(str)</td>
<td style="text-align:left">等待用户输入，str可选</td>
</tr>
<tr>
<td>str(obj)</td>
<td style="text-align:left">将obj转换为字符串</td>
</tr>
<tr>
<td>type(obj)</td>
<td style="text-align:left">返回obj的类型（本身是一个type对象）</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="命令行选项">命令行选项</h1><p>-d      提供调试输出<br>-O      生成优化字节码（产生.pyo文件）<br>-S      启动时不要运行导入地址查询Python路径<br>-v      详细输出（详细追踪import语句）<br>-m]]>
    </summary>
    
      <category term="Python" scheme="https://opensvn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[21世纪C语言 第2章 调试，测试，文档]]></title>
    <link href="https://opensvn.github.io/2015/12/18/21st-c-2/"/>
    <id>https://opensvn.github.io/2015/12/18/21st-c-2/</id>
    <published>2015-12-18T07:48:18.000Z</published>
    <updated>2015-12-18T09:17:22.013Z</updated>
    <content type="html"><![CDATA[<h1 id="使用调试器">使用调试器</h1><p>关于调试器的第一个简明提示：总是使用调试器。</p>
<h2 id="一个调试侦探故事">一个调试侦探故事</h2><p>调试代码：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> //size_t</span>

<span class="keyword">typedef</span> <span class="keyword">struct</span> meanvar {<span class="keyword">double</span> mean, var;} meanvar;

<span class="function">meanvar <span class="title">mean_and_var</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> *data)</span></span>{
    <span class="keyword">long</span> <span class="keyword">double</span> avg = <span class="number">0</span>,
          avg2 = <span class="number">0</span>;
    <span class="keyword">long</span> <span class="keyword">double</span> ratio;
    <span class="keyword">size_t</span> count= <span class="number">0</span>;
    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;  !isnan(data[i]); i++){
        ratio = count/(count+<span class="number">1</span>);
        count ++;
        avg   *= ratio;
        avg2  *= ratio;
        avg   += data[i]/(count +<span class="number">0.0</span>);
        avg2  += <span class="built_in">pow</span>(data[i], <span class="number">2</span>)/(count +<span class="number">0.0</span>);
    }
    <span class="keyword">return</span> (meanvar){.mean = avg,
                    .var = avg2 - <span class="built_in">pow</span>(avg, <span class="number">2</span>)}; <span class="comment">//E[x^2] - E^2[x]</span>
}

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{
    <span class="keyword">double</span> d[] = { <span class="number">34124.75</span>, <span class="number">34124.48</span>,
                   <span class="number">34124.90</span>, <span class="number">34125.31</span>,
                   <span class="number">34125.05</span>, <span class="number">34124.98</span>, NAN};

    meanvar mv = mean_and_var(d);
    <span class="built_in">printf</span>(<span class="string">"mean: %.10g var: %.10g\n"</span>, mv.mean, mv.var*<span class="number">6</span>/<span class="number">5.</span>);

    <span class="keyword">double</span> d2[] = { <span class="number">4.75</span>, <span class="number">4.48</span>,
                    <span class="number">4.90</span>, <span class="number">5.31</span>,
                    <span class="number">5.05</span>, <span class="number">4.98</span>, NAN};

    mv = mean_and_var(d2);
    mv.var *= <span class="number">6.</span>/<span class="number">5</span>;
    <span class="built_in">printf</span>(<span class="string">"mean: %.10g var: %.10g\n"</span>, mv.mean, mv.var);
}
</code></pre><p>使用<strong>CFLAGS=”-g -Wall -std=gnu11 -O3” make stddev</strong>编译代码，<strong>gdb stddev_bugged</strong>调试代码。</p>
<p><strong>Q: 这个程序是做什么的？</strong><br>A: <strong>run</strong>命令运行程序。</p>
<pre><code>(gdb) r
mean: <span class="number">5687.496667</span> var: <span class="number">194085710</span>
mean: <span class="number">0.83</span> var: <span class="number">4.1334</span>
[Inferior <span class="number">1</span> (process <span class="number">22734</span>) exited normally]
</code></pre><p><strong>Q: main函数中的代码符合我们的输出吗？</strong><br>A: <strong>list</strong>命令显示源代码</p>
<p><strong>Q: 我们如何查看mean_and_var发生了什么？</strong><br>A: 我们想要程序在mean_and_var暂停，因此我们在那里设置一个断点：</p>
<pre><code>(gdb) <span class="tag">b</span> mean_and_var
Breakpoint <span class="number">1</span> at <span class="number">0</span>x400820: file stddev_bugged<span class="class">.c</span>, line <span class="number">16</span>.
</code></pre><p><strong>Q: data是我们想的那样吗？</strong><br>A: 我们可以通过print简写为p查看data：</p>
<pre><code>(gdb) p *data
<span class="variable">$2</span> = <span class="number">34124.75</span>
</code></pre><p>我们只得到第一个元素，但GDB有一个特殊的@语法打印数组元素。打印10个元素[LLDB: mem read -tdouble -c10 data]：</p>
<pre><code>(gdb) p *data@10
$3 = {<span class="number">34124.75</span>, <span class="number">34124.48000</span><span class="number">0000003</span>, <span class="number">34124.90000</span><span class="number">0000001</span>, <span class="number">34125.30999</span><span class="number">9999998</span>, 
  <span class="number">34125.05000</span><span class="number">0000003</span>, <span class="number">34124.98000</span><span class="number">0000003</span>, nan(<span class="number">0x80000000</span>00000), 0, 
  <span class="number">4.94065645</span><span class="number">84124654</span>e-324, <span class="number">2.07325606</span><span class="number">87596022</span>e-317}
</code></pre><p>注意表达式前面的星号，没有它，我们会得到10个地址。</p>
<p><strong>Q: 这和main发送的匹配吗？</strong><br>A: 我们可以通过bt回溯：</p>
<pre><code>(gdb) bt
<span class="preprocessor">#<span class="number">0</span>  mean_and_var (data=data@entry=<span class="number">0x7fffffffdd50</span>) at stddev_bugged.c:<span class="number">16</span></span>
<span class="preprocessor">#<span class="number">1</span>  <span class="number">0x0000000000400520</span> in main () at stddev_bugged.c:<span class="number">38</span></span>
</code></pre><p>让我们看看data在frame 1是什么，首先切换到frame 1：</p>
<pre><code>(gdb) f <span class="number">1</span>
<span class="preprocessor">#<span class="number">1</span>  <span class="number">0x0000000000400520</span> in main () at stddev_bugged.c:<span class="number">38</span></span>
<span class="number">38</span>      meanvar mv = mean_and_var(d);
</code></pre><p>在这一层，data数组叫d：</p>
<pre><code>(gdb) p *d@7
$5 = {<span class="number">34124.75</span>, <span class="number">34124.48000</span><span class="number">0000003</span>, <span class="number">34124.90000</span><span class="number">0000001</span>, <span class="number">34125.30999</span><span class="number">9999998</span>, 
  <span class="number">34125.05000</span><span class="number">0000003</span>, <span class="number">34124.98000</span><span class="number">0000003</span>, nan(<span class="number">0x80000000</span>00000)}
</code></pre><p>我们可以返回frame 0通过f 0或与栈关联的移动：</p>
<pre><code>(gdb) down
<span class="preprocessor">#<span class="number">0</span>  mean_and_var (data=data@entry=<span class="number">0x7fffffffdd50</span>) at stddev_bugged.c:<span class="number">16</span></span>
<span class="number">16</span>  <span class="function">meanvar <span class="title">mean_and_var</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> *data)</span></span>{
</code></pre><p>注意up和down参考数字顺序。由bt产生的列表，数字最小的层在最上面，up走向数字大的层，down走向数字小的层。</p>
<p><strong>Q: 这是线程的问题吗？</strong><br>A: 我们可以得到一个线程列表通过info threads[LLDB: thread list]：</p>
<pre><code>(gdb) info threads
  Id   Target Id         Frame 
* <span class="number">1</span>    process <span class="number">6125</span> <span class="string">"stddev_bugged"</span> mean_and_var (
    data=data@entry=<span class="number">0x7fffffffdd50</span>) at stddev_bugged.c:<span class="number">16</span>
</code></pre><p>如果有多个线程，我们可以使用thread num（GDB）或thread select num（LLDB）切换过去。GDB用户可以在.gdbinit添加set print thread-events off关闭每一个线程烦人的通知。</p>
<p><strong>Q: mean_and_var在做什么？</strong><br>A: 我们可以重复步进程序的下一行：</p>
<pre><code>(gdb) n
<span class="number">18</span>            avg2 = <span class="number">0</span>;
(gdb) n
<span class="number">16</span>  <span class="function">meanvar <span class="title">mean_and_var</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> *data)</span></span>{
</code></pre><p>没有输入敲击回车重复上一个命令。还有其他的步进选项（snuc）。使用步进调试代码将会花费很多时间。且函数中有个循环，我们可以在循环中间设置一个断点：</p>
<pre><code>(gdb) b <span class="number">25</span>
Breakpoint <span class="number">2</span> at <span class="number">0x400715</span>: file stddev_bugged.c, line <span class="number">25.</span>
</code></pre><p>现在我们有2个断点，可以使用info break查看断点列表。</p>
<pre><code>(gdb) info <span class="tag">b</span>
Num     Type           Disp Enb Address            What
<span class="number">1</span>       breakpoint     keep y   <span class="number">0</span>x00000000004006c0 <span class="keyword">in</span> mean_and_var 
                                                   at stddev_bugged<span class="class">.c</span>:<span class="number">16</span>
    breakpoint already hit <span class="number">1</span> <span class="tag">time</span>
<span class="number">2</span>       breakpoint     keep y   <span class="number">0</span>x0000000000400715 <span class="keyword">in</span> mean_and_var 
                                                   at stddev_bugged<span class="class">.c</span>:<span class="number">25</span>
</code></pre><p>不再需要mean_and_var头部的断点了，可以禁止它[LLDB: break dis 1]：</p>
<pre><code><span class="list">(<span class="keyword">gdb</span>)</span> dis <span class="number">1</span>
</code></pre><p>你可以重新激活一个断点enable 1（GDB）或break enable 1（LLDB）。如果你不再需要一个断点可以删除它，del 1（GDB）或break del 1（LLDB）。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="使用调试器">使用调试器</h1><p>关于调试器的第一个简明提示：总是使用调试器。</p>
<h2 id="一个调试侦探故事">一个调试侦探故事</h2><p>调试代码：</p>
<pre><code><span class="preprocessor">#<s]]>
    </summary>
    
      <category term="C/C++" scheme="https://opensvn.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[21世纪C语言 第1章 便利编译配置]]></title>
    <link href="https://opensvn.github.io/2015/12/15/21st-c-1/"/>
    <id>https://opensvn.github.io/2015/12/15/21st-c-1/</id>
    <published>2015-12-15T11:55:08.000Z</published>
    <updated>2015-12-18T07:37:58.416Z</updated>
    <content type="html"><![CDATA[<h1 id="使用包管理器">使用包管理器</h1><p>必须获取的包：</p>
<ul>
<li>编译器。必须安装<strong>gcc</strong>；<strong>clang</strong>可能也有用。</li>
<li><strong>gdb</strong>，调试器</li>
<li><strong>Valgrind</strong>，测试C内存使用错误。</li>
<li><strong>gprof</strong>，一个分析工具</li>
<li><strong>make</strong>，你永远不需要直接调用编译器</li>
<li><strong>pkg-config</strong>，查找库</li>
<li><strong>Doxygen</strong>，文档生成</li>
<li>文本编辑器。<strong>Emacs</strong>或<strong>vim</strong>。</li>
<li>自动工具：<strong>Autoconf</strong>，<strong>Automake</strong>，<strong>libtool</strong>。</li>
<li><strong>Git</strong></li>
<li>Shell替换品，比如Z shell。</li>
</ul>
<p>一些省去重复造轮子的C库：</p>
<ul>
<li><strong>libcURL</strong></li>
<li><strong>libGLib</strong></li>
<li><strong>libGSL</strong></li>
<li><strong>libSQLite3</strong></li>
<li><strong>libXML2</strong></li>
</ul>
<h1 id="通向库的路径">通向库的路径</h1><pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span>  //erf, sqrt</span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> //printf</span>

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{
    <span class="built_in">printf</span>(<span class="string">"The integral of a Normal(0, 1) distribution "</span>
           <span class="string">"between -1.96 and 1.96 is: %g\n"</span>, erf(<span class="number">1.96</span>*<span class="built_in">sqrt</span>(<span class="number">1</span>/<span class="number">2.</span>)));
}
</code></pre><p>编译器会将math.h和stdio.h文件内容粘贴进代码文件。math.h中的声明并没有说明erf函数做了什么。链接器负责找到erf，你需要告诉链接器-lm找到math库。-l指示一个库需要链接进来。你可以免费使用printf，因为链接器会用隐式的-lc将标准库libc链接进来。</p>
<p>如果使用gcc编译器，完整的命令包括一些额外的标志就像这样：</p>
<pre><code>gcc <span class="built_in">erf</span>.c -o <span class="built_in">erf</span> -lm -g -Wall -O3 -std=gnu11
</code></pre><h2 id="一些出名的标志">一些出名的标志</h2><p>推荐使用这些编译标志：</p>
<ul>
<li><strong>-g</strong>，为调试添加符号。</li>
<li><strong>-std=gnu11</strong>，clang-和gcc-特定，指示编译器允许遵守C11和POSIX标准的代码。POSIX标准指定系统中要有c99程序。</li>
<li><strong>-o3</strong>，指示优化等级3，会尝试任何手段编译更快的代码。如果不需要太多优化，也可以使用<strong>-o0</strong>。</li>
<li><strong>-Wall</strong>，添加编译器警告。也可以使用<strong>-w1</strong>，只显示编译器警告，没有附注。<strong>-Werror</strong>，编译器将会把警告视为错误。</li>
</ul>
<h2 id="路径">路径</h2><p>在一个典型配置中，库至少会安装在三个地方：</p>
<ul>
<li>操作系统供应商可能会定义1到2个标准目录来安装库。</li>
<li>本地系统管理员可能有一个目录安装不想被供应商覆盖的包。</li>
<li>用户在自己主目录可能有库目录。</li>
</ul>
<p>假设你有一个叫libuseful的库安装在/usr/local目录。你已经把#include <useful.h>写进代码，现在你需要使用下面的命令编译代码：</useful.h></p>
<pre><code>gcc -<span class="constant">I</span>/usr/local/<span class="keyword">include</span> use_useful.c -o use_useful -<span class="constant">L</span>/usr/local/<span class="class"><span class="keyword">lib</span> -<span class="title">luseful</span></span>
</code></pre><ul>
<li><strong>-I</strong>将指定路径添加进头文件搜索路径，编译器在搜索路径搜索你包含的头文件。</li>
<li><strong>-L</strong>添加库搜索路径。</li>
<li>链接的顺序有关系。如果你有一个名字为specific.o的文件，依赖libbroad库，且libbroad库依赖libgeneral库，那么你需要，gcc specific.o -lbroad -lgeneral。任何其它的顺序都可能会失败。</li>
</ul>
<p><strong>pkg-config</strong>返回已安装库的维护信息。</p>
<pre><code>pkg-config --libs gsl libxml-2.0
pkg-config --cflags gsl libxml-2.0

-<span class="ruby">lgsl -lgslcblas -lm -lxml2
</span>-<span class="ruby"><span class="constant">I</span>/usr/<span class="keyword">include</span>/libxml2</span>
</code></pre><p>回到前面那个命令，当你使用反撇号包含一个命令时，shell会使用其输出替换该命令。</p>
<pre><code>gcc <span class="escape">`p</span>kg-config --cflags --libs gsl libxml-<span class="number">2.0</span><span class="escape">` </span>-o specific specific.c
</code></pre><p>等价于：</p>
<pre><code>gcc -I/usr/<span class="preprocessor"><span class="keyword">include</span>/libxml2 -lgsl -lgslcblas -lm -lxml2 -o specific specific.c</span>
</code></pre><h2 id="运行时链接">运行时链接</h2><p>静态库由编译器通过拷贝库内容链接进可执行程序。共享库在运行时链接进程序，意味着和编译时一样存在库的查找问题。如果是一个在常见位置的库，运行时系统将没有查找库的问题。如果库不在标准路径，则你需要找到一种修改运行时路径查找的方法。</p>
<ul>
<li>如果使用Autotools打包程序，libtool知道如何添加正确的标志，你不需要担心它。</li>
<li>当使用gcc，clang或icc基于libpath的库编译程序时，添加： LDADD=-Llibpath -Wl, -Rlibpath到makefile里面。-L标志告诉编译器去哪里查找库以确定符号；-Wl标志传递标志给链接器，链接器将指定-R标志的库嵌入运行时库的查找路径。pkg-config通常不知道运行时路径，因此需要手动输入。</li>
<li>运行时，链接器将使用另一个路径查找不在常见位置也没有-Wl,R…指定的库。这个路径在shell的启动脚本里面设置：</li>
</ul>
<pre><code><span class="built_in">export</span> LD_LIBRARY_PATH=libpath:<span class="variable">$LD_LIBRARY_PATH</span>     <span class="comment">#Linux, Cygwin</span>
<span class="built_in">export</span> DYLD_LIBRARY_PATH=libpath:<span class="variable">$DYLD_LIBRARY_PATH</span>    <span class="comment">#OS X</span>
</code></pre><h1 id="使用Makefile">使用Makefile</h1><p><strong>makefile</strong>提供了所有这些无止境的调整的一种解决方案。它基本上是组织的一组变量和单行shell脚本的序列。POSIX标准的<strong>make</strong>程序读取<strong>makefile</strong>里面的指令和变量，并将长且单调的命令行组合给我们。</p>
<pre><code><span class="constant">P</span>=program_name
<span class="constant">OBJECTS</span>=
<span class="constant">CFLAGS</span> = -g -Wall -O3
<span class="constant">LDLIBS</span>=
<span class="constant">CC</span>=c99
$(P): $(OBJECTS)
</code></pre><p>用法：</p>
<ul>
<li>一次就好：将这几行保存在.c文件同一个目录，并命名为Makefile（GNU Make）。在第一行设置你的程序名，没有.c后缀。</li>
<li>每次需要重新编译：输入<strong>make</strong>。</li>
</ul>
<h2 id="设置变量">设置变量</h2><p><strong>shell</strong>和<strong>make</strong>使用<strong>$</strong>指示变量的值。<strong>shell</strong>使用<strong>$var</strong>，而<strong>make</strong>需要任何变量名长度大于1个字符的变量包含在括号中：<strong>$(var)</strong>。</p>
<p>有几种方法告诉<strong>make</strong>变量：</p>
<ul>
<li>调用<strong>make</strong>之前设置变量并<strong>export</strong>这个变量。POSIX标准命令行设置CFLAGS变量：<strong>export CFLAGS=’-g -Wall -O3’</strong></li>
<li>你可以将这些<strong>export</strong>命令放进<strong>shell</strong>启动脚本，比如.bashrc或.zshrc。</li>
<li>你可以在命令之前赋值设置一个变量。<strong>PANTS=kakhi env | grep PANTS</strong>。等号两边不能有空格，因为空格是用来区分命令和赋值的。</li>
<li>早期的<strong>makefile</strong>可以在文件头设置变量。在<strong>makefile</strong>文件里面，等号两边可以有空格。</li>
<li><strong>make</strong>允许在命令行设置变量，独立于<strong>shell</strong>。</li>
</ul>
<pre><code>make CFLAGS="-g -Wall"  # <span class="operator"><span class="keyword">Set</span> a makefile <span class="keyword">variable</span>.
CFLAGS=<span class="string">"-g -Wall"</span> make  # <span class="keyword">Set</span> an environment <span class="keyword">variable</span> <span class="keyword">visible</span> <span class="keyword">to</span> make <span class="keyword">and</span> its children.</span>
</code></pre><h3 id="C语言中的环境变量">C语言中的环境变量</h3><pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> //getenv, atoi</span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> //printf</span>

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{
    <span class="keyword">char</span> *repstext = getenv(<span class="string">"reps"</span>);
    <span class="keyword">int</span> reps = repstext ? atoi(repstext) : <span class="number">10</span>;

    <span class="keyword">char</span> *msg = getenv(<span class="string">"msg"</span>);
    <span class="keyword">if</span> (!msg) msg = <span class="string">"Hello."</span>;

    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; reps; ++i)
        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, msg);
}

reps=<span class="number">10</span> msg=<span class="string">"Ha"</span> ./getenv
msg=<span class="string">"Ha"</span> ./getenv
reps=<span class="number">20</span> msg=<span class="string">" "</span> ./getenv
</code></pre><p><strong>make</strong>也提供一些内置变量：</p>
<ul>
<li><strong>$@</strong> 所有的目标文件。目标文件是源文件编译完生成的中间文件（.o文件）。</li>
<li><strong>$*</strong> 去掉后缀的目标文件。如果目标文件是prog.o，则<strong>$*</strong>是prog，且<strong>$*</strong>.c就是prog.c</li>
<li><strong>$&lt;</strong> 引起目标被触发并编译的文件名。如果我们编译prog.o，可能因为prog.c最近被修改了，所以<strong>$&lt;</strong>就是prog.c。</li>
</ul>
<h2 id="规则">规则</h2><p>除了设置变量，<strong>makefile</strong>的片段具有以下形式：</p>
<pre><code><span class="attribute">target</span>: <span class="string">dependencies</span>
        <span class="attribute">script</span>
</code></pre><p>如果通过命令<strong>make target</strong>目标被调用，则依赖被检查。如果目标是一个文件，依赖也全部是文件，且目标比依赖新，则文件是最新的，没有什么事要做。否则，目标的处理被暂停，依赖被运行或生成，可能通过另一个目标，当依赖的脚本都完成了，目标的脚本开始运行。</p>
<pre><code>all: <span class="tag">html</span> doc publish
doc:
    pdflatex $(f)<span class="class">.tex</span>
<span class="tag">html</span>:
    latex -interaction batchmode $(f)
    latex2html $(f)<span class="class">.tex</span>
publish:
    scp $(f)<span class="class">.pdf</span> $(Blogserver)
</code></pre><p>在前面简单的makefile里面，我们只有一个目标/依赖/脚本组合。比如：</p>
<pre><code>P=domath
OBJECTS=addition<span class="class">.o</span> subtraction<span class="class">.o</span>
$(P): $(OBJECTS)
</code></pre><p>P=domath是需要编译的程序，它依赖对象文件addition.o和substration.o。因为addition.o没有作为目标列出来，<strong>make</strong>使用隐式规则将.c文件编译成.o文件。同样的操作处理substraction.o和domath.o（GNU make隐式假定domath依赖domath.o）。当所有对象被编译时，我们没有脚本规则建立$(P)目标，GNU make填写默认脚本，链接.o文件成可执行程序。</p>
<p>POSIX标准<strong>make</strong>将.c文件编译成.o文件的默认规则：</p>
<pre><code><span class="variable">$(</span><span class="constant">CC</span>) <span class="variable">$(</span><span class="constant">CFLAGS</span>) <span class="variable">$(</span><span class="constant">LDFLAGS</span>) -o <span class="variable">$@</span> <span class="variable">$*</span>.c
</code></pre><p>$(CC)变量代表你的C编译器；POSIX标准指定默认CC=c99。$(CFLAGS)设置为之前的标志。$(LDFLAGS)没有设置因此为空。</p>
<p>GNU make将目标文件编译成可执行程序的默认规则：</p>
<pre><code><span class="variable">$(</span><span class="constant">CC</span>) <span class="variable">$(</span><span class="constant">LDFLAGS</span>) <span class="variable">$@</span> <span class="variable">$(</span><span class="constant">LDLIBS</span>)
</code></pre><p>回忆一下链接的顺序很重要，因此我们需要两个链接器变量。</p>
<pre><code>cc specific<span class="class">.o</span> -lbroad -lgeneral
LDLIBS=-lbroad -lgeneral
</code></pre><blockquote>
<p>如果想要看完整的make默认规则和内置变量，试一试：make -p &gt; default_rules</p>
</blockquote>
<p>这就是游戏规则：查找正确的变量并在makefile里面设置。</p>
<ul>
<li><strong>CFLAGS</strong>变量是一个根深蒂固的习俗，但是为链接器设置的变量在每个系统都不一样。甚至<strong>LDLIBS</strong>也不是POSIX标准，它只是GNU make使用。</li>
<li><strong>CFLAGS</strong>和<strong>LDLIBS</strong>变量是我们指定所有编译器标志并查找和指定库。如果你有<strong>pkg-config</strong>，使用反撇号调用。</li>
</ul>
<pre><code>CFLAGS=<span class="escape">`p</span>kg-config --cflags apophenia glib-<span class="number">2.0</span><span class="escape">` </span>-g -Wall -std=gnu11 -O3
LDLIBS=<span class="escape">`p</span>kg-config --libs apophenia glib-<span class="number">2.0</span>`
</code></pre><p>或者手动指定<strong>-I</strong>，<strong>-L</strong>和<strong>-l</strong>标志：</p>
<pre><code><span class="constant">CFLAGS</span>=-<span class="constant">I</span>/home/b/root/<span class="keyword">include</span> -g -<span class="constant">Wall</span> -<span class="constant">O3</span>
<span class="constant">LDLIBS</span>=-<span class="constant">L</span>/home/b/root/<span class="class"><span class="keyword">lib</span> -<span class="title">lweirdlib</span></span>
</code></pre><ul>
<li>在你将一个库和其路径添加进<strong>LDLIBS</strong>和<strong>CFLAGS</strong>后，没有理由再去除它。你不会在意最终的可执行程序可能大一点。而且这样也可以makefile在各个工程里面不太需要修改。</li>
<li>如果你的程序需要更多C文件，在makefile中添加name.o到OBJECTS。</li>
<li>如果你的程序只有一个.c文件，你可能根本不需要makefile。你可以使用下面的方法使用make：</li>
</ul>
<pre><code><span class="built_in">export</span> CFLAGS=<span class="string">'-g -Wall -O3 -std=gnu11'</span>
<span class="built_in">export</span> LDLIBS=<span class="string">'-lm'</span>
make erf
</code></pre><h1 id="从源文件使用库">从源文件使用库</h1><p>可以通过编译源代码来安装库。下面用GSL（GNU Scientific Library）库作为例子。假设你有<strong>root</strong>权限：</p>
<pre><code>wget ftp:<span class="comment">//ftp.gnu.org/gnu/gsl/gsl-2.1.tar.gz</span>
tar xvzf gsl-<span class="number">2.1</span><span class="class">.tar</span><span class="class">.gz</span>
cd gsl-<span class="number">2.1</span>
./configure
make
sudo make install
</code></pre><p>如果没有出错的话，GSL就已经安装好了。下面是一个简单的使用gsl库的程序：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;gsl/gsl_cdf.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{
    <span class="keyword">double</span> bottom_tail = gsl_cdf_gaussian_P(-<span class="number">1.96</span>, <span class="number">1</span>);
    <span class="built_in">printf</span>(<span class="string">"Area between [-1.96, 1.96]: %g\n"</span>, <span class="number">1</span>-<span class="number">2</span>*bottom_tail);
}
</code></pre><p>要使用你安装的库，你需要修改你的makefile，取决与你是否有<strong>pkg-config</strong>，你可以使用其中一个：</p>
<pre><code>LDLIBS=`pkg-config <span class="comment">--libs gsl`</span>
</code></pre><p>或：</p>
<pre><code><span class="attribute">LDLIBS</span>=<span class="string">-lgsl -lgslcblas -lm</span>
</code></pre><p>如果你没有安装在标准位置且没有<strong>pkg-config</strong>，你需要添加路径：</p>
<pre><code><span class="constant">CFLAGS</span>=-<span class="constant">I</span>/usr/local/<span class="keyword">include</span>
<span class="constant">LDLIBS</span>=-<span class="constant">L</span>/usr/local/<span class="class"><span class="keyword">lib</span> -<span class="title">Wl</span>,-<span class="title">R</span>/<span class="title">usr</span>/<span class="title">local</span>/<span class="title">lib</span></span>
</code></pre><h1 id="从源文件使用库（即使你的系统管理员不允许）">从源文件使用库（即使你的系统管理员不允许）</h1><p>首先创建一个目录，比如：</p>
<pre><code><span class="built_in">mkdir</span> ~/root
</code></pre><p>接着添加路径：</p>
<pre><code>PATH=~/root/bin:<span class="variable">$PATH</span>
</code></pre><p>在makefile中添加新路径：</p>
<pre><code><span class="constant">LDLIBS</span>=-<span class="constant">L</span><span class="variable">$(</span><span class="constant">HOME</span>)/root/<span class="class"><span class="keyword">lib</span> (<span class="title">plus</span> <span class="title">the</span> <span class="title">other</span> <span class="title">flags</span>, <span class="title">like</span> -<span class="title">lgsl</span> -<span class="title">lm</span> ...)</span>
<span class="constant">CFLAGS</span>=-<span class="constant">I</span><span class="variable">$(</span><span class="constant">HOME</span>)/root/<span class="keyword">include</span> (plus -g -<span class="constant">Wall</span> -<span class="constant">O3</span> ...)
</code></pre><p>将所要的库安装到指定路径：</p>
<pre><code>./configure --prefix=<span class="variable">$HOME</span>/root &amp;&amp; make &amp;&amp; make install
</code></pre><h1 id="通过嵌入文档编译C程序">通过嵌入文档编译C程序</h1><p>你已经看过编译的模式很多次了：</p>
<ol>
<li>设置一个变量代表编译的标志</li>
<li>设置一个变量代表链接的标志，每一个你使用的库包括一个-l标志</li>
<li>使用<strong>make</strong>或IDE将变量转换为完整的编译和链接命令。</li>
</ol>
<h2 id="从命令行包含头文件">从命令行包含头文件</h2><p><strong>gcc</strong>和<strong>clang</strong>有一个方便的标志包含头文件，比如：</p>
<pre><code>gcc -<span class="keyword">include</span> stdio.<span class="literal">h</span>
</code></pre><p>和这句一样：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>
</code></pre><p><strong>-include</strong>是编译器特定的。</p>
<h2 id="统一的头文件">统一的头文件</h2><p>为了有用，头文件必须包含<strong>typedefs</strong>，宏定义和函数声明，且不应该包含没有不会使用的定义或声明。而现在的趋势是节省用户时间，将多个头文件包含进一个头文件。</p>
<h2 id="嵌入文档">嵌入文档</h2><p>嵌入文档是一个POSIX标准shell的特性，你可以用在C，Python，Perl或其他。</p>
<pre><code><span class="keyword">python</span> - &lt;&lt;<span class="string">"XXXX"</span>
lines=<span class="number">2</span>
<span class="keyword">print</span> <span class="string">"\nThis script is %i lines long.\n"</span> <span class="variable">%(</span>lines,)
XXXX
</code></pre><ul>
<li>嵌入文档是shell的标准特性，因此它应该能在任何POSIX系统上工作。</li>
<li>“XXXX”是任意你喜欢的字符串；”EOF”很流行，”—–”看起来不错只要顶部和底部的破折号数量相同既可以。当shell看到你选择的字符串为独立的一行，它将停止发送脚本到程序stdin。</li>
<li>有一个变体以&lt;&lt;-开始，它会删除没一行开头的所有tab字符。</li>
<li>作为另一个变体，&lt;&lt;XXXX和&lt;&lt;”XXXX”不同。前面那个可以插入$shell_variable。</li>
</ul>
<h2 id="从标准输入编译">从标准输入编译</h2><pre><code>go<span class="emphasis">_libs="-lm"
go_</span>flags="-g -Wall -include allheads.h -O3"
alias go<span class="emphasis">_c="c99 -xc - $go_</span>libs $go<span class="emphasis">_flags"
go_</span>c &lt;&lt; <span class="emphasis">'---'</span>
<span class="header">int main(){printf("Hello from the command line.\n");}
---</span>
./a.out
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="使用包管理器">使用包管理器</h1><p>必须获取的包：</p>
<ul>
<li>编译器。必须安装<strong>gcc</strong>；<strong>clang</strong>可能也有用。</li>
<li><strong>gdb</strong>，调]]>
    </summary>
    
      <category term="C/C++" scheme="https://opensvn.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第16章 模板和泛型编程]]></title>
    <link href="https://opensvn.github.io/2015/12/14/cpp_primer_16/"/>
    <id>https://opensvn.github.io/2015/12/14/cpp_primer_16/</id>
    <published>2015-12-14T02:34:42.000Z</published>
    <updated>2016-03-04T05:35:44.491Z</updated>
    <content type="html"><![CDATA[<p>面向对象编程和泛型编程都是处理程序编写时类型未知的情况。两者的区别是面向对象编程直到运行时类型才能知道，而泛型编程类型在编译期间知道。</p>
<p>容器，迭代器和算法都是泛型编程的例子。当编写一个泛型程序，我们用一种独立于任何类型的方式编写代码。当使用一个泛型程序，我们提供程序的实例将操作的类型或值。</p>
<p>模板是C++中泛型编程的基础。模板是一个创建类或函数的公式或蓝图。当我们使用一个泛型类型，我们提供将蓝图转换为指定类或函数所需的信息。这个转换发生在编译期间。</p>
<h1 id="16-1_定义一个模板">16.1 定义一个模板</h1><p>想象我们要写一个函数比较两个值的大小。实际中，我们要定义多个这样的函数，每一个比较指定类型的值。</p>
<pre><code><span class="comment">// returns 0 if the values are equal, -1 if v1 is smaller, 1 if v2 is smaller</span>
<span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;v1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;v2)</span>
</span>{
    <span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> -<span class="number">1</span>;
    <span class="keyword">if</span> (v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>;
    <span class="keyword">return</span> <span class="number">0</span>;
}
<span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> &amp;v1, <span class="keyword">const</span> <span class="keyword">double</span> &amp;v2)</span>
</span>{
    <span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> -<span class="number">1</span>;
    <span class="keyword">if</span> (v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>;
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>这样的函数几乎相同：唯一不同是参数的类型不同，每一个函数体都相同。</p>
<h2 id="16-1-1_函数模板">16.1.1 函数模板</h2><p>我们定义一个函数模板而不是为每一种类型定义一个新函数。一个函数模板是一个公式，从这个公式我们能够生成指定类型的函数。</p>
<pre><code><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T &amp;v2)</span>
</span>{
    <span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> -<span class="number">1</span>;
    <span class="keyword">if</span> (v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>;
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>模板定义开始于关键字<strong>template</strong>后面跟着模板参数列表。模板参数列表由&lt;&gt;括起来，逗号分隔的一个或多个模板参数组成。</p>
<blockquote>
<p><strong>注释</strong><br>在模板定义中，模板参数列表不能为空。</p>
</blockquote>
<p>模板参数列表的行为非常像函数的参数列表。模板参数表示用在类或函数定义中的类型或值。当我们使用一个模板，我们指定一个（隐式或显式）模板实参绑定到模板参数。</p>
<h3 id="实例化函数模板">实例化函数模板</h3><p>当我们调用一个函数模板，编译器使用函数调用的实参为我们推导模板实参。</p>
<pre><code><span class="built_in">cout</span> &lt;&lt; compare(<span class="number">1</span>, <span class="number">0</span>) &lt;&lt; endl;       <span class="comment">// T is int</span>
</code></pre><p>编译器使用推导的模板参数来为我们实例化指定版本的函数。当编译器实例化一个模板，它使用实际的模板实参创建一个新的模板实例代替相应的模板参数。</p>
<pre><code><span class="comment">// instantiates int compare(const int&amp;, const int&amp;)</span>
<span class="built_in">cout</span> &lt;&lt; compare(<span class="number">1</span>, <span class="number">0</span>) &lt;&lt; endl;       <span class="comment">// T is int</span>
<span class="comment">// instantiates int compare(const vector&lt;int&gt;&amp;, const vector&lt;int&gt;&amp;)</span>
<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec1{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}, vec2{<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>};
<span class="built_in">cout</span> &lt;&lt; compare(vec1, vec2) &lt;&lt; endl; <span class="comment">// T is vector&lt;int&gt;</span>
</code></pre><h3 id="模板类型参数">模板类型参数</h3><p>一般而言，我们可以和使用内置类型或类类型一样的方式使用类型参数作为类型说明符。特别地，类型参数可以用来命名一个返回类型，函数参数类型，变量声明或函数内类型转换。</p>
<pre><code><span class="comment">// ok: same type used for the return type and parameter</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">foo</span><span class="params">(T* p)</span>
</span>{
    T tmp = *p; <span class="comment">// tmp will have the type to which p points</span>
    <span class="comment">// ...</span>
    <span class="keyword">return</span> tmp;
}
</code></pre><p>每一个类型参数之前必须有<strong>class</strong>或<strong>typename</strong>关键字。</p>
<pre><code><span class="comment">// error: must precede U with either typename or class</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, U&gt; <span class="function">T <span class="title">calc</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> U&amp;)</span></span>;
</code></pre><p>使用关键字<strong>typename</strong>指定模板类型参数比<strong>class</strong>似乎更直观。毕竟我们可以使用内置（非类类型）类型作为模板的类型实参。而且<strong>typename</strong>更加清晰地指示了跟在它后面的名字是一个类型名。但是，<strong>typename</strong>是在模板广泛使用之后才被加入C++的。</p>
<h3 id="非类型模板参数">非类型模板参数</h3><p>除了定义类型参数，我们还能定义非类型的模板参数。一个非类型参数代表一个值而不是类型。非类型参数由一个指定的类型名指定而不是<strong>class</strong>或<strong>typename</strong>关键字。</p>
<p>当模板实例化时，非类型参数被用户提供的或编译器推导的一个值替换。这些值必须是常量表达式，以允许编译器在编译期间实例化模板。</p>
<pre><code>template&lt;unsigned <span class="keyword">N</span>, unsigned <span class="keyword">M</span>&gt;
int <span class="keyword">compare</span>(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1)[<span class="keyword">N</span>], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[<span class="keyword">M</span>])
{
    <span class="keyword">return</span> strcmp(p1, p2);
}

<span class="keyword">compare</span>(<span class="string">"hi"</span>, <span class="string">"mom"</span>)
int <span class="keyword">compare</span>(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1)[3], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[4])
</code></pre><p>一个非类型参数可能是整型，对象或函数的指针或（左值）引用。绑定到非类型的整型参数的实参必须是常量表达式。绑定到指针或引用的非类型参数必须拥有静态生命周期。不能使用普通（非静态）局部对象或动态分配的对象作为模板实参传给指针或引用的非类型模板参数。指针参数也能用<strong>nullptr</strong>或0值常量表达式初始化。</p>
<blockquote>
<p><strong>注释</strong><br>用于非类型模板参数的模板实参必须是常量表达式。</p>
</blockquote>
<h3 id="inline和constexpr函数模板">inline和constexpr函数模板</h3><p>和非模板函数一样，函数模板可以被声明为<strong>inline</strong>或<strong>constexpr</strong>。<strong>inline</strong>或<strong>constexpr</strong>限定符跟在模板参数列表之后，函数返回类型之前。</p>
<pre><code><span class="comment">// ok: inline specifier follows the template parameter list</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;
<span class="comment">// error: incorrect placement of the inline specifier</span>
<span class="keyword">inline</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;
</code></pre><h3 id="编写类型独立的代码">编写类型独立的代码</h3><p>尽管简单，compare函数展示了编写泛型代码的两个重要原则：</p>
<ul>
<li>模板中的函数参数是const引用</li>
<li>函数体中的比较只使用&lt;</li>
</ul>
<p>只使用&lt;运算符，我们降低了对使用compare函数的类型的要求。这些类型只需要支持&lt;，没有必要支持&gt;。实际上，如果我们真正关心类型独立和可移植性，我们可能应该使用<strong>less</strong>定义函数。</p>
<pre><code><span class="comment">// version of compare that will be correct even if used on pointers; see § 14.8.2 (p.</span>
<span class="number">575</span>)
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T &amp;v2)</span>
</span>{
    <span class="keyword">if</span> (less&lt;T&gt;()(v1, v2)) <span class="keyword">return</span> -<span class="number">1</span>;
    <span class="keyword">if</span> (less&lt;T&gt;()(v2, v1)) <span class="keyword">return</span> <span class="number">1</span>;
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><blockquote>
<p><strong>最佳实践</strong><br>模板程序应该尽量减少作用在参数类型的要求的数量。</p>
</blockquote>
<h3 id="模板编译">模板编译</h3><p>当编译器看到模板的定义，并没有生成代码。只有当实例化一个指定的模板实例的时候生成代码。只有使用模板时生成代码的事实影响我们如何组织源代码和如何检测错误。</p>
<p>通常当我们调用一个函数，编译器只需要看到函数的声明。类似地，当我们使用类对象，类定义必须可用，但是成员函数的定义不需要提供。因此，我们把类定义和函数声明放在头文件而普通函数和成员函数放在源文件。</p>
<p>模板不一样：为了生成一个模板实例，编译器需要定义函数模板或类模板成员函数的代码。因此不像非模板代码，模板头文件既包含了定义也包含了声明。</p>
<blockquote>
<p><strong>注释</strong><br>函数模板和类模板成员函数的定义通常放进头文件。</p>
<p><strong>关键概念：模板和头文件</strong><br>模板包含两种名字：</p>
<ul>
<li>那些不依赖模板参数的名字</li>
<li>那些依赖模板参数的名字</li>
</ul>
<p>由模板的提供者保证当模板使用时所有不依赖模板参数的名字可见。而且，模板的提供者必须保证当模板实例化的时候模板的定义，包括类模板成员的定义可见。由模板的用户保证用来实例化模板所有的函数，类型和类型相关的操作符可见。<br>模板的作者应该提供一个头文件，包含模板定义，连同所有类模板或成员定义中使用的名字的声明。模板用户必须包含模板头文件和任意用来实例化模板的类型。</p>
</blockquote>
<h3 id="实例化期间最常报的编译错误">实例化期间最常报的编译错误</h3><p>第一个阶段是编译模板自己的时候。编译器在这个阶段通常不能找到很多错误。编译器能查找出语法错误，比如忘记标点或变量拼写错误。</p>
<p>第二个阶段是编译器看到模板的使用的时候。这个阶段也没有很多需要检查。对于一个函数模板调用，编译器只是检查参数的个数是否合适。也可以检查两个类型应该一样的参数是否真的相同。对于类模板，编译器能检查正确的模板参数个数。</p>
<p>第三个阶段是实例化的时候。只有这个时候类型相关的错误才能被发现。取决于编译器如何处理实例化，这些错误可能会在链接时报告。</p>
<blockquote>
<p><strong>警告</strong><br>由调用者保证传递给模板的参数支持模板使用到的任意操作，且这些操作在模板使用的上下文环境表现正确。</p>
</blockquote>
<h2 id="16-1-2_类模板">16.1.2 类模板</h2><p>类模板是产生类的蓝图。和函数模板不同，编译器不能为类模板推导模板参数。因此为了使用类模板，我们必须在模板名字后面的尖括号里面提供额外的信息。这些信息就是用来代替模板参数的模板实参列表。</p>
<h3 id="定义一个类模板">定义一个类模板</h3><p>和函数模板一样，类模板以<strong>template</strong>关键字开头，后跟一个模板参数列表。在类模板（和它的成员）的定义中，我们使用模板参数作为当模板使用时提供的类型或值的替身。</p>
<pre><code><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> Blob {
<span class="keyword">public</span>:
    <span class="keyword">typedef</span> T value_type;
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;::size_type size_type;
    <span class="comment">// constructors</span>
    Blob();
    Blob(<span class="built_in">std</span>::initializer_list&lt;T&gt; il);
    <span class="comment">// number of elements in the Blob</span>
    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> data-&gt;size(); }
    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> data-&gt;empty(); }
    <span class="comment">// add and remove elements</span>
    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T &amp;t)</span> </span>{data-&gt;push_back(t);}
    <span class="comment">// move version; see § 13.6.3 (p. 548)</span>
    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T &amp;&amp;t)</span> </span>{ data-&gt;push_back(<span class="built_in">std</span>::move(t)); }
    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;
    <span class="comment">// element access</span>
    <span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;
    T&amp; <span class="keyword">operator</span>[](size_type i); <span class="comment">// defined in § 14.5 (p. 566)</span>
<span class="keyword">private</span>:
    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt; data;
    <span class="comment">// throws msg if data[i] isn't valid</span>
    <span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;msg)</span> <span class="keyword">const</span></span>;
};
</code></pre><h3 id="实例化一个类模板">实例化一个类模板</h3><p>当我们使用一个类模板时，必须提供额外的信息。这些额外的信息是显式模板实参列表。编译器使用这些模板实参来实例化一个指定类。</p>
<pre><code>Blob&lt;<span class="keyword">int</span>&gt; ia;                <span class="comment">// empty Blob&lt;int&gt;</span>
Blob&lt;<span class="keyword">int</span>&gt; ia2 = {<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>}; <span class="comment">// Blob&lt;int&gt; with five elements</span>

<span class="keyword">template</span> &lt;&gt; <span class="keyword">class</span> Blob&lt;<span class="keyword">int</span>&gt; {
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type size_type;
    Blob();
    Blob(<span class="built_in">std</span>::initializer_list&lt;<span class="keyword">int</span>&gt; il);
    <span class="comment">// ...</span>
    <span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](size_type i);
<span class="keyword">private</span>:
    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; data;
    <span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;msg)</span> <span class="keyword">const</span></span>;
};
</code></pre><p>当编译器从Blob模板实例化一个类时，它重写了Blob模板，用int替换掉每一个模板参数T。编译器为每一个我们指定的类型生成一个不同的类。</p>
<pre><code>// these definitions instantiate two <span class="keyword">distinct</span> <span class="type">Blob</span> types
<span class="type">Blob</span>&lt;<span class="type">string</span>&gt; names; // <span class="type">Blob</span> that holds strings
<span class="type">Blob</span>&lt;double&gt; prices;// different element <span class="keyword">type</span>
</code></pre><blockquote>
<p><strong>注释</strong><br>每一个类模板的实例化构成了一个独立的类。类型Blob<string>和任何其它的Blob类型没有关系，也没有任何特殊权限访问其它Blob类型的成员。</string></p>
</blockquote>
<h3 id="模板作用域中模板类型的引用">模板作用域中模板类型的引用</h3><p>类模板用来实例化一个类型，且被实例化的类型总是包含模板实参。类模板中的代码通常不使用实际类型（或值）的名字作为模板实参。相反，我们经常使用模板自己的参数作为模板实参。</p>
<pre><code><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt; data;
<span class="built_in">shared_ptr</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;
</code></pre><h3 id="类模板成员函数">类模板成员函数</h3><p>和任意其它类一样，我们能够在类里面或外面定义类模板的成员函数。定义在类里面的成员函数默认为<strong>inline</strong>。类模板成员函数本身是个普通函数。但是类模板每一个实例都拥有自己版本的成员。因此类模板的成员函数拥有和类模板相同的模板参数。所以定义在类模板外面的成员函数以关键字<strong>template</strong>开头，后接类模板参数列表。</p>
<pre><code>template &lt;typename <span class="constant">T</span>&gt;
ret-<span class="keyword">type</span> <span class="constant">Blob</span>&lt;<span class="constant">T</span>&gt;<span class="symbol">:</span><span class="symbol">:member-name</span>(parm-list)
</code></pre><h3 id="check和元素访问成员">check和元素访问成员</h3><pre><code><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="keyword">void</span> Blob&lt;T&gt;::check(size_type i, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;msg)
<span class="keyword">const</span>
{
    <span class="keyword">if</span> (i &gt;= data-&gt;size())
        <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(msg);
}

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
T&amp; Blob&lt;T&gt;::back()
{
    check(<span class="number">0</span>, <span class="string">"back on empty Blob"</span>);
    <span class="keyword">return</span> data-&gt;back();
}
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
T&amp; Blob&lt;T&gt;::<span class="keyword">operator</span>[](size_type i)
{
    <span class="comment">// if i is too big, check will throw, preventing access to a nonexistent element</span>
    check(i, <span class="string">"subscript out of range"</span>);
    <span class="keyword">return</span> (*data)[i];
}

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; 
<span class="keyword">void</span> Blob&lt;T&gt;::pop_back()
{
    check(<span class="number">0</span>, <span class="string">"pop_back on empty Blob"</span>);
    data-&gt;pop_back();
}
</code></pre><h3 id="Blob构造函数">Blob构造函数</h3><p>和其它定义在类模板外面的成员函数一样，构造函数以声明模板参数开始。</p>
<pre><code>template &lt;typename <span class="constant">T&gt;</span>
<span class="constant">Blob&lt;T&gt;</span><span class="symbol">:</span><span class="symbol">:Blob</span>()<span class="symbol">:</span> data(<span class="symbol">std:</span><span class="symbol">:make_shared&lt;std</span><span class="symbol">:</span><span class="symbol">:vector&lt;T&gt;&gt;</span>()) { }

template &lt;typename <span class="constant">T&gt;</span>
<span class="constant">Blob&lt;T&gt;</span><span class="symbol">:</span><span class="symbol">:Blob</span>(<span class="symbol">std:</span><span class="symbol">:initializer_list&lt;T&gt;</span> il)<span class="symbol">:</span>
              data(<span class="symbol">std:</span><span class="symbol">:make_shared&lt;std</span><span class="symbol">:</span><span class="symbol">:vector&lt;T&gt;&gt;</span>(il)) { }
</code></pre><h3 id="类模板成员函数实例化">类模板成员函数实例化</h3><p>默认地，类模板的成员函数只有在程序使用这个函数时实例化。</p>
<pre><code><span class="comment">// instantiates Blob&lt;int&gt; and the initializer_list&lt;int&gt; constructor</span>
Blob&lt;<span class="keyword">int</span>&gt; squares = {<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>};
<span class="comment">// instantiates Blob&lt;int&gt;::size() const</span>
<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != squares.size(); ++i)
    squares[i] = i*i; <span class="comment">// instantiates Blob&lt;int&gt;::operator[](size_t)</span>
</code></pre><p>成员只有在使用时实例化这个事实使我们可以用一个可能不满足某些模板操作要求的类型实例化一个类。</p>
<blockquote>
<p><strong>注释</strong><br>默认地，一个实例化的类模板的成员只有当成员使用时才实例化。</p>
</blockquote>
<h3 id="类代码里面简化模板类名的使用">类代码里面简化模板类名的使用</h3><p>使用一个类模板类型必须提供一个模板实参有一个例外，在类模板作用域里面，我们可以不带模板实参使用模板名字。</p>
<pre><code><span class="comment">// BlobPtr throws an exception on attempts to access a nonexistent element</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> BlobPtr {
<span class="keyword">public</span>:
    BlobPtr(): curr(<span class="number">0</span>) { }
    BlobPtr(Blob&lt;T&gt; &amp;a, <span class="keyword">size_t</span> sz = <span class="number">0</span>):
            wptr(a.data), curr(sz) { }
    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>
    { <span class="keyword">auto</span> p = check(curr, <span class="string">"dereference past end"</span>);
      <span class="keyword">return</span> (*p)[curr];  <span class="comment">// (*p) is the vector to which this object points</span>
    }
    <span class="comment">// increment and decrement</span>
    BlobPtr&amp; <span class="keyword">operator</span>++();        <span class="comment">// prefix operators</span>
    BlobPtr&amp; <span class="keyword">operator</span>--();
<span class="keyword">private</span>:
    <span class="comment">// check returns a shared_ptr to the vector if the check succeeds</span>
    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt;
        check(<span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;) <span class="keyword">const</span>;
    <span class="comment">// store a weak_ptr, which means the underlying vector might be destroyed</span>
    <span class="built_in">std</span>::weak_ptr&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt; wptr;
    <span class="built_in">std</span>::<span class="keyword">size_t</span> curr;      <span class="comment">// current position within the array</span>
};
</code></pre><h3 id="在类模板外面使用类模板名字">在类模板外面使用类模板名字</h3><p>当我们在类模板外面定义成员时，必须记住我们不在类的作用域直到类名被看见。</p>
<pre><code>// postfix: increment/decrement the object but<span class="instruction"> return </span>the unchanged value
template &lt;typename T&gt;
BlobPtr&lt;T&gt;<span class="function"> BlobPtr&lt;T&gt;::operator++(</span>int<span class="function">)</span>
{
    // no<span class="instruction"> check </span>needed here; the call to prefix increment will do the<span class="instruction"> check
</span>    BlobPtr ret = *this;  // save the current value
    ++*this;    // advance one element; prefix ++ checks the increment
   <span class="instruction"> return </span>ret;  //<span class="instruction"> return </span>the saved state
}
</code></pre><p>当我们没有提供模板实参，编译器假设我们使用成员实例化一样的类型。因此，ret的定义就好像：</p>
<pre><code>BlobPtr<span class="variable">&lt;T&gt;</span> ret = <span class="keyword">*</span>this;
</code></pre><blockquote>
<p><strong>注释</strong><br>在类模板作用域里面，我们可以使用模板，而不指定模板实参。</p>
</blockquote>
<h3 id="类模板和友元">类模板和友元</h3><p>当一个类包含友元声明时，类和友元各自可以是模板或非模板。一个有非模板的友元的类模板授予其友元访问模板所有实例。当友元本身也是模板时，授予友元关系的类控制友元模板所有实例或指定实例友元关系。</p>
<h3 id="一对一友元关系">一对一友元关系</h3><p>从一个类模板到另一个模板（类模板或函数模板）建立相应实例之间的友元关系是最常见友元关系形式。为了引用一个指定的模板实例（类模板或函数模板），我们必须先声明模板。一个模板声明包含模板参数列表。</p>
<pre><code><span class="comment">// forward declarations needed for friend declarations in Blob</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> BlobPtr;
<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> Blob; <span class="comment">// needed for parameters in operator==</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Blob&lt;T&gt;&amp;, <span class="keyword">const</span> Blob&lt;T&gt;&amp;);
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> Blob {
    <span class="comment">// each instantiation of Blob grants access to the version of</span>
    <span class="comment">// BlobPtr and the equality operator instantiated with the same type</span>
    <span class="keyword">friend</span> <span class="keyword">class</span> BlobPtr&lt;T&gt;;
    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==&lt;T&gt;
           (<span class="keyword">const</span> Blob&lt;T&gt;&amp;, <span class="keyword">const</span> Blob&lt;T&gt;&amp;);
    <span class="comment">// other members as in § 12.1.1 (p. 456)</span>
};

Blob&lt;<span class="keyword">char</span>&gt; ca; <span class="comment">// BlobPtr&lt;char&gt; and operator==&lt;char&gt; are friends</span>
Blob&lt;<span class="keyword">int</span>&gt; ia;  <span class="comment">// BlobPtr&lt;int&gt; and operator==&lt;int&gt; are friends</span>
</code></pre><h3 id="通用和指定模板友元">通用和指定模板友元</h3><p>一个类也可以指定另一个模板的每一个实例为友元，或限制指定实例为友元：</p>
<pre><code><span class="comment">// forward declaration necessary to befriend a specific instantiation of a template</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> Pal;
<span class="keyword">class</span> C {  <span class="comment">//  C is an ordinary, nontemplate class</span>
    <span class="keyword">friend</span> <span class="keyword">class</span> Pal&lt;C&gt;;  <span class="comment">// Pal instantiated with class C is a friend to C</span>
    <span class="comment">// all instances of Pal2 are friends to C;</span>
    <span class="comment">// no forward declaration required when we befriend all instantiations</span>
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">friend</span> <span class="keyword">class</span> Pal2;
};
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> C2 { <span class="comment">// C2 is itself a class template</span>
    <span class="comment">// each instantiation of C2 has the same instance of Pal as a friend</span>
    <span class="keyword">friend</span> <span class="keyword">class</span> Pal&lt;T&gt;;  <span class="comment">// a template declaration for Pal must be in scope</span>
    <span class="comment">// all instances of Pal2 are friends of each instance of C2, prior declaration needed</span>
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt; <span class="keyword">friend</span> <span class="keyword">class</span> Pal2;
    <span class="comment">// Pal3 is a nontemplate class that is a friend of every instance of C2</span>
    <span class="keyword">friend</span> <span class="keyword">class</span> Pal3;    <span class="comment">// prior declaration for Pal3 not needed</span>
};
</code></pre><p>为了允许所有的实例都是友元，友元声明必须使用跟类不一样的模板参数。</p>
<h3 id="模板类型参数作为友元">模板类型参数作为友元</h3><p>在新标准下，我们可以将模板类型参数作为友元：</p>
<pre><code><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; <span class="keyword">class</span> Bar {
<span class="keyword">friend</span> Type; <span class="comment">// grants access to the type used to instantiate Bar</span>
    <span class="comment">//  ...</span>
};
</code></pre><p>值得注意的是尽管友元通常必须是一个类或函数，用内置类型实例化类Bar也可以，因此友元为内置类型在这种情况也允许。</p>
<h3 id="模板类型别名">模板类型别名</h3><p>类模板的一个实例定义了一个类类型，和其它类类型一样，我们可以使用<strong>typedef</strong>引用它：</p>
<pre><code><span class="keyword">typedef</span> Blob&lt;<span class="built_in">string</span>&gt; StrBlob;
</code></pre><p>因为模板不是一个类型，我们不能使用<strong>typedef</strong>引用一个模板，即没有办法用<strong>typedef</strong>引用Blob<t>。但是新标准允许我们为类模板定义一个类型别名：</t></p>
<pre><code><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> twin = pair&lt;T, T&gt;;
twin&lt;<span class="built_in">string</span>&gt; authors; <span class="comment">// authors is a pair&lt;string, string&gt;</span>
</code></pre><p>模板类型别名是一个类家庭的同义词：</p>
<pre><code>twin&lt;<span class="keyword">int</span>&gt; win_loss;  <span class="comment">// win_loss is a pair&lt;int, int&gt;</span>
twin&lt;<span class="keyword">double</span>&gt; area;   <span class="comment">// area is a pair&lt;double, double&gt;</span>
</code></pre><p>当我们定义一个模板类型别名，我们可以固定一个或多个模板参数：</p>
<pre><code><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> partNo = pair&lt;T, <span class="keyword">unsigned</span>&gt;;
partNo&lt;<span class="built_in">string</span>&gt; books;  <span class="comment">// books is a pair&lt;string, unsigned&gt;</span>
partNo&lt;Vehicle&gt; cars;  <span class="comment">// cars is a pair&lt;Vehicle, unsigned&gt;</span>
partNo&lt;Student&gt; kids;  <span class="comment">// kids is a pair&lt;Student, unsigned&gt;</span>
</code></pre><h3 id="类模板的静态成员">类模板的静态成员</h3><p>和其它类一样，类模板可以声明静态成员：</p>
<pre><code><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> Foo {
<span class="keyword">public</span>:
   <span class="keyword">static</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> count() { <span class="keyword">return</span> ctr; }
   <span class="comment">// other interface members</span>
<span class="keyword">private</span>:
   <span class="keyword">static</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> ctr;
   <span class="comment">// other implementation members</span>
};
</code></pre><p>每一个Foo的实例都有自己静态成员。</p>
<pre><code>// instantiates <span class="keyword">static</span> members Foo&lt;<span class="built_in">string</span>&gt;::ctr <span class="literal">and</span> Foo&lt;<span class="built_in">string</span>&gt;::count
Foo&lt;<span class="built_in">string</span>&gt; fs<span class="comment">;</span>
// all three objects share the same Foo&lt;<span class="built_in">int</span>&gt;::ctr <span class="literal">and</span> Foo&lt;<span class="built_in">int</span>&gt;::count members
Foo&lt;<span class="built_in">int</span>&gt; fi, fi2, fi3<span class="comment">;</span>
</code></pre><p>和其它静态数据成员一样，类模板的每一个静态数据成员必须只有一个定义。</p>
<pre><code><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="keyword">size_t</span> Foo&lt;T&gt;::ctr = <span class="number">0</span>; <span class="comment">// define and initialize ctr</span>
</code></pre><p>必须引用指定的实例来访问静态成员。</p>
<pre><code>Foo&lt;<span class="built_in">int</span>&gt; fi;                 // instantiates Foo&lt;<span class="built_in">int</span>&gt; <span class="keyword">class</span>
                             // and the static <span class="type">data</span> member ctr
auto ct = Foo&lt;<span class="built_in">int</span>&gt;::<span class="built_in">count</span>(); // instantiates Foo&lt;<span class="built_in">int</span>&gt;::<span class="built_in">count</span>
ct = fi.<span class="built_in">count</span>();             // uses Foo&lt;<span class="built_in">int</span>&gt;::<span class="built_in">count</span>
ct = Foo::<span class="built_in">count</span>();           // error: which template instantiation?
</code></pre><p>和其它成员函数一样，静态成员函数只有在程序中使用时才实例化。</p>
<h2 id="16-1-3_模板参数">16.1.3 模板参数</h2><p>和函数参数的名字一样，模板参数的名字没有实质意义。我们通常命名类型参数为T，也可以使用任何名字：</p>
<pre><code><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Foo&gt; <span class="function">Foo <span class="title">calc</span><span class="params">(<span class="keyword">const</span> Foo&amp; a, <span class="keyword">const</span> Foo&amp; b)</span>
</span>{
    Foo tmp = a; <span class="comment">// tmp has the same type as the parameters and return type</span>
    <span class="comment">// ...</span>
    <span class="keyword">return</span> tmp;  <span class="comment">// return type and parameters have the same type</span>
}
</code></pre><h3 id="模板参数和作用域">模板参数和作用域</h3><p>模板参数遵循正常的作用域规则。模板参数的名字在声明之后直到模板声明或定义结束之前都能使用。和其它名字一样，模板参数名隐藏任何外围声明的名字。但是一个被用来作为模板参数的名字在模板内不能被重复使用。</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">double</span> A;
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A a, B b)</span>
</span>{
    A tmp = a; <span class="comment">// tmp has same type as the template parameter A, not double</span>
    <span class="keyword">double</span> B;  <span class="comment">// error: redeclares template parameter B</span>
}
</code></pre><p>因为模板参数名不能重复使用，模板参数列表中的每一个模板参数名只能出现一次：</p>
<pre><code><span class="comment">// error: illegal reuse of template parameter name V</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> V, <span class="keyword">typename</span> V&gt; <span class="comment">// ...</span>
</code></pre><h3 id="模板声明">模板声明</h3><p>模板声明必须包含模板参数：</p>
<pre><code><span class="comment">// declares but does not define compare and Blob</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> Blob;
</code></pre><p>和函数参数一样，模板参数名不需要和定义中的模板参数名一样：</p>
<pre><code><span class="comment">// all three uses of calc refer to the same function template</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">calc</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>; <span class="comment">// declaration</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="function">U <span class="title">calc</span><span class="params">(<span class="keyword">const</span> U&amp;, <span class="keyword">const</span> U&amp;)</span></span>; <span class="comment">// declaration</span>
<span class="comment">// definition of the template</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;
<span class="function">Type <span class="title">calc</span><span class="params">(<span class="keyword">const</span> Type&amp; a, <span class="keyword">const</span> Type&amp; b)</span> </span>{ <span class="comment">/* . . . */</span> }
</code></pre><p>当然，模板的每一个声明和定义参数的数量和种类（类型或非类型）必须一样。</p>
<blockquote>
<p><strong>最佳实践</strong><br>一个文件需要的所有模板的声明通常应该一起出现在文件开头，在任何代码使用这些名字之前。</p>
</blockquote>
<h3 id="使用为类型的类成员">使用为类型的类成员</h3><p>我们可以使用作用域操作符（::）访问<strong>static</strong>成员和类型成员。假设T是一个模板类型参数，当编译器看到T::mem时，在实例化前它不知道mem是一个类型还是静态数据成员。但是为了处理模板，编译器必须知道一个名字是否代表类型。比如下面这个例子：</p>
<pre><code><span class="rule"><span class="attribute">T</span>:<span class="value">:size_type * p</span></span>;
</code></pre><p>编译器需要知道这是定义一个变量p还是静态数据成员与p相乘。语言默认假设通过作用域操作符访问的名字不是一个类型。因此如果我们想要使用模板类型参数的类型成员，我们必须显式告诉编译器这个名字是一个类型。我们使用关键字<strong>typename</strong>来做这件事：</p>
<pre><code><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="keyword">typename</span> T::<span class="function">value_type <span class="title">top</span><span class="params">(<span class="keyword">const</span> T&amp; c)</span>
</span>{
    <span class="keyword">if</span> (!c.empty())
        <span class="keyword">return</span> c.back();
    <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="keyword">typename</span> T::value_type();
}
</code></pre><blockquote>
<p><strong>注释</strong><br>当我们通知编译器一个名字代表类型时，必须使用关键字<strong>typename</strong>，而不是<strong>class</strong>。</p>
</blockquote>
<h3 id="默认模板实参">默认模板实参</h3><p>就像我们能够给函数参数提供默认实参，我们也能提供默认模板实参。新标准下，我们能给函数模板和类模板提供默认实参。早先的版本只允许类模板有默认实参。</p>
<pre><code>// compare has a default <span class="keyword">template</span> argument, less&lt;T&gt;
// <span class="keyword">and</span> a default function argument, F()
<span class="keyword">template</span> &lt;typename T, typename F = less&lt;T&gt;&gt;
<span class="type">int</span> compare(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T &amp;v2, F f = F())
{
    <span class="keyword">if</span> (f(v1, v2)) <span class="keyword">return</span> -<span class="number">1</span>;
    <span class="keyword">if</span> (f(v2, v1)) <span class="keyword">return</span> <span class="number">1</span>;
    <span class="keyword">return</span> <span class="number">0</span>;
}

<span class="type">bool</span> i = compare(<span class="number">0</span>, <span class="number">42</span>); // uses less; i <span class="keyword">is</span> -<span class="number">1</span>
// <span class="literal">result</span> depends on the isbns <span class="keyword">in</span> item1 <span class="keyword">and</span> item2
<span class="type">Sales_data</span> item1(cin), item2(cin);
<span class="type">bool</span> j = compare(item1, item2, compareIsbn);
</code></pre><h3 id="模板默认实参和类模板">模板默认实参和类模板</h3><p>不管什么时候使用类模板，我们必须在模板名后面跟尖括号。尖括号指示类必须从模板实例化。特别地，如果一个类模板为所有模板参数提供了默认实参，且我们使用这些默认值，我们必须在模板名后面放一对空的尖括号：</p>
<pre><code>template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>= <span class="keyword">int</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Numbers</span> </span>{   <span class="comment">// by default T is int</span>
<span class="keyword">public</span>:
    Numbers(T v = 0): val(v) { }
    <span class="comment">// various operations on numbers</span>
<span class="keyword">private</span>:
    T val;
};
Numbers&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; lots_of_precision;
Numbers&lt;&gt; average_precision; <span class="comment">// empty &lt;&gt; says we want the default type</span>
</code></pre><h2 id="16-1-4_成员模板">16.1.4 成员模板</h2><p>一个类（不管是普通类还是类模板）可能有本身是模板的成员函数。这种成员被称为成员模板。成员模板不能是虚函数。</p>
<h3 id="普通类的成员模板">普通类的成员模板</h3><pre><code><span class="comment">// function-object class that calls delete on a given pointer</span>
<span class="keyword">class</span> DebugDelete {
<span class="keyword">public</span>:
    DebugDelete(<span class="built_in">std</span>::ostream &amp;s = <span class="built_in">std</span>::<span class="built_in">cerr</span>): os(s) { }
    <span class="comment">// as with any function template, the type of T is deduced by the compiler</span>
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *p)</span> <span class="keyword">const</span>
      </span>{ os &lt;&lt; <span class="string">"deleting unique_ptr"</span> &lt;&lt; <span class="built_in">std</span>::endl; <span class="keyword">delete</span> p;
}
<span class="keyword">private</span>:
    <span class="built_in">std</span>::ostream &amp;os;
};
</code></pre><p>和其他模板一样，一个成员模板以它自己的模板参数列表开始。</p>
<pre><code><span class="keyword">double</span>* p = <span class="keyword">new</span> <span class="keyword">double</span>;
DebugDelete d;    <span class="comment">// an object that can act like a delete expression</span>
d(p); <span class="comment">// calls DebugDelete::operator()(double*), which deletes p</span>
<span class="keyword">int</span>* ip = <span class="keyword">new</span> <span class="keyword">int</span>;
<span class="comment">// calls operator()(int*) on a temporary DebugDelete object</span>
DebugDelete()(ip);

<span class="comment">// destroying the the object to which p points</span>
<span class="comment">// instantiates DebugDelete::operator()&lt;int&gt;(int *)</span>
unique_ptr&lt;<span class="keyword">int</span>, DebugDelete&gt; p(<span class="keyword">new</span> <span class="keyword">int</span>, DebugDelete());
<span class="comment">// destroying the the object to which sp points</span>
<span class="comment">// instantiates DebugDelete::operator()&lt;string&gt;(string*)</span>
unique_ptr&lt;<span class="built_in">string</span>,DebugDelete&gt; sp(<span class="keyword">new</span> <span class="built_in">string</span>, DebugDelete());
</code></pre><p><strong>unique_ptr</strong>的析构函数会调用DebugDelete的调用操作符。因此，当<strong>unique_ptr</strong>析构函数实例化时，DebugDelete的调用操作符也会实例化。</p>
<pre><code><span class="comment">// sample instantiations for member templates of DebugDelete</span>
<span class="keyword">void</span> DebugDelete::<span class="keyword">operator</span>()(<span class="keyword">int</span> *p) <span class="keyword">const</span> { <span class="keyword">delete</span> p; }
<span class="keyword">void</span> DebugDelete::<span class="keyword">operator</span>()(<span class="built_in">string</span> *p) <span class="keyword">const</span> { <span class="keyword">delete</span> p; }
</code></pre><h3 id="类模板的成员模板">类模板的成员模板</h3><p>我们也可以定义一个类模板的成员模板。这种情况下，类和成员都有它们自己的独立的模板参数。</p>
<pre><code><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> Blob {
    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt; Blob(It b, It e);
    <span class="comment">// ...</span>
};
</code></pre><p>不同于类模板的普通函数成员，成员模板是函数模板。当我们在类模板外面定义一个成员模板，我们必须为类模板和函数模板提供模板参数列表。类模板参数列表在前，后面跟成员模板参数列表：</p>
<pre><code>template &lt;typename <span class="constant">T</span>&gt;     <span class="regexp">//</span> <span class="keyword">type</span> parameter <span class="keyword">for</span> the <span class="class"><span class="keyword">class</span></span>
template &lt;typename <span class="constant">It</span>&gt;    <span class="regexp">//</span> <span class="keyword">type</span> parameter <span class="keyword">for</span> the constructor
    <span class="constant">Blob</span>&lt;<span class="constant">T</span>&gt;<span class="constant">::Blob</span>(<span class="constant">It</span> b, <span class="constant">It</span> e)<span class="symbol">:</span>
              data(<span class="symbol">std:</span><span class="symbol">:make_shared&lt;std</span><span class="symbol">:</span><span class="symbol">:vector&lt;T&gt;&gt;</span>(b, e)) {
}
</code></pre><h3 id="成员模板的实例化">成员模板的实例化</h3><p>为了实例化一个类模板的成员模板，我们必须为类模板和成员模板的模板参数提供实参。和以前一样，类模板参数的实参由调用成员模板的对象类型决定。同样，编译器通过传递给成员模板的实参推导出成员模板参数的实参。</p>
<pre><code><span class="keyword">int</span> ia[] = {<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>};
<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; vi = {<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>};
<span class="built_in">list</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; w = {<span class="string">"now"</span>, <span class="string">"is"</span>, <span class="string">"the"</span>, <span class="string">"time"</span>};
<span class="comment">// instantiates the Blob&lt;int&gt; class</span>
<span class="comment">// and the Blob&lt;int&gt; constructor that has two int* parameters</span>
Blob&lt;<span class="keyword">int</span>&gt; a1(begin(ia), end(ia));
<span class="comment">// instantiates the Blob&lt;int&gt; constructor that has</span>
<span class="comment">// two vector&lt;long&gt;::iterator parameters</span>
Blob&lt;<span class="keyword">int</span>&gt; a2(vi.begin(), vi.end());
<span class="comment">// instantiates the Blob&lt;string&gt; class and the Blob&lt;string&gt;</span>
<span class="comment">// constructor that has two (list&lt;const char*&gt;::iterator parameters</span>
Blob&lt;<span class="built_in">string</span>&gt; a3(w.begin(), w.end());
</code></pre><h2 id="16-1-5_控制实例化">16.1.5 控制实例化</h2><p>当模板被使用时才生成实例意味着同一个实例可能出现在多个对象文件。当两个或更多单独编译的源文件用相同的模板实参使用同一个模板时，在每一个文件中有一个模板实例。</p>
<p>在大型系统中，在多个文件中实例化同一个模板的开销将变得非常明显。在新标准下，我们可以使用显式实例化避免这种开销。显式实例化具有形式：</p>
<pre><code><span class="keyword">extern</span> <span class="keyword">template</span> declaration; <span class="comment">// instantiation declaration</span>
<span class="keyword">template</span> declaration;        <span class="comment">// instantiation definition</span>
</code></pre><p>declaration是一个类或函数声明，其模板参数被模板实参替换。</p>
<pre><code><span class="comment">// instantion declaration and definition</span>
<span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> Blob&lt;<span class="built_in">string</span>&gt;;             <span class="comment">// declaration</span>
<span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;   <span class="comment">// definition</span>
</code></pre><p>当编译器看到一个<strong>extern</strong>模板声明，它不会在那个文件生成实例化代码。将一个模板实例声明为<strong>extern</strong>承诺程序的其它地方存在一个<strong>nonextern</strong>的实例。对于一个指定的实例可以有多个<strong>extern</strong>声明但是只能存在一个实例的定义。</p>
<p>因为编译器使用模板时自动实例化，<strong>extern</strong>声明必须出现在任何使用实例的代码之前：</p>
<pre><code><span class="comment">// Application.cc</span>
<span class="comment">// these template types must be instantiated elsewhere in the program</span>
<span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> Blob&lt;<span class="built_in">string</span>&gt;;
<span class="function"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;)</span></span>;
Blob&lt;<span class="built_in">string</span>&gt; sa1, sa2; <span class="comment">// instantiation will appear elsewhere</span>
<span class="comment">// Blob&lt;int&gt; and its initializer_list constructor instantiated in this file</span>
Blob&lt;<span class="keyword">int</span>&gt; a1 = {<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>};
Blob&lt;<span class="keyword">int</span>&gt; a2(a1);  <span class="comment">// copy constructor instantiated in this file</span>
<span class="keyword">int</span> i = compare(a1[<span class="number">0</span>], a2[<span class="number">0</span>]); <span class="comment">// instantiation will appear elsewhere定义</span>
</code></pre><blockquote>
<p><strong>警告</strong><br>对于每一个实例声明，在程序的其它地方必须有一个显式实例定义。</p>
</blockquote>
<h3 id="实例定义实例化所有成员">实例定义实例化所有成员</h3><p>一个类模板的实例定义实例化其所有成员包括内联成员函数。当编译器看到一个实例定义，它不知道哪一个成员函数会被用到，因此编译器实例化所有成员。</p>
<blockquote>
<p><strong>注释</strong><br>实例定义只能用在类模板所有成员函数都能使用的类型。</p>
</blockquote>
<h2 id="16-1-6_效率和灵活性">16.1.6 效率和灵活性</h2><p>标准库的智能指针提供了一个关于模板设计者面临的设计选择的很好说明。</p>
<h1 id="16-2_模板实参推导">16.2 模板实参推导</h1><p>在模板实参推导期间，编译器使用实参的类型查找模板参数并生成最符合的函数。</p>
<h2 id="16-2-1_转换和模板类型参数">16.2.1 转换和模板类型参数</h2><p>使用模板类型参数的函数参数具有特殊的初始化规则。只有非常有限数量的转换被自动应用到这种参数。编译器生成一个新的实例而不是转换实参。</p>
<p>和以往一样，不管是形参还是实参的上层const都被忽略。在一个函数模板调用中执行的唯一其它转换有：</p>
<ul>
<li>const转换：引用（或指针）const对象的函数参数可以传递引用（或指针）非const对象。</li>
<li>数组到指针或函数到指针的转换：如果函数参数不是引用类型，则普通指针转换将被应用到参数为数组或函数类型上。数组参数被转换为指向第一个元素的指针。类似地，函数参数被转换为指向函数类型的指针。</li>
</ul>
<p>其它转换比如算术转换，派生类到基类转换和用户自定义的转换都不会执行。</p>
<pre><code><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">fobj</span><span class="params">(T, T)</span></span>; <span class="comment">// arguments are copied</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">fref</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>; <span class="comment">// references</span>
<span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"a value"</span>)</span></span>;
<span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">"another value"</span>)</span></span>;
fobj(s1, s2); <span class="comment">// calls fobj(string, string); const is ignored</span>
fref(s1, s2); <span class="comment">// calls fref(const string&amp;, const string&amp;)</span>
              <span class="comment">// uses premissible conversion to const on s1</span>
<span class="keyword">int</span> a[<span class="number">10</span>], b[<span class="number">42</span>];
fobj(a, b); <span class="comment">// calls f(int*, int*)</span>
fref(a, b); <span class="comment">// error: array types don't match</span>
</code></pre><blockquote>
<p><strong>注释</strong><br>const转换和数组或函数到指针的转换是模板类型唯一的实参到形参自动转换。</p>
</blockquote>
<h3 id="使用相同模板参数类型的函数参数">使用相同模板参数类型的函数参数</h3><p>一个模板类型参数可以被多个函数参数使用。因为转换非常有限，这种参数的实参必须具有一样的类型。如果推导的参数类型不匹配，那么调用出错。</p>
<pre><code><span class="keyword">long</span> lng;
compare(lng, <span class="number">1024</span>); <span class="comment">// error: cannot instantiate compare(long, int)</span>

<span class="comment">// argument types can differ but must be compatible</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;
<span class="function"><span class="keyword">int</span> <span class="title">flexibleCompare</span><span class="params">(<span class="keyword">const</span> A&amp; v1, <span class="keyword">const</span> B&amp; v2)</span>
</span>{
    <span class="keyword">if</span> (v1 &lt; v2) <span class="keyword">return</span> -<span class="number">1</span>;
    <span class="keyword">if</span> (v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>;
    <span class="keyword">return</span> <span class="number">0</span>;
}
<span class="keyword">long</span> lng;
flexibleCompare(lng, <span class="number">1024</span>); <span class="comment">// ok: calls flexibleCompare(long, int)</span>
</code></pre><h3 id="应用到普通实参的正常转换">应用到普通实参的正常转换</h3><p>函数模板可以有普通类型的参数，就是与模板类型参数无关的参数。这些参数不需要特殊处理，它们的转换规则和以前一样。</p>
<pre><code><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T
&amp;obj)</span>
</span>{
    <span class="keyword">return</span> os &lt;&lt; obj;
}
print(<span class="built_in">cout</span>, <span class="number">42</span>); <span class="comment">// instantiates print(ostream&amp;, int)</span>
<span class="function">ofstream <span class="title">f</span><span class="params">(<span class="string">"output"</span>)</span></span>;
print(f, <span class="number">10</span>);    <span class="comment">// uses print(ostream&amp;, int); converts f to ostream&amp;</span>
</code></pre><h2 id="16-2-2_函数模板显式参数">16.2.2 函数模板显式参数</h2><p>在某些情况下，编译器不可能推导出模板参数的类型。另一些情况，我们想要允许用户控制模板实例化。当一个函数返回类型不同于参数列表中的类型时，这两种情况经常出现。</p>
<h3 id="指定一个显式模板参数">指定一个显式模板参数</h3><pre><code><span class="comment">// T1 cannot be deduced: it doesn't appear in the function parameter list</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;
<span class="function">T1 <span class="title">sum</span><span class="params">(T2, T3)</span></span>;
</code></pre><p>这个例子中，没有用来推导T1类型的实参，调用者必须提供一个显式模板实参。我们可以像定义类模板实例那样，给一个函数调用提供显式模板实参。显式模板实参在尖括号中指定，在函数名之后，参数列表之前：</p>
<pre><code><span class="comment">// T1 is explicitly specified; T2 and T3 are inferred from the argument types</span>
auto val3 = <span class="keyword">sum</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(i, lng); <span class="comment">// long long sum(int, long)</span>
</code></pre><p>显式模板实参从左到右匹配相应的模板参数，</p>
<pre><code><span class="comment">// poor design: users must explicitly specify all three template parameters</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;
<span class="function">T3 <span class="title">alternative_sum</span><span class="params">(T2, T1)</span></span>;

<span class="comment">// error: can't infer initial template parameters</span>
<span class="keyword">auto</span> val3 = alternative_sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(i, lng);
<span class="comment">// ok: all three parameters are explicitly specified</span>
<span class="keyword">auto</span> val2 = alternative_sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>, <span class="keyword">long</span>&gt;(i, lng);
</code></pre><h3 id="显式指定参数应用普通转换">显式指定参数应用普通转换</h3><p>和普通类型参数允许普通转换的原因一样，显式指定参数也可以应用其实参的普通转换：</p>
<pre><code><span class="keyword">long</span> lng;
compare(lng, <span class="number">1024</span>);       <span class="comment">// error: template parameters don't match</span>
compare&lt;<span class="keyword">long</span>&gt;(lng, <span class="number">1024</span>); <span class="comment">// ok: instantiates compare(long, long)</span>
compare&lt;<span class="keyword">int</span>&gt;(lng, <span class="number">1024</span>);  <span class="comment">// ok: instantiates compare(int, int)</span>
</code></pre><h2 id="16-2-3_尾返回类型和类型转换">16.2.3 尾返回类型和类型转换</h2><p>使用显式模板参数来表示模板函数的返回类型工作得很好。另外一些情况下，需要有一个显式模板参数给用户强加了负担。</p>
<pre><code><span class="keyword">template</span> &lt;typename It&gt;
??? &amp;fcn(It beg, It end)
{
    <span class="comment">// process the range</span>
    <span class="keyword">return</span> *beg;  <span class="comment">// return a reference to an element from the range</span>
}

vector&lt;<span class="keyword">int</span>&gt; vi = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};
Blob&lt;<span class="built_in">string</span>&gt; ca = { <span class="string">"hi"</span>, <span class="string">"bye"</span> };
<span class="keyword">auto</span> &amp;i = fcn(vi.begin(), vi.end()); <span class="comment">// fcn should return int&amp;</span>
<span class="keyword">auto</span> &amp;s = fcn(ca.begin(), ca.end()); <span class="comment">// fcn should return string&amp;</span>

<span class="comment">// a trailing return lets us declare the return type after the parameter list is seen</span>
<span class="keyword">template</span> &lt;typename It&gt;
<span class="keyword">auto</span> fcn(It beg, It end) -&gt; decltype(*beg)
{
    <span class="comment">// process the range</span>
    <span class="keyword">return</span> *beg;  <span class="comment">// return a reference to an element from the range</span>
}
</code></pre><h3 id="类型转换标准库模板类">类型转换标准库模板类</h3><p>有时候我们不能直接访问到我们需要的类型。比如我们可能想要写一个类似fcn的函数返回一个元素的值而不是引用。编写这样的函数我们面临的问题是我们几乎不了解我们传递的参数类型。为了获取元素类型，我们可以使用库类型转换模板。这些模板定义在<strong>type_traits</strong>头文件。通常头文件<strong>type_traits</strong>中的类被用来所谓的元编程。</p>
<table>
<thead>
<tr>
<th>For Mod&lt;T&gt;, Mod is</th>
<th style="text-align:left">If T is</th>
<th style="text-align:left">Then Mod&lt;T&gt;::type is</th>
</tr>
</thead>
<tbody>
<tr>
<td>remove_reference</td>
<td style="text-align:left">X&amp; or X&amp;&amp;<br>otherwise</td>
<td style="text-align:left">X<br>T</td>
</tr>
<tr>
<td>add_const</td>
<td style="text-align:left">X&amp;, const X, or function<br>otherwise</td>
<td style="text-align:left">T<br>const T</td>
</tr>
<tr>
<td>add_lvalue_reference</td>
<td style="text-align:left">X&amp;<br>X&amp;&amp;<br>otherwise</td>
<td style="text-align:left">T<br>X&amp;<br>T&amp;</td>
</tr>
<tr>
<td>add_rvalue_reference</td>
<td style="text-align:left">X&amp; or X&amp;&amp;<br>otherwise</td>
<td style="text-align:left">T<br>T&amp;&amp;</td>
</tr>
<tr>
<td>remove_pointer</td>
<td style="text-align:left">X*<br>otherwise</td>
<td style="text-align:left">X<br>const T</td>
</tr>
<tr>
<td>add_pointer</td>
<td style="text-align:left">X&amp; or X&amp;&amp;<br>otherwise</td>
<td style="text-align:left">X*<br>T*</td>
</tr>
<tr>
<td>make_signed</td>
<td style="text-align:left">unsigned X<br>otherwise</td>
<td style="text-align:left">X<br>T</td>
</tr>
<tr>
<td>make_unsigned</td>
<td style="text-align:left">signed type<br>otherwise</td>
<td style="text-align:left">unsigned T<br>T</td>
</tr>
<tr>
<td>remove_extent</td>
<td style="text-align:left">X[n]<br>otherwise</td>
<td style="text-align:left">X<br>T</td>
</tr>
<tr>
<td>remove_all_extents</td>
<td style="text-align:left">X[n1][n2]…<br>otherwise</td>
<td style="text-align:left">X<br>T</td>
</tr>
</tbody>
</table>
<p>在这个例子中，我们可以使用<strong>remove_reference</strong>获取元素类型。</p>
<pre><code>remove_reference&lt;decltype(*beg)&gt;::<span class="class"><span class="keyword">type</span>
</span>
<span class="comment">// must use typename to use a type member of a template parameter; see § 16.1.3 (p.</span>
<span class="number">670</span>)
template &lt;typename <span class="type">It</span>&gt;
auto fcn2(<span class="type">It</span> beg, <span class="type">It</span> end) -&gt;
    typename remove_reference&lt;decltype(*beg)&gt;::<span class="class"><span class="keyword">type</span>
</span>{
    <span class="comment">// process the range</span>
    <span class="keyword">return</span> *beg;  <span class="comment">// return a copy of an element from the range</span>
}
</code></pre><p>注意type是一个依赖模板参数的类成员。因此我们必须在返回类型的声明中使用<strong>typename</strong>来告诉编译器type代表一个类型。</p>
<p>每一个上表中描述的类型转换模板和<strong>remove_reference</strong>类似工作。每一个模板都有一个公开的type成员代表一个类型。如果不可能（或没必要）转换一个模板参数，则type成员就是模板参数本身。</p>
<h2 id="16-2-4_函数指针和实参推导">16.2.4 函数指针和实参推导</h2><p>当我们从一个函数模板初始化或赋值一个函数指针时，编译器使用函数指针的类型推导模板实参。</p>
<pre><code>template &lt;typename T&gt; <span class="built_in">int</span> compare(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)<span class="comment">;</span>
// pf1 points <span class="keyword">to</span> the instantiation <span class="built_in">int</span> compare(<span class="keyword">const</span> <span class="built_in">int</span>&amp;, <span class="keyword">const</span> <span class="built_in">int</span>&amp;)
<span class="built_in">int</span> (*pf1)(<span class="keyword">const</span> <span class="built_in">int</span>&amp;, <span class="keyword">const</span> <span class="built_in">int</span>&amp;) = compare<span class="comment">;</span>
</code></pre><p>如果从函数指针类型不能决定模板实参则出错：</p>
<pre><code><span class="comment">// overloaded versions of func; each takes a different function pointer type</span>
<span class="function"><span class="keyword">void</span> <span class="title">func</span>(<span class="params"><span class="keyword">int</span>(*</span>)(<span class="params"><span class="keyword">const</span> <span class="keyword">string</span>&amp;, <span class="keyword">const</span> <span class="keyword">string</span>&amp;</span>))</span>;
<span class="function"><span class="keyword">void</span> <span class="title">func</span>(<span class="params"><span class="keyword">int</span>(*</span>)(<span class="params"><span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;</span>))</span>;
func(compare); <span class="comment">// error: which instantiation of compare?</span>
</code></pre><p>我们可以使用显式模板实参使得调用无二义性：</p>
<pre><code>// ok: explicitly specify which version of compare <span class="keyword">to</span> instantiate
<span class="function"><span class="keyword">func</span><span class="params">(compare&lt;int&gt;)</span>;  // <span class="title">passing</span> <span class="title">compare</span><span class="params">(const int&amp;, const int&amp;)</span></span>
</code></pre><blockquote>
<p><strong>注释</strong><br>When the address of a function-template instantiation is taken, the context<br>must be such that it allows a unique type or value to be determined for each<br>template parameter.</p>
</blockquote>
<h2 id="16-2-5_模板实参推导和引用">16.2.5 模板实参推导和引用</h2>]]></content>
    <summary type="html">
    <![CDATA[<p>面向对象编程和泛型编程都是处理程序编写时类型未知的情况。两者的区别是面向对象编程直到运行时类型才能知道，而泛型编程类型在编译期间知道。</p>
<p>容器，迭代器和算法都是泛型编程的例子。当编写一个泛型程序，我们用一种独立于任何类型的方式编写代码。当使用一个泛型程序，我们提]]>
    </summary>
    
      <category term="C/C++" scheme="https://opensvn.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Pygame简单帮助文档]]></title>
    <link href="https://opensvn.github.io/2015/11/19/pygame-doc/"/>
    <id>https://opensvn.github.io/2015/11/19/pygame-doc/</id>
    <published>2015-11-19T06:37:15.000Z</published>
    <updated>2015-11-19T06:38:37.556Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
      <category term="Pygame" scheme="https://opensvn.github.io/tags/Pygame/"/>
    
      <category term="Python" scheme="https://opensvn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Pygame第六章 接受用户输入]]></title>
    <link href="https://opensvn.github.io/2015/11/16/pygame-6/"/>
    <id>https://opensvn.github.io/2015/11/16/pygame-6/</id>
    <published>2015-11-16T08:39:23.000Z</published>
    <updated>2015-11-20T09:29:32.519Z</updated>
    <content type="html"><![CDATA[<p>用户可以有很多种方式与游戏交互，这一章详细讲解多种输入设备。除了从设备获取信息，我们也要探索如何将用户所做的事情翻译成游戏中有意义的事件。容易交互对任何游戏都至关重要，不管你有多好的外观和声音。</p>
<h1 id="控制游戏">控制游戏</h1><p>玩过游戏的都知道鼠标和键盘是游戏不可或缺的输入设备。键盘可以控制有限的方向和诸多的命令操作，而鼠标更是提供了全方位的方向和位置操作。不过这两个设备并不是为游戏而生，专业的游戏手柄给玩家提供了更好的操作感，加上力反馈等技术，应该说游戏设备越来越丰富，玩家们也是越来越幸福。</p>
<h1 id="理解键盘控制">理解键盘控制</h1><p>现在大多数键盘都是qwerty键盘。我们可以使用<strong>pygame.key</strong>模块检测所有的键。</p>
<h3 id="检测键盘按下">检测键盘按下</h3><p>在Pygame里面有两种方式检测键盘按下。一种方式是处理<strong>KEYDOWN</strong>事件和<strong>KEYUP</strong>事件，分别对应键盘按下和键盘松开。当我们使用键盘输入代表移动时，我们只需知道键是否被按下，这种情况可以直接使用<strong>pygame.key</strong>模块。</p>
<p>每一个键盘上的键都有一个常量键值关联它。每一个常量以<strong>K_</strong>开头，比如字母是K_a到K_z，数字是K_0到K_9，其它的如K_F1，K_LEFT，K_RETURN等。完整列表参考(<a href="http://www.pygame.org/docs/ref/key.html" target="_blank" rel="external">http://www.pygame.org/docs/ref/key.html</a>)。没有大写字母对应的键值，因为大写字母是小写字母和其它键的组合。</p>
<p>我们可以使用<strong>pygame.key.get_pressed</strong>函数检查一个键是否被按下。它返回一个布尔值列表，每一个布尔值对应一个键值常量。要查询某一个键，使用其键值常量作为列表下标。比如查看空格是否被按下：</p>
<pre><code>pressed_keys = pygame.<span class="variable">key</span>.get_pressed()
<span class="keyword">if</span> pressed_keys[K_SPACE]:
    # Space <span class="variable">key</span> has been pressed
    fire()
</code></pre><blockquote>
<p><strong>注意</strong> 由于硬件的限制，有些键组合不能被检测。原因请看<a href="http://www.sjbaker.org/steve/omniv/keyboards_are_evil.html" target="_blank" rel="external">http://www.sjbaker.org/steve/omniv/keyboards_are_evil.html</a></p>
</blockquote>
<pre><code>import pygame
<span class="keyword">from</span> pygame.locals import *
<span class="keyword">from</span> sys import <span class="keyword">exit</span>

pygame.init()
screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

font = pygame.font.SysFont(<span class="comment">'arial', 32)</span>
font_height = font.get_linesize()

<span class="keyword">while</span> <span class="literal">True</span>:
    <span class="keyword">for</span> <span class="keyword">event</span> <span class="keyword">in</span> pygame.<span class="keyword">event</span>.<span class="keyword">get</span>():
        <span class="keyword">if</span> <span class="keyword">event</span>.type == QUIT:
            <span class="keyword">exit</span>()

    screen.fill((<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))

    pressed_key_text = []
    pressed_keys = pygame.<span class="keyword">key</span>.get_pressed()
    y = font_height

    <span class="keyword">for</span> key_constant, pressed <span class="keyword">in</span> enumerate(pressed_keys):
        <span class="keyword">if</span> pressed:
            key_name = pygame.<span class="keyword">key</span>.name(key_constant)
            text_surface = font.render(key_name + <span class="comment">' pressed', True, (0, 0, 0))</span>
            screen.blit(text_surface, (<span class="number">8</span>, y))
            y += font_height

    pygame.display.update()
</code></pre><p>让我们更详细地复习<strong>pygame.key</strong>：</p>
<ul>
<li><strong>pygame.key.get_focused</strong> - Pygame窗口只有获得焦点后才会接受键事件。如果窗口获得焦点，<strong>get_focused</strong>函数返回真，否则返回假。全屏模式，总是返回真。</li>
<li><strong>pygame.key.get_pressed</strong> - 返回一个包含每一个键的布尔值列表。如果值为True，则对应键被按下。</li>
<li><strong>pygame.key.get_mods</strong> - 返回一个值，指示哪一个修饰键被按下。要检查哪一个修饰键被按下，可以对KMOD_常量使用位与操作。比如检查左shift键被按下，pygame.key.get_mods() &amp; KMOD_LSHIFT。</li>
<li><strong>pygame.key.set_mods</strong> - 可以设置修饰键模拟组合键按下的效果。要设置一个或多个修饰键，对KMOD_常量使用位或操作。比如设置shift和alt键，可以使用pygame.key.set_mods(KMOD_SHIFT | KMOD_ALT)。</li>
<li><strong>pygame.key.set_repeat</strong> - 可以使用<strong>set_repeat</strong>函数重复<strong>KEY_DOWN</strong>事件，它接受一个初始延迟时间和重复事件延迟时间，单位为毫秒。<strong>set_repeat</strong>不带参数禁用重复按键事件。</li>
<li><strong>pygame.key.name</strong> - 接受一个KEY_常量返回一个描述该键的字符串。</li>
</ul>
<h3 id="使用键盘控制方向">使用键盘控制方向</h3><p>四个基本方向向量：</p>
<table>
<thead>
<tr>
<th>方向</th>
<th style="text-align:left">向量</th>
</tr>
</thead>
<tbody>
<tr>
<td>Left</td>
<td style="text-align:left">(-1.0, 0.0)</td>
</tr>
<tr>
<td>Right</td>
<td style="text-align:left">(1.0, 0.0)</td>
</tr>
<tr>
<td>Up</td>
<td style="text-align:left">(0.0, –1.0)</td>
</tr>
<tr>
<td>Down</td>
<td style="text-align:left">(0.0, 1.0)</td>
</tr>
</tbody>
</table>
<pre><code>background_image_filename = <span class="string">'sushiplate.jpg'</span>
sprite_iamge_filename = <span class="string">'fugu.png'</span>

<span class="keyword">import</span> pygame
from pygame.locals <span class="keyword">import</span> *
from sys <span class="keyword">import</span> <span class="built_in">exit</span>
from gameobjects.vector2 <span class="keyword">import</span> Vector2

pygame.init()

screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)
<span class="built_in">background</span> = pygame.<span class="built_in">image</span>.load(background_image_filename).convert()
sprite = pygame.<span class="built_in">image</span>.load(sprite_iamge_filename).convert_alpha()

clock = pygame.time.Clock()

sprite_pos = Vector2(<span class="number">200</span>, <span class="number">150</span>)
sprite_speed = <span class="number">300.</span>

<span class="keyword">while</span> True:
    <span class="keyword">for</span> event in pygame.event.<span class="built_in">get</span>():
        <span class="keyword">if</span> event.type == QUIT:
            <span class="built_in">exit</span>()

    pressed_keys = pygame.<span class="variable">key</span>.get_pressed()
    key_direction = Vector2(<span class="number">0</span>, <span class="number">0</span>)
    <span class="keyword">if</span> pressed_keys[K_LEFT]:
        key_direction.x = -<span class="number">1</span>
    elif pressed_keys[K_RIGHT]:
        key_direction.x = +<span class="number">1</span>
    <span class="keyword">if</span> pressed_keys[K_UP]:
        key_direction.y = -<span class="number">1</span>
    elif pressed_keys[K_DOWN]:
        key_direction.y = +<span class="number">1</span>

    key_direction.normalize()

    screen.blit(<span class="built_in">background</span>, (<span class="number">0</span>, <span class="number">0</span>))
    screen.blit(sprite, sprite_pos)

    time_passed = clock.tick(<span class="number">30</span>)
    time_passed_seconds = time_passed / <span class="number">1000.0</span>

    sprite_pos += key_direction * sprite_speed * time_passed_seconds

    pygame.display.update()
</code></pre><h3 id="键盘旋转移动">键盘旋转移动</h3><p>往八个方向移动有点像人造的，现实中很少看到这样移动的，大多数东西都能自由转向。</p>
<pre><code>background_image_filename = <span class="string">'sushiplate.jpg'</span>
sprite_image_filename = <span class="string">'fugu.png'</span>

<span class="keyword">import</span> pygame
from pygame.locals <span class="keyword">import</span> *
from sys <span class="keyword">import</span> <span class="built_in">exit</span>
from gameobjects.vector2 <span class="keyword">import</span> Vector2
from math <span class="keyword">import</span> *

pygame.init()

screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

<span class="built_in">background</span> = pygame.<span class="built_in">image</span>.load(background_image_filename).convert()
sprite = pygame.<span class="built_in">image</span>.load(sprite_image_filename).convert_alpha()

clock = pygame.time.Clock()

sprite_pos = Vector2(<span class="number">200</span>, <span class="number">150</span>)
sprite_speed = <span class="number">300.</span>
sprite_rotation = <span class="number">0.</span>
sprite_rotation_speed = <span class="number">360.</span> # Degrees per <span class="built_in">second</span>

<span class="keyword">while</span> True:
    <span class="keyword">for</span> event in pygame.event.<span class="built_in">get</span>():
        <span class="keyword">if</span> event.type == QUIT:
            <span class="built_in">exit</span>()

    pressed_keys = pygame.<span class="variable">key</span>.get_pressed()

    rotation_direction = <span class="number">0.</span>
    movement_direction = <span class="number">0.</span>

    <span class="keyword">if</span> pressed_keys[K_LEFT]:
        rotation_direction = +<span class="number">1.0</span>
    <span class="keyword">if</span> pressed_keys[K_RIGHT]:
        rotation_direction = -<span class="number">1.0</span>
    <span class="keyword">if</span> pressed_keys[K_UP]:
        movement_direction = +<span class="number">1.0</span>
    <span class="keyword">if</span> pressed_keys[K_DOWN]:
        movement_direction = -<span class="number">1.0</span>

    screen.blit(<span class="built_in">background</span>, (<span class="number">0</span>, <span class="number">0</span>))

    rotated_sprite = pygame.transform.<span class="built_in">rotate</span>(sprite, sprite_rotation)
    w, h = rotated_sprite.get_size()
    sprite_draw_pos = Vector2(sprite_pos.x - w / <span class="number">2</span>, sprite_pos.y - h / <span class="number">2</span>)
    screen.blit(rotated_sprite, sprite_draw_pos)

    time_passed = clock.tick()
    time_passed_seconds = time_passed / <span class="number">1000.0</span>

    sprite_rotation += rotation_direction * sprite_rotation_speed * time_passed_seconds

    heading_x = <span class="built_in">sin</span>(sprite_rotation * pi / <span class="number">180.0</span>)
    heading_y = <span class="built_in">cos</span>(sprite_rotation * pi / <span class="number">180.0</span>)
    heading = Vector2(heading_x, heading_y)
    heading *= movement_direction

    sprite_pos += heading * sprite_speed * time_passed_seconds

    pygame.display.update()
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>用户可以有很多种方式与游戏交互，这一章详细讲解多种输入设备。除了从设备获取信息，我们也要探索如何将用户所做的事情翻译成游戏中有意义的事件。容易交互对任何游戏都至关重要，不管你有多好的外观和声音。</p>
<h1 id="控制游戏">控制游戏</h1><p>玩过游戏的都知道鼠]]>
    </summary>
    
      <category term="Pygame" scheme="https://opensvn.github.io/tags/Pygame/"/>
    
      <category term="Python" scheme="https://opensvn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Pygame第五章 让画面动起来]]></title>
    <link href="https://opensvn.github.io/2015/11/10/pygame-5/"/>
    <id>https://opensvn.github.io/2015/11/10/pygame-5/</id>
    <published>2015-11-10T12:21:33.000Z</published>
    <updated>2015-11-19T09:50:53.236Z</updated>
    <content type="html"><![CDATA[<p>这一章描述如何以一种可以预测的方式在屏幕上移动对象，和如何使运动在其他人电脑里面一致。</p>
<h1 id="理解帧率">理解帧率</h1><p>我们需要知道计算机游戏中关于运动的第一件事情就是<strong>没有什么东西真正在移动</strong>。电脑屏幕或电视机展示给我们一系列图片，当两张图片间隔时间够短时，我们的大脑将这些图片混合在一起从而制造了流畅运动的假象。一张图片称为一帧，FPS(Frame Per Second)是每秒的帧数，也就是帧率。产生流畅运动需要的帧数，因人而异。</p>
<p>游戏的帧率也受限于显示设备的刷新速度。比如，显示器的刷新速度为60HZ，也就是每秒刷新60次。产生帧的速度比刷新速度快会导致“tearing”现象，即下一个帧混进前一个帧。电脑要做的事情越多，帧率就会越慢。好消息是现在的桌面电脑已经足以产生你想要的视觉效果。</p>
<p>只需记住几个常量：一般的电视画面是24FPS；30FPS基本可以给玩家提供流畅的体验了；60FPS是LCD常用的刷新率，所以你的游戏的帧率再高也没什么意义了；在70FPS以上，很少有人能察觉任何提升了！</p>
<h1 id="直线运动">直线运动</h1><pre><code>background_image_filename = <span class="string">'sushiplate.jpg'</span>
sprite_image_filename = <span class="string">'fugu.png'</span>

import pygame
<span class="keyword">from</span> pygame.locals import *
<span class="keyword">from</span> sys import <span class="keyword">exit</span>

pygame.init()

screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

background = pygame.image.load(background_image_filename).convert()
sprite = pygame.image.load(sprite_image_filename)

# The x coordinate <span class="keyword">of</span> our sprite
x = <span class="number">0</span>.

<span class="keyword">while</span> <span class="keyword">True</span>:
    <span class="keyword">for</span> <span class="keyword">event</span> <span class="keyword">in</span> pygame.<span class="keyword">event</span>.get():
        <span class="keyword">if</span> <span class="keyword">event</span>.<span class="keyword">type</span> == QUIT:
            <span class="keyword">exit</span>()

    screen.blit(background, (<span class="number">0</span>, <span class="number">0</span>))
    screen.blit(sprite, (x, <span class="number">100</span>))
    x += <span class="number">10</span>.

    # <span class="keyword">If</span> the image goes off the <span class="keyword">end</span> <span class="keyword">of</span> the screen, move it back
    <span class="keyword">if</span> x &gt; <span class="number">640</span>.:
        x -= <span class="number">640</span>.

    pygame.display.update()
</code></pre><p>这段代码有两个问题，第一个是我们不能精确知道画一张图片到屏幕需要多长时间，另一个问题是这个精灵在配置差的机器上移动慢，在配置好的机器上移动更快。</p>
<h3 id="关于时间">关于时间</h3><p>解决第一个问题的技巧是使运动基于时间。我们需要知道距离上一个帧已经过去多长时间，据此我们能相应地在屏幕上放置任何物体。<strong>pygame.time</strong>模块有一个Clock对象可以用来跟踪时间。使用<strong>pygame.time.Clock()</strong>创建clock对象。</p>
<pre><code>clock = pygame<span class="class">.time</span><span class="class">.Clock</span>()
</code></pre><p>一旦创建了clock对象，你应该每一帧调用一次<strong>tick</strong>函数，返回上次调用该函数已过去的时间，单位毫秒。</p>
<pre><code>time_passed = clock.<span class="function"><span class="title">tick</span><span class="params">()</span></span>
</code></pre><p><strong>tick</strong>函数也接收一个可选参数表示最大帧率。</p>
<pre><code><span class="preprocessor"># Game will run at a maximum <span class="number">30</span> frames per second</span>
time_passed = clock.tick(<span class="number">30</span>)
time_passed_seconds = time_passed / <span class="number">1000.0</span>
</code></pre><p>我们要怎样使用这个time_passed_seconds来移动精灵呢？需要做的第一件事就是选择一个精灵移动的速度。接下来只要用这个速度乘于时间就能得出精灵该移动多远。</p>
<pre><code>background_image_filename = <span class="comment">'sushiplate.jpg'</span>
sprite_image_filename = <span class="comment">'fugu.png'</span>

import pygame
<span class="keyword">from</span> pygame.locals import *
<span class="keyword">from</span> sys import <span class="keyword">exit</span>

pygame.init()

screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

background = pygame.image.load(background_image_filename).convert()
sprite = pygame.image.load(sprite_image_filename)

<span class="preprocessor"># Our clock object</span>
clock = pygame.time.Clock()

<span class="preprocessor"># X coordinate of our sprite</span>
x = <span class="number">0.</span>
<span class="preprocessor"># Speed in pixels per second</span>
speed = <span class="number">250.</span>

<span class="keyword">while</span> <span class="literal">True</span>:
    <span class="keyword">for</span> <span class="keyword">event</span> <span class="keyword">in</span> pygame.<span class="keyword">event</span>.<span class="keyword">get</span>():
        <span class="keyword">if</span> <span class="keyword">event</span>.type == QUIT:
            <span class="keyword">exit</span>()

    screen.blit(background, (<span class="number">0</span>, <span class="number">0</span>))
    screen.blit(sprite, (x, <span class="number">100</span>))

    time_passed = clock.tick()
    time_passed_seconds = time_passed / <span class="number">1000.0</span>

    distance_moved = time_passed_seconds * speed
    x += distance_moved

    <span class="keyword">if</span> x &gt; <span class="number">640.</span>:
        x -= <span class="number">640.</span>

    pygame.display.update()
</code></pre><p>理解帧率和精灵移动速度的不同很重要。</p>
<pre><code>background_image_filename = <span class="string">'sushiplate.jpg'</span>
sprite_image_filename = <span class="string">'fugu.png'</span>

import pygame
<span class="built_in">from</span> pygame.locals import *
<span class="built_in">from</span> sys import exit

pygame.init()

screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

background = pygame.image.<span class="built_in">load</span>(background_image_filename).<span class="built_in">convert</span>()
sprite = pygame.image.<span class="built_in">load</span>(sprite_image_filename)

<span class="comment"># Our clock object</span>
clock = pygame.<span class="built_in">time</span>.Clock()

x1 = <span class="number">0.</span>
x2 = <span class="number">0.</span>
<span class="comment"># Speed in pixels per second</span>
speed = <span class="number">250.</span>

frame_no = <span class="number">0</span>

<span class="keyword">while</span> True:
    <span class="keyword">for</span> event <span class="operator">in</span> pygame.event.<span class="built_in">get</span>():
        <span class="keyword">if</span> event.type == QUIT:
            exit()

    screen.blit(background, (<span class="number">0</span>, <span class="number">0</span>))
    screen.blit(sprite, (x1, <span class="number">50</span>))
    screen.blit(sprite, (x2, <span class="number">250</span>))

    time_passed = clock.<span class="built_in">tick</span>(<span class="number">30</span>)
    time_passed_seconds = time_passed / <span class="number">1000.0</span>

    distance_moved = time_passed_seconds * speed
    x1 += distance_moved

    <span class="keyword">if</span> frame_no % <span class="number">5</span> == <span class="number">0</span>:
        distance_moved = time_passed_seconds * speed
        x2 += distance_moved * <span class="number">5</span>

    <span class="comment"># If the image goes off the end of the screen, move it back</span>
    <span class="keyword">if</span> x1 &gt; <span class="number">640.</span>:
        x1 -= <span class="number">640.</span>
    <span class="keyword">if</span> x2 &gt; <span class="number">640.</span>:
        x2 -= <span class="number">640.</span>

    pygame.display.update()
    frame_no += <span class="number">1</span>
</code></pre><h3 id="斜线运动">斜线运动</h3><p>直线运动很有用，但是一个游戏如果所有物体都水平或垂直移动看起来就很笨。我们需要能够在任何方向移动精灵。可以通过调整每个帧的x和y坐标做到。</p>
<pre><code>background_image_filename = <span class="symbol">'sushiplate</span>.jpg'
sprite_image_filename = <span class="symbol">'fugu</span>.png'

import pygame
from pygame.locals import *
from sys import exit

pygame.init<span class="literal">()</span>

screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

background = pygame.image.load(background_image_filename).convert<span class="literal">()</span>
sprite = pygame.image.load(sprite_image_filename).convert_alpha<span class="literal">()</span>

clock = pygame.time.<span class="type">Clock</span><span class="literal">()</span>

x, y = <span class="number">100.</span>, <span class="number">100.</span>
speed_x, speed_y = <span class="number">133.</span>, <span class="number">170.</span>

<span class="keyword">while</span> <span class="type">True</span>:
    for event <span class="keyword">in</span> pygame.event.get<span class="literal">()</span>:
        <span class="keyword">if</span> event.<span class="keyword">type</span> == <span class="type">QUIT</span>:
            exit<span class="literal">()</span>

    screen.blit(background, (<span class="number">0</span>, <span class="number">0</span>))
    screen.blit(sprite, (x, y))

    time_passed = clock.tick(<span class="number">30</span>)
    time_passed_seconds = time_passed / <span class="number">1000.0</span>

    x += speed_x * time_passed_seconds
    y += speed_y * time_passed_seconds

    # <span class="type">If</span> the sprite goes off the edge <span class="keyword">of</span> the screen,
    # make it move <span class="keyword">in</span> the opposite direction
    <span class="keyword">if</span> x &gt; <span class="number">640</span> - sprite.get_width<span class="literal">()</span>:
        speed_x = -speed_x
        x = <span class="number">640</span> - sprite.get_width<span class="literal">()</span>
    elif x &lt; <span class="number">0</span>:
        speed_x = -speed_x
        x = <span class="number">0</span>

    <span class="keyword">if</span> y &gt; <span class="number">480</span> - sprite.get_height<span class="literal">()</span>:
        speed_y = -speed_y
        y = <span class="number">480</span> - sprite.get_height<span class="literal">()</span>
    elif y &lt; <span class="number">0</span>:
        speed_y = -speed_y
        y = <span class="number">0</span>

    pygame.display.update<span class="literal">()</span>
</code></pre><p>为了达到反弹的效果，我们首先必须检查是否撞击到边缘。在坐标上做点简单的算术就行。如果x坐标小于0，则我们超过了屏幕的左边缘。如果x加上精灵的宽度比屏幕的宽度大，则精灵的右边缘超过屏幕的宽度。y坐标的判断类似，只是使用高度而不是宽度。</p>
<h1 id="探索向量">探索向量</h1><p>游戏开发者从数学借来向量并用到很多领域，比如2D和3D游戏。向量和点类似，它们都有x和y值(在2D中)，但是用途不一样。一个点的坐标(10, 20)在屏幕上总是同一个位置，而一个向量(10, 20)意思是从当前位置x坐标加上10，y坐标加上20。因此你可以认为一个点的坐标就是从原点(0, 0)到该点的向量。</p>
<h3 id="创建向量">创建向量</h3><p>你可以从任意2个点计算向量，只要用第二个点坐标减去第一个点坐标。比如点A(10, 20)，点B(30, 35)，则向量AB就是(20, 15)。这个向量告诉我们从A到B需要在x方向移动20个单位，在y方向移动15个单位。</p>
<h3 id="存储向量">存储向量</h3><p>在Python里面没有内置的向量类型，但是你可以将向量存入list，或者自己定义向量类。方便起见，我们选择定义自己的向量类。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Vector2</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x=<span class="number">0.0</span>, y=<span class="number">0.0</span>)</span>:</span>
        self.x = x
        self.y = y

    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>
        <span class="keyword">return</span> <span class="string">'(%s, %s)'</span> % (self.x, self.y)

<span class="decorator">    @classmethod</span>
    <span class="function"><span class="keyword">def</span> <span class="title">from_points</span><span class="params">(cls, P1, P2)</span>:</span>
        <span class="keyword">return</span> cls(P2[<span class="number">0</span>] - P1[<span class="number">0</span>], P2[<span class="number">1</span>] - P1[<span class="number">1</span>])
</code></pre><p><strong>@classmethod</strong>装饰使函数from_points变成一个类方法。类方法是通过类调用的，不是通过类实例调用，比如Vector2.from_points(P1, P2)。将from_points定义为一个类方法是因为它创建一个新的Vector2对象，而不是修改已经存在的对象。</p>
<h3 id="向量大小">向量大小</h3><p>从A到B的向量大小就是2个点之间的距离。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">get_magnitude</span><span class="params">(self)</span>:</span>
    <span class="keyword">return</span> math.sqrt(self.x ** <span class="number">2</span> + self.y ** <span class="number">2</span>)
</code></pre><h3 id="单位向量">单位向量</h3><p>向量实际描述了两件事情：大小和方向。通常这两个信息绑定在一个向量里面，但有时候你只需其中一个。有一种特殊的向量叫单位向量，它的大小总是为1。我们可以把任意向量缩放到一个单位向量，这叫向量的规格化。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">normalize</span><span class="params">(self)</span>:</span>
    magnitude = self.get_magnitude()
    self.x /= magnitude
    self.y /= magnitude
</code></pre><h3 id="向量加法">向量加法</h3><p>向量加法是将两个向量组合产生一个向量，它有两个向量组合的效果。也就是AC=AB+BC。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, rhs)</span>:</span>
    <span class="keyword">return</span> Vector2(self.x + rhs.x, self.y + rhs.y)
</code></pre><h3 id="向量减法">向量减法</h3><p>向量减法和加法类似。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">__sub__</span><span class="params">(self, rhs)</span>:</span>
    <span class="keyword">return</span> Vector2(self.x - rhs.x, self.y - rhs.y)
</code></pre><h3 id="否定向量">否定向量</h3><p>如果想要改变向量的方向，使向量AB变成向量BA，需要将向量每个元素都改变符号。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">__neg__</span><span class="params">(self)</span>:</span>
    <span class="keyword">return</span> Vector2(-self.x, -self.y)
</code></pre><h3 id="向量乘法和除法">向量乘法和除法</h3><p>将一个向量乘于或除于一个系数(数字)，效果是改变向量的大小。如果向量乘于一个整数，则产生同一方向的向量，如果乘于一个负数，则产生相反方向的向量。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, scalar)</span>:</span>
    <span class="keyword">return</span> Vector2(self.x * scalar, self.y * scalar)

<span class="function"><span class="keyword">def</span> <span class="title">__div__</span><span class="params">(self, scalar)</span>:</span>
    <span class="keyword">return</span> Vector2(self.x / scalar, self.y / scalar)
</code></pre><blockquote>
<p><strong>注意</strong> 向量乘于向量也是可以的，但是在游戏中不常用，你可能永远都不需要它。</p>
</blockquote>
<p>向量乘法如何使用呢？基于时间把向量分解为很多步，向量乘法很有用。如果我们知道从A到B需要10秒，我们可以计算出每一秒我们到达的坐标。</p>
<pre><code>A = (<span class="number">10.0</span>, <span class="number">20.0</span>)
B = (<span class="number">30.0</span>, <span class="number">35.0</span>)
AB = Vector2.from_points(A, B)
step = AB * <span class="number">.1</span>
<span class="keyword">position</span> = Vector2(A.x, A.y)
for n <span class="type">in</span> <span class="built_in">range</span>(<span class="number">10</span>):
    <span class="keyword">position</span> += step
    <span class="built_in">print</span> <span class="keyword">position</span>
</code></pre><p>当在两个点之间移动，计算中间位置是基本的。你还可以用向量计算在重力，外部作用力和摩擦力作用下很多现实的运动。</p>
<h3 id="游戏对象向量类">游戏对象向量类</h3><p>作者已经写了一个二维向量类作为游戏对象的一部分。</p>
<pre><code>from gameobjects.vector2 import *
A = (<span class="number">10.0</span>, <span class="number">20.0</span>)
B = (<span class="number">30.0</span>, <span class="number">35.0</span>)
AB = Vector2.from_points(A, B)
print <span class="string">"Vector AB is"</span>, AB
print <span class="string">"AB * 2 is"</span>, AB * <span class="number">2</span>
print <span class="string">"AB / 2 is"</span>, AB / <span class="number">2</span>
print <span class="string">"AB + (-10, 5) is"</span>, AB + (-<span class="number">10</span>, <span class="number">5</span>)
print <span class="string">"Magnitude of AB is"</span>, AB.get_magnitude()
print <span class="string">"AB normalized is"</span>, AB.get_normalized()
</code></pre><h1 id="使用向量创建运动">使用向量创建运动</h1><p>既然我们了解了向量，我们可以使用它以多种方式移动游戏角色，而且可以实现简单的，基于力学的物理现象，使得游戏更加可信。</p>
<h3 id="斜线运动-1">斜线运动</h3><p>让我们使用向量创建更加精确的斜线运动。</p>
<pre><code>background_image_filename = <span class="string">'sushiplate.jpg'</span>
sprite_image_filename = <span class="string">'fugu.png'</span>

from sys <span class="keyword">import</span> exit
<span class="keyword">import</span> pygame
from pygame.locals <span class="keyword">import</span> *
from gameobjects.vector2 <span class="keyword">import</span> Vector2

pygame.init()

screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

background = pygame.image.load(background_image_filename).convert()
sprite = pygame.image.load(sprite_image_filename).convert_alpha()

clock = pygame.time.Clock()

position = Vector2(<span class="number">100.0</span>, <span class="number">100.0</span>)
speed = <span class="number">250</span>
heading = Vector2()

<span class="keyword">while</span> True:
    <span class="keyword">for</span> event in pygame.event.<span class="keyword">get</span>():
        <span class="keyword">if</span> event.type == QUIT:
            exit()
        <span class="keyword">if</span> event.type == MOUSEBUTTONDOWN:
            destination = Vector2(*event.pos) - Vector2(*sprite.get_size()) / 2.
            heading = Vector2.from_points(position, destination)
            heading.normalize()

        screen.blit(background, (0, 0))
        screen.blit(sprite, position)

        time_passed = clock.tick()
        time_passed_seconds = time_passed / 1000.0

        distance_moved = time_passed_seconds * speed
        position += heading * distance_moved
        pygame.display.update()
</code></pre><p>目的坐标的计算需要解释一下。星号(<code>*</code>)用在函数的参数时，扩展为一个元组或列表。因此Vector2(*event.pos)相当于Vector2(event.pos[0], event.pos[1])。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一章描述如何以一种可以预测的方式在屏幕上移动对象，和如何使运动在其他人电脑里面一致。</p>
<h1 id="理解帧率">理解帧率</h1><p>我们需要知道计算机游戏中关于运动的第一件事情就是<strong>没有什么东西真正在移动</strong>。电脑屏幕或电视机展示]]>
    </summary>
    
      <category term="Pygame" scheme="https://opensvn.github.io/tags/Pygame/"/>
    
      <category term="Python" scheme="https://opensvn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[整理代码片段]]></title>
    <link href="https://opensvn.github.io/2015/11/10/colleague/"/>
    <id>https://opensvn.github.io/2015/11/10/colleague/</id>
    <published>2015-11-10T03:18:10.000Z</published>
    <updated>2015-12-15T11:27:16.594Z</updated>
    <content type="html"><![CDATA[<h1 id="根据pid获取进程名">根据pid获取进程名</h1><pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;libgen.h&gt;</span></span>

<span class="function"><span class="keyword">void</span> <span class="title">get_process_name_by_pid</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">char</span> *name)</span>
</span>{
    <span class="keyword">char</span> buf[<span class="number">256</span>] = {<span class="number">0</span>};
    <span class="keyword">char</span> path[<span class="number">256</span>] = {<span class="number">0</span>};

    <span class="built_in">sprintf</span>(buf, <span class="string">"/proc/%d/exe"</span>, pid);
    readlink(buf, path, <span class="keyword">sizeof</span>(path));

    <span class="keyword">char</span> *filename = basename(path);
    <span class="built_in">strcpy</span>(name, filename);
}

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    <span class="keyword">int</span> pid = getpid();
    <span class="keyword">char</span> name[<span class="number">256</span>] = {<span class="number">0</span>};
    get_process_name_by_pid(pid, name);
    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, name);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><h1 id="C语言变长数组">C语言变长数组</h1><pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>
<span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span>

<span class="function"><span class="keyword">void</span> <span class="title">test_vla</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span>
</span>{
    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);

    <span class="keyword">char</span> a[len + <span class="number">1</span>];
    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));

    <span class="built_in">strcpy</span>(a, str);

    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, a);
}

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    test_vla(<span class="string">"hello"</span>);
    test_vla(<span class="string">"world!"</span>);
    test_vla(<span class="string">"Amazing"</span>);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><h1 id="确保路径存在">确保路径存在</h1><pre><code><span class="function"><span class="keyword">bool</span> <span class="title">besure_path</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span>
</span>{
    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(pathname);

    <span class="keyword">char</span> buffer[len + <span class="number">1</span>];
    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));

    <span class="built_in">strcpy</span>(buffer, pathname);

    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)
    {
        <span class="keyword">if</span> (buffer[i] == <span class="string">'/'</span>)
        {
            buffer[i] = <span class="number">0</span>;

            <span class="keyword">if</span> (access(buffer, F_OK) &lt; <span class="number">0</span>)
            {
                <span class="keyword">if</span> (mkdir(buffer, <span class="number">0755</span>) &lt; <span class="number">0</span>)
                {
                    <span class="keyword">return</span> <span class="literal">false</span>;
                }
            }

            buffer[i] = <span class="string">'/'</span>;
        }
    }

    <span class="keyword">return</span> <span class="literal">true</span>;
}
</code></pre><h1 id="计算一个数字二进制表示1的个数">计算一个数字二进制表示1的个数</h1><pre><code><span class="function"><span class="keyword">int</span> <span class="title">count_bit</span><span class="params">(<span class="keyword">int</span> n)</span>
</span>{
    <span class="keyword">int</span> count = <span class="number">0</span>;

    <span class="keyword">while</span> (n != <span class="number">0</span>)
    {
        ++count;
        n &amp;= n - <span class="number">1</span>;
    }

    <span class="keyword">return</span> count;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="根据pid获取进程名">根据pid获取进程名</h1><pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdi]]>
    </summary>
    
      <category term="C/C++" scheme="https://opensvn.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Pygame第四章 创建视觉]]></title>
    <link href="https://opensvn.github.io/2015/11/07/pygame-4/"/>
    <id>https://opensvn.github.io/2015/11/07/pygame-4/</id>
    <published>2015-11-07T13:28:44.000Z</published>
    <updated>2015-11-19T06:20:46.008Z</updated>
    <content type="html"><![CDATA[<p>电脑游戏倾向于视觉上很自然，游戏开发者花费很多精力在处理图像和提升视觉效果来创建最令人愉快的体验上。</p>
<h1 id="像素的威力">像素的威力</h1><p>显示器里的一个独立的点称为一个图像单元或像素。如果一个显示器分辨率为1280x1024，则像素总数为1310720。一个屏幕上像素越多，则图片的质量越好。典型的家用电脑可以显示的颜色数量最高为16.7百万个。如果你想显示每一种颜色，你需要一个分辨率4096x4096的显示器。</p>
<pre><code>import pygame
pygame.init()

screen = pygame.<span class="keyword">display</span>.set_mode((640, 480))

all_colors = pygame.Surface((4096, 4096), depth=24)

<span class="keyword">for</span> r <span class="keyword">in</span> xrange(256):
    <span class="keyword">print</span> r + 1, '<span class="keyword">out</span> of 256'
    x = (r &amp; 15) * 256
    y = (r &gt;&gt; 4) * 256
    <span class="keyword">for</span> <span class="keyword">g</span> <span class="keyword">in</span> xrange(256):
        <span class="keyword">for</span> b <span class="keyword">in</span> xrange(256):
            all_colors.set_at((x + <span class="keyword">g</span>, y + b), (r, <span class="keyword">g</span>, b))

pygame.image.<span class="keyword">save</span>(all_colors, 'allcolors.bmp')
</code></pre><p>上面程序用到的类或方法：</p>
<pre><code>class Surface(__builtin__.object)
 |  pygame.Surface((<span class="variable">width</span>, <span class="variable">height</span>), flags=<span class="number">0</span>, depth=<span class="number">0</span>, masks=None): <span class="keyword">return</span> Surface
 |  pygame.Surface((<span class="variable">width</span>, <span class="variable">height</span>), flags=<span class="number">0</span>, Surface): <span class="keyword">return</span> Surface
 |  pygame object <span class="keyword">for</span> representing images

set_at(...)
    Surface.set_at((x, y), Color): <span class="keyword">return</span> None
    <span class="built_in">set</span> the <span class="built_in">color</span> value <span class="keyword">for</span> a single pixel

<span class="built_in">save</span>(...)
    pygame.<span class="built_in">image</span>.<span class="built_in">save</span>(Surface, filename): <span class="keyword">return</span> None
    <span class="built_in">save</span> an <span class="built_in">image</span> to disk
</code></pre><h1 id="和颜色打交道">和颜色打交道</h1><h3 id="Pygame中表示颜色">Pygame中表示颜色</h3><p>当Pygame需要一种颜色，你需要传进一个包含三个数字的元组，分别对应红绿蓝三种颜色，每个数值范围为[0, 255]。</p>
<table>
<thead>
<tr>
<th>颜色</th>
<th style="text-align:left">红色</th>
<th style="text-align:left">绿色</th>
<th style="text-align:left">蓝色</th>
<th style="text-align:left">元组</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑(Black)</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">(0, 0, 0)</td>
</tr>
<tr>
<td>蓝(Blue)</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">255</td>
<td style="text-align:left">(0, 0, 255)</td>
</tr>
<tr>
<td>绿(Green)</td>
<td style="text-align:left">0</td>
<td style="text-align:left">255</td>
<td style="text-align:left">0</td>
<td style="text-align:left">(0, 255, 0)</td>
</tr>
<tr>
<td>蓝绿(Cyan)</td>
<td style="text-align:left">0</td>
<td style="text-align:left">255</td>
<td style="text-align:left">255</td>
<td style="text-align:left">(0, 255, 255)</td>
</tr>
<tr>
<td>红(Red)</td>
<td style="text-align:left">255</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">(255, 0, 0)</td>
</tr>
<tr>
<td>洋红(Magenta)</td>
<td style="text-align:left">255</td>
<td style="text-align:left">0</td>
<td style="text-align:left">255</td>
<td style="text-align:left">(255, 0, 255)</td>
</tr>
<tr>
<td>黄(Yellow)</td>
<td style="text-align:left">255</td>
<td style="text-align:left">255</td>
<td style="text-align:left">0</td>
<td style="text-align:left">(255, 255, 0)</td>
</tr>
<tr>
<td>白(White)</td>
<td style="text-align:left">255</td>
<td style="text-align:left">255</td>
<td style="text-align:left">255</td>
<td style="text-align:left">(255, 255, 255)</td>
</tr>
</tbody>
</table>
<pre><code><span class="keyword">import</span> pygame
from pygame.locals <span class="keyword">import</span> *
from sys <span class="keyword">import</span> <span class="built_in">exit</span>

pygame.init()

screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

# Creates images with <span class="built_in">smooth</span> gradients
def create_scales(<span class="variable">height</span>):
    red_scale_surface = pygame.surface.Surface((<span class="number">640</span>, <span class="variable">height</span>))
    green_scale_surface = pygame.surface.Surface((<span class="number">640</span>, <span class="variable">height</span>))
    blue_scale_surface = pygame.surface.Surface((<span class="number">640</span>, <span class="variable">height</span>))
    <span class="keyword">for</span> x in range(<span class="number">640</span>):
        c = <span class="built_in">int</span>((x / <span class="number">639.</span>) * <span class="number">255.</span>)
        <span class="built_in">red</span> = (c, <span class="number">0</span>, <span class="number">0</span>)
        <span class="built_in">green</span> = (<span class="number">0</span>, c, <span class="number">0</span>)
        <span class="built_in">blue</span> = (<span class="number">0</span>, <span class="number">0</span>, c)
        line_rect = Rect(x, <span class="number">0</span>, <span class="number">1</span>, <span class="variable">height</span>)
        pygame.<span class="title">draw</span>.<span class="built_in">rect</span>(red_scale_surface, <span class="built_in">red</span>, line_rect)
        pygame.<span class="title">draw</span>.<span class="built_in">rect</span>(green_scale_surface, <span class="built_in">green</span>, line_rect)
        pygame.<span class="title">draw</span>.<span class="built_in">rect</span>(blue_scale_surface, <span class="built_in">blue</span>, line_rect)
    <span class="keyword">return</span> red_scale_surface, green_scale_surface, blue_scale_surface

red_scale, green_scale, blue_scale = create_scales(<span class="number">80</span>)

<span class="built_in">color</span> = [<span class="number">127</span>, <span class="number">127</span>, <span class="number">127</span>]

<span class="keyword">while</span> True:
    <span class="keyword">for</span> event in pygame.event.<span class="built_in">get</span>():
        <span class="keyword">if</span> event.type == QUIT:
            <span class="built_in">exit</span>()

    screen.<span class="built_in">fill</span>((<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))

    # Draw the scales to the screen
    screen.blit(red_scale, (<span class="number">0</span>, <span class="number">0</span>))
    screen.blit(green_scale, (<span class="number">0</span>, <span class="number">80</span>))
    screen.blit(blue_scale, (<span class="number">0</span>, <span class="number">160</span>))

    x, y = pygame.mouse.get_pos()

    # If the mouse was pressed on one of the sliders, adjust the <span class="built_in">color</span> component
    <span class="keyword">if</span> pygame.mouse.get_pressed()[<span class="number">0</span>]:
        <span class="keyword">for</span> component in range(<span class="number">3</span>):
            <span class="keyword">if</span> y &gt; component * <span class="number">80</span> and y &lt; (component + <span class="number">1</span>) * <span class="number">80</span>:
                <span class="built_in">color</span>[component] = <span class="built_in">int</span>((x / <span class="number">639.</span>) * <span class="number">255.</span>)
        pygame.display.set_caption(<span class="string">'Pygame Color Test - '</span> + <span class="built_in">str</span>(tuple(<span class="built_in">color</span>)))

    # Draw a circle <span class="keyword">for</span> each slider to represent the current setting
    <span class="keyword">for</span> component in range(<span class="number">3</span>):
        pos = (<span class="built_in">int</span>((<span class="built_in">color</span>[component] / <span class="number">255.</span>) * <span class="number">639</span>), component * <span class="number">80</span> + <span class="number">40</span>)
        pygame.<span class="title">draw</span>.circle(screen, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), pos, <span class="number">20</span>)

    pygame.<span class="title">draw</span>.<span class="built_in">rect</span>(screen, tuple(<span class="built_in">color</span>), (<span class="number">0</span>, <span class="number">240</span>, <span class="number">640</span>, <span class="number">240</span>))

    pygame.display.update()
</code></pre><p>上面程序用到的类或方法：</p>
<pre><code>class Rect(__builtin__.object)
 |  pygame.Rect(left, top, <span class="variable">width</span>, <span class="variable">height</span>): <span class="keyword">return</span> Rect
 |  pygame.Rect((left, top), (<span class="variable">width</span>, <span class="variable">height</span>)): <span class="keyword">return</span> Rect
 |  pygame.Rect(object): <span class="keyword">return</span> Rect
 |  pygame object <span class="keyword">for</span> storing rectangular coordinates

<span class="built_in">rect</span>(...)
    pygame.<span class="title">draw</span>.<span class="built_in">rect</span>(Surface, <span class="built_in">color</span>, Rect, <span class="variable">width</span>=<span class="number">0</span>): <span class="keyword">return</span> Rect
    <span class="title">draw</span> a rectangle <span class="built_in">shape</span>

get_pressed(...)
    pygame.mouse.get_pressed(): <span class="keyword">return</span> (button1, button2, button3)
    <span class="built_in">get</span> the state of the mouse buttons

circle(...)
    pygame.<span class="title">draw</span>.circle(Surface, <span class="built_in">color</span>, pos, radius, <span class="variable">width</span>=<span class="number">0</span>): <span class="keyword">return</span> Rect
    <span class="title">draw</span> a circle around a <span class="built_in">point</span>
</code></pre><h3 id="调整颜色">调整颜色</h3><p>要使颜色变暗，只需RGB每一个值都乘于一个0和1之间的系数。</p>
<pre><code>def scale_color(<span class="built_in">color</span>, <span class="built_in">scale</span>):
    <span class="built_in">red</span>, <span class="built_in">green</span>, <span class="built_in">blue</span> = <span class="built_in">color</span>
    <span class="built_in">red</span> = <span class="built_in">int</span>(<span class="built_in">red</span> * <span class="built_in">scale</span>)
    <span class="built_in">green</span> = <span class="built_in">int</span>(<span class="built_in">green</span> * <span class="built_in">scale</span>)
    <span class="built_in">blue</span> = <span class="built_in">int</span>(<span class="built_in">blue</span> * <span class="built_in">scale</span>)
    <span class="keyword">return</span> <span class="built_in">red</span>, <span class="built_in">green</span>, <span class="built_in">blue</span>

fireball_orange = (<span class="number">221</span>, <span class="number">99</span>, <span class="number">20</span>)
<span class="built_in">print</span> fireball_orange
<span class="built_in">print</span> scale_color(fireball_orange, <span class="number">.5</span>)
</code></pre><p>如果乘于一个大于1的数，颜色会变得更亮。但是如果颜色值大于255时，Pygame会抛出TypeError异常。</p>
<pre><code>def saturate_color(<span class="built_in">color</span>):
    <span class="built_in">red</span>, <span class="built_in">green</span>, <span class="built_in">blue</span> = <span class="built_in">color</span>
    <span class="built_in">red</span> = <span class="built_in">min</span>(<span class="built_in">red</span>, <span class="number">255</span>)
    <span class="built_in">green</span> = <span class="built_in">min</span>(<span class="built_in">green</span>, <span class="number">255</span>)
    <span class="built_in">blue</span> = <span class="built_in">min</span>(<span class="built_in">blue</span>, <span class="number">255</span>)
    <span class="keyword">return</span> <span class="built_in">red</span>, <span class="built_in">green</span>, <span class="built_in">blue</span>
</code></pre><p>当颜色饱和至255时，可能就失去原来的色调了，所以需要注意调整的系数。</p>
<h3 id="混合颜色">混合颜色</h3><p>有时候我们想要将一种颜色逐渐混入另一种颜色，比如一个僵尸在路过一个火山熔岩坑的时候，它会由绿色变成橙红色，再变为正常的绿色。我们怎样才能计算中间的颜色使得颜色转换平滑自然呢？<br>我们用一种叫做<strong>线性插值(linear interpolation)</strong>的方法来做这件事情。公式如下：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">lerp</span><span class="params">(value1, value2, factor)</span>:</span>
    <span class="keyword">return</span> value1 + (value2 - value1) * factor
</code></pre><p>如果逐渐改变系数因子，就会产生颜色的平滑转换。</p>
<pre><code><span class="keyword">import</span> pygame
<span class="keyword">from</span> pygame.locals <span class="keyword">import</span> *
<span class="keyword">from</span> sys <span class="keyword">import</span> exit

pygame.init()

screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

color1 = (<span class="number">221</span>, <span class="number">99</span>, <span class="number">20</span>) <span class="comment"># 火球黄</span>
color2 = (<span class="number">96</span>, <span class="number">130</span>, <span class="number">51</span>) <span class="comment"># 僵尸绿</span>

factor = <span class="number">0</span>

<span class="function"><span class="keyword">def</span> <span class="title">lerp</span><span class="params">(value1, value2, factor)</span>:</span>
    <span class="keyword">return</span> value1 + (value2 - value1) * factor

<span class="function"><span class="keyword">def</span> <span class="title">blend_color</span><span class="params">(color1, color2, blend_factor)</span>:</span>
    red1, green1, blue1 = color1
    red2, green2, blue2 = color2
    red = lerp(red1, red2, blend_factor)
    green = lerp(green1, green2, blend_factor)
    blue = lerp(blue1, blue2, blend_factor)
    <span class="keyword">return</span> int(red), int(green), int(blue)

<span class="keyword">while</span> <span class="keyword">True</span>:
    <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():
        <span class="keyword">if</span> event.type == QUIT:
            exit()

    screen.fill((<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))

    tri = [(<span class="number">0</span>, <span class="number">120</span>), (<span class="number">639</span>, <span class="number">100</span>), (<span class="number">639</span>, <span class="number">140</span>)]
    pygame.draw.polygon(screen, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), tri)
    pygame.draw.circle(screen, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), (int(factor * <span class="number">639.</span>), <span class="number">120</span>), <span class="number">10</span>)

    x, y = pygame.mouse.get_pos()
    <span class="keyword">if</span> pygame.mouse.get_pressed()[<span class="number">0</span>]:
        factor = x / <span class="number">639.</span>
        pygame.display.set_caption(<span class="string">'Pygame Color Blend Test - %.3f'</span> % factor)

    color = blend_color(color1, color2, factor)
    pygame.draw.rect(screen, color, (<span class="number">0</span>, <span class="number">240</span>, <span class="number">640</span>, <span class="number">240</span>))

    pygame.display.update()
</code></pre><p>用到的方法：</p>
<pre><code><span class="function"><span class="title">polygon</span><span class="params">(...)</span></span>
    pygame<span class="class">.draw</span><span class="class">.polygon</span>(Surface, <span class="attribute">color</span>, pointlist, <span class="attribute">width</span>=<span class="number">0</span>): return Rect
    draw <span class="tag">a</span> shape with any number of sides
</code></pre><h1 id="使用图片">使用图片</h1><p>图片对大多数游戏都是一个必须的部分。电脑存储图片为颜色的网阵。除了常见的红绿蓝，有些图片还存储额外的信息(alpha通道)。颜色的alpha值通常用来表示当图片画在另一张图片上的透明度。</p>
<h3 id="存储图片">存储图片</h3><p>有很多方式存储图片到硬盘。多年来，多种图片格式被开发出来。最有用的两种格式是JPEG和PNG。</p>
<ul>
<li>JPEG(Joint Photographic Expert Group)-JPEG图片文件扩展名为.jpg或.jpeg。数码相机常用这种格式，因为它是特别设计来存储图片的。它使用有损压缩，会降低图片质量，但是能很好地减小文件大小。JPEG不支持透明，对拥有硬边缘的东西比如字体和图表支持不好。</li>
<li>PNG(Portable Network Graphics)-PNG可能是最全面的图片格式，因为它能保存很多种图片类型并且压缩也很好。它也支持alpha通道，对游戏开发者来说是福利。PNG使用的压缩是无损压缩，缺点就是文件比JPEG文件大。</li>
</ul>
<p>除了JPEG和PNG，Pygame支持读取下面的格式：</p>
<ul>
<li>GIF(非动态)-网上使用的很多，支持透明和动画，只是只能有256种颜色，软件和游戏中使用很少</li>
<li>BMP-Windows上的标准图像格式，无压缩，质量很高但尺寸很大，一般不使用</li>
<li>PCX</li>
<li>TGA(只限非压缩的)</li>
<li>TIF</li>
<li>LBM(和PBM)</li>
<li>PBM(和PGM，PPM)</li>
<li>XPM</li>
</ul>
<p>根据经验，对于拥有很多颜色变化的大图片文件使用JPEG，否则使用PNG。</p>
<h3 id="使用Surface对象">使用Surface对象</h3><p>加载图片到Pygame只需一行，<strong>pygame.image.load</strong>接收一个图片文件名返回一个Surface对象，它是图片的容器。Surface对象可以表示许多种图片类型，但是Pygame隐藏了大多数细节，因此我们能够以相同的方式对待它们。你可以在Surface对象上画图，变形，或拷贝到另一个Surface。甚至屏幕也是一个Surface对象。</p>
<h3 id="创建Surface对象">创建Surface对象</h3><p>调用<strong>pygame.image.load</strong>是一种创建Surface的方式，它会创建和图片文件相同尺寸和颜色的Surface。也可以创建任意尺寸的空白Surface。使用<strong>pygame.Surface</strong>构造函数可以创建一个空白Surface。</p>
<pre><code>blank_surface = pygame.<span class="function"><span class="title">Surface</span><span class="params">((<span class="number">256</span>, <span class="number">256</span>)</span></span>)
</code></pre><p>还有一些选项会影响图片的创建。第一个参数是flags：</p>
<ul>
<li>HWSURFACE-创建硬件外观，比非硬件外观更快。通常最好不要设置这个标志，而是留给Pygame决定是否使用硬件外观。</li>
<li>SRCALPHA-创建拥有alpha信息的外观。这个选项需要depth参数设为32。</li>
</ul>
<p>第二个参数为depth，这个参数和<strong>pygame.display.set_mode</strong>的depth参数一样。通常最好不要设置这个参数(或设置为0)，但是如果想要保留alpha信息，则必须设置为32。</p>
<pre><code>blank_alpha_surface = pygame.Surface((<span class="number">256</span>, <span class="number">256</span>), flags=SRCALPHA, depth=<span class="number">32</span>)
</code></pre><h3 id="转换Surface">转换Surface</h3><p>当你使用Surface对象时，你不需要担心图像信息在内存是怎么存储的，因为Pygame隐藏了这些细节，因此不管什么图片类型，你的代码都能工作。自动转换的唯一缺点是如果你使用不同格式的图片，Pygame需要做更多工作，这可能会降低游戏性能。解决的方法是使用<strong>convert</strong>方法转换所有的图片为相同的格式。</p>
<p>如果不带参数调用<strong>convert</strong>，Surface会被转换为和显示设备的Surface一样的格式。这很有用因为通常起点和终点是相同类型的话拷贝Surface非常快，而大多数图片最终会被拷贝到显示设备。调用<strong>pygame.image.load</strong>时附加<strong>.convert()</strong>是个好习惯。Pygame还提供<strong>convert_alpha</strong>方法，转换Surface并保留alpha信息。</p>
<p><strong>convert</strong>和<strong>convert_alpha</strong>可以接收另外一个Surface参数，如果提供了这个参数，则Surface会被转换为和参数一样的Surface。</p>
<h3 id="矩形对象">矩形对象</h3><p>当一个函数调用会影响到屏幕的某一部分时，Pygame通常需要你提供一个矩形区域。你可以使用一个4元组定义矩形区域，(left, top, width, height)。或者使用2个2元组，((left, top), (width, height))。</p>
<pre><code>my_rect1 = (<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">150</span>)
my_rect2 = ((<span class="number">100</span>, <span class="number">100</span>), (<span class="number">200</span>, <span class="number">150</span>))
</code></pre><p>Pygame有一个Rect类存储和处理矩形对象。因为Rect对象很常使用，所以它包含在<strong>pygame.locals</strong>里面。创建Rect对象使用一样的元组参数。</p>
<pre><code>my_rect3 = Rect(<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">150</span>)
my_rect4 = Rect((<span class="number">100</span>, <span class="number">100</span>), (<span class="number">200</span>, <span class="number">150</span>))
</code></pre><p>一旦创建了Rect对象，就可以使用它来调整位置和大小，检查一个点是否在其中，判断矩形是否交叉等。详细请参考<a href="http://www.pygame.org/docs/ref/rect.html" target="_blank" rel="external">http://www.pygame.org/docs/ref/rect.html</a></p>
<h3 id="剪裁">剪裁</h3><p>通常创建游戏画面的时候，你可能想只绘制一部分。为了解决这个问题，Surface有一个剪裁区域，定义了屏幕的哪一部分可以被绘制。使用<strong>set_clip</strong>方法设置剪裁区域，<strong>get_clip</strong>获得当前剪裁区域。</p>
<pre><code>screen.<span class="function"><span class="title">set_clip</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">640</span>, <span class="number">300</span>)</span></span>
<span class="function"><span class="title">draw_map</span><span class="params">()</span></span>
screen.<span class="function"><span class="title">set_clip</span><span class="params">(<span class="number">0</span>, <span class="number">300</span>, <span class="number">640</span>, <span class="number">180</span>)</span></span>
<span class="function"><span class="title">draw_panel</span><span class="params">()</span></span>
</code></pre><h3 id="子表面(Subsurface)">子表面(Subsurface)</h3><p>一个子表面在其它Surface里面的Surface。当你在子表面上画图时，也会画在父表面上。子表面的一个用法是画图形字体。<strong>pygame.font</strong>模块可以产生漂亮的一种颜色的文字，但是游戏可能需要更丰富的表现。你可以为每一个字母保存一个文本，但是更简单的方法是保存所有字母到一张图片，然后创建26个子表面。</p>
<p>使用Surface对象的<strong>subsurface</strong>方法创建子表面，它接收一个Rect参数，表示覆盖父表面哪一部分，返回一个新的和父表面一样格式的Surface对象。</p>
<pre><code>my_font_image = Pygame.load(<span class="string">"font.png"</span>)
letters = {}
letters[<span class="string">"a"</span>] = my_font_image.subsurface((<span class="number">0</span>,<span class="number">0</span>), (<span class="number">80</span>,<span class="number">80</span>))
letters[<span class="string">"b"</span>] = my_font_image.subsurface((<span class="number">80</span>,<span class="number">0</span>), (<span class="number">80</span>,<span class="number">80</span>))

subsurface(...)
    Surface.subsurface(Rect): <span class="keyword">return</span> Surface
    create a <span class="keyword">new</span> surface that references its parent
</code></pre><p>当你使用子表面时，需要记住它们拥有自己的坐标系统。</p>
<h3 id="填充表面">填充表面</h3><p><strong>fill</strong>方法使用指定颜色填充Surface对象。</p>
<pre><code>screen.fill((<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))
</code></pre><p><strong>fill</strong>方法也可以带一个可选的Rect参数，指定填充区域。</p>
<blockquote>
<p><strong>注意</strong> 如果你使用其它方法画整个屏幕，就不必调用<strong>fill</strong>来清屏了。</p>
</blockquote>
<h3 id="设置表面像素">设置表面像素</h3><p>你能对表面做的一个最基本的事情就是设置单一像素，效果就是画一个非常小的点。很少需要一次画一个像素，因为有更多有效的画图方式，但是你需要处理脱机图片将会很有用。<br>使用<strong>set_at</strong>方法，参数为坐标和颜色，可以在表面画一个像素。</p>
<pre><code><span class="keyword">import</span> pygame
from pygame.locals <span class="keyword">import</span> *
from sys <span class="keyword">import</span> exit
from random <span class="keyword">import</span> randint

pygame.init()
screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

<span class="keyword">while</span> True:
    <span class="keyword">for</span> event in pygame.event.<span class="keyword">get</span>():
        <span class="keyword">if</span> event.type == QUIT:
            exit()

    rand_col = (randint(0, 255), randint(0, 255), randint(0, 255))
    <span class="keyword">for</span> _ in xrange(100):
        rand_pos = (randint(0, 639), randint(0, 479))
        screen.set_at(rand_pos, rand_col)

    pygame.display.update()
</code></pre><h3 id="获得表面的像素">获得表面的像素</h3><p>与<strong>set_at</strong>相对的是<strong>get_at</strong>，它返回给定坐标像素的颜色。获取像素有时候对于碰撞检测很必要。</p>
<pre><code>my_color = screen.<span class="function"><span class="title">get_at</span><span class="params">((<span class="number">100</span>, <span class="number">100</span>)</span></span>)
</code></pre><blockquote>
<p><strong>注意</strong> <strong>get_at</strong>在读取硬件表面时很慢。显示可能是硬件表面，尤其是全屏显示的时候，所以这时应该避免使用<strong>get_at</strong>。</p>
</blockquote>
<h3 id="锁定Surface">锁定Surface</h3><p>当Pygame在surface上画图时，surface必须先锁定。当surface被锁定时，Pygame完全控制surface，计算机其它进程只能等到surface解锁时才能使用。当你在surface上画图时，加锁和解锁自动发生。但是如果Pygame需要做太多加锁和解锁，程序会变得没有效率。我们可以通过手动加锁和解锁来减少加锁和解锁的次数，从而提高运行速度。</p>
<blockquote>
<p><strong>注意</strong> <strong>lock</strong>和<strong>unlock</strong>的次数必须一样，如果忘记了<strong>unlock</strong>一个surface，Pygame将失去响应。</p>
</blockquote>
<pre><code><span class="keyword">import</span> pygame
from pygame.locals <span class="keyword">import</span> *
from sys <span class="keyword">import</span> exit
from random <span class="keyword">import</span> randint

pygame.init()
screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

<span class="keyword">while</span> True:
    <span class="keyword">for</span> event in pygame.event.<span class="keyword">get</span>():
        <span class="keyword">if</span> event.type == QUIT:
            exit()

    rand_col = (randint(0, 255), randint(0, 255), randint(0, 255))
    screen.lock()
    <span class="keyword">for</span> _ in xrange(100):
        rand_pos = (randint(0, 639), randint(0, 479))
        screen.set_at(rand_pos, rand_col)
    screen.unlock()
    pygame.display.update()
</code></pre><p>不是所有的surface需要加锁。硬件surface需要(屏幕通常是硬件surface)，普通的surface不需要。Pygame提供一个<strong>mustlock</strong>方法返回True如果surface需要加锁。加锁不需要加锁的surface没有问题。</p>
<h3 id="Blitting">Blitting</h3><p>最常用的surface对象的方法可能是<strong>blit</strong>，是位块传输(<strong>bit block transfer</strong>)的缩写。Blitting意思是从一个surface拷贝图片数据到另一个surface。你可以使用它来画背景，字体，角色和游戏中几乎所有的事。</p>
<p>为了blit一个surface，用目标surface对象调用<strong>blit</strong>，传递源surface和目的坐标。也可以只blit一部分surface。</p>
<pre><code>screen.blit(background, (<span class="number">0</span>,<span class="number">0</span>))
screen.blit(ogre, (<span class="number">300</span>, <span class="number">200</span>), (<span class="number">100</span>*frame_no, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>))
</code></pre><h1 id="用Pygame画图">用Pygame画图</h1><p>我们在之前的例子中已经使用过一些<strong>pygame.draw</strong>模块的函数了。这个模块的用途就是在屏幕上画几何图形。你可以使用它创建整个游戏而不需要加载其它图片。</p>
<p><strong>pygame.draw</strong>模块的函数前两个参数都是surface和颜色。每一个函数也会至少带一个点，也许是一个点的列表。每个点是一个包含坐标的元组。</p>
<p>画图函数返回一个Rect对象包含了绘制过的区域，对于只想绘制屏幕的一部分很有用。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>rect</td>
<td style="text-align:left">绘制矩形</td>
</tr>
<tr>
<td>polygon</td>
<td style="text-align:left">绘制多边形(三条边或更多)</td>
</tr>
<tr>
<td>circle</td>
<td style="text-align:left">绘制圆</td>
</tr>
<tr>
<td>ellipse</td>
<td style="text-align:left">绘制椭圆</td>
</tr>
<tr>
<td>arc</td>
<td style="text-align:left">绘制圆弧</td>
</tr>
<tr>
<td>line</td>
<td style="text-align:left">绘制直线</td>
</tr>
<tr>
<td>lines</td>
<td style="text-align:left">绘制多个直线</td>
</tr>
<tr>
<td>aaline</td>
<td style="text-align:left">绘制平滑直线</td>
</tr>
<tr>
<td>aalines</td>
<td style="text-align:left">绘制多个平滑直线</td>
</tr>
</tbody>
</table>
<h3 id="pygame-draw-rect">pygame.draw.rect</h3><p>这个函数在surface上画一个矩形。除了目的surface和颜色，<strong>pygame.draw.rect</strong>接收一个Rect对象和width作为参数。如果width为0或忽略，则用固定颜色填充矩形，否则只画边缘。</p>
<pre><code><span class="keyword">import</span> pygame
from pygame.locals <span class="keyword">import</span> *
from sys <span class="keyword">import</span> exit

from random <span class="keyword">import</span> *

pygame.<span class="keyword">init</span>()
screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

<span class="keyword">while</span> <span class="type">True</span>:
    <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.<span class="keyword">get</span>():
        <span class="keyword">if</span> event.type == <span class="type">QUIT</span>:
            exit()

    screen.lock()
    <span class="keyword">for</span> <span class="built_in">count</span> <span class="keyword">in</span> range(<span class="number">10</span>):
        random_color = (randint(<span class="number">0</span>, <span class="number">255</span>), randint(<span class="number">0</span>, <span class="number">255</span>), randint(<span class="number">0</span>, <span class="number">255</span>))
        random_pos = (randint(<span class="number">0</span>, <span class="number">639</span>), randint(<span class="number">0</span>, <span class="number">479</span>))
        random_size = (<span class="number">639</span> - randint(random_pos[<span class="number">0</span>], <span class="number">639</span>), <span class="number">479</span> -
            randint(random_pos[<span class="number">1</span>], <span class="number">479</span>))
        pygame.draw.rect(screen, random_color, <span class="type">Rect</span>(random_pos, random_size))
    screen.unlock()

    pygame.display.update()
</code></pre><p>还有另外一个方法画填充的矩形。surface的<strong>fill</strong>方法接收一个Rect对象指定要填充的区域。<strong>fill</strong>比<strong>pygame.draw.rect</strong>要快，因为<strong>fill</strong>由显卡来执行。</p>
<h3 id="pygame-draw-polygon">pygame.draw.polygon</h3><p><strong>pygame.draw.polygon</strong>接收一系列点的列表并在它们之间画形状。它也有一个width参数，如果width被忽略或设置为0，则多边形被填充，否则只画边缘。</p>
<pre><code>import pygame
<span class="keyword">from</span> pygame.locals import *
<span class="keyword">from</span> sys import <span class="keyword">exit</span>

pygame.init()
screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

points = []

<span class="keyword">while</span> <span class="keyword">True</span>:
    <span class="keyword">for</span> <span class="keyword">event</span> <span class="keyword">in</span> pygame.<span class="keyword">event</span>.get():
        <span class="keyword">if</span> <span class="keyword">event</span>.<span class="keyword">type</span> == QUIT:
            <span class="keyword">exit</span>()
        <span class="keyword">if</span> <span class="keyword">event</span>.<span class="keyword">type</span> == MOUSEBUTTONDOWN:
            points.append(<span class="keyword">event</span>.pos)

    screen.fill((<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))

    <span class="keyword">if</span> len(points) &gt;= <span class="number">3</span>:
        pygame.draw.polygon(screen, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), points, <span class="number">1</span>)
    <span class="keyword">for</span> point <span class="keyword">in</span> points:
        pygame.draw.circle(screen, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), point, <span class="number">5</span>)

    pygame.display.update()
</code></pre><h3 id="pygame-draw-circle">pygame.draw.circle</h3><p><strong>circle</strong>函数在surface上画圆。它接收一个圆心坐标和半径作为参数。和之前一样，width参数如果为0或忽略，则圆被填充，否则只画边缘。</p>
<pre><code>import pygame
from pygame.locals import *
from sys import <span class="built_in">exit</span>
from random import *

pygame.init()
screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

<span class="keyword">while</span> True:
    <span class="keyword">for</span> event in pygame.event.get():
        <span class="keyword">if</span> event.type == QUIT:
            <span class="built_in">exit</span>()

    random_color = (randint(<span class="number">0</span>, <span class="number">255</span>), randint(<span class="number">0</span>, <span class="number">255</span>), randint(<span class="number">0</span>, <span class="number">255</span>))
    random_pos = (randint(<span class="number">0</span>, <span class="number">639</span>), randint(<span class="number">0</span>, <span class="number">479</span>))
    random_radius = randint(<span class="number">1</span>, <span class="number">200</span>)
    pygame.draw.circle(screen, random_color, random_pos, random_radius)

    pygame.display.update()
</code></pre><h3 id="pygame-draw-ellipse">pygame.draw.ellipse</h3><p><strong>用法</strong>： pygame.draw.ellipse(Surface, color, Rect, width=0)</p>
<pre><code>from random import *
import pygame
from pygame.locals import *
from sys import <span class="built_in">exit</span>

pygame.init()
screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

<span class="keyword">while</span> True:
    <span class="keyword">for</span> event in pygame.event.get():
        <span class="keyword">if</span> event.type == QUIT:
            <span class="built_in">exit</span>()

    x, y = pygame.mouse.get_pos()
    screen.fill((<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))
    pygame.draw.ellipse(screen, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">0</span>, x, y))

    pygame.display.update()
</code></pre><h3 id="pygame-draw-arc">pygame.draw.arc</h3><p><strong>用法</strong>：pygame.draw.arc(Surface, color, Rect, start_angle, stop_angle, width=1)<br><strong>arc</strong>函数仅仅画椭圆的一部分，而且只画边缘。圆弧是不封闭的，因此没有<strong>fill</strong>方法。这个函数的width参数默认为1，你也可以设置为更大的值以得到更粗的线。</p>
<pre><code>from random import *
from math import pi
import pygame
from pygame.locals import *
from sys import <span class="built_in">exit</span>

pygame.init()
screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

<span class="keyword">while</span> True:
    <span class="keyword">for</span> event in pygame.event.get():
        <span class="keyword">if</span> event.type == QUIT:
            <span class="built_in">exit</span>()

    x, y = pygame.mouse.get_pos()
    angle = (x / <span class="number">639.</span>) * pi * <span class="number">2</span>
    screen.fill((<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))
    pygame.draw.arc(screen, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">639</span>, <span class="number">479</span>), <span class="number">0</span>, angle)

    pygame.display.update()
</code></pre><h3 id="pygame-draw-line">pygame.draw.line</h3><p><strong>用法</strong>：pygame.draw.line(Surface, color, start_pos, end_pos, width=1)</p>
<pre><code><span class="keyword">import</span> pygame
from pygame.locals <span class="keyword">import</span> *
from sys <span class="keyword">import</span> exit

pygame.init()
screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

<span class="keyword">while</span> True:
    <span class="keyword">for</span> event in pygame.event.<span class="keyword">get</span>():
        <span class="keyword">if</span> event.type == QUIT:
            exit()

    screen.fill((255, 255, 255))
    mouse_pos = pygame.mouse.get_pos()

    <span class="keyword">for</span> x in xrange(0, 640, 20):
        pygame.draw.line(screen, (0, 0, 0), (x, 0), mouse_pos)
        pygame.draw.line(screen, (0, 0, 0), (x, 479), mouse_pos)

    <span class="keyword">for</span> y in xrange(0, 480, 20):
        pygame.draw.line(screen, (0, 0, 0), (0, y), mouse_pos)
        pygame.draw.line(screen, (0, 0, 0), (639, y), mouse_pos)

    pygame.display.update()
</code></pre><h3 id="pygame-draw-lines">pygame.draw.lines</h3><p><strong>用法</strong>：pygame.draw.lines(Surface, color, closed, pointlist, width=1)</p>
<p>closed是一个布尔值，指明是否需要多画一条线来使这些线条闭合。</p>
<pre><code>import pygame
<span class="keyword">from</span> pygame.locals import *
<span class="keyword">from</span> sys import <span class="keyword">exit</span>

pygame.init()
screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

points = []

<span class="keyword">while</span> <span class="keyword">True</span>:
    <span class="keyword">for</span> <span class="keyword">event</span> <span class="keyword">in</span> pygame.<span class="keyword">event</span>.get():
        <span class="keyword">if</span> <span class="keyword">event</span>.<span class="keyword">type</span> == QUIT:
            <span class="keyword">exit</span>()
        <span class="keyword">if</span> <span class="keyword">event</span>.<span class="keyword">type</span> == MOUSEMOTION:
            points.append(<span class="keyword">event</span>.pos)
            <span class="keyword">if</span> len(points) &gt; <span class="number">100</span>:
                del points[<span class="number">0</span>]

    screen.fill((<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))

    <span class="keyword">if</span> len(points) &gt; <span class="number">1</span>:
        pygame.draw.lines(screen, (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="keyword">False</span>, points, <span class="number">2</span>)

    pygame.display.update()
</code></pre><h3 id="pygame-draw-aaline">pygame.draw.aaline</h3><p><strong>用法</strong>：pygame.draw.aaline(Surface, color, start_pos, end_pos, width=1)</p>
<p>你可能注意到了上一个画线函数画出的线有锯齿。这是因为一个像素对应一个坐标，而这个坐标可能没有直接在线里面，这个现象叫做锯齿。任何试图避免或减少锯齿的方法称为抗锯齿。</p>
<p><strong>pygame.draw.aaline</strong>和<strong>pygame.draw.line</strong>参数一样，但是能画出平滑的直线。缺点是它慢一点。</p>
<h3 id="pygame-draw-aalines">pygame.draw.aalines</h3><p><strong>用法</strong>：pygame.draw.aalines(Surface, color, closed, pointlist, width=1)</p>
<p><strong>pygame.draw.aalines</strong>和<strong>pygame.draw.lines</strong>用法一样。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>电脑游戏倾向于视觉上很自然，游戏开发者花费很多精力在处理图像和提升视觉效果来创建最令人愉快的体验上。</p>
<h1 id="像素的威力">像素的威力</h1><p>显示器里的一个独立的点称为一个图像单元或像素。如果一个显示器分辨率为1280x1024，则像素总数为1310]]>
    </summary>
    
      <category term="Pygame" scheme="https://opensvn.github.io/tags/Pygame/"/>
    
      <category term="Python" scheme="https://opensvn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Pygame第三章 Pygame介绍]]></title>
    <link href="https://opensvn.github.io/2015/11/02/pygame-3/"/>
    <id>https://opensvn.github.io/2015/11/02/pygame-3/</id>
    <published>2015-11-02T00:16:02.000Z</published>
    <updated>2015-11-19T02:30:42.293Z</updated>
    <content type="html"><![CDATA[<h1 id="安装Pygame">安装Pygame</h1><p>Ubuntu下安装Pygame:</p>
<pre><code>sudo apt-<span class="built_in">get</span> install <span class="keyword">python</span>-pygame
</code></pre><p>装好后，查看Pygame版本:</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; import pygame
<span class="prompt">&gt;&gt;</span>&gt; print pygame.ver
</code></pre><h1 id="使用Pygame">使用Pygame</h1><p>Pygame有很多模块。每一个设备都有一个对应的模块。Pygame模块一览：</p>
<table>
<thead>
<tr>
<th>模块名</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>pygame.cdrom</td>
<td style="text-align:left">访问和控制光驱</td>
</tr>
<tr>
<td>pygame.cursors</td>
<td style="text-align:left">加载光标图片</td>
</tr>
<tr>
<td>pygame.display</td>
<td style="text-align:left">访问显示设备</td>
</tr>
<tr>
<td>pygame.draw</td>
<td style="text-align:left">绘制形状、线和点</td>
</tr>
<tr>
<td>pygame.event</td>
<td style="text-align:left">管理事件</td>
</tr>
<tr>
<td>pygame.font</td>
<td style="text-align:left">使用字体</td>
</tr>
<tr>
<td>pygame.image</td>
<td style="text-align:left">加载和存储图片</td>
</tr>
<tr>
<td>pygame.joystick</td>
<td style="text-align:left">使用游戏手柄或者类似设备</td>
</tr>
<tr>
<td>pygame.key</td>
<td style="text-align:left">读取键盘按键</td>
</tr>
<tr>
<td>pygame.mixer</td>
<td style="text-align:left">加载和播放声音</td>
</tr>
<tr>
<td>pygame.mouse</td>
<td style="text-align:left">管理鼠标</td>
</tr>
<tr>
<td>pygame.movie</td>
<td style="text-align:left">播放视频</td>
</tr>
<tr>
<td>pygame.music</td>
<td style="text-align:left">处理音乐和音频流</td>
</tr>
<tr>
<td>pygame.overlay</td>
<td style="text-align:left">访问高级视频叠加</td>
</tr>
<tr>
<td>pygame</td>
<td style="text-align:left">包含高层Pygame函数</td>
</tr>
<tr>
<td>pygame.rect</td>
<td style="text-align:left">管理矩形区域</td>
</tr>
<tr>
<td>pygame.sndarray</td>
<td style="text-align:left">操作声音数据</td>
</tr>
<tr>
<td>pygame.sprite</td>
<td style="text-align:left">操作移动图像</td>
</tr>
<tr>
<td>pygame.surface</td>
<td style="text-align:left">管理图像和屏幕</td>
</tr>
<tr>
<td>pygame.surfarray</td>
<td style="text-align:left">管理点阵图像数据</td>
</tr>
<tr>
<td>pygame.time</td>
<td style="text-align:left">管理时间和帧信息</td>
</tr>
<tr>
<td>pygame.transform</td>
<td style="text-align:left">缩放和移动图像</td>
</tr>
</tbody>
</table>
<p>有些模块可能在某些平台上不存在，比如游戏运行的硬件驱动没有安装，这种情况下，Pygame将设置这个模块为None，可以使用None来测试。下面这段代码检测<code>pygame.font</code>是否可用：</p>
<pre><code><span class="keyword">if</span> pygame<span class="class">.font</span> is None:
    print <span class="string">'The font module is not available!'</span>
    <span class="function"><span class="title">exit</span><span class="params">()</span></span>
</code></pre><h1 id="重温Hello_World">重温Hello World</h1><pre><code>background_image_filename = <span class="string">'sushiplate.jpg'</span>
mouse_image_filename = <span class="string">'fugu.png'</span>

<span class="keyword">import</span> pygame
from pygame.locals <span class="keyword">import</span> *
from sys <span class="keyword">import</span> exit

pygame.init()

screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)
pygame.display.set_caption(<span class="string">'Hello, World!'</span>)

background = pygame.image.load(background_image_filename).convert()
mouse_cursor = pygame.image.load(mouse_image_filename).convert_alpha()

<span class="keyword">while</span> True:
    <span class="keyword">for</span> event in pygame.event.<span class="keyword">get</span>():
        <span class="keyword">if</span> event.type == QUIT:
            exit()

    screen.blit(background, (0, 0))

    x, y = pygame.mouse.get_pos()
    x -= mouse_cursor.get_width() / 2
    y -= mouse_cursor.get_height() / 2
    screen.blit(mouse_cursor, (x, y))

    pygame.display.update()
</code></pre><p>第一行导入pygame包，使我们可以访问它的所有子模块。第二行导入一些常用函数和常量，这个不是必须的，但是更方便。</p>
<p><strong>pygame.init()</strong>非常简单，实际上却做了非常多工作。它初始化每一个Pygame的子模块。可以单独初始化某一个模块，比如<strong>pygame.sound.init()</strong>。</p>
<p><strong>pygame.display.set_mode</strong>返回一个Surface对象，代表桌面窗口。第一个参数为元祖，代表分辨率(必须)。第二个是一个标志位，具体意思见下表，如果不用什么特性，就指定0。第三个为色深，如果未提供或设置为0，Pygame将使用当前桌面的值。</p>
<table>
<thead>
<tr>
<th>标志位</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>FULLSCREEN</td>
<td style="text-align:left">创建一个全屏窗口</td>
</tr>
<tr>
<td>DOUBLEBUF</td>
<td style="text-align:left">创建一个“双缓冲”窗口，建议在HWSURFACE或者OPENGL时使用</td>
</tr>
<tr>
<td>HWSURFACE</td>
<td style="text-align:left">创建一个硬件加速的窗口，必须和FULLSCREEN同时使用</td>
</tr>
<tr>
<td>OPENGL</td>
<td style="text-align:left">创建一个OpenGL渲染的窗口</td>
</tr>
<tr>
<td>RESIZABLE</td>
<td style="text-align:left">创建一个可变大小的窗口</td>
</tr>
<tr>
<td>NOFRAME</td>
<td style="text-align:left">创建一个没有边框的窗口</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>色深</th>
<th style="text-align:left">颜色个数</th>
</tr>
</thead>
<tbody>
<tr>
<td>8 bits</td>
<td style="text-align:left">256种颜色</td>
</tr>
<tr>
<td>15 bits</td>
<td style="text-align:left">32768种颜色，空闲一位</td>
</tr>
<tr>
<td>16 bits</td>
<td style="text-align:left">65536种颜色</td>
</tr>
<tr>
<td>24 bits</td>
<td style="text-align:left">16.7百万种颜色</td>
</tr>
<tr>
<td>32 bits</td>
<td style="text-align:left">16.7百万种颜色，空闲8位</td>
</tr>
</tbody>
</table>
<p><strong>load</strong>函数读取一个文件并返回一个包含图片数据的Surface对象，直到画出来之前是不可见的。<br><strong>convert</strong>函数是将图像数据转化为Surface对象，每次加载完图像以后就应该做这件事件(事实上因为它太常用了，如果你不写Pygame也会帮你做)；<br><strong>convert_alpha</strong>相比<strong>convert</strong>，保留了Alpha通道信息(可以简单理解为透明的部分)，这样我们的光标才可以是不规则的形状。</p>
<p>游戏的主循环是一个无限循环，直到用户跳出。在这个主循环里做的事情就是不停地画背景和更新光标位置，虽然背景是不动的，我们还是需要每次都画它，否则鼠标覆盖过的位置就不能恢复正常了。<br>画完以后一定要<strong>update</strong>更新一下，否则画面一片漆黑。</p>
<pre><code><span class="function"><span class="title">init</span><span class="params">(...)</span></span>
    pygame.<span class="function"><span class="title">init</span><span class="params">()</span></span>: return (numpass, numfail)
    initialize all imported pygame modules

<span class="function"><span class="title">set_mode</span><span class="params">(...)</span></span>
    pygame<span class="class">.display</span><span class="class">.set_mode</span>(resolution=(<span class="number">0</span>,<span class="number">0</span>), flags=<span class="number">0</span>, depth=<span class="number">0</span>): return Surface
    initialize <span class="tag">a</span> window or screen <span class="keyword">for</span> <span class="attribute">display</span>

<span class="function"><span class="title">set_caption</span><span class="params">(...)</span></span>
    pygame<span class="class">.display</span><span class="class">.set_caption</span>(title, icontitle=None): return None
    set the current window <span class="tag">caption</span>

<span class="function"><span class="title">load</span><span class="params">(...)</span></span>
    pygame<span class="class">.image</span><span class="class">.load</span>(filename): return Surface
    pygame<span class="class">.image</span><span class="class">.load</span>(fileobj, namehint=): return Surface
    load new image from <span class="tag">a</span> file

<span class="function"><span class="title">convert</span><span class="params">(...)</span></span>
    Surface.<span class="function"><span class="title">convert</span><span class="params">(Surface)</span></span>: return Surface
    Surface.<span class="function"><span class="title">convert</span><span class="params">(depth, flags=<span class="number">0</span>)</span></span>: return Surface
    Surface.<span class="function"><span class="title">convert</span><span class="params">(masks, flags=<span class="number">0</span>)</span></span>: return Surface
    Surface.<span class="function"><span class="title">convert</span><span class="params">()</span></span>: return Surface
    change the pixel format of an image

<span class="function"><span class="title">convert_alpha</span><span class="params">(...)</span></span>
    Surface.<span class="function"><span class="title">convert_alpha</span><span class="params">(Surface)</span></span>: return Surface
    Surface.<span class="function"><span class="title">convert_alpha</span><span class="params">()</span></span>: return Surface
    change the pixel format of an image including per pixel alphas

<span class="function"><span class="title">get</span><span class="params">(...)</span></span>
    pygame<span class="class">.event</span><span class="class">.get</span>(): return Eventlist
    pygame<span class="class">.event</span><span class="class">.get</span>(type): return Eventlist
    pygame<span class="class">.event</span><span class="class">.get</span>(typelist): return Eventlist
    get events from the queue

<span class="function"><span class="title">blit</span><span class="params">(...)</span></span>
    Surface.<span class="function"><span class="title">blit</span><span class="params">(source, dest, area=None, special_flags = <span class="number">0</span>)</span></span>: return Rect
    draw one image onto another

<span class="function"><span class="title">get_pos</span><span class="params">(...)</span></span>
    pygame<span class="class">.mouse</span><span class="class">.get_pos</span>(): return (x, y)
    get the mouse <span class="attribute">cursor</span> <span class="attribute">position</span>

<span class="function"><span class="title">get_width</span><span class="params">(...)</span></span>
    Surface.<span class="function"><span class="title">get_width</span><span class="params">()</span></span>: return <span class="attribute">width</span>
    get the <span class="attribute">width</span> of the Surface

<span class="function"><span class="title">get_height</span><span class="params">(...)</span></span>
    Surface.<span class="function"><span class="title">get_height</span><span class="params">()</span></span>: return <span class="attribute">height</span>
    get the <span class="attribute">height</span> of the Surface

<span class="function"><span class="title">update</span><span class="params">(...)</span></span>
    pygame<span class="class">.display</span><span class="class">.update</span>(rectangle=None): return None
    pygame<span class="class">.display</span><span class="class">.update</span>(rectangle_list): return None
    update portions of the screen <span class="keyword">for</span> software displays
</code></pre><h1 id="理解事件">理解事件</h1><p>事件可以在任何时候产生，不管程序当前在做什么。因为你不能对发生的事件立刻做出反应，Pygame将事件存入一个队列，逐个处理。</p>
<h3 id="事件检索">事件检索</h3><p>上个程序中，使用<strong>pygame.event.get()</strong>来处理所有的事件，这就像打开大门让所有的人进入。如果我们使用<strong>pygame.event.wait()</strong>，Pygame就会等到一个事件发生才继续下去，就好像等在门口，直到有人来。这个函数不太常用，因为它会挂起程序直到有事情发生；而另外一个方法<strong>pygame.event.poll()</strong>就好一些，一旦调用，它会根据现在的情形返回一个真实的事件，否则返回一个类型为NOEVENT的假事件。</p>
<p>每隔一段固定的时间调用事件处理函数很有必要，这样Pygame才能在内部处理事件。如果不使用任何事件处理函数，也可以调用<strong>pygame.event.pump()</strong>替代事件循环。</p>
<p>事件对象包含一些描述事件发生的成员变量。所有事件对象都有一个事件类型。</p>
<table>
<thead>
<tr>
<th>事件</th>
<th style="text-align:left">产生途径</th>
<th style="text-align:left">参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>QUIT</td>
<td style="text-align:left">用户点击关闭按钮</td>
<td style="text-align:left">none</td>
</tr>
<tr>
<td>ACTIVEEVENT</td>
<td style="text-align:left">Pygame被激活或隐藏</td>
<td style="text-align:left">gain,state</td>
</tr>
<tr>
<td>KEYDOWN</td>
<td style="text-align:left">键盘按下</td>
<td style="text-align:left">unicode,key,mod</td>
</tr>
<tr>
<td>KEYUP</td>
<td style="text-align:left">键盘松开</td>
<td style="text-align:left">key,mod</td>
</tr>
<tr>
<td>MOUSEMOTION</td>
<td style="text-align:left">鼠标移动</td>
<td style="text-align:left">pos,rel,buttons</td>
</tr>
<tr>
<td>MOUSEBUTTONDOWN</td>
<td style="text-align:left">鼠标按下</td>
<td style="text-align:left">pos,button</td>
</tr>
<tr>
<td>MOUSEBUTTONUP</td>
<td style="text-align:left">鼠标松开</td>
<td style="text-align:left">pos,button</td>
</tr>
<tr>
<td>JOYAXISMOTION</td>
<td style="text-align:left">游戏手柄(Joystick or pad)移动</td>
<td style="text-align:left">joy,axis,value</td>
</tr>
<tr>
<td>JOYBALLMOTION</td>
<td style="text-align:left">游戏球(Joy ball)移动</td>
<td style="text-align:left">joy,ball,rel</td>
</tr>
<tr>
<td>JOYHATMOTION</td>
<td style="text-align:left">游戏手柄(Joystick)移动</td>
<td style="text-align:left">joy,hat,value</td>
</tr>
<tr>
<td>JOYBUTTONDOWN</td>
<td style="text-align:left">游戏手柄按下</td>
<td style="text-align:left">joy,button</td>
</tr>
<tr>
<td>JOYBUTTONUP</td>
<td style="text-align:left">游戏手柄放开</td>
<td style="text-align:left">joy,button</td>
</tr>
<tr>
<td>VIDEORESIZE</td>
<td style="text-align:left">Pygame窗口缩放</td>
<td style="text-align:left">size,w,h</td>
</tr>
<tr>
<td>VIDEOEXPOSE</td>
<td style="text-align:left">部分或所有Pygame窗口暴露</td>
<td style="text-align:left">none</td>
</tr>
<tr>
<td>USEREVENT</td>
<td style="text-align:left">触发一个用户事件</td>
<td style="text-align:left">code</td>
</tr>
</tbody>
</table>
<pre><code>import pygame
<span class="keyword">from</span> pygame.locals import *
<span class="keyword">from</span> sys import <span class="keyword">exit</span>

pygame.init()
SCREEN_SIZE = (<span class="number">800</span>, <span class="number">600</span>)
screen = pygame.display.set_mode(SCREEN_SIZE, <span class="number">0</span>, <span class="number">32</span>)

font = pygame.font.SysFont(<span class="comment">'arial', 16)</span>
font_height = font.get_linesize()
event_text = []

<span class="keyword">while</span> <span class="literal">True</span>:
    <span class="keyword">event</span> = pygame.<span class="keyword">event</span>.wait()
    event_text.append(str(<span class="keyword">event</span>))
    event_text = event_text[-SCREEN_SIZE[<span class="number">1</span>]/font_height:]

    <span class="keyword">if</span> <span class="keyword">event</span>.type == QUIT:
        <span class="keyword">exit</span>()

    screen.fill((<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))

    y = SCREEN_SIZE[<span class="number">1</span>] - font_height
    <span class="keyword">for</span> <span class="keyword">text</span> <span class="keyword">in</span> reversed(event_text):
        screen.blit(font.render(<span class="keyword">text</span>, <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)), (<span class="number">0</span>, y))
        y -= font_height

    pygame.display.update()
</code></pre><p><strong>pygame.font.SysFont</strong>返回一个pygame.font.Font对象。</p>
<pre><code><span class="function"><span class="title">SysFont</span><span class="params">(name, size, bold=False, italic=False)</span></span>
    pygame<span class="class">.font</span><span class="class">.SysFont</span>(name, size, bold=False, italic=False) -&gt; Font
    create <span class="tag">a</span> pygame Font from system <span class="attribute">font</span> resources

    This will search the system fonts <span class="keyword">for</span> the given <span class="attribute">font</span>
    name. You can also enable bold or italic styles, and
    the appropriate system <span class="attribute">font</span> will be selected <span class="keyword">if</span> available.

    This will always return <span class="tag">a</span> valid Font <span class="tag">object</span>, and will
    fallback on the builtin pygame <span class="attribute">font</span> <span class="keyword">if</span> the given <span class="attribute">font</span>
    is not found.

    Name can also be <span class="tag">a</span> comma separated list of names, <span class="keyword">in</span>
    which case set of names will be searched <span class="keyword">in</span> <span class="attribute">order</span>. Pygame
    uses <span class="tag">a</span> small set of common <span class="attribute">font</span> aliases, <span class="keyword">if</span> the specific
    <span class="attribute">font</span> you ask <span class="keyword">for</span> is not available, <span class="tag">a</span> reasonable alternative
    may be used.

<span class="function"><span class="title">get_linesize</span><span class="params">(...)</span></span>
    Font.<span class="function"><span class="title">get_linesize</span><span class="params">()</span></span>: return int
    get the line space of the <span class="attribute">font</span> text

<span class="function"><span class="title">wait</span><span class="params">(...)</span></span>
    pygame<span class="class">.event</span><span class="class">.wait</span>(): return Event
    wait <span class="keyword">for</span> <span class="tag">a</span> single event from the queue

<span class="function"><span class="title">render</span><span class="params">(...)</span></span>
    Font.<span class="function"><span class="title">render</span><span class="params">(text, antialias, color, background=None)</span></span>: return Surface
    draw text on <span class="tag">a</span> new Surface

<span class="function"><span class="title">fill</span><span class="params">(...)</span></span>
    Surface.<span class="function"><span class="title">fill</span><span class="params">(color, rect=None, special_flags=<span class="number">0</span>)</span></span>: return Rect
    fill Surface with <span class="tag">a</span> solid <span class="attribute">color</span>

<span class="function"><span class="title">pump</span><span class="params">(...)</span></span>
    pygame<span class="class">.event</span><span class="class">.pump</span>(): return None
    internally process pygame event handlers
</code></pre><h3 id="处理鼠标移动事件">处理鼠标移动事件</h3><p>当鼠标移动时，<strong>MOUSEMOTION</strong>事件发生。包含下面三个值：</p>
<ul>
<li>buttons-一个对应鼠标按钮的元组。buttons[0]是鼠标左按钮，buttons[1]是鼠标中间按钮，buttons[2]是鼠标右按钮。如果按钮被按下，则值为1，反之为0。多个按钮可以同时按下。</li>
<li>pos-一个元组，包含事件发生时鼠标所在位置。</li>
<li>rel-一个元祖，包含现在距离上次产生鼠标事件时的距离。</li>
</ul>
<h3 id="处理鼠标按钮事件">处理鼠标按钮事件</h3><p>除了鼠标移动事件，鼠标还能产生<strong>MOUSEBUTTONDOWN</strong>和<strong>MOUSEBUTTONUP</strong>事件。包含下面2个值：</p>
<ul>
<li>button-被按下的按钮的数字。1为鼠标左按钮，2为鼠标中间按钮，3为鼠标右按钮。</li>
<li>pos-一个元组，包含事件发生时鼠标所在位置。</li>
</ul>
<h3 id="处理键盘事件">处理键盘事件</h3><p>键盘和游戏手柄的事件类似。当一个键被按下<strong>KEYDOWN</strong>事件发生。当一个键松开<strong>KEYUP</strong>事件发生。</p>
<pre><code>bg_file = <span class="comment">'sushiplate.jpg'</span>

import pygame
<span class="keyword">from</span> pygame.locals import *
<span class="keyword">from</span> sys import <span class="keyword">exit</span>

pygame.init()
screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), FULLSCREEN, <span class="number">32</span>)
background = pygame.image.load(bg_file).convert()

x, y = <span class="number">0</span>, <span class="number">0</span>
move_x, move_y = <span class="number">0</span>, <span class="number">0</span>

<span class="keyword">while</span> <span class="literal">True</span>:
    <span class="keyword">for</span> <span class="keyword">event</span> <span class="keyword">in</span> pygame.<span class="keyword">event</span>.<span class="keyword">get</span>():
        <span class="keyword">if</span> <span class="keyword">event</span>.type == QUIT:
            <span class="keyword">exit</span>()
        <span class="keyword">if</span> <span class="keyword">event</span>.type == KEYDOWN:
            <span class="keyword">if</span> <span class="keyword">event</span>.<span class="keyword">key</span> == K_LEFT:
                move_x = -<span class="number">1</span>
            elif <span class="keyword">event</span>.<span class="keyword">key</span> == K_RIGHT:
                move_x = <span class="number">1</span>
            elif <span class="keyword">event</span>.<span class="keyword">key</span> == K_UP:
                move_y = -<span class="number">1</span>
            elif <span class="keyword">event</span>.<span class="keyword">key</span> == K_DOWN:
                move_y = <span class="number">1</span>
        elif <span class="keyword">event</span>.type == KEYUP:
            <span class="keyword">if</span> <span class="keyword">event</span>.<span class="keyword">key</span> == K_LEFT <span class="keyword">or</span> <span class="keyword">event</span>.<span class="keyword">key</span> == K_RIGHT:
                move_x = <span class="number">0</span>
            elif <span class="keyword">event</span>.<span class="keyword">key</span> == K_UP <span class="keyword">or</span> <span class="keyword">event</span>.<span class="keyword">key</span> == K_DOWN:
                move_y = <span class="number">0</span>
    x += move_x
    y += move_y

    screen.fill((<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))
    screen.blit(background, (x, y))

    pygame.display.update()
</code></pre><p><strong>KEYDOWN</strong>和<strong>KEYUP</strong>事件包含下面三个值：</p>
<ul>
<li>key-这是一个代表按下或松开的键值的数字。每一个键盘上的物理按钮都有一个以K_开头的常量。字母键为K_a到K_z，其它的如K_SPACE和K_RETURN。</li>
<li>mod-这个值代表和key组合使用的其它键，比如Shift，Alt和Ctrl。每一个组合键以KMOD_开头，比如KMOD_SHIFT，KMOD_ALT和KMOD_CTRL。如果mod &amp; KMOD_CTRL为真，则表示按下了Ctrl键。</li>
<li>unicode-这个是被按下的键的Unicode值。每一个符号都有一个Unicode值与它对应。</li>
</ul>
<h3 id="过滤事件">过滤事件</h3><p>一个游戏不是所有的事件都需要处理，而且通常存在其它方式获取某个事件可能提供的信息。比如，使用<strong>pygame.mouse.get_pos()</strong>就不需要响应<strong>MOUSEMOTION</strong>事件了。</p>
<p>使用<strong>pygame.event.set_blocked</strong>函数可以屏蔽事件，阻止事件进入事件队列。比如：</p>
<pre><code>pygame<span class="class">.event</span><span class="class">.set_blocked</span>(MOUSEMOTION)
pygame<span class="class">.event</span><span class="class">.set_blocked</span>([KEYDOWN, KEYUP])
pygame<span class="class">.event</span><span class="class">.set_blocked</span>(None)

<span class="function"><span class="title">set_blocked</span><span class="params">(...)</span></span>
    pygame<span class="class">.event</span><span class="class">.set_blocked</span>(type): return None
    pygame<span class="class">.event</span><span class="class">.set_blocked</span>(typelist): return None
    pygame<span class="class">.event</span><span class="class">.set_blocked</span>(None): return None
    control which events are allowed on the queue
</code></pre><p>与之相对的，<strong>pygame.event.set_allowed</strong>设定允许的事件。</p>
<pre><code><span class="function"><span class="title">set_allowed</span><span class="params">(...)</span></span>
    pygame<span class="class">.event</span><span class="class">.set_allowed</span>(type): return None
    pygame<span class="class">.event</span><span class="class">.set_allowed</span>(typelist): return None
    pygame<span class="class">.event</span><span class="class">.set_allowed</span>(None): return None
    control which events are allowed on the queue
</code></pre><p><strong>pygame.event.get_blocked</strong>可以查询一个事件是否被屏蔽。</p>
<pre><code><span class="function"><span class="title">get_blocked</span><span class="params">(...)</span></span>
    pygame<span class="class">.event</span><span class="class">.get_blocked</span>(type): return bool
    test <span class="keyword">if</span> <span class="tag">a</span> type of event is blocked from the queue
</code></pre><h3 id="产生事件">产生事件</h3><p>通常Pygame为你产生相应的事件，但是你也可以产生自己的事件。为了产生一个事件，必须首先使用<strong>pygame.event.Event</strong>创建一个事件对象，然后使用<strong>pygame.event.post</strong>发送到事件队列尾端。</p>
<pre><code>my_event = pygame.event.Event(KEYDOWN, key=K_SPACE, mod=<span class="number">0</span>, unicode=<span class="string">u' '</span>)
pgame.event.post(my_event)
</code></pre><p>事件构造函数接收事件类型和事件值参数。</p>
<pre><code><span class="function"><span class="title">Event</span><span class="params">(...)</span></span>
    pygame<span class="class">.event</span><span class="class">.Event</span>(type, dict): return Event
    pygame<span class="class">.event</span><span class="class">.Event</span>(type, **attributes): return Event
    create <span class="tag">a</span> new event <span class="tag">object</span>

<span class="function"><span class="title">post</span><span class="params">(...)</span></span>
    pygame<span class="class">.event</span><span class="class">.post</span>(Event): return None
    place <span class="tag">a</span> new event on the queue
</code></pre><p>除了模拟Pygame产生的事件，也可以创建新的事件。你只需使用一个大于<strong>USEREVENT</strong>的值作为事件的值。</p>
<pre><code>CATONKEYBOARD = USEREVENT + <span class="number">1</span>
my_event = pygame<span class="class">.event</span><span class="class">.Event</span>(CATONKEYBOARD, message=<span class="string">"Bad cat!"</span>)
pgame<span class="class">.event</span><span class="class">.post</span>(my_event)

<span class="keyword">for</span> event <span class="keyword">in</span> pygame<span class="class">.event</span><span class="class">.get</span>():
    <span class="keyword">if</span> event<span class="class">.type</span> == CATONKEYBOARD:
        print event.message
</code></pre><h1 id="打开一个显示">打开一个显示</h1><h3 id="全屏显示">全屏显示</h3><p><strong>pygame.display.set_mode</strong>第二个参数设置为<strong>FULLSCREEN</strong>，就能得到一个全屏窗口了。</p>
<pre><code>screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), FULLSCREEN, <span class="number">32</span>)
</code></pre><blockquote>
<p><strong>注意</strong><br>如果在全屏模式下出问题，有时候非常难回到桌面。因此进入全屏模式前，需要先在窗口模式下测试。同时提供一个退出程序方法，因为全屏模式下关闭按钮看不到。</p>
</blockquote>
<p>当进入全屏时，你的显卡可能会切换到不同的显示模式，这将改变显示的宽度，高度和一次显示颜色的数量。显卡只支持几种大小和颜色数量的组合。如果显示的大小不支持，Pygame将选择下一个大小，并居中显示。<strong>pygame.display.list_modes</strong>可以查看显卡支持的分辨率。</p>
<pre><code>&gt;&gt;&gt; import pygame
&gt;&gt;&gt; pygame.<span class="function"><span class="title">init</span><span class="params">()</span></span>
&gt;&gt;&gt; pygame<span class="class">.display</span><span class="class">.list_modes</span>()

<span class="function"><span class="title">list_modes</span><span class="params">(...)</span></span>
    pygame<span class="class">.display</span><span class="class">.list_modes</span>(depth=<span class="number">0</span>, flags=pygame.FULLSCREEN): return list
    get list of available fullscreen modes
</code></pre><p>如果显卡不支持你想要的颜色数量，Pygame将自动转换以适应当前显示设备。</p>
<pre><code>background_image_filename = <span class="string">'sushiplate.jpg'</span>

import pygame
<span class="keyword">from</span> pygame.locals import *
<span class="keyword">from</span> sys import <span class="keyword">exit</span>

pygame.init()
screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)
background = pygame.image.load(background_image_filename).convert()

Fullscreen = <span class="keyword">False</span>

<span class="keyword">while</span> <span class="keyword">True</span>:
    <span class="keyword">for</span> <span class="keyword">event</span> <span class="keyword">in</span> pygame.<span class="keyword">event</span>.get():
        <span class="keyword">if</span> <span class="keyword">event</span>.<span class="keyword">type</span> == QUIT:
            <span class="keyword">exit</span>()

    <span class="keyword">if</span> <span class="keyword">event</span>.<span class="keyword">type</span> == KEYDOWN:
        <span class="keyword">if</span> <span class="keyword">event</span>.key == K_f:
            Fullscreen = <span class="keyword">not</span> Fullscreen
            <span class="keyword">if</span> Fullscreen:
                screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), FULLSCREEN, <span class="number">32</span>)
            <span class="keyword">else</span>:
                screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

    screen.blit(background, (<span class="number">0</span>, <span class="number">0</span>))
    pygame.display.update()
</code></pre><h3 id="可变尺寸的Pygame窗口">可变尺寸的Pygame窗口</h3><p>有时候用户想要能够改变窗口大小，调用<strong>pygame.display.set_mode</strong>时使用<strong>RESIZABLE</strong>标志位，可以达到这个目的。Pygame通过发送包含新宽高的<strong>VIDEORESIZE</strong>事件告诉用户窗口大小改变了。当收到这个事件时，我们应该再次调用<strong>pygame.display.set_mode</strong>。</p>
<pre><code>background_image_filename = <span class="string">'sushiplate.jpg'</span>

import pygame
<span class="keyword">from</span> pygame.locals import *
<span class="keyword">from</span> sys import <span class="keyword">exit</span>

SCREEN_SIZE = (<span class="number">640</span>, <span class="number">480</span>)

pygame.init()
screen = pygame.display.set_mode(SCREEN_SIZE, RESIZABLE, <span class="number">32</span>)

background = pygame.image.load(background_image_filename).convert()

<span class="keyword">while</span> <span class="keyword">True</span>:
    <span class="keyword">event</span> = pygame.<span class="keyword">event</span>.wait()
    <span class="keyword">if</span> <span class="keyword">event</span>.<span class="keyword">type</span> == QUIT:
        <span class="keyword">exit</span>()
    <span class="keyword">if</span> <span class="keyword">event</span>.<span class="keyword">type</span> == VIDEORESIZE:
        SCREEN_SIZE = <span class="keyword">event</span>.size
        screen = pygame.display.set_mode(SCREEN_SIZE, RESIZABLE, <span class="number">32</span>)
        pygame.display.set_caption(<span class="string">'Window resized to '</span> + str(<span class="keyword">event</span>.size))

    screen_width, screen_height = SCREEN_SIZE
    <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">0</span>, screen_height, background.get_height()):
        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, screen_width, background.get_width()):
            screen.blit(background, (x, y))

    pygame.display.update()
</code></pre><p><strong>VIDEORESIZE</strong>事件包含下面的值：</p>
<ul>
<li>size-一个元组，包含更改后窗口的尺寸。size[0]代表宽度，size[1]代表高度。</li>
<li>w-宽度，和size[0]一样，但是更方便</li>
<li>h-高度，和size[1]一样，但是更方便</li>
</ul>
<h3 id="无边框窗口">无边框窗口</h3><p>当调用<strong>set_mode</strong>时使用<strong>NOFRAME</strong>标志可以设置一个无边框窗口。</p>
<h3 id="其它显示标志">其它显示标志</h3><p>通常最好是使用0显示窗口而使用<strong>FULLSCREEN</strong>全屏以保证程序在所有平台都能运行。其它高级标志也许会有兼容问题。<br>如果设置了<strong>HWSURFACE</strong>标志，将创建一个硬件显示，存储在显存里面，只能和<strong>FULLSCREEN</strong>一起使用。</p>
<pre><code>screen = pygame.display.set_mode(SCREEN_SIZE, HWSURFACE <span class="string">| FULLSCREEN, 32)</span>
</code></pre><p>硬件显示比常规显示更快，因为它能够利用显卡的特性加速显示，缺点是兼容性不够好。硬件显示也能从<strong>DOUBLEBUF</strong>标志受益。这个有效地创建2个硬件显示，但是一次只能看见一个。</p>
<pre><code>screen = pygame.display.set_mode(SCREEN_SIZE, DOUBLEBUF |<span class="string"> HWSURFACE </span>|<span class="string"> FULLSCREEN, 32)</span>
</code></pre><p>通常当你调用<strong>pygame.display.update()</strong>时，整个屏幕从内存拷贝到显示设备，这会花费一些时间。而双缓冲允许你立刻切换到新的屏幕，使你的程序运行更快。</p>
<blockquote>
<p><strong>注意</strong><br>如果使用双缓冲显示，应该调用<strong>pygame.display.flip()</strong>而不是<strong>pygame.display.update()</strong>。这个做立即显示切换而不是拷贝屏幕数据。</p>
</blockquote>
<pre><code><span class="function"><span class="title">flip</span><span class="params">(...)</span></span>
    pygame<span class="class">.display</span><span class="class">.flip</span>(): return None
    update the full <span class="attribute">display</span> Surface to the screen
</code></pre><p>最后一个显示标志是<strong>OPENGL</strong>，它能够使用3D加速显示。</p>
<h1 id="使用字体模块">使用字体模块</h1><p>字体模块使用TrueType字体(TTFs)。必须先创建一个Font对象才能使用字体。最简单的方式就是使用<strong>pygame.font.SysFont</strong>，它会使用系统自带的一个字体。</p>
<pre><code>my_font = pygame<span class="class">.font</span><span class="class">.SysFont</span>(<span class="string">"arial"</span>, <span class="number">16</span>)
</code></pre><p>第一个参数是你想要创建字体的名字，第二个参数指定了字体的大小。Pygame会在系统字体里面查找，如果没找到则返回一个默认字体。<strong>pygame.font.get_fonts()</strong>可以获得当前系统所有可用字体。也可以使用<strong>pygame.font.Font</strong>直接从.ttf文件创建字体。</p>
<pre><code>my_font = pygame.font.Font(<span class="string">"my_font.ttf"</span>, <span class="number">16</span>)

class Font(__builtin__.object)
 |  pygame.font.Font(filename, size): <span class="constant">return</span> Font
 |  pygame.font.Font(object, size): <span class="constant">return</span> Font
 |  <span class="built_in">create</span> <span class="operator">a</span> <span class="built_in">new</span> Font object <span class="built_in">from</span> <span class="operator">a</span> <span class="built_in">file</span>

get_fonts()
    pygame.font.get_fonts() -&gt; list
    <span class="built_in">get</span> <span class="operator">a</span> list <span class="operator">of</span> <span class="keyword">system</span> font names

    Returns <span class="operator">the</span> list <span class="operator">of</span> all found <span class="keyword">system</span> fonts. Note that
    <span class="operator">the</span> names <span class="operator">of</span> <span class="operator">the</span> fonts will be all lowercase <span class="operator">with</span> spaces
    removed. This is how pygame internally stores <span class="operator">the</span> font
    names <span class="keyword">for</span> matching.
</code></pre><p>一旦创建了Font对象，就可以使用Font对象的<strong>render</strong>函数来渲染文字。它创建一个新的包含文字的Surface，可以输出到显示设备。</p>
<pre><code>text_surface = my_font.<span class="function"><span class="title">render</span><span class="params">(<span class="string">"Pygame is cool!"</span>, True, (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))

<span class="function"><span class="title">render</span><span class="params">(...)</span></span>
    Font.<span class="function"><span class="title">render</span><span class="params">(text, antialias, color, background=None)</span></span>: return Surface
    draw text on <span class="tag">a</span> new Surface
</code></pre><p><strong>render</strong>的第一个参数是你想渲染的文字，它必须是一行。如果有多行，必须使用多个<strong>render</strong>调用。第二个参数是一个布尔值，用来开启抗锯齿。如果设置为True，则文字看起来会比较平滑。后面两个参数是文字的颜色和背景颜色。背景色是可选的，默认为透明的。</p>
<pre><code>import pygame
pygame.<span class="function"><span class="title">init</span><span class="params">()</span></span>

my_name = <span class="string">'Smith'</span>
my_font = pygame<span class="class">.font</span><span class="class">.SysFont</span>(<span class="string">'arial'</span>, <span class="number">64</span>)
name_surface = my_font.<span class="function"><span class="title">render</span><span class="params">(my_name, True, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))
pygame<span class="class">.image</span><span class="class">.save</span>(name_surface, <span class="string">'name.png'</span>)
</code></pre><p>font模块详尽参考见<a href="http://www.pygame.org/docs/ref/font.html" target="_blank" rel="external">http://www.pygame.org/docs/ref/font.html</a></p>
<blockquote>
<p><strong>注意</strong><br>安装的字体因机各异，不能保证某个字体一定存在。解决方法是.ttf文件同游戏一起发布，但必须得到字体作者的许可。</p>
</blockquote>
<h1 id="当Pygame出错">当Pygame出错</h1><p>当<strong>pygame.image.load</strong>不能读取图片时，Pygame会抛出<strong>pygame.error</strong>异常。</p>
<pre><code>&gt;&gt;&gt; import pygame
&gt;&gt;&gt; screen = pygame.<span class="keyword">display</span>.set_mode((640, 0))
Traceback (most recent call last):
<span class="keyword">File</span> <span class="string">"&lt;interactive input&gt;"</span>, <span class="keyword">line</span> 1, <span class="keyword">in</span> ?
pygame.<span class="keyword">error</span>: Cannot <span class="keyword">set</span> 0 sized <span class="keyword">display</span> mode

<span class="keyword">class</span> <span class="keyword">error</span>(exceptions.RuntimeError)
 |  Method resolution <span class="keyword">order</span>:
 |      <span class="keyword">error</span>
 |      exceptions.RuntimeError
 |      exceptions.StandardError
 |      exceptions.Exception
 |      exceptions.BaseException
 |      __builtin__.object
</code></pre><p>一般而言，当你碰到<strong>pygame.error</strong>异常时，你也做不了什么事，因为这说明一个比较大的故障发生了。通常你能做的就是指导用户怎么做。在一个大的项目里面，检查错误很重要。</p>
<pre><code>try:
    screen = pygame<span class="class">.display</span><span class="class">.set_mode</span>(SCREEN_SIZE)
except pygame<span class="class">.error</span>, e:
    print <span class="string">"Can't create the display :-("</span>
    print e
    <span class="function"><span class="title">exit</span><span class="params">()</span></span>
</code></pre><h1 id="Pygame动起来">Pygame动起来</h1><pre><code>background_image_filename = <span class="comment">'sushiplate.jpg'</span>
SCREEN_SIZE = (<span class="number">640</span>, <span class="number">480</span>)
message = <span class="comment">'    This is a demonstration of the scrolly message script.    '</span>

import pygame
<span class="keyword">from</span> pygame.locals import *
<span class="keyword">from</span> sys import <span class="keyword">exit</span>

pygame.init()
screen = pygame.display.set_mode(SCREEN_SIZE)

font = pygame.font.SysFont(<span class="comment">'arial', 80)</span>
text_surface = font.render(message, <span class="literal">True</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>))

x = <span class="number">0</span>
y = (SCREEN_SIZE[<span class="number">1</span>] - text_surface.get_height()) / <span class="number">2</span>

background = pygame.image.load(background_image_filename).convert()

<span class="keyword">while</span> <span class="literal">True</span>:
    <span class="keyword">for</span> <span class="keyword">event</span> <span class="keyword">in</span> pygame.<span class="keyword">event</span>.<span class="keyword">get</span>():
        <span class="keyword">if</span> <span class="keyword">event</span>.type == QUIT:
            <span class="keyword">exit</span>()

    screen.blit(background, (<span class="number">0</span>, <span class="number">0</span>))

    x -= <span class="number">2</span>
    <span class="keyword">if</span> x &lt; -text_surface.get_width():
        x = <span class="number">0</span>

    screen.blit(text_surface, (x, y))
    screen.blit(text_surface, (x + text_surface.get_width(), y))

    pygame.display.update()
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="安装Pygame">安装Pygame</h1><p>Ubuntu下安装Pygame:</p>
<pre><code>sudo apt-<span class="built_in">get</span> install <span class="keyword">p]]>
    </summary>
    
      <category term="Pygame" scheme="https://opensvn.github.io/tags/Pygame/"/>
    
      <category term="Python" scheme="https://opensvn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PyQt编程第八章 数据处理和自定义文件类型]]></title>
    <link href="https://opensvn.github.io/2015/10/30/pyqt-8/"/>
    <id>https://opensvn.github.io/2015/10/30/pyqt-8/</id>
    <published>2015-10-30T04:40:00.000Z</published>
    <updated>2015-10-30T05:11:35.842Z</updated>
    <content type="html"><![CDATA[<h1 id="主窗口的职责">主窗口的职责</h1><p>主窗口的职责通常是为用户提供高级文件处理动作和展示程序数据。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="主窗口的职责">主窗口的职责</h1><p>主窗口的职责通常是为用户提供高级文件处理动作和展示程序数据。</p>
]]>
    </summary>
    
      <category term="PyQt" scheme="https://opensvn.github.io/tags/PyQt/"/>
    
      <category term="Python" scheme="https://opensvn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PyQt编程第七章 使用Qt Designer]]></title>
    <link href="https://opensvn.github.io/2015/10/28/pyqt-7/"/>
    <id>https://opensvn.github.io/2015/10/28/pyqt-7/</id>
    <published>2015-10-28T00:50:57.000Z</published>
    <updated>2015-10-30T00:20:27.590Z</updated>
    <content type="html"><![CDATA[<p>用户界面保存在.ui文件中，包含一个窗口部件和布局的详细情况。<strong>Qt Designer</strong>能够关联标签和它的伙伴，<br>设置tab顺序(这个也可以用<code>QWidget.setTabOrder()</code>完成)。<strong>Qt Designer</strong>也能够关联信号和槽，<br>但是只能是内置的信号和槽。</p>
<p>一旦用户界面设计完成并保存在.ui文件，必须转化为代码才能使用。这个可以用<code>pyuic4</code>完成，比如：</p>
<pre><code>$ pyuic4 -o ui_findandreplacedlg<span class="class">.py</span> findandreplacedlg.ui
</code></pre><h1 id="设计用户界面">设计用户界面</h1><p>使用<strong>Qt Designer</strong>通用步骤：</p>
<ol>
<li>拖动一个部件到窗体合适的位置，通常只有容器部件需要改变大小。</li>
<li>设置部件的属性。如果部件会在代码里面用到，设置一个有意义的名字。</li>
<li>重复1和2直到所有部件都在窗体上。</li>
<li>如果存在大的间隙，添加间隔器。</li>
<li>选择2个或多个部件进行布局(Shift+Click)，使用一个布局管理器布局。</li>
<li>重复5直到所有部件已经布局完毕。</li>
<li>点击窗体(不选择任何部件)，使用一个布局管理器布局窗体。</li>
<li>创建标签的伙伴。</li>
<li>设置窗体的tab顺序，如果顺序错误。</li>
<li>创建合适的内置信号和槽的关联。</li>
<li>预览窗体，检查所有东西都按照自己的意图工作。</li>
<li>设置窗体的对象名字和标题并保存。</li>
</ol>
<p>尽管可以先将布局拖进窗体，然后再添加部件到布局，但是最好是先将部件添加到窗体，然后再进行布局。</p>
<p><code>addStretch()</code>和插入<code>QSpacerItem</code>一样。</p>
<p>预览窗口点击Form-&gt;Preview或者Ctrl+R。如果想预览不同风格，点击Form-&gt;Preview in</p>
<h1 id="实现对话框">实现对话框</h1><p>当使用<strong>Qt Designer</strong>创建一个用户界面时，我们使用多继承创建一个子类。第一个父类是<code>QDialog</code>，<br>第二个父类是用<strong>Qt Designer</strong>设计的界面。</p>
<pre><code><span class="import"><span class="keyword">import</span> re</span>
<span class="title">from</span> <span class="type">PyQt4</span>.<span class="type">QtCore</span> <span class="import"><span class="keyword">import</span> *</span>
<span class="title">from</span> <span class="type">PyQt4</span>.<span class="type">QtGui</span> <span class="import"><span class="keyword">import</span> *</span>
<span class="import"><span class="keyword">import</span> ui_findandreplacedlg</span>
<span class="class">
<span class="keyword">class</span> <span class="type">FindAndReplaceDlg</span><span class="container">(<span class="type">QDialog</span>,
    <span class="title">ui_findandreplacedlg</span>.<span class="type">Ui_FindAndReplaceDlg</span>)</span>:
    def __init__<span class="container">(<span class="title">self</span>, <span class="title">text</span>, <span class="title">parent</span>=<span class="type">None</span>)</span>:
        super<span class="container">(<span class="type">FindAndReplaceDlg</span>, <span class="title">self</span>)</span>.__init__<span class="container">(<span class="title">parent</span>)</span>
        self.__text = unicode<span class="container">(<span class="title">text</span>)</span>
        self.__index = 0
        self.setupUi<span class="container">(<span class="title">self</span>)</span>
        if not <span class="type">MAC</span>:
            self.findButton.setFocusPolicy<span class="container">(<span class="type">Qt</span>.<span class="type">NoFocus</span>)</span>
            self.replaceButton.setFocusPolicy<span class="container">(<span class="type">Qt</span>.<span class="type">NoFocus</span>)</span>
            self.replaceAllButton.setFocusPolicy<span class="container">(<span class="type">Qt</span>.<span class="type">NoFocus</span>)</span>
            self.closeButton.setFocusPolicy<span class="container">(<span class="type">Qt</span>.<span class="type">NoFocus</span>)</span>
        self.updateUi<span class="container">()</span></span>
</code></pre><p><code>setupUi()</code>方法由生成的ui模块提供，调用这个方法创建用户界面。<br><code>setupUi()</code>方法调用<code>QtCore.QMetaObject.connectSlotsByName()</code>创建信号和槽之间的联系。<br>任何具有形式<code>on_widgetName_signalName</code>的槽都有一个信号连接到它。</p>
<pre><code><span class="decorator">@pyqtSignature('QString')</span>
<span class="function"><span class="keyword">def</span> <span class="title">on_findLineText_textEdited</span><span class="params">(self, text)</span>:</span>
    self.__index = <span class="number">0</span>
    self.updateUi()
</code></pre><p>多亏<code>setupUi()</code>，这个方法自动连接到findLineEdit的<code>textEdited()</code>信号。当需要自动连接到指定<br>信号，使用<code>@pyqtSignature</code>装饰指定信号参数。装饰的作用是区分同名但参数不同的信号。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">updateUi</span><span class="params">(self)</span>:</span>
    enable = <span class="keyword">not</span> self.findLineEdit.text().isEmpty()
    self.findButton.setEnabled(enable)
    self.replaceButton.setEnabled(enable)
    self.replaceAllButton.setEnabled(enable)

<span class="function"><span class="keyword">def</span> <span class="title">text</span><span class="params">(self)</span>:</span>
    <span class="keyword">return</span> self.__text

<span class="decorator">@pyqtSignature('')</span>
<span class="function"><span class="keyword">def</span> <span class="title">on_findButton_clicked</span><span class="params">(self)</span>:</span>
    regex = self.makeRegex()
    match = regex.search(self.__text, self.__index)
    <span class="keyword">if</span> match <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:
        self.__index = match.end()
        self.emit(SIGNAL(<span class="string">'found'</span>), match.start())
    <span class="keyword">else</span>:
        self.emit(SIGNAL(<span class="string">'notfound'</span>))

<span class="function"><span class="keyword">def</span> <span class="title">makeRegex</span><span class="params">(self)</span>:</span>
    findText = unicode(self.findLineEdit.text())
    <span class="keyword">if</span> unicode(self.syntaxComboBox.currentText()) == <span class="string">'Literal'</span>:
        findText = re.escape(findText)
    flags = re.MULTILINE|re.DOTALL|re.UNICODE
    <span class="keyword">if</span> <span class="keyword">not</span> self.caseCheckBox.isChecked():
        flags |= re.IGNORECASE
    <span class="keyword">if</span> self.wholeCheckBox.isChecked():
        findText = <span class="string">r'\b%s\b'</span> % findText
    <span class="keyword">return</span> re.compile(findText, flags)
</code></pre><p>如果被搜索的文本是<code>QString</code>而不是<code>unicode</code>，则选择<code>QRegExp</code>更好。</p>
<pre><code><span class="decorator">@pyqtSignature('')</span>
<span class="function"><span class="keyword">def</span> <span class="title">on_replaceButton_clicked</span><span class="params">(self)</span>:</span>
    regex = self.makeRegex()
    self.__text = regex.sub(unicode(self.replaceLineEdit.text()),
        self.__text, <span class="number">1</span>)

<span class="decorator">@pyqtSignature('')</span>
<span class="function"><span class="keyword">def</span> <span class="title">on_replaceAllButton_clicked</span><span class="params">(self)</span>:</span>
    regex = self.makeRegex()
    self.__text = regex.sub(unicode(self.replaceLineEdit.text()),
        self.__text)
</code></pre><h1 id="测试对话框">测试对话框</h1><pre><code><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>
    <span class="keyword">import</span> sys

    text = <span class="string">"""US experience shows that, unlike traditional patents,
software patents do not encourage innovation and R&amp;D, quite the
contrary. In particular they hurt small and medium-sized enterprises
and generally newcomers in the market. They will just weaken the market
and increase spending on patents and litigation, at the expense of
technological innovation and research. Especially dangerous are
attempts to abuse the patent system by preventing interoperability as a
means of avoiding competition with technological ability.
--- Extract quoted from Linus Torvalds and Alan Cox's letter
to the President of the European Parliament
http://www.effi.org/patentit/patents_torvalds_cox.html"""</span>

    <span class="function"><span class="keyword">def</span> <span class="title">found</span><span class="params">(where)</span>:</span>
        <span class="keyword">print</span> <span class="string">'Found at %d'</span> % where

    <span class="function"><span class="keyword">def</span> <span class="title">nomore</span><span class="params">()</span>:</span>
        <span class="keyword">print</span> <span class="string">'No more found'</span>

    app = QApplication(sys.argv)
    form = FindAndReplaceDlg(text)
    form.connect(form, SIGNAL(<span class="string">'found'</span>), found)
    form.connect(form, SIGNAL(<span class="string">'notfound'</span>), nomore)
    form.show()
    app.exec_()
    <span class="keyword">print</span> form.text()
</code></pre><h1 id="总结">总结</h1><p>使用<strong>Qt Designer</strong>和手工创建界面最大的不同是在初始化的时候，我们简单地调用<code>setupUi()</code>创建界面，<br>布局，信号和槽的关联。槽的命名惯例是<code>on_widgetName_signalName</code>，连同<code>@pyqtSignature</code>装饰<br>就可以利用<code>setupUi()</code>自动关联信号和槽。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>用户界面保存在.ui文件中，包含一个窗口部件和布局的详细情况。<strong>Qt Designer</strong>能够关联标签和它的伙伴，<br>设置tab顺序(这个也可以用<code>QWidget.setTabOrder()</code>完成)。<strong>Qt]]>
    </summary>
    
      <category term="PyQt" scheme="https://opensvn.github.io/tags/PyQt/"/>
    
      <category term="Python" scheme="https://opensvn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Project Euler Problem 1]]></title>
    <link href="https://opensvn.github.io/2015/10/23/project-euler-1/"/>
    <id>https://opensvn.github.io/2015/10/23/project-euler-1/</id>
    <published>2015-10-23T08:30:00.000Z</published>
    <updated>2015-10-23T09:14:57.827Z</updated>
    <content type="html"><![CDATA[<h1 id="Multiples_of_3_and_5">Multiples of 3 and 5</h1><p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.</p>
<p>Find the sum of all the multiples of 3 or 5 below 1000.</p>
<pre><code>sum = <span class="number">3</span> * (<span class="number">1</span> + <span class="number">999</span> / <span class="number">3</span>) * (<span class="number">999</span> / <span class="number">3</span>) / <span class="number">2</span> + \
      <span class="number">5</span> * (<span class="number">1</span> + <span class="number">999</span> / <span class="number">5</span>) * (<span class="number">999</span> / <span class="number">5</span>) / <span class="number">2</span> - \
      <span class="number">15</span> * (<span class="number">1</span> + <span class="number">999</span> / <span class="number">15</span>) * (<span class="number">999</span> / <span class="number">15</span>) / <span class="number">2</span>
print sum
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Multiples_of_3_and_5">Multiples of 3 and 5</h1><p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3]]>
    </summary>
    
      <category term="Project Euler" scheme="https://opensvn.github.io/tags/Project-Euler/"/>
    
      <category term="Python" scheme="https://opensvn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PyQt编程第六章 主窗口]]></title>
    <link href="https://opensvn.github.io/2015/10/21/pyqt-6/"/>
    <id>https://opensvn.github.io/2015/10/21/pyqt-6/</id>
    <published>2015-10-21T03:25:57.000Z</published>
    <updated>2015-10-27T11:12:35.816Z</updated>
    <content type="html"><![CDATA[<h1 id="创建一个主窗口">创建一个主窗口</h1><pre><code><span class="preprocessor"><span class="keyword">import</span> os</span>
<span class="preprocessor"><span class="keyword">import</span> platform</span>
<span class="preprocessor"><span class="keyword">import</span> sys</span>
from PyQt4.QtCore <span class="preprocessor"><span class="keyword">import</span> *</span>
from PyQt4.QtGui <span class="preprocessor"><span class="keyword">import</span> *</span>
<span class="preprocessor"><span class="keyword">import</span> helpform</span>
<span class="preprocessor"><span class="keyword">import</span> newimagedlg</span>
<span class="preprocessor"><span class="keyword">import</span> qrc_resources</span>
__version__ = <span class="string">"1.0.0"</span>
</code></pre><p><code>import</code>的顺序：先Python标准模块，然后第三方模块(比如PyQt)，最后自己定义的模块。<br>一个程序通常有一个版本字符串，按照惯例称为<code>__version__</code>。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span><span class="params">(QMainWindow)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent=None)</span>:</span>
        super(MainWindow, self).__init__(parent)
        self.image = QImage()
        self.dirty = <span class="keyword">False</span>
        self.filename = <span class="keyword">None</span>
        self.mirroredvertically = <span class="keyword">False</span>
        self.mirroredhorizontally = <span class="keyword">False</span>
</code></pre><p><code>QImage</code>并不是继承自<code>QObject</code>，不需要<code>parent</code>。</p>
<pre><code>self<span class="class">.imageLabel</span> = <span class="function"><span class="title">QLabel</span><span class="params">()</span></span>
self<span class="class">.imageLabel</span><span class="class">.setMinimumSize</span>(<span class="number">200</span>, <span class="number">200</span>)
self<span class="class">.imageLabel</span><span class="class">.setAlignment</span>(Qt.AlignCenter)
self<span class="class">.imageLabel</span><span class="class">.setContextMenuPolicy</span>(Qt.ActionsContextMenu)
self.<span class="function"><span class="title">setCentralWidget</span><span class="params">(self.imageLabel)</span></span>
</code></pre><p>PyQt提供许多种方式创建右键菜单，我们使用最简单和最常见的方式。首先必须设置部件的右键菜单策略，然后<br>给部件添加一些操作。</p>
<p>和对话框不一样，在一个主窗口风格的程序中，只有一个中心部件，尽管它可以是组合而成的。我么只需要调用<br><code>setCentralWidget</code>就好了。</p>
<p>在PyQt中，悬浮窗口是<code>QDockWidget</code>类的实例。我们可以添加一个部件到悬浮部件。</p>
<pre><code><span class="keyword">log</span>DockWidget = QDockWidget(<span class="string">"Log"</span>, <span class="literal">self</span>)
<span class="keyword">log</span>DockWidget.<span class="built_in">set</span>ObjectName(<span class="string">"LogDockWidget"</span>)
<span class="keyword">log</span>DockWidget.<span class="built_in">set</span>AllowedAreas(Qt.LeftDockWidgetArea|
                              Qt.RightDockWidgetArea)
<span class="literal">self</span>.listWidget = QListWidget()
<span class="keyword">log</span>DockWidget.<span class="built_in">set</span>Widget(<span class="literal">self</span>.listWidget)
<span class="literal">self</span>.addDockWidget(Qt.RightDockWidgetArea, <span class="keyword">log</span>DockWidget)
</code></pre><p>悬浮部件不会被加入布局，所以当创建它们时，需要指定<code>parent</code>。</p>
<p>每一个PyQt对象都可以指定一个对象名字。PyQt使用对象名字区分悬浮部件。<br><code>setFeatures</code>方法控制悬浮部件能否移动，悬浮或关闭。</p>
<p><code>QPrinter</code>对象管理打印机操作。</p>
<pre><code><span class="literal">self</span>.sizeLabel = QLabel()
<span class="literal">self</span>.sizeLabel.<span class="built_in">set</span>FrameStyle(QFrame.StyledPanel|QFrame.Sunken)
status = <span class="literal">self</span>.statusBar()
status.<span class="built_in">set</span>SizeGripEnabled(False)
status.addPermanentWidget(<span class="literal">self</span>.sizeLabel)
status.showMessage(<span class="string">"Ready"</span>, <span class="number">5000</span>)
</code></pre><p>状态栏由<code>QMainWindow</code>第一次调用<code>statusBar</code>创建。<code>showMessage</code>在状态栏显示信息直到另一个<br><code>showMessage</code>被调用或<code>clearMessage</code>被调用。</p>
<h1 id="动作和键序列">动作和键序列</h1><p>PyQt用<code>QAction</code>封装用户动作。</p>
<pre><code>fileNewAction = <span class="function"><span class="title">QAction</span><span class="params">(QIcon(<span class="string">"images/filenew.png"</span>)</span></span>, <span class="string">"&amp;New"</span>, self)
fileNewAction.<span class="function"><span class="title">setShortcut</span><span class="params">(QKeySequence.New)</span></span>
helpText = <span class="string">"Create a new image"</span>
fileNewAction.<span class="function"><span class="title">setToolTip</span><span class="params">(helpText)</span></span>
fileNewAction.<span class="function"><span class="title">setStatusTip</span><span class="params">(helpText)</span></span>
self.<span class="function"><span class="title">connect</span><span class="params">(fileNewAction, SIGNAL(<span class="string">"triggered()"</span>)</span></span>, self.fileNew)
</code></pre><p>许多键序列都标准化了，有些甚至跨平台。比如<code>Ctrl+N</code>对应新建，<code>Ctrl+S</code>对应保存。<br><code>QKeySequence</code>提供标准化的键序列常量，如<code>QKeySequence.New</code>，<code>QKeySequence.Paste</code><br>对于还未标准化的键序列(或向后兼容的原因)，可以用字符串作为快捷键，setShortcut(“Ctrl+Q”)。</p>
<p>注意我们给<code>QAction</code>一个self作为父亲。每一个<code>QObject</code>子类(除了顶级窗口)都有一个父亲。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>a.data()</td>
<td style="text-align:left">返回QAction a的数据，作为QVariant</td>
</tr>
<tr>
<td>a.setData(v)</td>
<td style="text-align:left">设置QAction a的数据为QVariant v</td>
</tr>
<tr>
<td>a.isChecked()</td>
<td style="text-align:left">返回True如果QAction a被确认过</td>
</tr>
<tr>
<td>a.setChecked(b)</td>
<td style="text-align:left">选与不选QAction a取决于bool b</td>
</tr>
<tr>
<td>a.isEnabled()</td>
<td style="text-align:left">返回True如果QAction a生效</td>
</tr>
<tr>
<td>a.setEnabled(b)</td>
<td style="text-align:left">生效或失效QAction a取决于bool b</td>
</tr>
<tr>
<td>a.setSeparator(b)</td>
<td style="text-align:left">设置QAction a为正常动作或分隔符取决于bool b</td>
</tr>
<tr>
<td>a.setShortcut(k)</td>
<td style="text-align:left">设置QAction a的快捷键为QKeySequence k</td>
</tr>
<tr>
<td>a.setStatusTip(s)</td>
<td style="text-align:left">设置QAction a的状态提示为string s</td>
</tr>
<tr>
<td>a.setText(s)</td>
<td style="text-align:left">设置QAction a的文本为string s</td>
</tr>
<tr>
<td>a.setToolTip(s)</td>
<td style="text-align:left">设置QAction a的工具提示为string s</td>
</tr>
<tr>
<td>a.setWhatsThis(s)</td>
<td style="text-align:left">设置QAction a的What’s This?文本为string s</td>
</tr>
<tr>
<td>a.toggled(b)</td>
<td style="text-align:left">这个信号被发射当QAction a的选中状态改变；bool b为True如果动作被选中</td>
</tr>
<tr>
<td>a.triggered(b)</td>
<td style="text-align:left">这个信号被发射QAction a被调用；bool b为True如果a被选中</td>
</tr>
</tbody>
</table>
<p>一旦创建了动作，我们就能把它添加到菜单或工具栏。</p>
<pre><code>fileMenu.<span class="function"><span class="title">addAction</span><span class="params">(fileNewAction)</span></span>
fileToolbar.<span class="function"><span class="title">addAction</span><span class="params">(fileNewAction)</span></span>
</code></pre><h1 id="资源文件">资源文件</h1><p>创建一个资源模块需要做两件事情。第一创建一个<code>.qrc</code>的文件，包含程序详细的资源。然后运行<code>pyrcc4</code><br>读取<code>.qrc</code>文件生成资源模块。<code>.qrc</code>是一个XML格式的文件。</p>
<pre><code><span class="doctype">&lt;!DOCTYPE RCC&gt;</span><span class="tag">&lt;<span class="title">RCC</span> <span class="attribute">version</span>=<span class="value">"1.0"</span>&gt;</span>
<span class="tag">&lt;<span class="title">qresource</span>&gt;</span>
<span class="tag">&lt;<span class="title">file</span> <span class="attribute">alias</span>=<span class="value">"filenew.png"</span>&gt;</span>images/filenew.png<span class="tag">&lt;/<span class="title">file</span>&gt;</span>
<span class="tag">&lt;<span class="title">file</span> <span class="attribute">alias</span>=<span class="value">"fileopen.png"</span>&gt;</span>images/fileopen.png<span class="tag">&lt;/<span class="title">file</span>&gt;</span>
···
<span class="tag">&lt;<span class="title">file</span> <span class="attribute">alias</span>=<span class="value">"icon.png"</span>&gt;</span>images/icon.png<span class="tag">&lt;/<span class="title">file</span>&gt;</span>
<span class="tag">&lt;<span class="title">file</span>&gt;</span>help/editmenu.html<span class="tag">&lt;/<span class="title">file</span>&gt;</span>
<span class="tag">&lt;<span class="title">file</span>&gt;</span>help/filemenu.html<span class="tag">&lt;/<span class="title">file</span>&gt;</span>
<span class="tag">&lt;<span class="title">file</span>&gt;</span>help/index.html<span class="tag">&lt;/<span class="title">file</span>&gt;</span>
<span class="tag">&lt;/<span class="title">qresource</span>&gt;</span>
<span class="tag">&lt;/<span class="title">RCC</span>&gt;</span>
</code></pre><p>现在使用一个新建文件的图片，我们可以写成<code>QIcon(&quot;:/images/filenew.png&quot;)</code>，多亏了别名，<br>也可以缩写为<code>QIcon(&quot;:/filenew.png&quot;)</code>。前面的:/告诉PyQt文件是一个资源。在使用资源之前，<br>必须生成资源模块并导入进程序。</p>
<pre><code>C:\pyqt\chap06&gt;pyrcc4 -o qrc_resources<span class="class">.py</span> resources.qrc
</code></pre><h1 id="创建和使用动作">创建和使用动作</h1><p>一个辅助创建动作的函数：</p>
<pre><code>def createAction(self, text, slot=None, shortcut=None, <span class="attribute">icon</span>=None,
                 tip=None, checkable=False, signal=<span class="string">"triggered()"</span>):
    action = <span class="function"><span class="title">QAction</span><span class="params">(text, self)</span></span>
    <span class="keyword">if</span> <span class="attribute">icon</span> is not None:
        action.<span class="function"><span class="title">setIcon</span><span class="params">(QIcon(<span class="string">":/%s.png"</span> % icon)</span></span>)
    <span class="keyword">if</span> shortcut is not None:
        action.<span class="function"><span class="title">setShortcut</span><span class="params">(shortcut)</span></span>
    <span class="keyword">if</span> tip is not None:
        action.<span class="function"><span class="title">setToolTip</span><span class="params">(tip)</span></span>
        action.<span class="function"><span class="title">setStatusTip</span><span class="params">(tip)</span></span>
    <span class="keyword">if</span> slot is not None:
        self.<span class="function"><span class="title">connect</span><span class="params">(action, SIGNAL(signal)</span></span>, slot)
    <span class="keyword">if</span> checkable:
        action.<span class="function"><span class="title">setCheckable</span><span class="params">(True)</span></span>
    return action
fileNewAction = self.createAction(<span class="string">"&amp;New..."</span>, self<span class="class">.fileNew</span>,
        QKeySequence<span class="class">.New</span>, <span class="string">"filenew"</span>, <span class="string">"Create an image file"</span>)
fileQuitAction = self.createAction(<span class="string">"&amp;Quit"</span>, self<span class="class">.close</span>,
        <span class="string">"Ctrl+Q"</span>, <span class="string">"filequit"</span>, <span class="string">"Close the application"</span>)
editZoomAction = self.createAction(<span class="string">"&amp;Zoom..."</span>, self<span class="class">.editZoom</span>,
        <span class="string">"Alt+Z"</span>, <span class="string">"editzoom"</span>, <span class="string">"Zoom the image"</span>)
editInvertAction = self.createAction(<span class="string">"&amp;Invert"</span>,
        self<span class="class">.editInvert</span>, <span class="string">"Ctrl+I"</span>, <span class="string">"editinvert"</span>,
        <span class="string">"Invert the image's colors"</span>, True, <span class="string">"toggled(bool)"</span>)
</code></pre><p><code>toggled(bool)</code>信号不仅告诉我们动作被调用，而且返回动作是否被选中。</p>
<p>一个动作组管理一组动作使得任何时候只有一个动作被选中。</p>
<pre><code>mirrorGroup = <span class="function"><span class="title">QActionGroup</span><span class="params">(self)</span></span>
editUnMirrorAction = self.createAction(<span class="string">"&amp;Unmirror"</span>,
        self<span class="class">.editUnMirror</span>, <span class="string">"Ctrl+U"</span>, <span class="string">"editunmirror"</span>,
        <span class="string">"Unmirror the image"</span>, True, <span class="string">"toggled(bool)"</span>)
mirrorGroup.<span class="function"><span class="title">addAction</span><span class="params">(editUnMirrorAction)</span></span>
editUnMirrorAction.<span class="function"><span class="title">setChecked</span><span class="params">(True)</span></span>
</code></pre><p>可选中的动作默认是未选中状态，所以在动作组中初始时必须选择一个为选中状态。</p>
<p>虽然所有动作已经创建好，但是它们还不能工作。只有当动作加进菜单或工具栏才能起作用。</p>
<pre><code>editMenu = self.<span class="function"><span class="title">menuBar</span><span class="params">()</span></span>.<span class="function"><span class="title">addMenu</span><span class="params">(<span class="string">"&amp;Edit"</span>)</span></span>
self.addActions(editMenu, (editInvertAction,
        editSwapRedAndBlueAction, editZoomAction))
def <span class="function"><span class="title">addActions</span><span class="params">(self, target, actions)</span></span>:
    <span class="keyword">for</span> action <span class="keyword">in</span> actions:
        <span class="keyword">if</span> action is None:
            target.<span class="function"><span class="title">addSeparator</span><span class="params">()</span></span>
        <span class="keyword">else</span>:
            target.<span class="function"><span class="title">addAction</span><span class="params">(action)</span></span>
</code></pre><p>也可以使用<code>QWidget.addActions</code>添加多个动作到菜单或工具栏。</p>
<pre><code>mirrorMenu = editMenu.<span class="function"><span class="title">addMenu</span><span class="params">(QIcon(<span class="string">":/editmirror.png"</span>)</span></span>,
                              <span class="string">"&amp;Mirror"</span>)
self.addActions(mirrorMenu, (editUnMirrorAction,
        editMirrorHorizontalAction, editMirrorVerticalAction))
</code></pre><p>子目录的创建和其它目录一样，不同的是使用<code>QMenu.addMenu</code>加进父目录。</p>
<pre><code>self<span class="class">.fileMenu</span> = self.<span class="function"><span class="title">menuBar</span><span class="params">()</span></span>.<span class="function"><span class="title">addMenu</span><span class="params">(<span class="string">"&amp;File"</span>)</span></span>
self<span class="class">.fileMenuActions</span> = (fileNewAction, fileOpenAction,
        fileSaveAction, fileSaveAsAction, None,
        filePrintAction, fileQuitAction)
self.<span class="function"><span class="title">connect</span><span class="params">(self.fileMenu, SIGNAL(<span class="string">"aboutToShow()"</span>)</span></span>,
             self.updateFileMenu)

fileToolbar = self.<span class="function"><span class="title">addToolBar</span><span class="params">(<span class="string">"File"</span>)</span></span>
fileToolbar.<span class="function"><span class="title">setObjectName</span><span class="params">(<span class="string">"FileToolBar"</span>)</span></span>
self.addActions(fileToolbar, (fileNewAction, fileOpenAction,
                              fileSaveAsAction))
</code></pre><p><code>addToolBar</code>创建一个<code>QToolBar</code>对象。</p>
<pre><code>editToolbar = self.<span class="function"><span class="title">addToolBar</span><span class="params">(<span class="string">"Edit"</span>)</span></span>
editToolbar.<span class="function"><span class="title">setObjectName</span><span class="params">(<span class="string">"EditToolBar"</span>)</span></span>
self.addActions(editToolbar, (editInvertAction,
        editSwapRedAndBlueAction, editUnMirrorAction,
        editMirrorVerticalAction,
        editMirrorHorizontalAction))
</code></pre><p>添加部件到工具栏都一样： 创建部件，配置好部件，连接信号，然后把部件添加到工具栏</p>
<pre><code>self<span class="class">.zoomSpinBox</span> = <span class="function"><span class="title">QSpinBox</span><span class="params">()</span></span>
self<span class="class">.zoomSpinBox</span><span class="class">.setRange</span>(<span class="number">1</span>, <span class="number">400</span>)
self<span class="class">.zoomSpinBox</span><span class="class">.setSuffix</span>(<span class="string">" %"</span>)
self<span class="class">.zoomSpinBox</span><span class="class">.setValue</span>(<span class="number">100</span>)
self<span class="class">.zoomSpinBox</span><span class="class">.setToolTip</span>(<span class="string">"Zoom the image"</span>)
self<span class="class">.zoomSpinBox</span><span class="class">.setStatusTip</span>(self<span class="class">.zoomSpinBox</span><span class="class">.toolTip</span>())
self<span class="class">.zoomSpinBox</span><span class="class">.setFocusPolicy</span>(Qt.NoFocus)
self.connect(self<span class="class">.zoomSpinBox</span>,
             <span class="function"><span class="title">SIGNAL</span><span class="params">(<span class="string">"valueChanged(int)"</span>)</span></span>, self.showImage)
editToolbar.<span class="function"><span class="title">addWidget</span><span class="params">(self.zoomSpinBox)</span></span>
</code></pre><p>之前有一行这样的代码：</p>
<pre><code><span class="tag">self</span><span class="class">.imageLabel</span><span class="class">.setContextMenuPolicy</span>(<span class="tag">Qt</span><span class="class">.ActionsContextMenu</span>)
</code></pre><p>它告诉PyQt，如果动作被加进imageLabel部件，它们也被用作右键菜单。</p>
<pre><code><span class="keyword">self</span>.addActions(<span class="keyword">self</span>.imageLabel, (editInvertAction,
        editSwapRedAndBlueAction, editUnMirrorAction,
        editMirrorVerticalAction, editMirrorHorizontalAction))
</code></pre><p><code>QWidget</code>类有一个<code>addAction</code>方法，因此<code>QMenu</code>，<code>QMenuBar</code>，<code>QToolBar</code>都继承了这个方法。<br>尽管<code>QWidget</code>没有<code>addSeparator</code>方法，为了方便，<code>QMenu</code>，<code>QMenuBar</code>，<code>QToolBar</code>都提供了。<br>如果要添加一个分隔符到右键菜单，则必须添加一个分隔动作。</p>
<pre><code>separator = <span class="function"><span class="title">QAction</span><span class="params">(self)</span></span>
separator.<span class="function"><span class="title">setSeparator</span><span class="params">(True)</span></span>
self.addActions(editToolbar, (editInvertAction,
        editSwapRedAndBlueAction, separator, editUnMirrorAction,
        editMirrorVerticalAction, editMirrorHorizontalAction))
</code></pre><h1 id="恢复和保存主窗口状态">恢复和保存主窗口状态</h1><pre><code>def <span class="function"><span class="title">main</span><span class="params">()</span></span>:
    app = <span class="function"><span class="title">QApplication</span><span class="params">(sys.argv)</span></span>
    app.<span class="function"><span class="title">setOrganizationName</span><span class="params">(<span class="string">"Qtrac Ltd."</span>)</span></span>
    app.<span class="function"><span class="title">setOrganizationDomain</span><span class="params">(<span class="string">"qtrac.eu"</span>)</span></span>
    app.<span class="function"><span class="title">setApplicationName</span><span class="params">(<span class="string">"Image Changer"</span>)</span></span>
    app.<span class="function"><span class="title">setWindowIcon</span><span class="params">(QIcon(<span class="string">":/icon.png"</span>)</span></span>)
    <span class="tag">form</span> = <span class="function"><span class="title">MainWindow</span><span class="params">()</span></span>
    <span class="tag">form</span>.<span class="function"><span class="title">show</span><span class="params">()</span></span>
    app.<span class="function"><span class="title">exec_</span><span class="params">()</span></span>
</code></pre><p>函数main的第二行到第四行的主要作用就是程序配置的加载和保存。如果不传任何参数给<code>QSettings</code>对象，<br>则它会使用这三行代码设定的名字。这些名字使得程序配置保存在合适的地方，比如Windows的注册表，Linux<br>的$HOME/.config</p>
<pre><code>settings = <span class="function"><span class="title">QSettings</span><span class="params">()</span></span>
self<span class="class">.recentFiles</span> = settings.<span class="function"><span class="title">value</span><span class="params">(<span class="string">"RecentFiles"</span>)</span></span>.<span class="function"><span class="title">toStringList</span><span class="params">()</span></span>
size = settings.value(<span class="string">"MainWindow/Size"</span>,
                      <span class="function"><span class="title">QVariant</span><span class="params">(QSize(<span class="number">600</span>, <span class="number">500</span>)</span></span>)).<span class="function"><span class="title">toSize</span><span class="params">()</span></span>
self.<span class="function"><span class="title">resize</span><span class="params">(size)</span></span>
<span class="attribute">position</span> = settings.value(<span class="string">"MainWindow/Position"</span>,
                          <span class="function"><span class="title">QVariant</span><span class="params">(QPoint(<span class="number">0</span>, <span class="number">0</span>)</span></span>)).<span class="function"><span class="title">toPoint</span><span class="params">()</span></span>
self.<span class="function"><span class="title">move</span><span class="params">(position)</span></span>
self.restoreState(
        settings.<span class="function"><span class="title">value</span><span class="params">(<span class="string">"MainWindow/State"</span>)</span></span>.<span class="function"><span class="title">toByteArray</span><span class="params">()</span></span>)
self.<span class="function"><span class="title">setWindowTitle</span><span class="params">(<span class="string">"Image Changer"</span>)</span></span>
self.<span class="function"><span class="title">updateFileMenu</span><span class="params">()</span></span>
QTimer.<span class="function"><span class="title">singleShot</span><span class="params">(<span class="number">0</span>, self.loadInitialFile)</span></span>
</code></pre><p><code>QSettings.value()</code>返回一个<code>QVariant</code>，因此必须转换为我们期望的数据类型。<br>带2个参数形式的<code>value()</code>方法，第二个参数是默认值。</p>
<p><code>resize()</code>和<code>move()</code>并不会造成窗口抖动，因为这些操作是在窗口显示之前已经完成。<br>Qt4.2引入2个新的方法保存和恢复一个顶层窗口的几何位置。</p>
<pre><code>self.<span class="function"><span class="title">restoreGeometry</span><span class="params">(settings.value(<span class="string">"Geometry"</span>)</span></span>.<span class="function"><span class="title">toByteArray</span><span class="params">()</span></span>)
</code></pre><p><code>QMainWindow</code>类提供<code>restoreState()</code>和<code>saveState()</code>方法，来恢复自或保存到一个<code>QByteArray</code>。<br>它们只保存拥有唯一对象名的悬浮窗口的大小和位置以及工具栏的位置。</p>
<blockquote>
<p><strong>启动时做大量处理</strong><br>如果我们需要在启动时做大量处理，比如加载许多大文件，我们经常用一个独立的加载方法来做此事。<br>想象一下，比如这个方法是loadInitialFiles()，加载许多大文件。则在show()和事件循环(exec_())<br>开始之前，用户将体验到一个非常长的启动延迟。<br>我们希望窗口尽可能快的出现，使用户知道启动成功，并能够看到长时间运行的进程。这些通过0延迟的<br>singleShot计时器完成。因为它并不会立即执行连接的槽，相反它简单地将槽放到事件队列就返回。<br>0延迟计时器意思是，“当事件队列没有其它事件处理时处理这个事件”</p>
</blockquote>
<pre><code>def <span class="function"><span class="title">loadInitialFile</span><span class="params">(self)</span></span>:
    settings = <span class="function"><span class="title">QSettings</span><span class="params">()</span></span>
    fname = <span class="function"><span class="title">unicode</span><span class="params">(settings.value(<span class="string">"LastFile"</span>)</span></span>.<span class="function"><span class="title">toString</span><span class="params">()</span></span>)
    <span class="keyword">if</span> fname and QFile.<span class="function"><span class="title">exists</span><span class="params">(fname)</span></span>:
        self.<span class="function"><span class="title">loadFile</span><span class="params">(fname)</span></span>
</code></pre><p>如果用户试图关闭程序，不管什么方式，<code>closeEvent()</code>被调用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">closeEvent</span><span class="params">(self, event)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.okToContinue():</span><br><span class="line">        settings = QSettings()</span><br><span class="line">        filename = QVariant(QString(self.filename)) \</span><br><span class="line">                <span class="keyword">if</span> self.filename <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">else</span> QVariant()</span><br><span class="line">        settings.setValue(<span class="string">"LastFile"</span>, filename)</span><br><span class="line">        recentFiles = QVariant(self.recentFiles) \</span><br><span class="line">                <span class="keyword">if</span> self.recentFiles <span class="keyword">else</span> QVariant()</span><br><span class="line">        settings.setValue(<span class="string">"RecentFiles"</span>, recentFiles)</span><br><span class="line">        settings.setValue(<span class="string">"MainWindow/Size"</span>, QVariant(self.size()))</span><br><span class="line">        settings.setValue(<span class="string">"MainWindow/Position"</span>,</span><br><span class="line">                QVariant(self.pos()))</span><br><span class="line">        settings.setValue(<span class="string">"MainWindow/State"</span>,</span><br><span class="line">                QVariant(self.saveState()))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        event.ignore()</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>语法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>m.addDockWidget(a, d)</td>
<td style="text-align:left">在QMainWindow m中添加QDockWidget d到Qt.QDockWidgetArea a</td>
</tr>
<tr>
<td>m.addToolBar(s)</td>
<td style="text-align:left">添加并返回一个名叫string s的QToolBar</td>
</tr>
<tr>
<td>m.menuBar()</td>
<td style="text-align:left">返回QMainWindow m的QMenuBar(第一次调用创建目录)</td>
</tr>
<tr>
<td>m.restoreGeometry(ba)</td>
<td style="text-align:left">根据QByteArray ba恢复QMainWindow m的位置和大小(Qt4.3)</td>
</tr>
<tr>
<td>m.restoreState(ba)</td>
<td style="text-align:left">根据QByteArray ba恢复QMainWindow m的悬浮窗和工具栏的状态</td>
</tr>
<tr>
<td>m.saveGeometry()</td>
<td style="text-align:left">返回封装在QByteArray中QMainWindow m的位置和大小(Qt4.3)</td>
</tr>
<tr>
<td>m.saveState()</td>
<td style="text-align:left">返回封装在QByteArray中QMainWindow m的悬浮窗和工具栏的状态</td>
</tr>
<tr>
<td>m.setCentralWidget(w)</td>
<td style="text-align:left">设置QMainWindow m的中央部件为QWidget w</td>
</tr>
<tr>
<td>m.statusBar()</td>
<td style="text-align:left">返回QMainWindow的QStatusBar(第一次调用创建状态栏)</td>
</tr>
<tr>
<td>m.setWindowIcon(i)</td>
<td style="text-align:left">设置QMainWindow m的图标为QIcon i；这个方法继承自QWidget</td>
</tr>
<tr>
<td>m.setWindowTitle(s)</td>
<td style="text-align:left">设置QMainWindow m的标题为string s；这个方法继承自QWidget</td>
</tr>
</tbody>
</table>
<p>如果我们使用Qt4，使用<code>QWidget.restoreGeometry()</code>恢复窗口的几何位置，那么我们可以如此保存几何状态：</p>
<pre><code>settings.<span class="function"><span class="title">setValue</span><span class="params">(<span class="string">"Geometry"</span>, QVariant(self.saveGeometry()</span></span>))
</code></pre><p>使用这种方法，不需要单独保存主窗口的大小和位置。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">okToContinue</span><span class="params">(self)</span>:</span>
    <span class="keyword">if</span> self.dirty:
    reply = QMessageBox.question(self,
                    <span class="string">"Image Changer - Unsaved Changes"</span>,
                    <span class="string">"Save unsaved changes?"</span>,
                    QMessageBox.Yes|QMessageBox.No|
                    QMessageBox.Cancel)
    <span class="keyword">if</span> reply == QMessageBox.Cancel:
        <span class="keyword">return</span> <span class="keyword">False</span>
    <span class="keyword">elif</span> reply == QMessageBox.Yes:
        self.fileSave()
    <span class="keyword">return</span> <span class="keyword">True</span>
</code></pre><p>有些开发者使用<code>QMessageBox.Save</code>和<code>QMessageBox.Discard</code>。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">updateFileMenu</span><span class="params">(<span class="keyword">self</span>)</span>:</span>
    <span class="keyword">self</span>.fileMenu.clear()
    <span class="keyword">self</span>.addActions(<span class="keyword">self</span>.fileMenu, <span class="keyword">self</span>.fileMenuActions[<span class="symbol">:-</span><span class="number">1</span>])
    current = <span class="constant">QString</span>(<span class="keyword">self</span>.filename) \
            <span class="keyword">if</span> <span class="keyword">self</span>.filename is <span class="keyword">not</span> <span class="constant">None</span> <span class="keyword">else</span> <span class="constant">None</span>
    recentFiles = []
    <span class="keyword">for</span> fname <span class="keyword">in</span> <span class="keyword">self</span>.<span class="symbol">recentFiles:</span>
        <span class="keyword">if</span> fname != current <span class="keyword">and</span> <span class="constant">QFile</span>.exists(fname)<span class="symbol">:</span>
            recentFiles.append(fname)
    <span class="keyword">if</span> <span class="symbol">recentFiles:</span>
        <span class="keyword">self</span>.fileMenu.addSeparator()
        <span class="keyword">for</span> i, fname <span class="keyword">in</span> enumerate(recentFiles)<span class="symbol">:</span>
            action = <span class="constant">QAction</span>(<span class="constant">QIcon</span>(<span class="string">":/icon.png"</span>), <span class="string">"&amp;%d %s"</span> % (
                    i + <span class="number">1</span>, <span class="constant">QFileInfo</span>(fname).fileName()), <span class="keyword">self</span>)
            action.setData(<span class="constant">QVariant</span>(fname))
            <span class="keyword">self</span>.connect(action, <span class="constant">SIGNAL</span>(<span class="string">"triggered()"</span>),
                         <span class="keyword">self</span>.loadFile)
            <span class="keyword">self</span>.fileMenu.addAction(action)
    <span class="keyword">self</span>.fileMenu.addSeparator()
    <span class="keyword">self</span>.fileMenu.addAction(<span class="keyword">self</span>.fileMenuActions[-<span class="number">1</span>])
</code></pre><blockquote>
<p><strong>QMessageBox的静态方法</strong><br>QMessageBox类提供多个方便的静态方法，这些方法弹出一个有合适图标和按钮的模式对话框。<br>最常用的方法为critical()，information()，question()和waring()。这些方法携带参数<br>父类部件，窗口标题，消息文本(可以是纯文本或HTML)，0个或多个按钮。如果未指定按钮，则为OK按钮。<br>Qt4.0和Qt4.1中，OK按钮或Yes按钮位或QMessageBox.Default，Cancel按钮或No按钮位或<br>  QMessageBox.Escape很常见。<br>    reply = QMessageBox.question(self,<br>            “Image Changer - Unsaved Changes”, “Save unsaved changes?”,<br>            QMessageBox.Yes|QMessageBox.Default,<br>            QMessageBox.No|QMessageBox.Escape)<br>4.2中则自动绑定默认动作到相应的按钮上。<br>如果我们想创建自定义的消息框，可以创建一个QMessageBox实例，然后使用QMessageBox.addButton()<br>QMessageBox.setIcon()添加按钮，再调用QMessageBox.exec_()弹出消息框。</p>
</blockquote>
<pre><code>def <span class="function"><span class="title">addRecentFile</span><span class="params">(self, fname)</span></span>:
    <span class="keyword">if</span> fname is None:
        return
    <span class="keyword">if</span> not self<span class="class">.recentFiles</span><span class="class">.contains</span>(fname):
        self<span class="class">.recentFiles</span><span class="class">.prepend</span>(<span class="function"><span class="title">QString</span><span class="params">(fname)</span></span>)
        while self<span class="class">.recentFiles</span><span class="class">.count</span>() &gt; <span class="number">9</span>:
            self<span class="class">.recentFiles</span><span class="class">.takeLast</span>()
</code></pre><h1 id="处理文件动作">处理文件动作</h1><pre><code><span class="function"><span class="keyword">def</span> <span class="title">fileNew</span><span class="params">(self)</span>:</span>
    <span class="keyword">if</span> <span class="keyword">not</span> self.okToContinue():
        <span class="keyword">return</span>
    dialog = newimagedlg.NewImageDlg(self)
    <span class="keyword">if</span> dialog.exec_():
        self.addRecentFile(self.filename)
        self.image = QImage()
        <span class="keyword">for</span> action, check <span class="keyword">in</span> self.resetableActions:
            action.setChecked(check)
        self.image = dialog.image()
        self.filename = <span class="keyword">None</span>
        self.dirty = <span class="keyword">True</span>
        self.showImage()
        self.sizeLabel.setText(<span class="string">"%d x %d"</span> % (self.image.width(),
                                            self.image.height()))
        self.updateStatus(<span class="string">"Created new image"</span>)

<span class="function"><span class="keyword">def</span> <span class="title">updateStatus</span><span class="params">(self, message)</span>:</span>
    self.statusBar().showMessage(message, <span class="number">5000</span>)
    self.listWidget.addItem(message)
    <span class="keyword">if</span> self.filename <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:
        self.setWindowTitle(<span class="string">"Image Changer - %s[*]"</span> % \
                            os.path.basename(self.filename))
    <span class="keyword">elif</span> <span class="keyword">not</span> self.image.isNull():
        self.setWindowTitle(<span class="string">"Image Changer - Unnamed[*]"</span>)
    <span class="keyword">else</span>:
        self.setWindowTitle(<span class="string">"Image Changer[*]"</span>)
    self.setWindowModified(self.dirty)

<span class="function"><span class="keyword">def</span> <span class="title">fileOpen</span><span class="params">(self)</span>:</span>
    <span class="keyword">if</span> <span class="keyword">not</span> self.okToContinue():
        <span class="keyword">return</span>
    dir = os.path.dirname(self.filename) \
            <span class="keyword">if</span> self.filename <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">else</span> <span class="string">"."</span>
    formats = [<span class="string">"*.%s"</span> % unicode(format).lower() \
               <span class="keyword">for</span> format <span class="keyword">in</span> QImageReader.supportedImageFormats()]
    fname = unicode(QFileDialog.getOpenFileName(self,
                        <span class="string">"Image Changer - Choose Image"</span>, dir,
                        <span class="string">"Image files (%s)"</span> % <span class="string">" "</span>.join(formats)))
    <span class="keyword">if</span> fname:
        self.loadFile(fname)
</code></pre><p><code>QFileDialog.getOpenFileName()</code>返回一个<code>QString</code>保存文件名的绝对路径，或者返回空。</p>
<pre><code>fname = unicode(QFileDialog.getOpenFileName(self,
                <span class="string">"%s - Choose Image"</span> % QApplication.applicationName(),
                dir, <span class="string">"Image files (%s)"</span> % <span class="string">" "</span>.join(formats)))

<span class="function"><span class="keyword">def</span> <span class="title">loadFile</span><span class="params">(self, fname=None)</span>:</span>
    <span class="keyword">if</span> fname <span class="keyword">is</span> <span class="keyword">None</span>:
        action = self.sender()
        <span class="keyword">if</span> isinstance(action, QAction):
            fname = unicode(action.data().toString())
            <span class="keyword">if</span> <span class="keyword">not</span> self.okToContinue():
                <span class="keyword">return</span>
        <span class="keyword">else</span>:
            <span class="keyword">return</span>
    <span class="keyword">if</span> fname:
        self.filename = <span class="keyword">None</span>
        image = QImage(fname)
        <span class="keyword">if</span> image.isNull():
            message = <span class="string">"Failed to read %s"</span> % fname
        <span class="keyword">else</span>:
            self.addRecentFile(fname)
            self.image = QImage()
            <span class="keyword">for</span> action, check <span class="keyword">in</span> self.resetableActions:
                action.setChecked(check)
            self.image = image
            self.filename = fname
            self.showImage()
            self.dirty = <span class="keyword">False</span>
            self.sizeLabel.setText(<span class="string">"%d x %d"</span> % (
                        image.width(), image.height()))
            message = <span class="string">"Loaded %s"</span> % os.path.basename(fname)
        self.updateStatus(message)

<span class="function"><span class="keyword">def</span> <span class="title">fileSave</span><span class="params">(self)</span>:</span>
    <span class="keyword">if</span> self.image.isNull():
        <span class="keyword">return</span>
    <span class="keyword">if</span> self.filename <span class="keyword">is</span> <span class="keyword">None</span>:
        self.fileSaveAs()
    <span class="keyword">else</span>:
        <span class="keyword">if</span> self.image.save(self.filename, <span class="keyword">None</span>):
            self.updateStatus(<span class="string">"Saved as %s"</span> % self.filename)
            self.dirty = <span class="keyword">False</span>
        <span class="keyword">else</span>:
            self.updateStatus(<span class="string">"Failed to save %s"</span> % self.filename)

<span class="function"><span class="keyword">def</span> <span class="title">fileSaveAs</span><span class="params">(self)</span>:</span>
    <span class="keyword">if</span> self.image.isNull():
        <span class="keyword">return</span>
    fname = self.filename <span class="keyword">if</span> self.filename <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">else</span> <span class="string">"."</span>
    formats = [<span class="string">"*.%s"</span> % unicode(format).lower() \
               <span class="keyword">for</span> format <span class="keyword">in</span> QImageWriter.supportedImageFormats()]
    fname = unicode(QFileDialog.getSaveFileName(self,
                    <span class="string">"Image Changer - Save Image"</span>, fname,
                    <span class="string">"Image files (%s)"</span> % <span class="string">" "</span>.join(formats)))
    <span class="keyword">if</span> fname:
        <span class="keyword">if</span> <span class="string">"."</span> <span class="keyword">not</span> <span class="keyword">in</span> fname:
            fname += <span class="string">".png"</span>
        self.addRecentFile(fname)
        self.filename = fname
        self.fileSave()
</code></pre><p>QFileDialog.getSaveFileName()提示用户提供一个文件名用来保存当前文件。</p>
<h1 id="处理编辑动作">处理编辑动作</h1><pre><code>def <span class="function"><span class="title">editInvert</span><span class="params">(self, on)</span></span>:
    <span class="keyword">if</span> self<span class="class">.image</span><span class="class">.isNull</span>():
        return
    self<span class="class">.image</span><span class="class">.invertPixels</span>()
    self.<span class="function"><span class="title">showImage</span><span class="params">()</span></span>
    self<span class="class">.dirty</span> = True
    self.<span class="function"><span class="title">updateStatus</span><span class="params">(<span class="string">"Inverted"</span> if on else <span class="string">"Uninverted"</span>)</span></span>

def <span class="function"><span class="title">editMirrorHorizontal</span><span class="params">(self, on)</span></span>:
    <span class="keyword">if</span> self<span class="class">.image</span><span class="class">.isNull</span>():
        return
    self<span class="class">.image</span> = self<span class="class">.image</span><span class="class">.mirrored</span>(True, False)
    self.<span class="function"><span class="title">showImage</span><span class="params">()</span></span>
    self<span class="class">.mirroredhorizontally</span> = not self<span class="class">.mirroredhorizontally</span>
    self<span class="class">.dirty</span> = True
    self.updateStatus(<span class="string">"Mirrored Horizontally"</span> \
            <span class="keyword">if</span> on <span class="keyword">else</span> <span class="string">"Unmirrored Horizontally"</span>)

def <span class="function"><span class="title">editUnMirror</span><span class="params">(self, on)</span></span>:
    <span class="keyword">if</span> self<span class="class">.image</span><span class="class">.isNull</span>():
        return
    <span class="keyword">if</span> self<span class="class">.mirroredhorizontally</span>:
        self.<span class="function"><span class="title">editMirrorHorizontal</span><span class="params">(False)</span></span>
    <span class="keyword">if</span> self<span class="class">.mirroredvertically</span>:
        self.<span class="function"><span class="title">editMirrorVertical</span><span class="params">(False)</span></span>

def <span class="function"><span class="title">editZoom</span><span class="params">(self)</span></span>:
    <span class="keyword">if</span> self<span class="class">.image</span><span class="class">.isNull</span>():
        return
    percent, ok = QInputDialog.getInteger(self,
            <span class="string">"Image Changer - Zoom"</span>, <span class="string">"Percent:"</span>,
            self<span class="class">.zoomSpinBox</span><span class="class">.value</span>(), <span class="number">1</span>, <span class="number">400</span>)
    <span class="keyword">if</span> ok:
        self<span class="class">.zoomSpinBox</span><span class="class">.setValue</span>(percent)
</code></pre><p><code>QInputDialog</code>提供了一些其它方便的静态方法，<code>getDouble()</code>，<code>getItem()</code>，<code>getText()</code>。<br>所有这些方法返回一个tuple，包含一个指示用户是否输入的bool值和一个合法值。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">showImage</span><span class="params">(self, percent=None)</span>:</span>
    <span class="keyword">if</span> self.image.isNull():
        <span class="keyword">return</span>
    <span class="keyword">if</span> percent <span class="keyword">is</span> <span class="keyword">None</span>:
        percent = self.zoomSpinBox.value()
    factor = percent / <span class="number">100.0</span>
    width = self.image.width() * factor
    height = self.image.height() * factor
    image = self.image.scaled(width, height, Qt.KeepAspectRatio)
    self.imageLabel.setPixmap(QPixmap.fromImage(image))
</code></pre><p>根据PyQt的文档，<code>QPixmap</code>对屏幕显示做了优化，而<code>QImage</code>对编辑做了优化，因此我们用它保存图像数据。</p>
<h1 id="处理帮助动作">处理帮助动作</h1><pre><code><span class="function"><span class="keyword">def</span> <span class="title">helpAbout</span><span class="params">(self)</span>:</span>
    QMessageBox.about(self, <span class="string">"About Image Changer"</span>,
            <span class="string">"""&lt;b&gt;Image Changer&lt;/b&gt; v %s
            &lt;p&gt;Copyright &amp;copy; 2007 Qtrac Ltd. 
            All rights reserved.
            &lt;p&gt;This application can be used to perform
            simple image manipulations.
            &lt;p&gt;Python %s - Qt %s - PyQt %s on %s"""</span> % (
            __version__, platform.python_version(),
            QT_VERSION_STR, PYQT_VERSION_STR, platform.system()))
</code></pre><p><code>QMessageBox.about()</code>静态方法弹出一个给定标题和文本的只有OK按钮的模式对话框，其文本可以是HTML。</p>
<h1 id="总结">总结</h1><p>主窗口风格的程序由<code>QMainWindow</code>子类创建，其窗口只有一个单一的部件作为中央部件。</p>
<p>动作用来表示程序向用户提供的功能。这些动作保存在<code>QAction</code>对象中，包含文本(用于菜单)，图标(用于菜单<br>和工具栏)，工具栏提示和状态栏提示，以及所连接的槽。<br>通常所有的动作都会添加进菜单，而只有经常使用的一些加入工具栏。</p>
<p>动作，动作组和悬浮窗必须显式提供一个父亲，比如主窗口，以保证在合适的时候能被销毁。</p>
<p>程序通常使用资源(小文件，比如图标，和数据文件)，PyQt的资源机制使得访问和使用资源非常简单。使用<br><code>pyrcc4</code>将资源文件编程Python模块，再导入程序使用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="创建一个主窗口">创建一个主窗口</h1><pre><code><span class="preprocessor"><span class="keyword">import</span> os</span>
<span class="preprocessor">]]>
    </summary>
    
      <category term="PyQt" scheme="https://opensvn.github.io/tags/PyQt/"/>
    
      <category term="Python" scheme="https://opensvn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PyQt编程第五章 对话框]]></title>
    <link href="https://opensvn.github.io/2015/10/14/pyqt-5/"/>
    <id>https://opensvn.github.io/2015/10/14/pyqt-5/</id>
    <published>2015-10-14T08:20:56.000Z</published>
    <updated>2015-10-21T01:20:37.116Z</updated>
    <content type="html"><![CDATA[<p>对话框以“智力”分类为：哑巴，标准和聪明，取决于对话框知道程序数据的多少。<br>对话框以“模式”分类为：模式对话框和无模式对话框。</p>
<p>应用模式对话框一旦被调用，用户只能与其交互，不能使用程序其它部分。<br>窗口模式对话框和应用模式对话框类似，只是它仅仅阻止与其父窗口交互。<br>无模式对话框允许用户与程序其它部分交互。</p>
<p>编写对话框另一个重要方面是如何处理有效性检验。我们尽量挑选合适的部件并设置其属性来避免编写有效性<br>检验代码。<br>我们称应用到单个部件的检验为部件级确认。当部件之间有相互关系时，称为表级确认。</p>
<h1 id="“哑巴”对话框">“哑巴”对话框</h1><p>哑巴对话框不知道其部件使用的数据。哑巴对话框通常是带有<code>accept</code>和<code>reject</code>按钮的模式对话框。</p>
<pre><code>def <span class="function"><span class="title">setPenProperties</span><span class="params">(self)</span></span>:
    dialog = <span class="function"><span class="title">PenPropertiesDlg</span><span class="params">(self)</span></span>
    dialog<span class="class">.widthSpinBox</span><span class="class">.setValue</span>(self.<span class="attribute">width</span>)
    dialog<span class="class">.beveledCheckBox</span><span class="class">.setChecked</span>(self.beveled)
    dialog<span class="class">.styleComboBox</span><span class="class">.setCurrentIndex</span>(
            dialog<span class="class">.styleComboBox</span><span class="class">.findText</span>(self.style))
    <span class="keyword">if</span> dialog.<span class="function"><span class="title">exec_</span><span class="params">()</span></span>:
        self<span class="class">.width</span> = dialog<span class="class">.widthSpinBox</span><span class="class">.value</span>()
        self<span class="class">.beveled</span> = dialog<span class="class">.beveledCheckBox</span><span class="class">.isChecked</span>()
        self<span class="class">.style</span> = <span class="function"><span class="title">unicode</span><span class="params">(dialog.styleComboBox.currentText()</span></span>)
        self.<span class="function"><span class="title">updateData</span><span class="params">()</span></span>
</code></pre><p>当我们调用一个对话框的<code>exec_</code>时，则以模式对话框显示。当用户点击<code>accept</code>，<code>exec_</code>返回<code>True</code>，<br>否则返回<code>False</code>。</p>
<pre><code>class <span class="function">PenPropertiesDlg</span>(QDialog)<span class="value">:
    def __<span class="function">init__</span>(self, parent=None):
        <span class="function">super</span>(PenPropertiesDlg, self).__<span class="function">init__</span>(parent)
        widthLabel = <span class="function">QLabel</span>(<span class="string">"&amp;Width:"</span>)
        self.widthSpinBox = <span class="function">QSpinBox</span>()
        widthLabel.<span class="function">setBuddy</span>(self.widthSpinBox)
        self.widthSpinBox.<span class="function">setAlignment</span>(Qt.AlignRight|Qt.AlignVCenter)
        self.widthSpinBox.<span class="function">setRange</span>(<span class="number">0</span>, <span class="number">24</span>)
        self.beveledCheckBox = <span class="function">QCheckBox</span>(<span class="string">"&amp;Beveled edges"</span>)
        styleLabel = <span class="function">QLabel</span>(<span class="string">"&amp;Style:"</span>)
        self.styleComboBox = <span class="function">QComboBox</span>()
        styleLabel.<span class="function">setBuddy</span>(self.styleComboBox)
        self.styleComboBox.<span class="function">addItems</span>([<span class="string">"Solid"</span>, <span class="string">"Dashed"</span>, <span class="string">"Dotted"</span>,
                                     <span class="string">"DashDotted"</span>, <span class="string">"DashDotDotted"</span>])
        okButton = <span class="function">QPushButton</span>(<span class="string">"&amp;OK"</span>)
        cancelButton = <span class="function">QPushButton</span>(<span class="string">"Cancel"</span>)

        buttonLayout = <span class="function">QHBoxLayout</span>()
        buttonLayout.<span class="function">addStretch</span>()
        buttonLayout.<span class="function">addWidget</span>(okButton)
        buttonLayout.<span class="function">addWidget</span>(cancelButton)
        layout = <span class="function">QGridLayout</span>()
        layout.<span class="function">addWidget</span>(widthLabel, <span class="number">0</span>, <span class="number">0</span>)
        layout.<span class="function">addWidget</span>(self.widthSpinBox, <span class="number">0</span>, <span class="number">1</span>)
        layout.<span class="function">addWidget</span>(self.beveledCheckBox, <span class="number">0</span>, <span class="number">2</span>)
        layout.<span class="function">addWidget</span>(styleLabel, <span class="number">1</span>, <span class="number">0</span>)
        layout.<span class="function">addWidget</span>(self.styleComboBox, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)
        layout.<span class="function">addLayout</span>(buttonLayout, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>)
        self.<span class="function">setLayout</span>(layout)

        self.<span class="function">connect</span>(okButton, <span class="function">SIGNAL</span>(<span class="string">"clicked()"</span>),
                     self, <span class="function">SLOT</span>(<span class="string">"accept()"</span>))
        self.<span class="function">connect</span>(cancelButton, <span class="function">SIGNAL</span>(<span class="string">"clicked()"</span>),
                     self, <span class="function">SLOT</span>(<span class="string">"reject()"</span>))
        self.<span class="function">setWindowTitle</span>(<span class="string">"Pen Properties"</span>)</span>
</code></pre><p>在标签文字中的引号(<code>&amp;</code>)有2个可能的含义，一个简单地为字符引号。另一个指示引号后面的字母为键盘<br>加速键，可以使用Alt+字母快速定位。字符引号和加速键的区别是标签有没有一个“伙伴”。</p>
<p><strong>对话框按钮布局</strong></p>
<pre><code>buttonBox = QDialogButtonBox(QDialogButtonBox.<span class="built_in">Ok</span>
                             | QDialogButtonBox.Cancel)
buttonBox.button(QDialogButtonBox.<span class="built_in">Ok</span>).setDefault(True)
layout.addWidget(buttonBox, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>)
<span class="keyword">self</span>.connect(buttonBox, SIGNAL(<span class="string">"accepted()"</span>),
             <span class="keyword">self</span>, SLOT(<span class="string">"accept()"</span>))
<span class="keyword">self</span>.connect(buttonBox, SIGNAL(<span class="string">"rejected()"</span>),
             <span class="keyword">self</span>, SLOT(<span class="string">"reject()"</span>))
</code></pre><p><code>QDialogButtonBox</code>自动处理不同平台的默认外观。<br><code>QDialogButtonBox</code>默认是水平布局，可以传递<code>Qt.Vertical</code>给它构造器设置垂直布局，或者调用<br><code>setOrientation</code>函数。</p>
<p><code>QGridLayout.addWidget</code>方法的参数是部件，所在行，所在列，和可选的行扩展数，列扩展数。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>b.addLayout(l)</td>
<td style="text-align:left">添加QLayout l到QBoxLayout b中, b通常是QHBoxLayout或QVBoxLayout</td>
</tr>
<tr>
<td>b.addSpacing(i)</td>
<td style="text-align:left">添加一个指定数量为i的QSpacerItem到QBoxLayout b中</td>
</tr>
<tr>
<td>b.addStretch(i)</td>
<td style="text-align:left">添加一个最小为0且伸展系数为i的QSpacerItem到QBoxLayout b中</td>
</tr>
<tr>
<td>b.addWidget(w)</td>
<td style="text-align:left">添加QWidget w到QBoxLayout b中</td>
</tr>
<tr>
<td>b.setStretchFactor(x, i)</td>
<td style="text-align:left">设置QBoxLayout b的伸展系数或QWidget x为i</td>
</tr>
<tr>
<td>g.addLayout(l, r, c)</td>
<td style="text-align:left">在行r列c添加QLayout l到QGridLayout g; 可以提供附加的行扩展和列扩展参数</td>
</tr>
<tr>
<td>g.addWidget(w, r, c)</td>
<td style="text-align:left">在行r列c添加QWidget w到QGridLayout g; 可以提供附加的行扩展和列扩展参数</td>
</tr>
<tr>
<td>g.setRowStretch(r, i)</td>
<td style="text-align:left">设置QGridLayout g行r的伸展为i</td>
</tr>
<tr>
<td>g.setColumnStretch(c, i)</td>
<td style="text-align:left">设置QGridLayout g列c的伸展为i</td>
</tr>
</tbody>
</table>
<h1 id="标准对话框">标准对话框</h1><p>我们认为一个对话框是标准对话框，如果它访问部件都是通过类方法，而不是部件本身。</p>
<h2 id="模式OK/Cancel风格对话框">模式OK/Cancel风格对话框</h2><pre><code>def <span class="function"><span class="title">setNumberFormat1</span><span class="params">(self)</span></span>:
    dialog = numberformatdlg1.<span class="function"><span class="title">NumberFormatDlg</span><span class="params">(self.format, self)</span></span>
    <span class="keyword">if</span> dialog.<span class="function"><span class="title">exec_</span><span class="params">()</span></span>:
        self<span class="class">.format</span> = dialog.<span class="function"><span class="title">numberFormat</span><span class="params">()</span></span>
        self.<span class="function"><span class="title">refreshTable</span><span class="params">()</span></span>
</code></pre><table>
<thead>
<tr>
<th>语法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>d.addButton(b, r)</td>
<td style="text-align:left">添加具有QDialogButtonBox.ButtonRole r的QPushButton b到QDialogButtonBox d中</td>
</tr>
<tr>
<td>d.addButton(t, r)</td>
<td style="text-align:left">添加具有QDialogButtonBox.ButtonRole r且名字为t的QPushButton到QDialogButtonBox d中，返回所添加的按钮</td>
</tr>
<tr>
<td>d.addButton(s)</td>
<td style="text-align:left">添加由QDialogButtonBox.StandardButton s指定的按钮QDialogButtonBox d中，返回所添加的按钮</td>
</tr>
<tr>
<td>d.setOrientation(o)</td>
<td style="text-align:left">设置QDialogButtonBox d的方向为Qt.Orientation o(垂直或水平)</td>
</tr>
<tr>
<td>d.button(s)</td>
<td style="text-align:left">返回QDialogButtonBox d中由StandardButton s指定的按钮，或None</td>
</tr>
<tr>
<td>d.accepted()</td>
<td style="text-align:left">当角色为QDialogButtonBox.Accept的按钮被点击，发射该信号</td>
</tr>
<tr>
<td>d.rejected()</td>
<td style="text-align:left">当角色为QDialogButtonBox.Reject的按钮被点击，发射该信号</td>
</tr>
</tbody>
</table>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">accept</span><span class="params">(self)</span>:</span>
    <span class="class"><span class="keyword">class</span> <span class="title">ThousandsError</span><span class="params">(Exception)</span>:</span> <span class="keyword">pass</span>
    <span class="class"><span class="keyword">class</span> <span class="title">DecimalError</span><span class="params">(Exception)</span>:</span> <span class="keyword">pass</span>
    QMessageBox.warning(self, <span class="string">"Decimal Marker Error"</span>, unicode(e))
    QDialog.accept(self)
</code></pre><p>为什么这里不使用<code>super</code>来调用基类的<code>accept</code>而是显式使用<code>QDialog</code>？因为在这个环境下使用<code>super</code><br>不起作用。PyQt为了尽可能效率高，使用懒惰属性查找，结果就是此处的<code>super</code>在PyQt的子类中不会像预期<br>那样工作。(见pyqt4ref.html文档，”super and PyQt classes”)</p>
<h1 id="智能对话框">智能对话框</h1><p>智能对话框通常是无模式的，带有<code>apply</code>和<code>close</code>按钮。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>d.accept()</td>
<td style="text-align:left">关闭(隐藏)QDialog d，停止事件循环，并导致exec_()返回True。如果设置了Qt.WA_DeleteOnClose，则对话框被删除</td>
</tr>
<tr>
<td>d.reject()</td>
<td style="text-align:left">关闭(隐藏)QDialog d，停止事件循环，并导致exec_()返回False。</td>
</tr>
<tr>
<td>d.done(i)</td>
<td style="text-align:left">关闭(隐藏)QDialog d，停止事件循环，并导致exec_()返回i。</td>
</tr>
<tr>
<td>d.exec_()</td>
<td style="text-align:left">模式显示QDialog d，阻塞直到对话框关闭</td>
</tr>
<tr>
<td>d.show()</td>
<td style="text-align:left">无模式显示QDialog d；继承自QWidget</td>
</tr>
<tr>
<td>d.setSizeGripEnabled(b)</td>
<td style="text-align:left">显示或隐藏QDialog d的size grip，基于bool b</td>
</tr>
</tbody>
</table>
<h2 id="无模式Apply/Close风格对话框">无模式Apply/Close风格对话框</h2><pre><code><span class="function"><span class="keyword">def</span> <span class="title">setNumberFormat2</span><span class="params">(self)</span>:</span>
    dialog = numberformatdlg2.NumberFormatDlg(self.format, self)
    self.connect(dialog, SIGNAL(<span class="string">"changed"</span>), self.refreshTable)
    dialog.show()
</code></pre><p>尽管dialog超出范围，PyQt足够聪明地保存了一个无模式对话框的引用，因此dialog继续存在。可以设置<br>dialog的属性为Qt.WA_DeleteOnClose，则每次都删除对话框而不是隐藏。</p>
<pre><code>def __init__(<span class="literal">self</span>, format, parent=None):
    super(NumberFormatDlg, <span class="literal">self</span>).__init__(parent)
    <span class="literal">self</span>.<span class="built_in">set</span>Attribute(Qt.WA_DeleteOnClose)
    punctuationRe = QRegExp(r<span class="string">"[ ,;:.]"</span>)
    thousandsLabel = QLabel(<span class="string">"&amp;Thousands separator"</span>)
    <span class="literal">self</span>.thousandsEdit = QLineEdit(format[<span class="string">"thousandsseparator"</span>])
    thousandsLabel.<span class="built_in">set</span>Buddy(<span class="literal">self</span>.thousandsEdit)
    <span class="literal">self</span>.thousandsEdit.<span class="built_in">set</span>MaxLength(<span class="number">1</span>)
    <span class="literal">self</span>.thousandsEdit.<span class="built_in">set</span>Validator(
            QRegExpValidator(punctuationRe, <span class="literal">self</span>))
    decimalMarkerLabel = QLabel(<span class="string">"Decimal &amp;marker"</span>)
    <span class="literal">self</span>.decimalMarkerEdit = QLineEdit(format[<span class="string">"decimalmarker"</span>])
    decimalMarkerLabel.<span class="built_in">set</span>Buddy(<span class="literal">self</span>.decimalMarkerEdit)
    <span class="literal">self</span>.decimalMarkerEdit.<span class="built_in">set</span>MaxLength(<span class="number">1</span>)
    <span class="literal">self</span>.decimalMarkerEdit.<span class="built_in">set</span>Validator(
            QRegExpValidator(punctuationRe, <span class="literal">self</span>))
    <span class="literal">self</span>.decimalMarkerEdit.<span class="built_in">set</span>InputMask(<span class="string">"X"</span>)
    decimalPlacesLabel = QLabel(<span class="string">"&amp;Decimal places"</span>)
    <span class="literal">self</span>.decimalPlacesSpinBox = QSpinBox()
    decimalPlacesLabel.<span class="built_in">set</span>Buddy(<span class="literal">self</span>.decimalPlacesSpinBox)
    <span class="literal">self</span>.decimalPlacesSpinBox.<span class="built_in">set</span>Range(<span class="number">0</span>, <span class="number">6</span>)
    <span class="literal">self</span>.decimalPlacesSpinBox.<span class="built_in">set</span>Value(format[<span class="string">"decimalplaces"</span>])
    <span class="literal">self</span>.redNegativesCheckBox = QCheckBox(<span class="string">"&amp;Red negative numbers"</span>)
    <span class="literal">self</span>.redNegativesCheckBox.<span class="built_in">set</span>Checked(format[<span class="string">"rednegatives"</span>])
    buttonBox = QDialogButtonBox(QDialogButtonBox.Apply|
                                 QDialogButtonBox.Close)
    <span class="literal">self</span>.connect(buttonBox.button(QDialogButtonBox.Apply),
                 SIGNAL(<span class="string">"clicked()"</span>), <span class="literal">self</span>.apply)
    <span class="literal">self</span>.connect(buttonBox, SIGNAL(<span class="string">"rejected()"</span>),
                 <span class="literal">self</span>, SLOT(<span class="string">"reject()"</span>))
    <span class="literal">self</span>.<span class="built_in">set</span>WindowTitle(<span class="string">"Set Number Format (Modeless)"</span>)
</code></pre><p><code>QRegExpValidator</code>初始化式需要一个正则表达式和一个<code>parent</code>。<br>一个掩饰“X”说明需要任意一个字符，格式掩饰在<code>QLineEdit.inputMask</code>文档中说明。</p>
<h2 id="无模式“Live”对话框">无模式“Live”对话框</h2><pre><code>def <span class="function"><span class="title">setNumberFormat3</span><span class="params">(self)</span></span>:
    <span class="keyword">if</span> self<span class="class">.numberFormatDlg</span> is None:
        self<span class="class">.numberFormatDlg</span> = numberformatdlg3.NumberFormatDlg(
                self<span class="class">.format</span>, self<span class="class">.refreshTable</span>, self)
    self<span class="class">.numberFormatDlg</span><span class="class">.show</span>()
    self<span class="class">.numberFormatDlg</span><span class="class">.raise_</span>()
    self<span class="class">.numberFormatDlg</span><span class="class">.activateWindow</span>()
</code></pre><p><code>raise_</code>将对话框置于其它窗口之上<br><code>activateWindow</code>聚焦于对话框</p>
<pre><code>self.connect(self<span class="class">.thousandsEdit</span>,
             <span class="function"><span class="title">SIGNAL</span><span class="params">(<span class="string">"textEdited(QString)"</span>)</span></span>, self.checkAndFix)
self.connect(self<span class="class">.decimalMarkerEdit</span>,
             <span class="function"><span class="title">SIGNAL</span><span class="params">(<span class="string">"textEdited(QString)"</span>)</span></span>, self.checkAndFix)
self.connect(self<span class="class">.decimalPlacesSpinBox</span>,
             <span class="function"><span class="title">SIGNAL</span><span class="params">(<span class="string">"valueChanged(int)"</span>)</span></span>, self.apply)
self.connect(self<span class="class">.redNegativesCheckBox</span>,
             <span class="function"><span class="title">SIGNAL</span><span class="params">(<span class="string">"toggled(bool)"</span>)</span></span>, self.apply)
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>对话框以“智力”分类为：哑巴，标准和聪明，取决于对话框知道程序数据的多少。<br>对话框以“模式”分类为：模式对话框和无模式对话框。</p>
<p>应用模式对话框一旦被调用，用户只能与其交互，不能使用程序其它部分。<br>窗口模式对话框和应用模式对话框类似，只是它仅仅阻止与]]>
    </summary>
    
      <category term="PyQt" scheme="https://opensvn.github.io/tags/PyQt/"/>
    
      <category term="Python" scheme="https://opensvn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PyQt编程第四章 GUI编程介绍]]></title>
    <link href="https://opensvn.github.io/2015/10/12/pyqt-4/"/>
    <id>https://opensvn.github.io/2015/10/12/pyqt-4/</id>
    <published>2015-10-12T12:34:55.000Z</published>
    <updated>2015-10-14T05:57:31.771Z</updated>
    <content type="html"><![CDATA[<h1 id="一个25行的弹出警告">一个25行的弹出警告</h1><pre><code><span class="keyword">import</span> sys
<span class="keyword">import</span> time
<span class="keyword">from</span> PyQt4.QtCore <span class="keyword">import</span> *
<span class="keyword">from</span> PyQt4.QtGui <span class="keyword">import</span> *

app = QApplication(sys.argv)

<span class="keyword">try</span>:
    due = QTime.currentTime()
    message = <span class="string">"Alert!"</span>
    <span class="keyword">if</span> len(sys.argv) &lt; <span class="number">2</span>:
        <span class="keyword">raise</span> ValueError
    hours, mins = sys.argv[<span class="number">1</span>].split(<span class="string">":"</span>)
    due = QTime(int(hours), int(mins))
    <span class="keyword">if</span> <span class="keyword">not</span> due.isValid():
        <span class="keyword">raise</span> ValueError
    <span class="keyword">if</span> len(sys.argv) &gt; <span class="number">2</span>:
        message = <span class="string">" "</span>.join(sys.argv[<span class="number">2</span>:])
<span class="keyword">except</span> ValueError:
    message = <span class="string">"Usage: alert.pyw HH:MM [optional message]"</span> <span class="comment"># 24hr clock</span>

<span class="keyword">while</span> QTime.currentTime() &lt; due:
    time.sleep(<span class="number">20</span>) <span class="comment"># 20 seconds</span>

label = QLabel(<span class="string">"&lt;font color=red size=72&gt;&lt;b&gt;"</span> + message + <span class="string">"&lt;/b&gt;&lt;/font&gt;"</span>)
label.setWindowFlags(Qt.SplashScreen)
label.show()
QTimer.singleShot(<span class="number">60000</span>, app.quit) <span class="comment"># 1 minute</span>
app.exec_()
</code></pre><p>每一个PyQt图形程序必须有一个<code>QApplication</code>对象，因为它能识别一些命令行的参数，接受<code>sys.argv</code>作为<br>参数。</p>
<p>PyQt中任何部件都能用作顶级窗口，比如一个按钮或一个标签。当部件如此使用时，PyQt自动给它一个标题栏。<br>一旦窗口设置好后，就可以调用<code>show</code>方法，这个时候窗口没有显示。<code>show</code>方法仅仅是将一个画图事件加入<br><code>QApplication</code>对象的事件队列。</p>
<p><code>app.exec_</code>开始<code>QApplication</code>对象事件循环。第一个事件是画图事件，因此标签窗口弹出。一分钟后超时<br>事件触发，<code>app.quit</code>被调用。这个方法执行图形程序的结束清理工作，关闭窗口，释放资源。</p>
<p>图形程序的事件循环，伪代码如下：</p>
<pre><code><span class="keyword">while</span> <span class="keyword">True</span>:
    <span class="keyword">event</span> = getNextEvent()
    <span class="keyword">if</span> <span class="keyword">event</span>:
        <span class="keyword">if</span> <span class="keyword">event</span> == Terminate:
            <span class="keyword">break</span>
        processEvent(<span class="keyword">event</span>)
</code></pre><h1 id="一个30行的表达式求值程序">一个30行的表达式求值程序</h1><pre><code><span class="keyword">from</span> __future__ <span class="keyword">import</span> division
<span class="keyword">import</span> sys
<span class="keyword">from</span> math <span class="keyword">import</span> *
<span class="keyword">from</span> PyQt4.QtCore <span class="keyword">import</span> *
<span class="keyword">from</span> PyQt4.QtGui <span class="keyword">import</span> *

<span class="class"><span class="keyword">class</span> <span class="title">Form</span><span class="params">(QDialog)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent=None)</span>:</span>
        super(Form, self).__init__(parent)
        self.browser = QTextBrowser()
        self.lineedit = QLineEdit(<span class="string">"Type an expression and press Enter"</span>)
        self.lineedit.selectAll()
        layout = QVBoxLayout()
        layout.addWidget(self.browser)
        layout.addWidget(self.lineedit)
        self.setLayout(layout)
        self.lineedit.setFocus()
        self.connect(self.lineedit, SIGNAL(<span class="string">"returnPressed()"</span>),
                     self.updateUi)
        self.setWindowTitle(<span class="string">"Calculate"</span>)

    <span class="function"><span class="keyword">def</span> <span class="title">updateUi</span><span class="params">(self)</span>:</span>
        <span class="keyword">try</span>:
            text = unicode(self.lineedit.text())
            self.browser.append(<span class="string">"%s = &lt;b&gt;%s&lt;/b&gt;"</span> % (text, eval(text)))
        <span class="keyword">except</span>:
            self.browser.append(
                    <span class="string">"&lt;font color=red&gt;%s is invalid!&lt;/font&gt;"</span> % text)

app = QApplication(sys.argv)
form = Form()
form.show()
app.exec_()
</code></pre><p>所有PyQt的部件，都继承自<code>QWidget</code>，并且都是新风格的类。默认地，当一个部件被关闭时，它仅仅是被隐藏了。<br>当一个窗体隐藏了，如果PyQt检查到程序没有可见窗体，而且进一步交互也不可能，PyQt会执行程序的结束清理工作。</p>
<blockquote>
<p><strong>对象所有权</strong></p>
<ul>
<li>所有PyQt类继承自<code>QObject</code>，包括所有的部件。没有父亲的部件是一个顶级窗口，孩子部件被包含在父亲部件<br>里面。父亲部件对孩子部件拥有所有权。</li>
<li>PyQt使用父子所有权模型来保证当一个父亲部件被销毁，所有它的孩子部件也被自动销毁。</li>
<li>为避免内存泄漏，除了顶级窗口，我们应该保证所有部件都有父亲。</li>
<li>布局管理器自动将部件重新绑定到正确的父亲部件上。</li>
</ul>
</blockquote>
<p>PyQt提供3种布局管理器：垂直布局，水平布局，网格布局。布局可以嵌套。<br>每一个部件通过发射信号声明状态改变。</p>
<h1 id="一个70行的汇率转换器">一个70行的汇率转换器</h1><pre><code>import sys
import urllib2
<span class="keyword">from</span> PyQt4.QtCore import *
<span class="keyword">from</span> PyQt4.QtGui import *

class Form(QDialog):
    def __init__(<span class="literal">self</span>, parent=None):
        super(Form, <span class="literal">self</span>).__init__(parent)

        date = <span class="literal">self</span>.getdata()
        rates = sorted(<span class="literal">self</span>.rates.keys())

        dateLabel = QLabel(date)
        <span class="literal">self</span>.<span class="keyword">from</span>ComboBox = QComboBox()
        <span class="literal">self</span>.<span class="keyword">from</span>ComboBox.addItems(rates)
        <span class="literal">self</span>.<span class="keyword">from</span>SpinBox = QDoubleSpinBox()
        <span class="literal">self</span>.<span class="keyword">from</span>SpinBox.<span class="built_in">set</span>Range(<span class="number">0.01</span>, <span class="number">10000000.00</span>)
        <span class="literal">self</span>.<span class="keyword">from</span>SpinBox.<span class="built_in">set</span>Value(<span class="number">1.00</span>)
        <span class="literal">self</span>.<span class="keyword">to</span>ComboBox = QComboBox()
        <span class="literal">self</span>.<span class="keyword">to</span>ComboBox.addItems(rates)
        <span class="literal">self</span>.<span class="keyword">to</span>Label = QLabel(<span class="string">"1.00"</span>)
        grid = QGridLayout()
        grid.addWidget(dateLabel, <span class="number">0</span>, <span class="number">0</span>)
        grid.addWidget(<span class="literal">self</span>.<span class="keyword">from</span>ComboBox, <span class="number">1</span>, <span class="number">0</span>)
        grid.addWidget(<span class="literal">self</span>.<span class="keyword">from</span>SpinBox, <span class="number">1</span>, <span class="number">1</span>)
        grid.addWidget(<span class="literal">self</span>.<span class="keyword">to</span>ComboBox, <span class="number">2</span>, <span class="number">0</span>)
        grid.addWidget(<span class="literal">self</span>.<span class="keyword">to</span>Label, <span class="number">2</span>, <span class="number">1</span>)
        <span class="literal">self</span>.<span class="built_in">set</span>Layout(grid)
        <span class="literal">self</span>.connect(<span class="literal">self</span>.<span class="keyword">from</span>ComboBox,
                SIGNAL(<span class="string">"currentIndexChanged(int)"</span>), <span class="literal">self</span>.updateUi)
        <span class="literal">self</span>.connect(<span class="literal">self</span>.<span class="keyword">to</span>ComboBox,
                SIGNAL(<span class="string">"currentIndexChanged(int)"</span>), <span class="literal">self</span>.updateUi)
        <span class="literal">self</span>.connect(<span class="literal">self</span>.<span class="keyword">from</span>SpinBox,
                SIGNAL(<span class="string">"valueChanged(double)"</span>), <span class="literal">self</span>.updateUi)
        <span class="literal">self</span>.<span class="built_in">set</span>WindowTitle(<span class="string">"Currency"</span>)

    def updateUi(<span class="literal">self</span>):
        <span class="keyword">to</span> = unicode(<span class="literal">self</span>.<span class="keyword">to</span>ComboBox.currentText())
        from_ = unicode(<span class="literal">self</span>.<span class="keyword">from</span>ComboBox.currentText())
        amount = (<span class="literal">self</span>.rates[from_] / <span class="literal">self</span>.rates[<span class="keyword">to</span>]) * \
                 <span class="literal">self</span>.<span class="keyword">from</span>SpinBox.value()
        <span class="literal">self</span>.<span class="keyword">to</span>Label.<span class="built_in">set</span>Text(<span class="string">"%0.2f"</span> % amount)

    def getdata(<span class="literal">self</span>): <span class="comment"># Idea taken from the Python Cookbook</span>
        <span class="literal">self</span>.rates = {}
        try:
            date = <span class="string">"Unknown"</span>
            fh = urllib2.urlopen(<span class="string">"http://www.bankofcanada.ca"</span>
                                 <span class="string">"/en/markets/csv/exchange_eng.csv"</span>)
            <span class="keyword">for</span> line <span class="keyword">in</span> fh:
                line = line.rstrip()
                if not line or line.startswith((<span class="string">"#"</span>, <span class="string">"Closing "</span>)):
                    continue
                fields = line.split(<span class="string">","</span>)
                if line.startswith(<span class="string">"Date "</span>):
                    date = fields[-<span class="number">1</span>]
                else:
                    try:
                        value = float(fields[-<span class="number">1</span>])
                        <span class="literal">self</span>.rates[unicode(fields[<span class="number">0</span>])] = value
                    except ValueError:
                        <span class="built_in">pass</span>
            return <span class="string">"Exchange Rates Date: "</span> + date
        except Exception, e:
            return <span class="string">"Failed to download:\n%s"</span> % e

app = QApplication(sys.argv)
form = Form()
form.show()
app.exec_()
</code></pre><h1 id="信号和槽">信号和槽</h1><p>每一个<code>QObject</code>支持信号和槽机制。所有的PyQt部件都有一组预定义的信号。不管什么时候一个信号发射，PyQt<br>默认简单地将其丢掉。必须将信号连接到槽来捕捉信号。在PyQt中，槽是任何可调用的对象。大多数部件也有预定义<br>好的槽。</p>
<p><code>connect</code>的语法，s通常是<code>self</code>，w是部件：</p>
<pre><code>s.<span class="function"><span class="title">connect</span><span class="params">(w, SIGNAL(<span class="string">"signalSignature"</span>)</span></span>, functionName)
s.<span class="function"><span class="title">connect</span><span class="params">(w, SIGNAL(<span class="string">"signalSignature"</span>)</span></span>, instance.methodName)
s.<span class="function"><span class="title">connect</span><span class="params">(w, SIGNAL(<span class="string">"signalSignature"</span>)</span></span>, instance, <span class="function"><span class="title">SLOT</span><span class="params">(<span class="string">"slotSignature"</span>)</span></span>)
</code></pre><p>signalSignature是信号的名字，并带一个逗号隔开的参数列表。如果是Qt信号，则参数类型必须是C++类型。<br>当书写信号的C++参数类型时，可以丢弃<code>const</code>和<code>&amp;</code>，但是必须保留<code>*</code>。</p>
<p>PyQt信号发射时被定义，它们可以有任意数量，任意类型的参数。</p>
<p>slotSignature和signalSignature有着一样的形式。一个槽的参数可能比信号少。相应的信号和槽的参数必须类型相同。<br>如果是Qt槽而不是Python方法时，使用<code>SLOT</code>语法效率更高。</p>
<pre><code>self.<span class="function"><span class="title">connect</span><span class="params">(dial, SIGNAL(<span class="string">"valueChanged(int)"</span>)</span></span>, spinbox, <span class="function"><span class="title">SLOT</span><span class="params">(<span class="string">"setValue(int)"</span>)</span></span>)
self.<span class="function"><span class="title">connect</span><span class="params">(spinbox, SIGNAL(<span class="string">"valueChanged(int)"</span>)</span></span>, dial, <span class="function"><span class="title">SLOT</span><span class="params">(<span class="string">"setValue(int)"</span>)</span></span>)
</code></pre><p>可以将多个信号连接到同一个槽，也可以将一个信号连接到多个槽。尽管很罕见，我们也可以将一个信号连接到另一个<br>信号，这样当第一个信号发射时，将会引起它连接的信号发射。</p>
<p>通过<code>QObject.connect</code>建立连接，<code>QObject.disconnect</code>解除连接。实际上，我们很少需要自己解除连接，<br>PyQt会自动解除已经销毁的对象相关的连接。</p>
<p>使用<code>QObject.emit</code>发射自定义的信号。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">ZeroSpinBox</span><span class="params">(QSpinBox)</span>:</span>
    zeros = <span class="number">0</span>

    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent=None)</span>:</span>
        super(ZeroSpinBox, self).__init__(parent)
        self.connect(self, SIGNAL(<span class="string">'valueChanged(int)'</span>), self.checkzero)

    <span class="function"><span class="keyword">def</span> <span class="title">checkzero</span><span class="params">(self)</span>:</span>
        <span class="keyword">if</span> self.value() == <span class="number">0</span>:
            self.zeros += <span class="number">1</span>
            self.emit(SIGNAL(<span class="string">'atzero'</span>), self.zeros)
</code></pre><p>一个没有参数(没有括号)的信号是一个短路Python信号。当这种信号被发射，任何数据都可以当作额外的参数传给<br><code>emit</code>方法，这些参数被当作Python对象传递。<br>至少有一个参数的信号是Qt信号或非短路Python信号，其参数都将转换为C++数据类型。</p>
<p>PyQt的信号和槽机制并不局限于GUI类，任何<code>QObject</code>的子类都可以使用信号和槽。</p>
<pre><code><span class="keyword">from</span> PyQt4.QtCore <span class="keyword">import</span> *

<span class="class"><span class="keyword">class</span> <span class="title">TaxRate</span><span class="params">(QObject)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>
        super(TaxRate, self).__init__()
        self.__rate = <span class="number">17.5</span>

    <span class="function"><span class="keyword">def</span> <span class="title">rate</span><span class="params">(self)</span>:</span>
        <span class="keyword">return</span> self.__rate

    <span class="function"><span class="keyword">def</span> <span class="title">setRate</span><span class="params">(self, rate)</span>:</span>
        <span class="keyword">if</span> rate != self.__rate:
            self.__rate = rate
            self.emit(SIGNAL(<span class="string">'rateChanged'</span>), self.__rate)

<span class="function"><span class="keyword">def</span> <span class="title">rateChanged</span><span class="params">(value)</span>:</span>
    <span class="keyword">print</span> <span class="string">'TaxRate changed to %.2f%%'</span> % value

vat = TaxRate()
vat.connect(vat, SIGNAL(<span class="string">'rateChanged'</span>), rateChanged)
vat.setRate(<span class="number">17.5</span>)
vat.setRate(<span class="number">8.5</span>)
</code></pre><p>多个信号连接到同一个槽时，如何确定谁调用了槽。</p>
<pre><code><span class="literal">self</span>.connect(button2, SIGNAL(<span class="string">"clicked()"</span>),
             partial(<span class="literal">self</span>.<span class="literal">any</span>Button, <span class="string">"Two"</span>)) <span class="comment"># WRONG for PyQt 4.0-4.2</span>
<span class="literal">self</span>.connect(button3, SIGNAL(<span class="string">"clicked()"</span>),
             lambda who=<span class="string">"Three"</span>: <span class="literal">self</span>.<span class="literal">any</span>Button(who)) <span class="comment"># WRONG before 4.1.1</span>
</code></pre><p>在PyQt4.3之前，在<code>connect</code>中创建的函数，在<code>connect</code>返回时被垃圾回收。因此需要保存一个引用到该函数。<br>在PyQt4.1.1之前，在<code>connect</code>中创建的<code>lambda</code>也会被垃圾回收，同样需要保存一个引用。</p>
<pre><code>self<span class="class">.button2callback</span> = <span class="function"><span class="title">partial</span><span class="params">(self.anyButton, <span class="string">"Two"</span>)</span></span>
self.<span class="function"><span class="title">connect</span><span class="params">(button2, SIGNAL(<span class="string">"clicked()"</span>)</span></span>, self.button2callback)

self<span class="class">.button3callback</span> = lambda who=<span class="string">"Three"</span>: self.<span class="function"><span class="title">anyButton</span><span class="params">(who)</span></span>
self.<span class="function"><span class="title">connect</span><span class="params">(button3, SIGNAL(<span class="string">"clicked()"</span>)</span></span>, self.button3callback)
</code></pre><p>另外一种方法是使用<code>sender</code>告诉我们是哪个对象。</p>
<pre><code>self.connect(button4, SIGNAL(<span class="string">"clicked()"</span>), self.clicked)
self.connect(button5, SIGNAL(<span class="string">"clicked()"</span>), self.clicked)
<span class="function"><span class="keyword">def</span> <span class="title">clicked</span><span class="params">(self)</span>:</span>
    button = self.sender()
    <span class="keyword">if</span> button <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> <span class="keyword">not</span> isinstance(button, QPushButton):
        <span class="keyword">return</span>
    self.label.setText(<span class="string">"You clicked button '%s'"</span> % button.text())
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="一个25行的弹出警告">一个25行的弹出警告</h1><pre><code><span class="keyword">import</span> sys
<span class="keyword">import</span> time
<span class="]]>
    </summary>
    
      <category term="PyQt" scheme="https://opensvn.github.io/tags/PyQt/"/>
    
      <category term="Python" scheme="https://opensvn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PyQt编程第一章 数据类型和数据结构]]></title>
    <link href="https://opensvn.github.io/2015/10/12/pyqt-1/"/>
    <id>https://opensvn.github.io/2015/10/12/pyqt-1/</id>
    <published>2015-10-12T10:57:23.000Z</published>
    <updated>2015-10-14T03:34:21.602Z</updated>
    <content type="html"><![CDATA[<h1 id="执行Python代码">执行Python代码</h1><pre><code><span class="built_in">print</span> <span class="string">'Hello world'</span>
</code></pre><p><code>Python</code>读取<code>.py</code>或<code>.pyw</code>文件到内存，解析文件，生成字节码，然后运行。<br>对于<code>import</code>的模块，<code>Python</code>首先检查是否存在预编译的字节码(<code>pyo</code>或<code>pyc</code>)，根据时间戳判断<br>是否需要重新编译。在大多数<code>Python</code>的安装过程中，提供的模块都被编译了，来避免使用时编译。</p>
<h1 id="变量和对象">变量和对象</h1><p><code>Python</code>变量没有类型限制(动态类型)，而且它们也不需要声明。</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; x = <span class="number">71</span>
<span class="prompt">&gt;&gt;</span>&gt; y = <span class="string">'Dove'</span>
</code></pre><p>变量是对象的引用，并不是对象本身。</p>
<blockquote>
<p><strong>函数，方法和操作符</strong><br>函数是可以独立执行的子例程。方法是只能绑定到一个对象执行的函数。操作符可以独立或绑定到对象，<br>但是不需要括号。</p>
</blockquote>
<p><code>Python</code>有两种比较对象的方式：通过<strong>身份</strong>和通过<strong>值</strong>。一个对象的身份是内存中的有效地址，<br>这也是对象引用所保存的值。如果使用比较操作符，如<code>==</code>和<code>&lt;</code>，是值的比较。如果使用<code>is</code>，则是<br>身份的比较，这种比较很快。一个对象的身份可以通过<code>id()</code>获取。</p>
<p><code>Python</code>有一个特殊对象<code>None</code>，可以赋值给任何变量，意思是没有值。<code>None</code>对象只有一个实例，<br>因此<code>is</code>和<code>is not</code>比较<code>None</code>总是很快。</p>
<p>将一个值赋值给一个变量称为绑定。如果赋值给一个已经存在的变量，称为重新绑定。一旦一个对象没有<br>名字绑定，则加入垃圾回收进程。</p>
<p><code>Python</code>变量名由<code>ASCII</code>字母，数字和下划线组成。变量名不应该与<code>Python</code>的关键字或内置常量<br>如<code>None</code>，<code>True</code>，<code>False</code>相同。</p>
<h1 id="数字和字符串">数字和字符串</h1><p><code>Python</code>提供了几种数字类型和两种字符串类型。这些类型都是不可变的。</p>
<pre><code><span class="prompt">&gt;&gt;</span>&gt; x = <span class="number">5</span>
<span class="prompt">&gt;&gt;</span>&gt; y = x
<span class="prompt">&gt;&gt;</span>&gt; x, y
(<span class="number">5</span>, <span class="number">5</span>)
<span class="prompt">&gt;&gt;</span>&gt; y += <span class="number">1</span>
<span class="prompt">&gt;&gt;</span>&gt; x, y
(<span class="number">5</span>, <span class="number">6</span>)
</code></pre><p>增量赋值操作符应用到不可变对象只是一个语法糖：它并没有改变对象，而是创建了一个新对象，并重新<br>绑定到新对象。</p>
<p>我们需要记住<code>=</code>操作符执行绑定操作而不是赋值。</p>
<h2 id="整数和长整数">整数和长整数</h2><p><code>Python</code>提供3种整数类型：<code>bool</code>，<code>int</code>，<code>long</code>。<br><code>bool</code>类型的值只能是<code>True</code>和<code>False</code>。当用于数字环境时，被当作1和0。<br><code>long</code>类型的长度只局限于机器的可用内存。<br><code>int</code>类型的长度和大多数语言的一样。当<code>int</code>类型有溢出危险时，自动提升为<code>long</code>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="执行Python代码">执行Python代码</h1><pre><code><span class="built_in">print</span> <span class="string">'Hello world'</span>
</code></pre><p>]]>
    </summary>
    
      <category term="PyQt" scheme="https://opensvn.github.io/tags/PyQt/"/>
    
      <category term="Python" scheme="https://opensvn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第15章 面向对象编程]]></title>
    <link href="https://opensvn.github.io/2015/09/21/cpp_primer_15/"/>
    <id>https://opensvn.github.io/2015/09/21/cpp_primer_15/</id>
    <published>2015-09-21T01:04:53.000Z</published>
    <updated>2015-12-15T11:27:27.778Z</updated>
    <content type="html"><![CDATA[<h1 id="15-1_OOP概述">15.1 OOP概述</h1><p>面向对象编程的关键思想是数据抽象，继承和动态绑定。使用数据抽象，我们可以定义接口和实现分离的类。通过继承，我们可以定义相似类之间的关系模型。通过动态绑定，我们可以使用这些类对象而忽略它们之间的差别。</p>
<h2 id="继承">继承</h2><p>通过继承联系的类构成一个层级关系。典型地，有一个基类在层级的顶端，其它类直接或间接继承这个类。这些继承类被称为派生类。基类定义层级中共同的成员。每一个派生类定义它自己特定的成员。</p>
<pre><code><span class="keyword">class</span> Quote {
<span class="keyword">public</span>:
    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span></span>;
    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::size_t n)</span> <span class="keyword">const</span></span>;
};
</code></pre><p>派生类必须指定继承自哪个（或哪些）基类。继承列表是逗号分隔的包含可选访问限定符的基类列表。</p>
<pre><code><span class="keyword">class</span> Bulk_quote : <span class="keyword">public</span> Quote { <span class="comment">// Bulk_quote继承自Quote</span>
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::size_t)</span> <span class="keyword">const</span> override</span>;
};
</code></pre><p>派生类必须在类定义里面包含所有它想定义的虚函数的声明。派生类可以声明这些函数为<strong>virtual</strong>，但没有要求这么做。新标准让派生类可以显式指定想要覆盖的虚函数，在参数列表后面指定<strong>override</strong>就可以。</p>
<h2 id="动态绑定">动态绑定</h2><pre><code><span class="function"><span class="keyword">double</span> <span class="title">print_total</span><span class="params">(ostream &amp;os,
                   <span class="keyword">const</span> Quote &amp;item, size_t n)</span>
</span>{
    <span class="comment">// 取决于绑定到item参数的类型调用Quote::net_price或Bulk_quote::net_price</span>
    <span class="keyword">double</span> ret = item.net_price(n);
    os &lt;&lt; <span class="string">"ISBN: "</span> &lt;&lt; item.isbn() <span class="comment">// 调用Quote::isbn</span>
       &lt;&lt; <span class="string">" # sold: "</span> &lt;&lt; n &lt;&lt; <span class="string">" total due: "</span> &lt;&lt; ret &lt;&lt; endl;
     <span class="keyword">return</span> ret;
}

<span class="comment">// basic是Quote类型; bulk是Bulk_quote类型</span>
print_total(<span class="built_in">cout</span>, basic, <span class="number">20</span>); <span class="comment">// 调用Quote::net_price</span>
print_total(<span class="built_in">cout</span>, bulk, <span class="number">20</span>);  <span class="comment">// 调用Bulk_quote::net_price</span>
</code></pre><p>因为直到运行时才能根据对象的实际类型确定调用哪个函数，因此动态绑定又叫运行时绑定。</p>
<blockquote>
<p><strong>注解</strong><br>在C++中，动态绑定发生在通过基类的引用或指针调用虚函数时。</p>
</blockquote>
<h1 id="15-2_定义基类和派生类">15.2 定义基类和派生类</h1><h2 id="15-2-1_定义一个基类">15.2.1 定义一个基类</h2><pre><code><span class="keyword">class</span> Quote {
<span class="keyword">public</span>:
    Quote() = <span class="keyword">default</span>;
    Quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;book, <span class="keyword">double</span> sales_price):
                     bookNo(book), price(sales_price) { }
    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> bookNo; }
    <span class="comment">// 派生类将覆盖和应用不同的打折策略</span>
    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::size_t n)</span> <span class="keyword">const</span>
               </span>{ <span class="keyword">return</span> n * price; }
    <span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>; <span class="comment">// 析构函数动态绑定</span>
<span class="keyword">private</span>:
    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;
<span class="keyword">protected</span>:
    <span class="keyword">double</span> price = <span class="number">0.0</span>;
};
</code></pre><blockquote>
<p><strong>注解</strong><br>基类通常应该定义一个虚析构函数，即使没有什么工作要做。</p>
</blockquote>
<h3 id="成员函数和继承">成员函数和继承</h3><p>基类将那些期望派生类覆盖的函数定义为虚函数。任何非<strong>static</strong>的成员函数，除了构造函数，都可以为虚函数。关键字<strong>virtual</strong>仅仅出现在类里面声明处，在类外面函数定义处不需要出现。基类中声明为<strong>virtual</strong>的函数，在派生类中隐式为<strong>virtual</strong>。</p>
<p>没有被声明为<strong>virtual</strong>的成员函数在编译的时候确定。</p>
<h3 id="访问控制和继承">访问控制和继承</h3><p>派生类继承基类的成员，但是派生类的成员函数不能访问基类的私有成员。有时候基类允许派生类访问而又禁止其他用户使用，我们指定这类成员为<strong>protected</strong>。</p>
<h2 id="15-2-2_定义一个派生类">15.2.2 定义一个派生类</h2><p>派生类必须指定继承自哪个类，子类在类继承列表中指定基类。类继承列表由逗号分隔的基类名组成，每个基类名前面可能有<strong>public</strong>，<strong>protected</strong>，<strong>private</strong>其中一个。派生类必须声明每一个想要覆盖的成员函数。</p>
<pre><code><span class="keyword">class</span> Bulk_quote : <span class="keyword">public</span> Quote { <span class="comment">// Bulk_quote继承自Quote</span>
    Bulk_quote() = <span class="keyword">default</span>;
    Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;, <span class="keyword">double</span>, <span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="keyword">double</span>);
    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::size_t)</span> <span class="keyword">const</span> override</span>;
<span class="keyword">private</span>:
    <span class="built_in">std</span>::<span class="keyword">size_t</span> min_qty = <span class="number">0</span>; <span class="comment">// 打折需要的最小购买量</span>
    <span class="keyword">double</span> discount = <span class="number">0.0</span>;   <span class="comment">// 折扣</span>
};
</code></pre><p>当继承为<strong>public</strong>时，基类的<strong>public</strong>成员成为派生类的接口。另外，我们能将<strong>public</strong>继承的派生类对象绑定到基类的指针或引用。</p>
<p>大多数类直接继承一个基类，这种继承称为单继承，继承超过一个基类称为多继承。</p>
<h3 id="派生类中的虚函数">派生类中的虚函数</h3><p>派生类经常但不总是覆盖它们继承的虚函数。如果派生类不覆盖虚函数，则像其它成员一样，继承基类的版本。在参数列表后面，<strong>const</strong>或引用限定符后面使用<strong>override</strong>表示覆盖虚函数。</p>
<h3 id="派生类对象和派生类到基类的转换">派生类对象和派生类到基类的转换</h3><p>派生类对象包含了多个部分：一个子对象包含派生类自己定义的非<strong>static</strong>成员，加上一个从基类继承而来的相应的子对象。</p>
<p>因为派生类对象包含对应于基类的子部分，我们可以使用子类就好像它是基类一样。特别地，我们可以将子类对象的基类部分绑定到基类的引用或指针。</p>
<pre><code><span class="label">Quote</span> <span class="keyword">item; </span>       // 基类对象
<span class="keyword">Bulk_quote </span><span class="keyword">bulk; </span>  // 子类对象
<span class="label">Quote</span> *p = &amp;<span class="keyword">item; </span> // 指向基类的指针
p = &amp;<span class="keyword">bulk; </span>        // p指向<span class="keyword">bulk的Quote部分
</span><span class="label">Quote</span> &amp;r = <span class="keyword">bulk; </span>  // r绑定到<span class="keyword">bulk的Quote部分</span>
</code></pre><p>这种转换称为派生类到基类的转换。和其它转换一样，编译器隐式应用派生类到基类的转换。</p>
<blockquote>
<p><strong>注解</strong><br>派生类对象包含基类的子对象是继承如何工作的关键。</p>
</blockquote>
<h3 id="派生类构造函数">派生类构造函数</h3><p>尽管派生类对象包含从基类继承的成员，但是派生类不能直接初始化这些成员。派生类必须使用基类的构造函数初始化基类部分。</p>
<blockquote>
<p><strong>注解</strong><br>每一个类控制它的成员如何初始化。基类成员先初始化，然后按声明的顺序初始化派生类的成员。</p>
</blockquote>
<pre><code>Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> p,
           <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc) :
           Quote(book, p), min_qty(qty), discount(disc) { }
    <span class="comment">// as before</span>
};
</code></pre><h3 id="在派生类中使用基类的成员">在派生类中使用基类的成员</h3><p>派生类可以使用基类的<strong>public</strong>和<strong>protected</strong>成员：</p>
<pre><code><span class="comment">// 如果购买了指定数量的商品，使用折扣价格</span>
<span class="keyword">double</span> Bulk_quote::net_price(<span class="keyword">size_t</span> cnt) <span class="keyword">const</span>
{
    <span class="keyword">if</span> (cnt &gt;= min_qty)
        <span class="keyword">return</span> cnt * (<span class="number">1</span> - discount) * price;
    <span class="keyword">else</span>
        <span class="keyword">return</span> cnt * price;
}
</code></pre><p>值得知道的是派生类的作用域嵌套在基类作用域里面。因此派生类使用基类和自己的成员没有差别。</p>
<blockquote>
<p><strong>关键概念</strong>: 尊重基类的接口<br>派生类构造函数可以对基类的<strong>public</strong>和<strong>protected</strong>成员赋值。尽管如此，通常不应该这么做。像基类的其他用户一样，派生类应该尊重基类的接口，使用基类的构造函数初始化基类部分成员。</p>
</blockquote>
<h3 id="继承和static成员">继承和static成员</h3><p>如果基类定义了<strong>static</strong>成员，那么在整个继承层次中只有一个这样的成员。不管有多少个派生类，每一个<strong>static</strong>成员只有一个实例。<strong>static</strong>成员遵守正常的访问控制。如果成员是<strong>private</strong>，则不能访问。</p>
<pre><code><span class="keyword">class</span> Base {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">statmem</span><span class="params">()</span></span>;
};
<span class="keyword">class</span> Derived : <span class="keyword">public</span> Base {
    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Derived&amp;)</span></span>;
};
<span class="keyword">void</span> Derived::f(<span class="keyword">const</span> Derived &amp;derived_obj)
{
    Base::statmem();    <span class="comment">// ok: Base定义了statmem</span>
    Derived::statmem(); <span class="comment">// ok: Derived继承类statmem</span>
    <span class="comment">// ok: 派生类对象可以访问基类的static成员</span>
    derived_obj.statmem();
    statmem();
}
</code></pre><h3 id="派生类的声明">派生类的声明</h3><p>派生类的声明和其它类一样。声明包含类名字但不包括派生列表：</p>
<pre><code><span class="keyword">class</span> <span class="title">Bulk_quote</span> : <span class="title">public</span> <span class="title">Quote</span>; <span class="comment">// error: 派生列表不能出现在这</span>
<span class="keyword">class</span> <span class="title">Bulk_quote</span>; <span class="comment">// ok: 声明派生类的正确方式</span>
</code></pre><h3 id="作为基类使用的类">作为基类使用的类</h3><p>在使用类作为基类前，一个类必须定义，而不仅仅是声明：</p>
<pre><code><span class="keyword">class</span> <span class="title">Quote</span>;   <span class="comment">// 声明但是未定义</span>
<span class="comment">// error: Quote必须定义</span>
<span class="keyword">class</span> <span class="title">Bulk_quote</span> : <span class="title">public</span> <span class="title">Quote</span> { ... };
</code></pre><p>这个限制的原因很容易理解：每一个派生类包含从基类继承的成员。要使用这些成员，派生类必须知道它们是什么。这个规则暗示我们一个类不可能继承自己。一个基类本身也可以是派生类。</p>
<p>每一个类继承了其直接基类的所有成员。直接基类的成员包含了它的直接基类和继承链继承而来的成员。因此，最远的派生类包含了一个其直接基类的子对象和每一个间接基类的子对象。</p>
<h3 id="阻止继承">阻止继承</h3><p>在新标准下，我们可以在类名后面跟着<strong>final</strong>阻止类被继承：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">NoDerived</span> <span class="title">final</span> </span>{ <span class="comment">/*  */</span> }; <span class="comment">// NoDerived不能作为基类</span>
<span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>{ <span class="comment">/*  */</span> };
<span class="class"><span class="keyword">class</span> <span class="title">Last</span> <span class="title">final</span> : <span class="title">Base</span> </span>{ <span class="comment">/*  */</span> }; <span class="comment">// Last不能作为基类</span>
<span class="class"><span class="keyword">class</span> <span class="title">Bad</span> : <span class="title">NoDerived</span> </span>{ <span class="comment">/*  */</span> };   <span class="comment">// error: NoDerived is final</span>
<span class="class"><span class="keyword">class</span> <span class="title">Bad2</span> : <span class="title">Last</span> </span>{ <span class="comment">/*  */</span> };       <span class="comment">// error: Last is final</span>
</code></pre><h2 id="15-2-3_转换和继承">15.2.3 转换和继承</h2><blockquote>
<p><strong>警告</strong><br>理解基类和派生类之间的转换是理解C++面向对象编程如何工作的基础</p>
</blockquote>
<p>通常我们只能绑定指针或引用到相同类型的对象上或者需要一个可接受的转换。可以将基类的引用或指针绑定到一个派生类对象的事实暗示：当我们使用基类的指针或引用时，我们不知道指针或引用绑定的对象的实际类型。这个对象可以是基类对象或派生类对象。</p>
<blockquote>
<p><strong>注解</strong><br>像内置指针一样，智能指针支持派生类到基类的转换。</p>
</blockquote>
<h3 id="静态类型和动态类型">静态类型和动态类型</h3><p>静态类型是变量声明的类型或表达式产生的类型，在编译期间就已经知道了。动态类型是变量或表达式表示的内存中对象的类型，直到运行时才知道。不是指针或引用的表达式的动态类型总是和静态类型一样。</p>
<blockquote>
<p><strong>注解</strong><br>理解基类的指针或引用的静态类型与动态类型可能不一样很重要。</p>
</blockquote>
<h3 id="没有基类到派生类的隐式转换">没有基类到派生类的隐式转换</h3><pre><code><span class="label">Quote</span> <span class="keyword">base;
</span><span class="keyword">Bulk_quote* </span><span class="keyword">bulkP </span>= &amp;<span class="keyword">base; </span> // error: can<span class="string">'t convert base to derived
Bulk_quote&amp; bulkRef = base; // error: can'</span>t convert <span class="keyword">base </span>to derived
</code></pre><p>令人惊讶地是，即使基类指针或引用绑定的是派生类对象，我们也不能将基类转换到派生类：</p>
<pre><code><span class="keyword">Bulk_quote </span><span class="keyword">bulk;
</span><span class="label">Quote</span> *<span class="keyword">itemP </span>= &amp;<span class="keyword">bulk; </span>       // ok: dynamic type is <span class="keyword">Bulk_quote
</span><span class="keyword">Bulk_quote </span>*<span class="keyword">bulkP </span>= <span class="keyword">itemP; </span>  // error: can<span class="string">'t convert base to derived</span>
</code></pre><p>编译器在编译期间无法知道这种转换在运行时是否安全。如果基类有一个或多个虚函数，我们可以使用<strong>dynamic_cast</strong>要求在运行时检查转换。或者如果我们知道这些从基类到派生类的转换是安全的，我们可以使用<strong>static_cast</strong>替换编译器的检查。</p>
<h3 id="也没有对象间的转换">也没有对象间的转换</h3><p>派生类到基类的自动转换只发生在引用或指针类型的转换。派生类和基类之间没有这种转换。</p>
<pre><code>Bulk_quote bulk;  <span class="comment"> // object of derived type</span>
Quote <span class="keyword">item</span>(bulk); <span class="comment"> // uses the Quote::Quote(const Quote&amp;) constructor</span>
<span class="keyword">item</span> = bulk;      <span class="comment"> // calls Quote::operator=(const Quote&amp;)</span>
</code></pre><blockquote>
<p><strong>警告</strong><br>当我们用一个派生类对象给一个基类对象初始化或赋值时，只有基类部分复制，移动或赋值了，派生类部分被忽略了。</p>
<p><strong>关键概念</strong>： 继承相关的类型转换</p>
<ul>
<li>继承类到基类的转换只发生在指针或引用类型</li>
<li>没有基类到继承类的隐式转换</li>
<li>像其它成员一样，继承类到基类的转换可能因为访问控制的原因不能访问。</li>
</ul>
</blockquote>
<h1 id="15-3_虚函数">15.3 虚函数</h1><p>因为运行之前我们不知道哪个函数会调用，虚函数必须总是定义了的。</p>
<h2 id="虚函数调用可能在运行时确定">虚函数调用可能在运行时确定</h2><p>动态绑定仅仅发生在通过指针或引用调用虚函数。</p>
<pre><code><span class="keyword">base</span> = derived;         <span class="comment">// 从derived拷贝Quote部分到base </span>
<span class="keyword">base</span>.net_price(<span class="number">20</span>);     <span class="comment">// 调用Quote::net_price</span>
</code></pre><p>当我们在一个表达式中用一个非引用且非指针的普通类型调用虚函数时，绑定发生在编译期间。</p>
<blockquote>
<p><strong>关键概念</strong>： C++中的多态<br>指针和引用的动态类型和静态类型可以不同是C++支持多态的基石。</p>
<p><strong>注解</strong><br>运行期间确定虚函数仅当通过指针或引用的调用。只有这些情况下，对象的动态类型才可能和静态类型不同。</p>
</blockquote>
<h2 id="派生类的虚函数">派生类的虚函数</h2><p>当派生类覆盖了一个虚函数时，声明时可以重复<strong>virtual</strong>关键字，但是没有要求这样做。一旦一个函数被声明为<strong>virtual</strong>，这个函数在所有继承类中都是<strong>virtual</strong>。</p>
<p>派生类中的虚函数必须和基类中虚函数参数一样。除了返回类型为和继承相关的指针或引用之外，派生类虚函数的返回类型也必须和基类一样。就是如果D继承自B，那么基类的虚函数可以返回B<em>，而派生类的虚函数可以返回D</em>。然而这种返回类型需要派生类到基类的转换可访问。</p>
<blockquote>
<p><strong>注解</strong><br>基类中的虚函数在继承类中隐式为<strong>virtual</strong>。当派生类覆盖一个虚函数，参数必须和基类一样。</p>
</blockquote>
<h2 id="final和override限定符">final和override限定符</h2><p>继承类定义一个和基类虚函数同名但是参数不同的函数是合法的。编译器认为这样的函数独立于基类的虚函数。</p>
<p>新标准下我们可以在继承类中指定虚函数为<strong>override</strong>。编译器会拒绝程序如果函数标注为<strong>override</strong>却没有覆盖一个已存在的虚函数。</p>
<pre><code><span class="keyword">struct</span> B {
    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span>(<span class="params"><span class="keyword">int</span></span>) <span class="keyword">const</span></span>;
    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span>(<span class="params"></span>)</span>;
    <span class="function"><span class="keyword">void</span> <span class="title">f3</span>(<span class="params"></span>)</span>;
};
<span class="keyword">struct</span> D1 : B {
    <span class="function"><span class="keyword">void</span> <span class="title">f1</span>(<span class="params"><span class="keyword">int</span></span>) <span class="keyword">const</span> <span class="keyword">override</span></span>; <span class="comment">// ok: f1 matches f1 in the base</span>
    <span class="function"><span class="keyword">void</span> <span class="title">f2</span>(<span class="params"><span class="keyword">int</span></span>) <span class="keyword">override</span></span>; <span class="comment">// error: B has no f2(int) function</span>
    <span class="function"><span class="keyword">void</span> <span class="title">f3</span>(<span class="params"></span>) <span class="keyword">override</span></span>;    <span class="comment">// error: f3 not virtual</span>
    <span class="function"><span class="keyword">void</span> <span class="title">f4</span>(<span class="params"></span>) <span class="keyword">override</span></span>;    <span class="comment">// error: B doesn't have a function named f4</span>
};
</code></pre><p>我们也可以将一个函数指定为<strong>final</strong>。任何试图覆盖一个被定义为<strong>final</strong>的函数都被视为错误：</p>
<pre><code><span class="keyword">struct</span> D2 : B {
    <span class="comment">// inherits f2() and f3() from B and overrides f1(int)</span>
    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> final</span>; <span class="comment">// 后续子类不能覆盖f1(int)</span>
};
<span class="keyword">struct</span> D3 : D2 {
    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>; <span class="comment">// ok: overrides f2 inherited from the indirect base, B</span>
    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>; <span class="comment">// error: D2 declared f2 as final</span>
};
</code></pre><p><strong>final</strong>和<strong>override</strong>限定符出现在参数列表（包含const或引用修饰符）和尾返回之后。</p>
<h2 id="虚函数和默认实参">虚函数和默认实参</h2><p>如果一个函数调用使用默认实参，被使用的值是函数定义的静态类型的值。</p>
<blockquote>
<p><strong>最佳实践</strong><br>包含默认实参的虚函数应该在基类和派生类中使用相同的默认实参。</p>
</blockquote>
<h2 id="避开虚机制">避开虚机制</h2><p>我们可以使用<strong>::</strong>操作符强制调用指定版本的虚函数。</p>
<pre><code><span class="comment">// 调用基类版本，不管baseP的动态类型</span>
<span class="keyword">double</span> undiscounted = baseP-&gt;Quote::net_price(<span class="number">42</span>);
</code></pre><blockquote>
<p><strong>注解</strong><br>通常，只有成员函数或友元函数里面的代码应该使用作用域操作符来避开虚机制。</p>
</blockquote>
<p>为什么想要避开虚机制？最常见的理由是一个派生类的虚函数调用基类的版本。这种情况下，基类版本做了继承层次所有类型的共同工作。派生类定义的版本只需做自己的额外工作。</p>
<blockquote>
<p><strong>警告</strong><br>如果继承类虚函数想要调用基类版本的虚函数，却忽略了作用域操作符，将会导致无限递归。</p>
</blockquote>
<h1 id="15-4_虚基类">15.4 虚基类</h1><h2 id="纯虚函数">纯虚函数</h2><p>和普通的虚函数不一样的是，纯虚函数没有必要定义。虚函数写上<strong>= 0</strong>替代函数体成为纯虚函数。<strong>= 0</strong>只出现在类里面函数声明处。</p>
<pre><code><span class="comment">// class to hold the discount rate and quantity</span>
<span class="comment">// derived classes will implement pricing strategies using these data</span>
<span class="keyword">class</span> Disc_quote : <span class="keyword">public</span> Quote {
<span class="keyword">public</span>:
    Disc_quote() = <span class="keyword">default</span>;
    Disc_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> price,
              <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc):
                 Quote(book, price),
                 quantity(qty), discount(disc) { }
    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::size_t)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;
<span class="keyword">protected</span>:
    <span class="built_in">std</span>::<span class="keyword">size_t</span> quantity = <span class="number">0</span>; <span class="comment">//  purchase size for the discount to apply</span>
    <span class="keyword">double</span> discount = <span class="number">0.0</span>;    <span class="comment">//  fractional discount to apply</span>
};
</code></pre><p>虽然我们不能直接定义Disc_quote对象，但是Disc_quote的派生类会使用Disc_quote的构造函数构造Disc_quote部分。</p>
<p>值得注意的是我们可以提供纯虚函数的定义，但是必须定义在类外面。</p>
<h2 id="有纯虚函数的类为虚基类">有纯虚函数的类为虚基类</h2><p>包含纯虚函数的类（或继承而没有覆盖）是虚基类。虚基类为后续的子类定义了可覆盖的接口。不能直接创建虚基类的对象。</p>
<pre><code>// Disc_quote定义了<span class="keyword">Bulk_quote将要覆盖的纯虚函数
</span><span class="label">Disc_quote</span> discounted<span class="comment">; // error: can't define a Disc_quote object</span>
<span class="keyword">Bulk_quote </span><span class="keyword">bulk; </span>      // ok: <span class="keyword">Bulk_quote </span>has no pure virtual functions
</code></pre><p>继承自虚基类的类必须覆盖纯虚函数，否则这个类也是虚基类。</p>
<h2 id="派生类构造函数只初始化其直接基类">派生类构造函数只初始化其直接基类</h2><pre><code><span class="comment">// the discount kicks in when a specified number of copies of the same book are sold</span>
<span class="comment">// the discount is expressed as a fraction to use to reduce the normal price</span>
<span class="keyword">class</span> Bulk_quote : <span class="keyword">public</span> Disc_quote {
<span class="keyword">public</span>:
    Bulk_quote() = <span class="keyword">default</span>;
    Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> price,
              <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc):
          Disc_quote(book, price, qty, disc) { }
    <span class="comment">// overrides the base version to implement the bulk purchase discount policy</span>
    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::size_t)</span> <span class="keyword">const</span> override</span>;
};
</code></pre><p>每一个类控制自己类对象的初始化。</p>
<blockquote>
<p><strong>关键概念：重构</strong><br>添加Disc_quote到Quote继承层次是重构的一个例子。重构包含重新设计类层次，从一个类移动操作或数据到另一个类。重构在面向对象程序里面很常见。<br>值得注意的是尽管我们改变了继承层次，使用Bulk_quote或Quote的代码不需要改变。</p>
</blockquote>
<h1 id="15-5_访问控制和继承">15.5 访问控制和继承</h1><p>就像每一个类控制自己成员的初始化，每一个类也控制其成员对派生类是否可访问。</p>
<h2 id="protected成员">protected成员</h2><p><strong>protected</strong>限定符可以被认为是<strong>private</strong>和<strong>public</strong>的混合：</p>
<ul>
<li>像<strong>private</strong>，<strong>protected</strong>成员对类用户是不可访问的。</li>
<li>像<strong>public</strong>，<strong>protected</strong>成员对派生类的成员和友元是可访问的。</li>
</ul>
<p>另外，<strong>protected</strong>有一个重要性质：</p>
<ul>
<li>派生类成员或友元只能通过派生类对象访问基类的<strong>protected</strong>成员。派生类没有权限访问基类<strong>protected</strong>成员。</li>
</ul>
<pre><code><span class="keyword">class</span> Base {
<span class="keyword">protected</span>:
    <span class="keyword">int</span> prot_mem;     <span class="comment">// protected member</span>
};
<span class="keyword">class</span> Sneaky : <span class="keyword">public</span> Base  {
    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;  <span class="comment">// can access Sneaky::prot_mem</span>
    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base&amp;)</span></span>;    <span class="comment">// can't access Base::prot_mem</span>
    <span class="keyword">int</span> j;                          <span class="comment">// j is private by default</span>
};
<span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span> </span>{ s.j = s.prot_mem = <span class="number">0</span>; } <span class="comment">// ok</span>
<span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span> </span>{ b.prot_mem = <span class="number">0</span>; } <span class="comment">// error</span>
</code></pre><h2 id="public，private和protected继承">public，private和protected继承</h2><p>继承类成员的访问由基类中该成员访问控制符和派生列表访问控制符共同控制。</p>
<pre><code><span class="keyword">class</span> <span class="title">Base</span> {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">void</span> <span class="title">pub_mem</span>(<span class="params"></span>)</span>;   <span class="comment">// public member</span>
<span class="keyword">protected</span>:
    <span class="keyword">int</span> prot_mem;     <span class="comment">// protected member</span>
<span class="keyword">private</span>:
    <span class="keyword">char</span> priv_mem;    <span class="comment">// private member</span>
};
<span class="keyword">struct</span> Pub_Derv : <span class="keyword">public</span> Base {
    <span class="comment">// ok: derived classes can access protected members</span>
    <span class="function"><span class="keyword">int</span> <span class="title">f</span>(<span class="params"></span>) </span>{ <span class="keyword">return</span> prot_mem; }
    <span class="comment">// error: private members are inaccessible to derived classes</span>
    <span class="function"><span class="keyword">char</span> <span class="title">g</span>(<span class="params"></span>) </span>{ <span class="keyword">return</span> priv_mem; }
};
<span class="keyword">struct</span> Priv_Derv : <span class="keyword">private</span> Base {
    <span class="comment">// private derivation doesn't affect access in the derived class</span>
    <span class="function"><span class="keyword">int</span> <span class="title">f1</span>(<span class="params"></span>) <span class="keyword">const</span> </span>{ <span class="keyword">return</span> prot_mem; }
};
</code></pre><p>派生类的访问控制符对派生类访问其直接基类的成员没有影响。基类成员的访问只由基类的访问控制符控制。派生类的访问控制符是用来控制派生类使用者及子类对其成员的使用。</p>
<pre><code>Pub_Derv d1;   <span class="comment">//  members inherited from Base are public</span>
Priv_Derv d2;  <span class="comment">//  members inherited from Base are private</span>
d1.pub_mem();  <span class="comment">//  ok: pub_mem is public in the derived class</span>
d2.pub_mem();  <span class="comment">//  error: pub_mem is private in the derived class</span>

<span class="keyword">struct</span> Derived_from_Public : <span class="keyword">public</span> Pub_Derv {
    <span class="comment">// ok: Base::prot_mem remains protected in Pub_Derv</span>
    <span class="function"><span class="keyword">int</span> <span class="title">use_base</span><span class="params">()</span> </span>{ <span class="keyword">return</span> prot_mem; }
};
<span class="keyword">struct</span> Derived_from_Private : <span class="keyword">public</span> Priv_Derv {
    <span class="comment">// error: Base::prot_mem is private in Priv_Derv</span>
    <span class="function"><span class="keyword">int</span> <span class="title">use_base</span><span class="params">()</span> </span>{ <span class="keyword">return</span> prot_mem; }
};
</code></pre><h2 id="派生类到基类转换的可访问性">派生类到基类转换的可访问性</h2><p>假设D继承B：</p>
<ul>
<li>用户代码可以使用派生类到基类的转换当D公开继承B，私有继承或保护继承都不行。</li>
<li>D的成员函数和友元可以使用派生类到基类的转换而不管是如何继承的。派生类到直接基类的转换对于派生类的成员和友元总是可以访问的。</li>
<li>从D派生的成员函数和友元能使用派生类到基类的转换当D公开或保护继承B，私有继承不行。</li>
</ul>
<blockquote>
<p><strong>提示</strong><br>在代码的任何地方，如果基类的<strong>public</strong>成员能够访问，则派生类到基类的转换可以访问，反过来不行。</p>
</blockquote>
<h2 id="友元和继承">友元和继承</h2><p>就像友元不能传递，友元也不能继承。基类的友元对派生类没有特殊访问权限，派生类的友元对基类也没有特殊访问权限。</p>
<pre><code><span class="keyword">class</span> <span class="title">Base</span> {
    <span class="comment">// added friend declaration; other members as before</span>
    friend <span class="keyword">class</span> <span class="title">Pal</span>; <span class="comment">// Pal has no access to classes derived from Base</span>
};
<span class="keyword">class</span> <span class="title">Pal</span> {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">int</span> <span class="title">f</span>(<span class="params">Base b</span>) </span>{ <span class="keyword">return</span> b.prot_mem; } <span class="comment">// ok: Pal is a friend of</span>
<span class="function">Base
    <span class="keyword">int</span> <span class="title">f2</span>(<span class="params">Sneaky s</span>) </span>{ <span class="keyword">return</span> s.j; } <span class="comment">// error: Pal not friend of</span>
Sneaky
    <span class="comment">// access to a base class is controlled by the base class, even inside a derived</span>
<span class="function"><span class="keyword">object</span>
    <span class="keyword">int</span> <span class="title">f3</span>(<span class="params">Sneaky s</span>) </span>{ <span class="keyword">return</span> s.prot_mem; } <span class="comment">// ok: Pal is a friend</span>
};
</code></pre><p>f3的合法看似惊人，但是它直接遵循每一个类控制其成员的访问这条规则。类Pal是基类Base的友元，因此Pal可以访问基类对象的成员。这种访问包含嵌套在派生类对象中基类部分。</p>
<p>当一个类将另一个类作为友元，只有这个类被赋予了友元关系，其基类或者子类都没有友元关系。</p>
<pre><code><span class="comment">// D2 has no access to protected or private members in Base</span>
<span class="keyword">class</span> D2 : <span class="keyword">public</span> Pal {
<span class="keyword">public</span>:
   <span class="function"><span class="keyword">int</span> <span class="title">mem</span><span class="params">(Base b)</span>
       </span>{ <span class="keyword">return</span> b.prot_mem; } <span class="comment">// error: friendship doesn't inherit</span>
};
</code></pre><blockquote>
<p><strong>注解</strong><br>友元关系不能继承，每一个类控制自己成员的访问。</p>
</blockquote>
<h2 id="免除个别成员访问规则">免除个别成员访问规则</h2><p>有时候需要改变派生类中成员的访问级别，可以使用<strong>using</strong>声明。</p>
<pre><code><span class="keyword">class</span> Base {
<span class="keyword">public</span>:
    <span class="built_in">std</span>::<span class="keyword">size_t</span> size() <span class="keyword">const</span> { <span class="keyword">return</span> n; }
<span class="keyword">protected</span>:
    <span class="built_in">std</span>::<span class="keyword">size_t</span> n;
};
<span class="keyword">class</span> Derived : <span class="keyword">private</span> Base {    <span class="comment">//  <span class="doctag">note:</span> private inheritance</span>
<span class="keyword">public</span>:
    <span class="comment">// maintain access levels for members related to the size of the object</span>
    <span class="keyword">using</span> Base::size;
<span class="keyword">protected</span>:
    <span class="keyword">using</span> Base::n;
};
</code></pre><p>因为Derived使用<strong>private</strong>继承，则继承的成员默认为<strong>private</strong>成员。<strong>using</strong>声明调整了这些成员的可访问级别。</p>
<p><strong>using</strong>声明可以命名任何可访问的直接或间接基类的成员。访问由<strong>using</strong>声明的名字取决于<strong>using</strong>声明之前的访问限定符。</p>
<blockquote>
<p><strong>注解</strong><br>派生类只为允许访问的名字提供<strong>using</strong>声明。</p>
</blockquote>
<h2 id="默认继承保护级别">默认继承保护级别</h2><p>默认地，<strong>class</strong>关键字定义的派生类使用<strong>private</strong>继承，<strong>struct</strong>定义的派生类使用<strong>public</strong>继承。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>{ <span class="comment">/* ...   */</span> };
<span class="class"><span class="keyword">struct</span> <span class="title">D1</span> : <span class="title">Base</span> </span>{ <span class="comment">/* ...   */</span> };   <span class="comment">// public inheritance by default</span>
<span class="class"><span class="keyword">class</span> <span class="title">D2</span> : <span class="title">Base</span> </span>{ <span class="comment">/* ...   */</span> };    <span class="comment">// private inheritance by default</span>
</code></pre><p>一个常见的误解是使用<strong>struct</strong>和<strong>class</strong>定义的类有深层次的不同。唯一的不同就是成员的默认访问级别和默认继承访问限定符，没有其它差别。</p>
<blockquote>
<p><strong>最佳实践</strong><br>类私有继承必须显式指定<strong>private</strong>而不是依赖默认行为。显式指定可以清晰的说明<strong>private</strong>继承是有意的而不是疏忽。</p>
</blockquote>
<h1 id="15-6_继承下的类作用域">15.6 继承下的类作用域</h1><p>每一个类定义自己的作用域，作用域里面定义其成员。在继承下，派生类的作用域嵌套在基类作用域里面。如果一个名字在派生类作用域找不到，则搜索外围基类作用域。正是这种分层嵌套的类作用域允许派生类成员使用基类成员就好像这些成员是派生类的一部分一样。</p>
<pre><code><span class="keyword">Bulk_quote </span><span class="keyword">bulk;
</span><span class="label">cout</span> &lt;&lt; <span class="keyword">bulk.isbn();</span>
</code></pre><p>isbn的名字查找如下：</p>
<ul>
<li>因为isbn被Bulk_quote对象调用，查找从类Bulk_quote开始，没有找到。</li>
<li>因为Bulk_quote继承自Disc_quote，接下来查找Disc_quote，还是没找到。</li>
<li>因为Disc_quote继承自Quote，接下来查找Quote，找到了。</li>
</ul>
<h2 id="名字查找发生在编译时">名字查找发生在编译时</h2><p>对象，引用或指针的静态类型决定了对象的哪个成员可见，甚至当静态类型和动态类型不一样时。</p>
<pre><code><span class="keyword">class</span> Disc_quote : <span class="keyword">public</span> Quote {
<span class="keyword">public</span>:
    <span class="built_in">std</span>::pair&lt;<span class="keyword">size_t</span>, <span class="keyword">double</span>&gt; discount_policy() <span class="keyword">const</span>
        { <span class="keyword">return</span> {quantity, discount}; }
    <span class="comment">// other members as before</span>
};

Bulk_quote bulk;
Bulk_quote *bulkP = &amp;bulk; <span class="comment">//  static and dynamic types are the same</span>
Quote *itemP = &amp;bulk;      <span class="comment">//  static and dynamic types differ</span>
bulkP-&gt;discount_policy();  <span class="comment">//  ok: bulkP has type Bulk_quote*</span>
itemP-&gt;discount_policy();  <span class="comment">//  error: itemP has type Quote*</span>
</code></pre><blockquote>
<p><strong>关键概念</strong>：名字查找和继承<br>给定调用p-&gt;mem()或obj.mem()</p>
<ul>
<li>首先确定p的静态类型。因为调用了一个成员，p一定指向一个类类型。</li>
<li>查找p静态类型相应的成员mem，如果没找到，则继续在继承层级中找。如果基类中都没找到，编译错误。</li>
<li>一旦mem找到了，执行正常的类型检查以确认调用是否合法。</li>
<li>假设调用合法，编译器再根据调用是否为虚函数来产生代码。</li>
</ul>
</blockquote>
<h2 id="名字冲突和继承">名字冲突和继承</h2><p>和其它作用域一样，继承类可以重用其直接或间接基类中的一个名字。和往常一样，定义在内部作用域(派生类）的名字，隐藏了外部作用域（基类）名字的使用。</p>
<pre><code><span class="keyword">struct</span> Base {
    Base(): mem(<span class="number">0</span>) { }
<span class="keyword">protected</span>:
    <span class="keyword">int</span> mem;
};
<span class="keyword">struct</span> Derived : Base {
    Derived(<span class="keyword">int</span> i): mem(i) { } <span class="comment">// initializes Derived::mem to i</span>
                               <span class="comment">// Base::mem is default initialized</span>
    <span class="function"><span class="keyword">int</span> <span class="title">get_mem</span><span class="params">()</span> </span>{ <span class="keyword">return</span> mem; }  <span class="comment">// returns Derived::mem</span>
<span class="keyword">protected</span>:
    <span class="keyword">int</span> mem;   <span class="comment">// hides mem in the base</span>
};
</code></pre><blockquote>
<p><strong>注解</strong><br>与基类成员同名的派生类成员隐藏了基类成员的直接使用。</p>
</blockquote>
<h2 id="使用作用域操作符使用被隐藏成员">使用作用域操作符使用被隐藏成员</h2><p>我们可以使用作用域操作符来使用被隐藏的基类成员。</p>
<pre><code><span class="keyword">struct</span> Derived : Base {
    <span class="function"><span class="keyword">int</span> <span class="title">get_base_mem</span><span class="params">()</span> </span>{ <span class="keyword">return</span> Base::mem; }
    <span class="comment">// ...</span>
};
</code></pre><p>作用域操作符覆盖正常的名字查找，并指引编译器从指定的作用域开始查找。</p>
<blockquote>
<p><strong>最佳实践</strong><br>除了覆盖继承的虚函数，基类通常不应该重用已经在基类中定义过的名字。</p>
</blockquote>
<h2 id="名字查找发生在类型检查之前">名字查找发生在类型检查之前</h2><p>定义在派生类的同名函数不重载基类的函数。基类成员被隐藏了，即使参数列表不一样。一旦名字被找到，编译器不再继续查找。</p>
<pre><code><span class="keyword">struct</span> Base {
    <span class="function"><span class="keyword">int</span> <span class="title">memfcn</span><span class="params">()</span></span>;
};
<span class="keyword">struct</span> Derived : Base {
    <span class="function"><span class="keyword">int</span> <span class="title">memfcn</span><span class="params">(<span class="keyword">int</span>)</span></span>;   <span class="comment">// hides memfcn in the base</span>
};
Derived d; Base b;
b.memfcn();       <span class="comment">//  calls Base::memfcn</span>
d.memfcn(<span class="number">10</span>);     <span class="comment">//  calls Derived::memfcn</span>
d.memfcn();       <span class="comment">//  error: memfcn with no arguments is hidden</span>
d.Base::memfcn(); <span class="comment">//  ok: calls Base::memfcn</span>
</code></pre><h2 id="虚函数和作用域">虚函数和作用域</h2><p>我们现在可以理解为什么派生类和基类中的虚函数必须有一样的参数列表。如果基类和派生类中虚函数参数不一样，那么没有办法通过基类的引用或指针调用派生类虚函数。</p>
<pre><code><span class="keyword">class</span> Base {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span></span>;
};
<span class="keyword">class</span> D1 : <span class="keyword">public</span> Base {
<span class="keyword">public</span>:
    <span class="comment">// hides fcn in the base; this fcn is not virtual</span>
    <span class="comment">// D1 inherits the definition of Base::fcn()</span>
    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span></span>;      <span class="comment">// parameter list differs from fcn in Base</span>
    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>; <span class="comment">// new virtual function that does not exist in Base</span>
};
<span class="keyword">class</span> D2 : <span class="keyword">public</span> D1 {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// nonvirtual function hides D1::fcn(int)</span>
    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span></span>;    <span class="comment">// overrides virtual fcn from Base</span>
    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;    <span class="comment">// overrides virtual f2 from D1</span>
};

Base bobj;  D1 d1obj; D2 d2obj;
Base *bp1 = &amp;bobj, *bp2 = &amp;d1obj, *bp3 = &amp;d2obj;
bp1-&gt;fcn(); <span class="comment">// virtual call, will call Base::fcn at run time</span>
bp2-&gt;fcn(); <span class="comment">// virtual call, will call Base::fcn at run time</span>
bp3-&gt;fcn(); <span class="comment">// virtual call, will call D2::fcn at run time</span>
D1 *d1p = &amp;d1obj; D2 *d2p = &amp;d2obj;
bp2-&gt;f2(); <span class="comment">// error: Base has no member named f2</span>
d1p-&gt;f2(); <span class="comment">// virtual call, will call D1::f2() at run time</span>
d2p-&gt;f2(); <span class="comment">// virtual call, will call D2::f2() at run time</span>

Base *p1 = &amp;d2obj; D1 *p2 = &amp;d2obj; D2 *p3 =  &amp;d2obj;
p1-&gt;fcn(<span class="number">42</span>);  <span class="comment">// error: Base has no version of fcn that takes an int</span>
p2-&gt;fcn(<span class="number">42</span>);  <span class="comment">// statically bound, calls D1::fcn(int)</span>
p3-&gt;fcn(<span class="number">42</span>);  <span class="comment">// statically bound, calls D2::fcn(int)</span>
</code></pre><h2 id="覆盖重载函数">覆盖重载函数</h2><p>派生类可以覆盖0个或多个继承的重载函数。如果派生类想要使所有重载版本可用，则必须覆盖所有的函数或所有函数不覆盖。</p>
<p>有时候只想覆盖一些重载函数，派生类可以提供一个<strong>using</strong>声明给重载的成员。一个<strong>using</strong>声明指定一个名字，不带参数列表。因此，<strong>using</strong>声明将基类的重载函数都加到派生类的作用域。派生类只需定义那些想要覆盖的函数。</p>
<h1 id="15-7_构造函数和复制控制">15.7 构造函数和复制控制</h1><p>像其它类一样，继承层次中的类控制其对象的创建，复制，移动，赋值和销毁。如果一个类没有定义自己的复制控制操作，编译器将合成这些操作。同样这些合成的操作可能是<strong>deleted</strong>的函数。</p>
<h2 id="15-7-1_虚析构函数">15.7.1 虚析构函数</h2><p>继承给基类的复制控制主要的直接影响是基类通常应该定义一个虚析构函数。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> </span>{
<span class="keyword">public</span>:
    <span class="comment">// virtual destructor needed if a base pointer pointing to a derived object is deleted</span>
    virtual ~Quote() = <span class="keyword">default</span>; <span class="comment">// dynamic binding for the destructor</span>
};

Quote *itemP = <span class="keyword">new</span> Quote;   <span class="comment">//  same static and dynamic type</span>
<span class="keyword">delete</span> itemP;               <span class="comment">//  destructor for Quote called</span>
itemP = <span class="keyword">new</span> Bulk_quote;     <span class="comment">//  static and dynamic types differ</span>
<span class="keyword">delete</span> itemP;               <span class="comment">//  destructor for Bulk_quote called</span>
</code></pre><blockquote>
<p><strong>警告</strong><br>如果基类析构函数不是<strong>virtual</strong>的， <strong>delete</strong>基类指针指向派生类对象是<strong>undefined</strong>。</p>
</blockquote>
<p>对于如果一个类需要析构函数，它也需要复制和赋值操作符这个规则，基类的析构函数是个重要例外。</p>
<h3 id="虚析构函数关闭了合成的Move">虚析构函数关闭了合成的Move</h3><p>如果一个类定义了虚析构函数，即使是<strong>= default</strong>使用合成版本，则编译器不会合成<strong>move</strong>操作。</p>
<h2 id="15-7-2_合成复制控制和继承">15.7.2 合成复制控制和继承</h2><p>基类或派生类中合成的复制控制成员和任何其它合成的复制控制成员一样：逐个初始化，复制或销毁类成员。另外，这些成员使用基类的相应操作初始化，复制或销毁其对象的直接基类部分。</p>
<p>值得注意的是基类的成员是否是合成的或用户定义的并没有关系。重要的是相应的成员是可访问的且不是一个被删除的函数。</p>
<h3 id="基类和派生类中被删除的复制控制成员">基类和派生类中被删除的复制控制成员</h3><p>基类或者派生类中合成的构造函数或任何复制控制成员，跟其它类的原因一样，都可能被定义为被删除的。另外基类定义的方式会导致派生类的成员被定义为被删除的：</p>
<ul>
<li>如果基类的默认构造函数，复制构造函数，赋值操作符或析构函数是被删除的或不能访问，则派生类中相应的成员被定义为被删除的，因为编译器无法使用基类的成员来构造，赋值或销毁派生类对象的基类部分。</li>
<li>如果基类有一个不能访问的或被删除的析构函数，则派生类中合成的默认构造函数和复制构造函数被定义为被删除的，因为没有办法销毁派生类对象的基类部分。</li>
<li>编译器不会合成一个被删除的移动操作。如果基类的移动操作是被删除的或不能访问，则派生类中的移动操作是被删除的，因为基类部分不能被移动。如果基类的析构函数是被删除的或不能访问，则派生类的移动构造函数是被删除的。</li>
</ul>
<pre><code><span class="keyword">class</span> B {
public:
    B();
    B(<span class="keyword">const</span> B&amp;) = delete;
    <span class="comment">// other members, not including a move constructor</span>
};
<span class="keyword">class</span> <span class="keyword">D</span> : public B {
    <span class="comment">// no constructors</span>
};
<span class="keyword">D</span> <span class="keyword">d</span>;     <span class="comment">// ok: D's synthesized default constructor uses B's default constructor</span>
<span class="keyword">D</span> d2(<span class="keyword">d</span>); <span class="comment">// error: D's synthesized copy constructor is deleted</span>
<span class="keyword">D</span> d3(std::<span class="keyword">move</span>(<span class="keyword">d</span>)); <span class="comment">// error: implicitly uses D's deleted copy constructor</span>
</code></pre><h3 id="移动操作和继承">移动操作和继承</h3><p>我们已经看到，大多数基类定义了一个虚析构函数。因此基类通常没有合成的移动操作，同样派生类也没有合成的移动操作。由于基类缺少移动操作而限制了派生类合成移动操作，如果合理基类一般应该定义移动操作。如果显式定义了移动操作，基类一般也要显式定义复制操作。</p>
<pre><code><span class="keyword">class</span> <span class="title">Quote</span> {
<span class="keyword">public</span>:
    Quote() = <span class="keyword">default</span>;             <span class="comment">// memberwise default initialize</span>
    Quote(<span class="keyword">const</span> Quote&amp;) = <span class="keyword">default</span>; <span class="comment">// memberwise copy</span>
    Quote(Quote&amp;&amp;) = <span class="keyword">default</span>;      <span class="comment">// memberwise copy</span>
    Quote&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Quote&amp;) = <span class="keyword">default</span>; <span class="comment">// copy assign</span>
    Quote&amp; <span class="keyword">operator</span>=(Quote&amp;&amp;) = <span class="keyword">default</span>;      <span class="comment">// move assign</span>
    <span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>;
    <span class="comment">// other members as before</span>
};
</code></pre><h2 id="15-7-3_派生类复制控制成员">15.7.3 派生类复制控制成员</h2><p>初始化阶段，派生类的构造函数初始化派生类对象的基类部分和自己的成员。因此派生类的复制和移动构造函数必须复制和移动派生类对象的基类部分和自己的成员。类似地，派生类的赋值操作符必须赋值基类部分给派生类对象。</p>
<p>不像构造函数和赋值操作符，析构函数只对派生类自己的申请的资源负责。</p>
<blockquote>
<p><strong>警告</strong><br>当派生类定义了复制和移动操作，这些操作负责整个派生类对象的复制和移动，包括基类成员。</p>
</blockquote>
<h3 id="定义派生类复制和移动构造函数">定义派生类复制和移动构造函数</h3><p>当我们为派生类定义一个复制或移动构造函数，我们通常使用相应的基类构造函数来初始化对象的基类部分：</p>
<pre><code><span class="keyword">class</span> Base { <span class="comment">/* ...    */</span> } ;
<span class="keyword">class</span> <span class="keyword">D</span>: public Base {
public:
    <span class="comment">// by default, the base class default constructor initializes the base part of an object</span>
    <span class="comment">// to use the copy or move constructor, we must explicitly call that</span>
    <span class="comment">// constructor in the constructor initializer list</span>
    <span class="literal">D</span>(<span class="keyword">const</span> <span class="keyword">D</span>&amp; <span class="keyword">d</span>): Base(<span class="keyword">d</span>)      <span class="comment">// copy the base members</span>
                 <span class="comment">/* initializers for members of D */</span> { <span class="comment">/* ...  */</span> }
    <span class="literal">D</span>(<span class="keyword">D</span>&amp;&amp; <span class="keyword">d</span>): Base(std::<span class="keyword">move</span>(<span class="keyword">d</span>)) <span class="comment">// move the base members</span>
                 <span class="comment">/* initializers for members of D */</span> { <span class="comment">/* ...  */</span> }
};
</code></pre><blockquote>
<p><strong>警告</strong><br>默认地，基类默认构造函数初始化派生类对象的基类部分。如果我们想要复制或移动基类部分，必须在派生类构造函数的初始化列表中显式使用基类的复制或移动构造函数。</p>
</blockquote>
<h3 id="派生类赋值操作符">派生类赋值操作符</h3><p>和复制或移动构造函数一样，派生类的赋值操作符必须显式赋值其基类部分：</p>
<pre><code><span class="comment">// Base::operator=(const Base&amp;) is not invoked automatically</span>
D &amp;D::<span class="keyword">operator</span>=(<span class="keyword">const</span> D &amp;rhs)
{
    Base::<span class="keyword">operator</span>=(rhs); <span class="comment">// assigns the base part</span>
    <span class="comment">// assign the members in the derived class, as usual,</span>
    <span class="comment">// handling self-assignment and freeing existing resources as appropriate</span>
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
</code></pre><p>值得注意的是派生类构造函数和赋值操作符可以使用基类的相应操作，不管基类是否定义了这些操作还是使用合成的版本。</p>
<h3 id="派生类析构函数">派生类析构函数</h3><p>一个对象的数据成员在析构函数执行完毕之后被隐式销毁。类似地，对象的基类部分也是隐式销毁。因此和构造函数和赋值操作符不同的是，派生类析构函数只对销毁派生类申请的资源负责。</p>
<pre><code><span class="keyword">class</span> D: <span class="keyword">public</span> Base {
<span class="keyword">public</span>:
    <span class="comment">// Base::~Base invoked automatically</span>
    ~D() { /* <span class="keyword">do</span> what it takes <span class="keyword">to</span> clean up derived members   */ }
};
</code></pre><h3 id="在构造函数和析构函数调用虚函数">在构造函数和析构函数调用虚函数</h3><p>我们已经知道，派生类对象的基类部分先被构造。当基类构造函数在执行时，派生类部分没有初始化。同样，派生类对象以相反的顺序被销毁，因此当基类的析构函数运行时，派生类部分已经被销毁。因此当这些基类成员在执行时，对象是不完整的。</p>
<p>为了适应这种不完整性，编译器在构造和析构之间将对象的类型看成是变化的。当对象被构造时，将它的类型看成和构造函数一样的类型，虚函数的调用会绑定到和构造函数一样的类型。对于析构函数也一样。</p>
<blockquote>
<p><strong>注解</strong><br>如果构造函数和析构函数调用一个虚函数，虚函数运行版本是相对于构造函数或析构函数自己类型的版本。</p>
</blockquote>
<h2 id="15-7-4_继承的构造函数">15.7.4 继承的构造函数</h2><p>新标准下，派生类可以重用基类定义的构造函数。和只能初始化直接基类的原因一样，一个类只能继承直接基类的构造函数，不能继承默认的复制和移动构造函数。使用<strong>using</strong>声明指定继承基类的构造函数。</p>
<pre><code><span class="keyword">class</span> Bulk_quote : <span class="keyword">public</span> Disc_quote {
<span class="keyword">public</span>:
    <span class="keyword">using</span> Disc_quote::Disc_quote; <span class="comment">// inherit Disc_quote's constructors</span>
    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::size_t)</span> <span class="keyword">const</span></span>;
};
</code></pre><p><strong>using</strong>声明只是使一个名字在当前作用域可见。当应用到构造函数，一个<strong>using</strong>声明引起编译器生成代码。编译器生成对应于每一个基类构造函数的派生类构造函数。这些编译器生成的构造函数具有以下形式：</p>
<pre><code><span class="tag">derived</span>(parms) : <span class="tag">base</span>(args) { }
</code></pre><p>在Bulk_quote类，继承的构造函数如下：</p>
<pre><code>Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> price,
          <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc):
      Disc_quote(book, price, qty, disc) { }
</code></pre><h3 id="继承构造函数的特征">继承构造函数的特征</h3><p>不像对普通成员使用<strong>using</strong>声明，构造函数<strong>using</strong>声明不会改变继承构造函数的访问级别。而且，<strong>using</strong>声明不能指定<strong>explicit</strong>或<strong>constexpr</strong>。如果构造函数在基类中是<strong>explicit</strong>或<strong>constexpr</strong>，则继承构造函数有一样的属性。</p>
<p>如果基类构造函数有默认实参，这些参数不会被继承。相反，派生类得到多个继承构造函数，每一个有默认实参的参数被相继忽略。比如，如果基类有一个2个参数的构造函数，第2个参数有默认实参，则派生类获得2个构造函数：一个带2个参数（没有默认实参）和一个带单一参数对应于基类最左边，非默认的参数的构造函数。</p>
<p>如果基类有多个构造函数，则除了两个例外，派生类继承基类每一个构造函数。第一个例外是派生类继承一些构造函数并定义其它构造函数自己的版本。如果派生类定义了一个与基类构造函数参数一样的构造函数，那么这个构造函数不会被继承。第二个例外是默认，复制和移动构造函数不会被继承。一个继承构造函数不会被看作用户定义的构造函数。因此，一个只有继承构造函数的类会合成默认构造函数。</p>
<h1 id="15-8_容器和继承">15.8 容器和继承</h1><p>当我们使用一个容器来存储来自继承层次的对象，通常我们必须间接存储这些对象。我们不能把继承相关的类型对象直接放进容器，因为没有办法定义一个容器存放不同类型的元素。</p>
<p>vector不能存放Quote类型可能不明显。这种情况下，我们能把Bulk_quote对象放进容器，但是这些对象不再是Bulk_quote对象了：</p>
<pre><code><span class="built_in">vector</span>&lt;Quote&gt; basket;
basket.push_back(Quote(<span class="string">"0-201-82470-1"</span>, <span class="number">50</span>));
<span class="comment">// ok, but copies only the Quote part of the object into basket</span>
basket.push_back(Bulk_quote(<span class="string">"0-201-54848-8"</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">.25</span>));
<span class="comment">// calls version defined by Quote, prints 750, i.e., 15 * $50</span>
<span class="built_in">cout</span> &lt;&lt; basket.back().net_price(<span class="number">15</span>) &lt;&lt; endl;
</code></pre><blockquote>
<p><strong>警告</strong><br>因为派生类对象赋值给基类对象被切掉，容器和继承相关的类型不能很好的融合。</p>
</blockquote>
<h2 id="将（智能）指针而不是对象放进容器">将（智能）指针而不是对象放进容器</h2><p>当我们需要容器存放继承相关的对象，定义容器存放基类的指针。和往常一样，指针指向的对象的动态类型可能是基类类型或派生类类型：</p>
<pre><code><span class="built_in">vector</span>&lt;<span class="built_in">shared_ptr</span>&lt;Quote&gt;&gt; basket;
basket.push_back(make_shared&lt;Quote&gt;(<span class="string">"0-201-82470-1"</span>, <span class="number">50</span>));
basket.push_back(
    make_shared&lt;Bulk_quote&gt;(<span class="string">"0-201-54848-8"</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">.25</span>));
<span class="comment">// calls the version defined by Quote; prints 562.5, i.e., 15 * $50 less the discount</span>
<span class="built_in">cout</span> &lt;&lt; basket.back()-&gt;net_price(<span class="number">15</span>) &lt;&lt; endl;
</code></pre><p>就像我们能够转换指向派生类对象的普通指针为指向基类的普通指针，我们也能转换指向派生类的智能指针为指向基类的智能指针。</p>
<h2 id="15-8-1_编写Basket类">15.8.1 编写Basket类</h2><p>C++中的面向对象编程的一个讽刺是我们不能使用对象直接支持它。反而，我们必须使用指针和引用。由于指针强加给程序的复杂性，我们通常定义辅助的类来帮助管理复杂性。</p>
<pre><code><span class="keyword">class</span> Basket {
<span class="keyword">public</span>:
    <span class="comment">// Basket uses synthesized default constructor and copy-control members</span>
    <span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Quote&gt; &amp;sale)</span>
        </span>{ items.insert(sale); }
    <span class="comment">// prints the total price for each book and the overall total for all items in the</span>
<span class="function">basket
    <span class="keyword">double</span> <span class="title">total_receipt</span><span class="params">(<span class="built_in">std</span>::ostream&amp;)</span> <span class="keyword">const</span></span>;
<span class="keyword">private</span>:
    <span class="comment">// function to compare shared_ptrs needed by the multiset member</span>
    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Quote&gt; &amp;lhs,
                        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Quote&gt; &amp;rhs)</span>
    </span>{ <span class="keyword">return</span> lhs-&gt;isbn() &lt; rhs-&gt;isbn(); }
    <span class="comment">// multiset to hold multiple quotes, ordered by the compare member</span>
    <span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Quote&gt;, <span class="keyword">decltype</span>(compare)*&gt;
                  items{compare};
};
</code></pre><h3 id="定义Basket的成员">定义Basket的成员</h3><pre><code><span class="keyword">double</span> Basket::total_receipt(ostream &amp;os) const
{
    <span class="keyword">double</span> <span class="keyword">sum</span> = <span class="number">0.0</span>;   <span class="comment">// holds the running total</span>
    <span class="comment">// iter refers to the first element in a batch of elements with the same ISBN</span>
    <span class="comment">// upper_bound returns an iterator to the element just past the end of that batch</span>
    <span class="keyword">for</span> (auto iter = items.cbegin();
              iter != items.cend();
              iter = items.upper_bound(*iter)) {
        <span class="comment">// we know there's at least one element with this key in the Basket</span>
        <span class="comment">// print the line item for this book</span>
        <span class="keyword">sum</span> += print_total(os, **iter, items.<span class="keyword">count</span>(*iter));
    }
    os &lt;&lt; <span class="string">"Total Sale: "</span> &lt;&lt; <span class="keyword">sum</span> &lt;&lt; endl; <span class="comment">// print the final overall</span>
total
    <span class="keyword">return</span> <span class="keyword">sum</span>;
}
</code></pre><h3 id="隐藏指针">隐藏指针</h3><p>Basket的用户仍然需要处理动态分配的内存，因为add_item带一个shared_ptr参数。</p>
<pre><code>Basket bsk;
bsk.add_item(make_shared&lt;Quote&gt;(<span class="string">"123"</span>, <span class="number">45</span>));
bsk.add_item(make_shared&lt;Bulk_quote&gt;(<span class="string">"345"</span>, <span class="number">45</span>, <span class="number">3</span>, <span class="number">.15</span>));
</code></pre><p>我们下一步将重定义add_item来接收Quote对象而不是shared_ptr。</p>
<pre><code><span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(<span class="keyword">const</span> Quote&amp; sale)</span></span>;  <span class="comment">// copy the given object</span>
<span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(Quote&amp;&amp; sale)</span></span>;       <span class="comment">// move the given object</span>
</code></pre><h3 id="模拟虚复制">模拟虚复制</h3><p>我们将通过给Quote类一个虚成员分配自己的拷贝来解决这个问题。</p>
<pre><code><span class="keyword">class</span> Quote {
<span class="keyword">public</span>:
    <span class="comment">// virtual function to return a dynamically allocated copy of itself</span>
    <span class="comment">// these members use reference qualifiers; see §13.6.3 (p. 546)</span>
    <span class="function"><span class="keyword">virtual</span> Quote* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> &amp; </span>{<span class="keyword">return</span> <span class="keyword">new</span> Quote(*<span class="keyword">this</span>);}
    <span class="function"><span class="keyword">virtual</span> Quote* <span class="title">clone</span><span class="params">()</span> &amp;&amp; </span>{<span class="keyword">return</span> <span class="keyword">new</span> Quote(<span class="built_in">std</span>::move(*<span class="keyword">this</span>));}
    <span class="comment">// other members as before</span>
};
<span class="keyword">class</span> Bulk_quote : <span class="keyword">public</span> Quote {
    <span class="function">Bulk_quote* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> &amp; </span>{<span class="keyword">return</span> <span class="keyword">new</span> Bulk_quote(*<span class="keyword">this</span>);}
    <span class="function">Bulk_quote* <span class="title">clone</span><span class="params">()</span> &amp;&amp; </span>{ <span class="keyword">return</span> <span class="keyword">new</span> Bulk_quote(<span class="built_in">std</span>::move(*<span class="keyword">this</span>));}
    <span class="comment">// other members as before</span>
};

<span class="keyword">class</span> Basket {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(<span class="keyword">const</span> Quote&amp; sale)</span> <span class="comment">// copy the given object</span>
      </span>{ items.insert(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Quote&gt;(sale.clone())); }
    <span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(Quote&amp;&amp; sale)</span>      <span class="comment">// move the given object</span>
      </span>{ items.insert(
          <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Quote&gt;(<span class="built_in">std</span>::move(sale).clone())); }
    <span class="comment">// other members as before</span>
};
</code></pre><h1 id="15-9_文本查询重温">15.9 文本查询重温</h1>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="15-1_OOP概述">15.1 OOP概述</h1><p>面向对象编程的关键思想是数据抽象，继承和动态绑定。使用数据抽象，我们可以定义接口和实现分离的类。通过继承，我们可以定义相似类之间的关系模型。通过动态绑定，我们可以使用这些类对象而忽略它们之间的差别。</p]]>
    </summary>
    
      <category term="C/C++" scheme="https://opensvn.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[重载操作和转换]]></title>
    <link href="https://opensvn.github.io/2015/09/20/cpp_primer_14/"/>
    <id>https://opensvn.github.io/2015/09/20/cpp_primer_14/</id>
    <published>2015-09-20T02:47:02.000Z</published>
    <updated>2015-12-15T11:27:23.510Z</updated>
    <content type="html"><![CDATA[<p>这是C++ primer第五版第14章的读书笔记。</p>
<h1 id="基本概念">基本概念</h1><p>重载操作符是具有特殊名字的函数：关键字<strong>operator</strong>后面跟着需要被定义的操作符的符号。像其它函数一样，重载操作符有返回值，参数列表和函数体。</p>
<p>重载操作符的参数和操作符的操作数一样多。除了函数调用操作符(<strong>operator()</strong>)，重载操作符没有默认实参。</p>
<blockquote>
<p><strong>注意</strong><br>当重载操作符是成员函数时，<strong>this</strong>绑定到左操作数。因此，成员操作符函数少一个操作数。</p>
</blockquote>
<p>操作符函数必须为类的成员或至少有一个类类型参数：</p>
<pre><code><span class="comment">// error: cannot redefine the built-in operator for ints</span>
<span class="keyword">int</span> <span class="keyword">operator</span>+(<span class="keyword">int</span>, <span class="keyword">int</span>);
</code></pre><p>我们可以重载大多数操作符，而且只能重载已经存在的操作符：</p>
<pre><code>                可以重载的操作符
+       -       *       /       %       ^
&amp;       |       ~       !       ,       =
&lt;       &gt;       &lt;=      &gt;=      ++      --
&lt;&lt;      &gt;&gt;      ==      !=      &amp;&amp;      ||
+=      -=      /=      %=      ^=      &amp;=
|=      *=      &lt;&lt;=     &gt;&gt;=     []      <span class="function"><span class="params">()</span>
-&gt;</span><span class="function">      -&gt;*</span>     <span class="keyword">new</span>     <span class="keyword">new</span>[]   <span class="keyword">delete</span>  <span class="keyword">delete</span>[]
                不能重载的操作符
        ::      .*      .       ?:
</code></pre><p>重载操作符和相应的内置操作符有相同的优先级和结合性。</p>
<h3 id="直接调用重载操作符函数">直接调用重载操作符函数</h3><pre><code><span class="keyword">data</span>1 + <span class="keyword">data</span>2;           // 表达式调用
operator+(<span class="keyword">data</span>1, <span class="keyword">data</span>2); // 等价的函数调用
<span class="keyword">data</span>1 += <span class="keyword">data</span>2;          // 表达式调用
<span class="keyword">data</span>1.operator+=(<span class="keyword">data</span>2); // 等价的成员函数调用
</code></pre><h3 id="有些操作符不应该重载">有些操作符不应该重载</h3><p>重载操作符不保留求值顺序或短路求值。</p>
<blockquote>
<p><strong>最佳实践</strong><br>通常，逗号（,），取地址（&amp;），逻辑与（&amp;&amp;）和逻辑或（||）不应该重载。</p>
</blockquote>
<h3 id="使用和内置操作符意思一致的定义">使用和内置操作符意思一致的定义</h3><ul>
<li>如果类使用IO，定义与内置类型IO操作一致的<strong>shift</strong>操作符</li>
<li>如果类有测试相等的操作，定义<strong>operator==</strong>。如果类有<strong>operator==</strong>，通常也应该定义<strong>operator!=</strong>。</li>
<li>如果类有单一的自然顺序的操作，定义<strong>operator&lt;</strong>。如果类有<strong>operator&lt;</strong>，通常也应该定义其它关系操作符。</li>
<li>重载操作符的返回类型应该和内置操作符的返回类型兼容：逻辑操作符和关系操作符应该返回<strong>bool</strong>，算术操作符应该返回类的值，赋值操作符应该返回左操作数的引用。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：明智地使用操作符重载<br>当内置操作符和类的操作有逻辑映射的时候，操作符重载最有用。</p>
</blockquote>
<h3 id="选择成员或非成员实现">选择成员或非成员实现</h3><p>以下指导方针能够帮助我们决定是否将一个操作符定义为成员函数或普通的非成员函数：</p>
<ul>
<li>赋值操作符（=），下标操作符（[]），调用操作符（()），成员访问操作符（-&gt;）必须定义为成员。</li>
<li>复合赋值操作符通常应该定义为成员，但是没有要求一定这样。</li>
<li>改变对象状态或与类对象联系紧密的操作符，通常应该定义为成员。比如++，–和解引用（*）。</li>
<li>那些可能转换操作数的对称的操作符，比如算术操作符，关系操作符，位操作符，通常应该定义为非成员。</li>
</ul>
<h1 id="输入输出操作符">输入输出操作符</h1><h3 id="重载输出操作符_&lt;&lt;">重载输出操作符 &lt;&lt;</h3><pre><code>ostream &amp;operator&lt;&lt;(ostream &amp;os, const Sales_data &amp;<span class="property">item</span>)
{
    os &lt;&lt; <span class="property">item</span>.isbn() &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="property">item</span>.units_sold &lt;&lt; <span class="string">" "</span>
       &lt;&lt; <span class="property">item</span>.revenue &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="property">item</span>.avg_price();
<span class="command">    return</span> os;
}
</code></pre><blockquote>
<p><strong>最佳实践</strong><br>通常输出操作符应该最小格式化输出对象的内容，不应该打印换行。</p>
</blockquote>
<h3 id="IO操作符必须是非成员函数">IO操作符必须是非成员函数</h3><p>输入输出操作符遵循库<strong>iostream</strong>的惯例必须为普通的非成员函数。</p>
<pre><code><span class="type">Sales_data</span> <span class="typedef"><span class="keyword">data</span>;</span>
<span class="typedef"><span class="keyword">data</span> &lt;&lt; cout; // 如果operator&lt;&lt;是<span class="type">Sales_data</span>的一个成员</span>
</code></pre><p>如果这些操作符是任意一个类的成员，那它们应该是<strong>istream</strong>或<strong>ostream</strong>的成员，但是我们无法给标准库添加成员。输入输出操作符通常需要读或写非公开的数据成员。因此，IO操作符通常必须声明为<strong>friend</strong>。</p>
<h3 id="重载输入操作符_&gt;&gt;">重载输入操作符 &gt;&gt;</h3><pre><code>istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;<span class="keyword">is</span>, Sales_data &amp;item)
{
    <span class="keyword">double</span> price;
    <span class="keyword">is</span> &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;
    <span class="keyword">if</span> (<span class="keyword">is</span>)        <span class="comment">// 检查输入是否成功</span>
        item.revenue = item.units_sold * price;
    <span class="keyword">else</span>
        item = Sales_data(); <span class="comment">// 输入失败：给对象一个默认值</span>
    <span class="keyword">return</span> <span class="keyword">is</span>;
}
</code></pre><blockquote>
<p><strong>注意</strong><br>输入操作符必须处理输入失败的可能性。输出操作符通常没有这个困扰。</p>
</blockquote>
<p>我们选择在读取了所有数据之后，使用数据之前来检查流状态。</p>
<blockquote>
<p><strong>最佳实践</strong><br>输入操作符应该决定做什么错误恢复。当错误发生时，使对象处于一个合法状态尤其重要，因为对象可能被部分修改。</p>
</blockquote>
<p>通常输入操作符应该只设置<strong>failbit</strong>。<strong>eofbit</strong>和<strong>badbit</strong>最好是留给IO库去指示。</p>
<h1 id="算术和关系操作符">算术和关系操作符</h1><p>通常我们将算术和关系操作符定义为非成员函数，以允许转换左右操作符中的一个。这些操作符不需要修改操作数的状态，所以参数通常为<strong>const</strong>引用。定义了算术操作符的类通常也要定义相应的复合赋值操作符。</p>
<pre><code>Sales_data
operator+(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)
{
    Sales_data <span class="keyword">sum</span> = lhs;
    <span class="keyword">sum</span> += rhs;
    <span class="keyword">return</span> <span class="keyword">sum</span>;
}
</code></pre><blockquote>
<p><strong>提示</strong><br>定义了算术操作符和相应的复合赋值操作符的类，应该使用复合赋值操作符来实现算术操作符。</p>
</blockquote>
<h3 id="相等操作符">相等操作符</h3><pre><code><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)
{
    <span class="keyword">return</span> lhs.isbn() == rhs.isbn() &amp;&amp;
           lhs.units_sold == rhs.units_sold &amp;&amp;
           lhs.revenue == rhs.revenue;
}
<span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)
{
    <span class="keyword">return</span> !(lhs == rhs);
}
</code></pre><p>相等操作符的设计原理：</p>
<ul>
<li>如果一个类有一个确定2个对象是否相等的操作，那么该类应该定义<strong>operator==</strong>，而不是命名函数，而且可以容易使用标准库容器和算法。</li>
<li>如果一个类定义了<strong>operator==</strong>，这个操作符通常应该确定给定的对象是否包含相同的数据。</li>
<li>通常地，相等操作符应该是可传递的， 比如如果a == b, b == c， 则a == c。</li>
<li>如果一个类定义了<strong>operator==</strong>，那也应该定义<strong>operator!=</strong>，反之也一样。</li>
<li>相等或不等操作符应该将实际工作委托给另一个。</li>
</ul>
<blockquote>
<p><strong>最佳实践</strong><br>相等性具有逻辑意义的类通常应该定义<strong>operator==</strong>，定义了<strong>operator==</strong>的类使得用户容易使用标准库算法。</p>
</blockquote>
<h3 id="关系操作符">关系操作符</h3><p>定义了相等操作符的类通常（不总是）也会定义关系操作符。特别地，关系容器和有些算法使用<strong>&lt;</strong>操作符，定义<strong>operator&lt;</strong>会很有用。</p>
<p>通常关系操作符应该：</p>
<ul>
<li>定义一个顺序关系和关联容器的key的需求一致。</li>
<li>定义一个关系和<strong>==</strong>一致，如果类2种操作符都定义了。特别地，如果2个对象<strong>!=</strong>，则其中一个应该<strong>&lt;</strong>另一个。</li>
</ul>
<blockquote>
<p><strong>最佳实践</strong><br>如果只有一个逻辑定义<strong>&lt;</strong>存在，类通常应该定义<strong>&lt;</strong>操作符。然而，如果类也有<strong>==</strong>，只有当<strong>&lt;</strong>和<strong>==</strong>产生的结果一致时，定义<strong>&lt;</strong>。</p>
</blockquote>
<h3 id="赋值操作符">赋值操作符</h3><p>除了<strong>copy-</strong>和<strong>move-</strong>赋值操作符之外，类还可以定义其它的赋值操作符允许其它类型作为右操作数。</p>
<pre><code><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;
v = {<span class="string">"a"</span>, <span class="string">"an"</span>, <span class="string">"the"</span>};
<span class="keyword">class</span> StrVec {
<span class="keyword">public</span>:
    StrVec &amp;<span class="keyword">operator</span>=(<span class="built_in">std</span>::initializer_list&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;);
};
StrVec &amp;StrVec::<span class="keyword">operator</span>=(initializer_list&lt;<span class="built_in">string</span>&gt; il)
{
    <span class="keyword">auto</span> data = alloc_n_copy(il.begin(), il.end());
    <span class="built_in">free</span>();
    elements = data.first;
    first_free = cap = data.second;
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
</code></pre><p>不像<strong>copy-</strong>和<strong>move-</strong>赋值操作符，这个操作符不需要检查自我赋值。</p>
<blockquote>
<p><strong>注意</strong><br>赋值操作符可以被重载。不管参数类型是什么，赋值操作符必须定义为成员函数。</p>
</blockquote>
<p>复合赋值操作符不需要是类成员。然而，我们倾向于定义所有的赋值操作符，包括复合赋值操作符为类成员。</p>
<pre><code>Sales_data&amp; Sales_data::<span class="keyword">operator</span>+=(<span class="keyword">const</span> Sales_data &amp;rhs)
{
    units_sold += rhs.units_sold;
    revenue += rhs.revenue;
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
</code></pre><blockquote>
<p><strong>最佳实践</strong><br>赋值操作符必须，而且通常复合赋值操作符应该，定义为成员。这些操作符应该返回左操作数的引用。</p>
</blockquote>
<h3 id="下标操作符">下标操作符</h3><p>可以通过位置来获取元素的代表容器的类，通常定义下标操作符，<strong>operater[]</strong>。</p>
<blockquote>
<p><strong>注意</strong><br>下标操作符必须为成员函数。</p>
<p><strong>最佳实践</strong><br>如果一个类有下标操作符，它通常应该定义2个版本：一个返回普通引用，一个返回const引用。</p>
</blockquote>
<pre><code><span class="keyword">class</span> StrVec {
<span class="keyword">public</span>:
    <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n)
        { <span class="keyword">return</span> elements[n]; }
    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n) <span class="keyword">const</span>
        { <span class="keyword">return</span> elements[n]; }
<span class="keyword">private</span>:
    <span class="built_in">std</span>::<span class="built_in">string</span> *elements; <span class="comment">// 指向数组第一个元素</span>
};

<span class="keyword">const</span> StrVec cvec = svec;
<span class="keyword">if</span> (svec.size() &amp;&amp; svec[<span class="number">0</span>].empty())  {
    svec[<span class="number">0</span>] = <span class="string">"zero"</span>; <span class="comment">// ok: 返回一个普通引用</span>
    cvec[<span class="number">0</span>] = <span class="string">"Zip"</span>;  <span class="comment">// error: 返回一个const引用</span>
}
</code></pre><h3 id="自增和自减操作符">自增和自减操作符</h3><p>自增和自减操作符最常被迭代器类实现。语言并没要要求这些操作符是成员，但是由于这些操作符改变它们操作的对象的状态，我们选择将它们定义为成员。</p>
<blockquote>
<p><strong>最佳实践</strong><br>定义自增或自减操作符的类应该定义<strong>prefix</strong>和<strong>postfix</strong>版本。这些操作符应该定义为成员。</p>
</blockquote>
<pre><code><span class="keyword">class</span> StrBlobPtr {
<span class="keyword">public</span>:
    StrBlobPtr&amp; <span class="keyword">operator</span>++(); <span class="comment">// 前自增操作符</span>
    StrBlobPtr&amp; <span class="keyword">operator</span>--(); <span class="comment">// 前自减操作符</span>
};

StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>++()
{
    check(curr, <span class="string">"increment past end of StrBlobPtr"</span>);
    ++curr;
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}

StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>--()
{
    --curr;
    check(-<span class="number">1</span>, <span class="string">"decrement past begin of StrBlobPtr"</span>);
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
</code></pre><blockquote>
<p><strong>最佳实践</strong><br>为了和内置操作符一致，前置操作符应该返回自增过或自减过的对象的引用。</p>
</blockquote>
<pre><code><span class="keyword">class</span> StrBlobPtr {
<span class="keyword">public</span>:
    StrBlobPtr <span class="keyword">operator</span>++(<span class="keyword">int</span>);    <span class="comment">// 后置操作符</span>
    StrBlobPtr <span class="keyword">operator</span>--(<span class="keyword">int</span>);
};

StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>++(<span class="keyword">int</span>)
{
    StrBlobPtr ret = *<span class="keyword">this</span>;
    ++*<span class="keyword">this</span>;
    <span class="keyword">return</span> ret;
}

StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>--(<span class="keyword">int</span>)
{
    StrBlobPtr ret = *<span class="keyword">this</span>;
    --*<span class="keyword">this</span>;
    <span class="keyword">return</span> ret;
}
</code></pre><blockquote>
<p><strong>最佳实践</strong><br>为了和内置操作符一致，后置操作符应该返回旧的（未自增或自减）值，而不是引用。</p>
<p><strong>注意</strong><br><strong>int</strong>参数没有用到，所以没有给它一个名字。</p>
</blockquote>
<pre><code><span class="function">StrBlobPtr <span class="title">p</span><span class="params">(a1)</span></span>;
p.<span class="keyword">operator</span>++(<span class="number">0</span>);  <span class="comment">// 调用后自增操作符</span>
p.<span class="keyword">operator</span>++();   <span class="comment">// 调用前自增操作符</span>
</code></pre><h3 id="成员访问操作符">成员访问操作符</h3><p>解引用（*）和箭头（-&gt;）操作符经常使用在迭代器类和智能指针类中。</p>
<pre><code><span class="keyword">class</span> StrBlobPtr {
<span class="keyword">public</span>:
    <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>
    { 
        <span class="keyword">auto</span> p = check(curr, <span class="string">"dereference past end"</span>);
        <span class="keyword">return</span> (*p)[curr];  <span class="comment">// (*p)是这个对象指向的vector</span>
    }
    <span class="built_in">std</span>::<span class="built_in">string</span>* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>
    {
        <span class="keyword">return</span> &amp; <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*(); <span class="comment">// 将实际工作委托给解引用操作符</span>
    }
};
</code></pre><blockquote>
<p><strong>注意</strong><br>箭头操作符必须定义为成员，没有要求解引用为成员但通常也应该为成员。</p>
</blockquote>
<p>值得注意的是我们定义这些操作符为<strong>const</strong>成员，获取一个元素不会改变这个对象的状态。</p>
<pre><code>StrBlob a1 = {<span class="string">"hi"</span>, <span class="string">"bye"</span>, <span class="string">"now"</span>};
<span class="function">StrBlobPtr <span class="title">p</span><span class="params">(a1)</span></span>;            <span class="comment">// p指向a1里面的vector</span>
*p = <span class="string">"okay"</span>;                 <span class="comment">// 给a1中第一个元素赋值</span>
<span class="built_in">cout</span> &lt;&lt; p-&gt;size() &lt;&lt; endl;   <span class="comment">// 第一个元素的size()</span>
<span class="built_in">cout</span> &lt;&lt; (*p).size() &lt;&lt; endl; <span class="comment">// 等价于p-&gt;size()</span>
</code></pre><p>当我们写<strong>point-&gt;mem</strong>时，<strong>point</strong>必须是指向一个类对象的指针或是一个重载了<strong>operator-&gt;</strong>的类的对象。取决于<strong>point</strong>的类型，<strong>point-&gt;mem</strong>等价于：</p>
<pre><code>(*<span class="built_in">point</span>).mem;          <span class="comment">// point是一个内置指针类型</span>
<span class="built_in">point</span>.operator()-&gt;mem; <span class="comment">// point是一个类的对象</span>
</code></pre><blockquote>
<p><strong>注意</strong><br>箭头操作符必须返回一个指向类类型的指针或一个定义了自己的箭头操作符的类类型的对象。</p>
</blockquote>
<h3 id="函数调用操作符">函数调用操作符</h3><p>重载了函数调用操作符的类允许它的对象像函数一样使用。因为这种类可以保存状态，它们比普通函数更灵活。</p>
<pre><code><span class="keyword">struct</span> absInt {
    <span class="built_in">int</span> operator<span class="literal">()</span>(<span class="built_in">int</span> <span class="keyword">val</span>) const {
        return <span class="keyword">val</span> &lt; <span class="number">0</span> ? -<span class="keyword">val</span> : <span class="keyword">val</span>;
    }
};
</code></pre><p>定义了函数调用操作符的类的对象被称为函数对象，我们可以像函数调用一样提供一个参数列表给函数对象：</p>
<pre><code><span class="keyword">int</span> i = -<span class="number">42</span>;
absInt absObj;
<span class="keyword">int</span> ui = absObj(i);
</code></pre><blockquote>
<p><strong>注意</strong><br>函数调用操作符必须是成员函数。一个类可以定义多个版本的调用操作符，每一个参数类型或数量必须不一样。</p>
</blockquote>
<p>和其他类一样，一个函数对象类除了<strong>operator()</strong>，还可以有其它成员。函数对象类通常包含其它成员用来调整函数调用操作符的操作。</p>
<pre><code><span class="keyword">class</span> PrintString {
<span class="keyword">public</span>:
    PrintString(ostream &amp;o = <span class="built_in">cout</span>, <span class="keyword">char</span> c = <span class="string">' '</span>):
        os(o), sep(c) { }
    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> <span class="keyword">const</span> </span>{ os &lt;&lt; s &lt;&lt; sep;}
<span class="keyword">private</span>:
    ostream &amp;os;   <span class="comment">// stream on which to write</span>
    <span class="keyword">char</span> sep;      <span class="comment">// character to print after each output</span>
};

PrintString printer;   <span class="comment">// uses the defaults; prints to cout</span>
printer(s);            <span class="comment">// prints s followed by a space on cout</span>
<span class="function">PrintString <span class="title">errors</span><span class="params">(<span class="built_in">cerr</span>, <span class="string">'\n'</span>)</span></span>;
errors(s);             <span class="comment">// prints s followed by a newline on cerr</span>
</code></pre><p>函数对象最常用于泛型算法的参数：</p>
<pre><code>for_each<span class="list">(<span class="keyword">vs</span>.begin<span class="list">()</span>, vs.end<span class="list">()</span>, PrintString<span class="list">(<span class="keyword">cerr</span>, '\n')</span>)</span><span class="comment">;</span>
</code></pre><h3 id="Lambdas是函数对象">Lambdas是函数对象</h3><p>当我们写一个<strong>lambda</strong>时，编译器将表达式翻译成一个匿名类的匿名对象。由<strong>lambda</strong>生成的类包含了一个重载的函数调用操作符。</p>
<pre><code>stable_sort<span class="list">(<span class="keyword">words</span>.begin<span class="list">()</span>, words.end<span class="list">()</span>,
            []<span class="list">(<span class="keyword">const</span> string <span class="keyword">&amp;a</span>, const string <span class="keyword">&amp;b</span>)</span>
              { return a.size<span class="list">()</span> &lt; b.size<span class="list">()</span><span class="comment">;});</span></span>
</code></pre><p>行为就像一个匿名对象的类，看起来像：</p>
<pre><code><span class="keyword">class</span> <span class="title">ShorterString</span> {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span>(<span class="params"></span>)(<span class="params"><span class="keyword">const</span> <span class="keyword">string</span> &amp;s1, <span class="keyword">const</span> <span class="keyword">string</span> &amp;s2</span>) <span class="keyword">const</span>
    </span>{ <span class="keyword">return</span> s1.size() &lt; s2.size(); }
};

stable_sort(words.begin(), words.end(), ShorterString());
</code></pre><h3 id="类表示Lambdas带捕获成员">类表示Lambdas带捕获成员</h3><pre><code>auto wc = find_if<span class="list">(<span class="keyword">words</span>.begin<span class="list">()</span>, words.end<span class="list">()</span>,
            [sz]<span class="list">(<span class="keyword">const</span> string <span class="keyword">&amp;a</span>)</span>{ return a.size<span class="list">()</span> &gt;= sz<span class="comment">;});</span></span>
</code></pre><p>会生成像这样的类：</p>
<pre><code><span class="keyword">class</span> SizeComp {
<span class="keyword">public</span>:
    SizeComp(<span class="keyword">size_t</span> n): sz(n) { } <span class="comment">// parameter for each captured variable</span>
    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> <span class="keyword">const</span>
        </span>{ <span class="keyword">return</span> s.size() &gt;= sz; }
<span class="keyword">private</span>:
    <span class="keyword">size_t</span> sz; <span class="comment">// a data member for each variable captured by value</span>
};

<span class="keyword">auto</span> wc = find_if(words.begin(), words.end(), SizeComp(sz));
</code></pre><p>由lambda表达式生成的类有一个<strong>deleted</strong>默认构造函数，<strong>deleted</strong>赋值操作符和一个默认析构函数。是否有<strong>deleted</strong>或默认的<strong>copy/move</strong>构造函数取决于捕获的数据成员。</p>
<h3 id="标准库定义的函数对象">标准库定义的函数对象</h3><p>标准库定义了一个类集合，表示算术，关系和逻辑运算符。<br><strong>plus</strong>类有一个函数调用操作符，应用<strong>+</strong>操作符。<br><strong>modulus</strong>类有一个函数调用操作符，应用<strong>%</strong>操作符。<br><strong>equal_to</strong>类有一个函数调用操作符，应用<strong>==</strong>操作符。</p>
<pre><code>plus&lt;<span class="built_in">int</span>&gt; intAdd;       // <span class="function"><span class="keyword">function</span></span> object that can add two <span class="built_in">int</span> values
negate&lt;<span class="built_in">int</span>&gt; intNegate;  // <span class="function"><span class="keyword">function</span></span> object that can negate an <span class="built_in">int</span> <span class="keyword">value</span>
<span class="built_in">int</span> <span class="built_in">sum</span> = intAdd(<span class="number">10</span>, <span class="number">20</span>);         // <span class="built_in">sum</span> = <span class="number">30</span>
<span class="built_in">sum</span> = intNegate(intAdd(<span class="number">10</span>, <span class="number">20</span>));  // <span class="built_in">sum</span> = -<span class="number">30</span>
<span class="built_in">sum</span> = intAdd(<span class="number">10</span>, intNegate(<span class="number">10</span>));  // <span class="built_in">sum</span> = <span class="number">0</span>
</code></pre><h3 id="算法中使用标准库函数对象">算法中使用标准库函数对象</h3><pre><code><span class="comment">// passes a temporary function object that applies the &lt; operator to two strings</span>
sort(svec.<span class="keyword">begin</span>(), svec.<span class="keyword">end</span>(), greater&lt;<span class="keyword">string</span>&gt;());
</code></pre><p>标准库函数对象保证对指针也有作用。</p>
<pre><code>vector&lt;<span class="keyword">string</span> *&gt; nameTable;  <span class="comment">// vector of pointers</span>
<span class="comment">// error: the pointers in nameTable are unrelated, so &lt; is undefined</span>
sort(nameTable.<span class="keyword">begin</span>(), nameTable.<span class="keyword">end</span>(),
     [](<span class="keyword">string</span> *a, <span class="keyword">string</span> *b) <span class="comment">{ return a &lt; b; }</span>);
<span class="comment">// ok: library guarantees that less on pointer types is well defined</span>
sort(nameTable.<span class="keyword">begin</span>(), nameTable.<span class="keyword">end</span>(), less&lt;<span class="keyword">string</span>*&gt;());
</code></pre><p>值得注意的是关联容器使用<strong>less<key_type></key_type></strong>排序它们的元素。因此，我们能定义一个指针集合，或者使用一个指针作为<strong>key</strong>的<strong>map</strong>容器而不用直接指定<strong>less</strong>。</p>
<h3 id="可调用对象和函数">可调用对象和函数</h3><p>C++有几种可调用对象：函数和函数指针，lambdas，由<strong>bind</strong>创建的对象和重载了函数调用操作符的类。</p>
<p>不同类型可以有相同的调用签名：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{ <span class="keyword">return</span> i + j; } <span class="comment">// 普通函数</span>
<span class="keyword">auto</span> mod = [](<span class="keyword">int</span> i, <span class="keyword">int</span> j) { <span class="keyword">return</span> i % j; }; <span class="comment">// 匿名函数</span>
<span class="comment">// 函数对象类</span>
<span class="keyword">struct</span> div {
    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> denominator, <span class="keyword">int</span> divisor)</span> </span>{
        <span class="keyword">return</span> denominator / divisor;
    }
};

<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>(*)(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; binops;

binops.insert({<span class="string">"+"</span>, add}); <span class="comment">// ok: add是一个指向合适类型的函数指针</span>
binops.insert({<span class="string">"%"</span>, mod}); <span class="comment">// error: mod不是一个指向函数的指针</span>
</code></pre><h3 id="标准库function类型">标准库function类型</h3><pre><code><span class="comment">#include &lt;functional&gt;</span>

<span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt; <span class="title">f</span></span>;          空函数对象。
<span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt; <span class="title">f</span><span class="params">(nullptr)</span></span>; 显式构造空函数对象。
<span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt; <span class="title">f</span><span class="params">(obj)</span></span>;     保存一个obj的副本。
f                       <span class="keyword">true</span>当f拥有一个可调用对象，否则<span class="keyword">false</span>。
f(args)                 传递参数args，调用函数。

定义为<span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;的成员的类型
<span class="title">result_type</span>             可调用对象的返回类型。
<span class="title">argument_type</span>           当参数为1个或2个时的类型。
<span class="title">first_argument_type</span>
<span class="title">second_argument_type</span></span>
</code></pre><p><strong>function</strong>是一个模板。和其它模板一样，我们必须指定<strong>function</strong>的函数类型。</p>
<pre><code>function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f1 = add;    <span class="comment">// 函数指针</span>
function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f2 = div();  <span class="comment">// 函数对象</span>
function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f3 = [](<span class="keyword">int</span> i, <span class="keyword">int</span> j) { <span class="keyword">return</span> i * j;}; <span class="comment">// 匿名函数</span>
<span class="built_in">cout</span> &lt;&lt; f1(<span class="number">4</span>,<span class="number">2</span>) &lt;&lt; endl; <span class="comment">// prints 6</span>
<span class="built_in">cout</span> &lt;&lt; f2(<span class="number">4</span>,<span class="number">2</span>) &lt;&lt; endl; <span class="comment">// prints 2</span>
<span class="built_in">cout</span> &lt;&lt; f3(<span class="number">4</span>,<span class="number">2</span>) &lt;&lt; endl; <span class="comment">// prints 8</span>

<span class="built_in">map</span>&lt;<span class="built_in">string</span>, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; binops = {
    {<span class="string">"+"</span>, add},                  <span class="comment">// function pointer</span>
    {<span class="string">"-"</span>, <span class="built_in">std</span>::minus&lt;<span class="keyword">int</span>&gt;()},    <span class="comment">// library function object</span>
    {<span class="string">"/"</span>,  div()},               <span class="comment">// user-defined function object</span>
    {<span class="string">"*"</span>, [](<span class="keyword">int</span> i, <span class="keyword">int</span> j) { <span class="keyword">return</span> i * j; }}, <span class="comment">// unnamed lambda</span>
    {<span class="string">"%"</span>, mod} };                <span class="comment">// named lambda object</span>

binops[<span class="string">"+"</span>](<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// calls add(10, 5)</span>
binops[<span class="string">"-"</span>](<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// uses the call operator of the minus&lt;int&gt; object</span>
binops[<span class="string">"/"</span>](<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// uses the call operator of the div object</span>
binops[<span class="string">"*"</span>](<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// calls the lambda function object</span>
binops[<span class="string">"%"</span>](<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// calls the lambda function object</span>
</code></pre><h3 id="重载函数和function">重载函数和function</h3><p>我们不能直接保存一个重载函数的函数名：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>{ <span class="keyword">return</span> i + j; }
<span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;
<span class="built_in">map</span>&lt;<span class="built_in">string</span>, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; binops;
binops.insert({<span class="string">"+"</span>, add}); <span class="comment">// error: which add?</span>
</code></pre><p>解决二义性的一个方法是存储函数指针：</p>
<pre><code><span class="built_in">int</span> (*fp)(<span class="built_in">int</span>,<span class="built_in">int</span>) = <span class="built_in">add</span>;
binops.insert({<span class="string">"+"</span>, fp});
</code></pre><p>或者使用lambda消除歧义：</p>
<pre><code>binops.insert({<span class="string">"+"</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) {<span class="function"><span class="keyword">return</span> <span class="title">add</span><span class="params">(a, b)</span></span>;}});
</code></pre><h1 id="重载，转换和操作符">重载，转换和操作符</h1><p>转换构造函数和转换操作符定义了类类型的转换。这种转换又叫做用户定义的转换。</p>
<h3 id="转换操作符">转换操作符</h3><p>转换操作符是一种特殊的成员函数，将一个类类型的值转换为其它类型的值。一个典型的转换函数具有形式：</p>
<pre><code><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">const</span></span>;
</code></pre><p>转换操作符可以为任意（除了<strong>void</strong>）函数返回的类型定义转换。不允许转换为数组或函数类型。允许转换为指针（数据指针和函数指针）和引用。</p>
<blockquote>
<p><strong>注意</strong><br>转换函数必须是一个成员函数，不能指定返回类型，参数列表必须为空，通常为const。</p>
</blockquote>
<h3 id="定义一个具有转换操作符的类">定义一个具有转换操作符的类</h3><pre><code><span class="keyword">class</span> SmallInt {
<span class="keyword">public</span>:
    SmallInt(<span class="keyword">int</span> i = <span class="number">0</span>): val(i)
    {
        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; <span class="number">255</span>)
            <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">"Bad SmallInt value"</span>);
    }
    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> val; }
<span class="keyword">private</span>:
    <span class="built_in">std</span>::<span class="keyword">size_t</span> val;
};

SmallInt si;
si = <span class="number">4</span>; <span class="comment">// implicitly converts 4 to SmallInt then calls SmallInt::operator=</span>
si + <span class="number">3</span>; <span class="comment">// implicitly converts si to int followed by integer addition</span>
</code></pre><p>尽管编译器每次只应用一个用户定义的转换操作，隐式调用用户定义的转换可以在之前或之后跟着一个标准转换。</p>
<pre><code>SmallInt si = <span class="number">3.14</span>;
si + <span class="number">3.14</span>;
</code></pre><p>因为转换操作符是隐式调用的，没有办法给它们传递参数。因此，转换操作符不带参数。尽管转换函数没有指定返回值，每一个转换函数必须返回相应的转换类型。</p>
<pre><code><span class="keyword">class</span> SmallInt {
<span class="keyword">public</span>:
    <span class="function"><span class="keyword">int</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>;            <span class="comment">// error: return type</span>
    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">(<span class="keyword">int</span> = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;         <span class="comment">// error: parameter list</span>
    <span class="keyword">operator</span> <span class="keyword">int</span>*() <span class="keyword">const</span> { <span class="keyword">return</span> <span class="number">42</span>; } <span class="comment">// error: 42 is not a pointer</span>
};
<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">(SmallInt&amp;)</span></span>;                 <span class="comment">// error: nonmember</span>
</code></pre><blockquote>
<p><strong>警告</strong><br>避免滥用转换函数。</p>
</blockquote>
<h3 id="转换操作符可以产生惊人的结果">转换操作符可以产生惊人的结果</h3><p>实际上，类很少定义转换操作符。然而一个例外是：类定义转换为bool类型并不罕见。</p>
<pre><code><span class="keyword">int</span> i = <span class="number">42</span>;
<span class="built_in">cin</span> &lt;&lt; i; <span class="comment">// this code would be legal if the conversion to bool were not explicit!</span>
</code></pre><h3 id="explicit转换操作符">explicit转换操作符</h3><p>为了防止前面的问题，新标准引入<strong>explicit</strong>转换。</p>
<pre><code><span class="keyword">class</span> SmallInt {
<span class="keyword">public</span>:
    <span class="comment">// the compiler won't automatically apply this conversion</span>
    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> val; }
};

SmallInt si = <span class="number">3</span>;  <span class="comment">// ok: the SmallInt constructor is not explicit</span>
si + <span class="number">3</span>; <span class="comment">// error: implicit conversion is required, but operator int is explicit</span>
<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(si) + <span class="number">3</span>; <span class="comment">// ok: explicitly request the conversion</span>
</code></pre><p>如果转换操作符是<strong>explicit</strong>的，我们只能通过<strong>cast</strong>来显式转换。一个例外是编译器会在条件测试中应用显式转换：</p>
<ul>
<li><strong>if</strong>，<strong>while</strong>或<strong>do while</strong>条件测试</li>
<li><strong>for</strong>的条件表达式</li>
<li>逻辑非<strong>!</strong>，逻辑与<strong>&amp;&amp;</strong>或逻辑或<strong>||</strong>的操作数</li>
<li>条件运算符<strong>?:</strong>条件测试</li>
</ul>
<h3 id="转换为bool类型">转换为bool类型</h3><p>当我们在条件测试中使用流对象，我们使用定义在IO类型里面的<strong>operator bool</strong>转换操作：</p>
<pre><code><span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; value)
</code></pre><blockquote>
<p><strong>最佳实践</strong><br>通常转换为<strong>bool</strong>是有意用于条件测试的。因此，<strong>operator bool</strong>通常应该定义为<strong>explicit</strong>。</p>
</blockquote>
<h3 id="避免歧义的转换">避免歧义的转换</h3><p>有两种方法会发生多个转换路径的情况。第一个就是当2个类提供了相互的转换。第二个就是定义了多个转换，其转换类型之间也可以转换。</p>
<blockquote>
<p><strong>警告</strong><br>通常，类定义相互转换或定义了多个从算术类型或到算术类型的转换是个坏主意。</p>
</blockquote>
<h4 id="参数匹配和相互转换">参数匹配和相互转换</h4><pre><code><span class="keyword">struct</span> B;
<span class="keyword">struct</span> A {
    A() = <span class="keyword">default</span>;
    A(<span class="keyword">const</span> B&amp;);        <span class="comment">// converts a B to an A</span>
};
<span class="keyword">struct</span> B {
    <span class="function"><span class="keyword">operator</span> <span class="title">A</span>(<span class="params"></span>) <span class="keyword">const</span></span>; <span class="comment">// also converts a B to an A</span>
};

<span class="function">A <span class="title">f</span>(<span class="params"><span class="keyword">const</span> A&amp;</span>)</span>;
B b;
A a = f(b); <span class="comment">// error ambiguous: f(B::operator A())</span>
            <span class="comment">//          or f(A::A(const B&amp;))</span>

A a1 = f(b.<span class="function"><span class="keyword">operator</span> <span class="title">A</span>(<span class="params"></span>))</span>; <span class="comment">// ok: use B's conversion operator</span>
A a2 = f(A(b));           <span class="comment">// ok: use A's constructor</span>
</code></pre><p>需要注意的是我们不能通过<strong>cast</strong>来解决这个二义性，因为<strong>cast</strong>有着一样的歧义。</p>
<h4 id="内置类型的多个转换和歧义">内置类型的多个转换和歧义</h4><pre><code><span class="keyword">struct</span> A {
    A(<span class="keyword">int</span> = <span class="number">0</span>);   <span class="comment">// usually a bad idea to have two</span>
    A(<span class="keyword">double</span>);    <span class="comment">// conversions from arithmetic types</span>
    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>;    <span class="comment">// usually a bad idea to have two</span>
    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// conversions to arithmetic types</span>
};

<span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span>)</span></span>;
A a;
f2(a); <span class="comment">// error ambiguous: f(A::operator int())</span>
       <span class="comment">//          or f(A::operator double())</span>
<span class="keyword">long</span> lg;
<span class="function">A <span class="title">a2</span><span class="params">(lg)</span></span>; <span class="comment">// error ambiguous: A::A(int) or A::A(double)</span>

<span class="keyword">short</span> s = <span class="number">42</span>;
<span class="comment">// promoting short to int is better than converting short to double</span>
<span class="function">A <span class="title">a3</span><span class="params">(s)</span></span>;  <span class="comment">// uses A::A(int)</span>
</code></pre><blockquote>
<p><strong>注意</strong><br>当使用2个用户定义的转换时，如果有标准转换，使用标准转换的级别来选择最佳匹配。</p>
<p>转换和操作符：</p>
<ul>
<li>不要定义类之间的相互转换</li>
<li>避免定义多个到内置算术类型的转换。</li>
</ul>
<p>最简单的规则就是：除了显式转换为<strong>bool</strong>类型外，避免定义转换函数和限制那些看起来对的隐式构造函数。</p>
</blockquote>
<h4 id="重载函数和转换构造函数">重载函数和转换构造函数</h4><pre><code><span class="keyword">struct</span> C {
    C(<span class="keyword">int</span>);
};
<span class="keyword">struct</span> D {
    D(<span class="keyword">int</span>);
};

<span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">(<span class="keyword">const</span> C&amp;)</span></span>;
<span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">(<span class="keyword">const</span> D&amp;)</span></span>;

manip(<span class="number">10</span>); <span class="comment">// error ambiguous: manip(C(10)) or manip(D(10))</span>
manip(C(<span class="number">10</span>)); <span class="comment">// ok: calls manip(const C&amp;)</span>
</code></pre><blockquote>
<p><strong>警告</strong><br>需要频繁地在函数调用中使用构造函数或强制转换来转换参数一个坏设计的表现。</p>
</blockquote>
<h4 id="重载函数和用户定义的转换">重载函数和用户定义的转换</h4><p>在重载函数调用中，如果有2个或更多用户定义的转换提供可行的匹配，转换被认为是一样好。</p>
<pre><code><span class="keyword">struct</span> E {
    E(<span class="keyword">double</span>);
};
<span class="function"><span class="keyword">void</span> <span class="title">manip2</span><span class="params">(<span class="keyword">const</span> C&amp;)</span></span>;
<span class="function"><span class="keyword">void</span> <span class="title">manip2</span><span class="params">(<span class="keyword">const</span> E&amp;)</span></span>;
<span class="comment">// error ambiguous: two different user-defined conversions could be used</span>
manip2(<span class="number">10</span>); <span class="comment">// manip2(C(10) or manip2(E(double(10)))</span>
</code></pre><blockquote>
<p><strong>注意</strong><br>在重载函数调用中，附加的标准转换级别有作用仅当可行函数是同一个用户定义的转换。如果是不同的用户定义的转换，则调用有歧义。</p>
</blockquote>
<h3 id="函数匹配和操作符重载">函数匹配和操作符重载</h3><p>如果a是一个类类型，a sym b表达式可能是：</p>
<pre><code>a.operatorsym<span class="comment">(b)</span>; <span class="comment">// a has operatorsym as a member function</span>
operatorsym<span class="comment">(a, b)</span>; <span class="comment">// operatorsym is an ordinary function</span>
</code></pre><blockquote>
<p><strong>注意</strong><br>在候选函数集中表达式中的操作符可以是成员或非成员函数。</p>
</blockquote>
<pre><code><span class="keyword">class</span> SmallInt {
    <span class="keyword">friend</span> SmallInt <span class="keyword">operator</span>+(<span class="keyword">const</span> SmallInt&amp;, <span class="keyword">const</span> SmallInt&amp;);
<span class="keyword">public</span>:
    SmallInt(<span class="keyword">int</span> = <span class="number">0</span>);                   <span class="comment">// conversion from int</span>
    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> val; } <span class="comment">// conversion to int</span>
<span class="keyword">private</span>:
    <span class="built_in">std</span>::<span class="keyword">size_t</span> val;
};

SmallInt s1, s2;
SmallInt s3 = s1 + s2;  <span class="comment">// uses overloaded operator+</span>
<span class="keyword">int</span> i = s3 + <span class="number">0</span>;         <span class="comment">// error: ambiguous</span>
</code></pre><blockquote>
<p><strong>警告</strong><br>既提供了到算术类型的转换，又重载了相应的算术操作符，可能会导致二义性。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是C++ primer第五版第14章的读书笔记。</p>
<h1 id="基本概念">基本概念</h1><p>重载操作符是具有特殊名字的函数：关键字<strong>operator</strong>后面跟着需要被定义的操作符的符号。像其它函数一样，重载操作符有返回值，参数]]>
    </summary>
    
      <category term="C/C++" scheme="https://opensvn.github.io/tags/C-C/"/>
    
  </entry>
  
</feed>
