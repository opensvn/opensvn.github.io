
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>Pygame第五章 让画面动起来 | opensvn</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="opensvn">
    

    
    <meta name="description" content="这一章描述如何以一种可以预测的方式在屏幕上移动对象，和如何使运动在其他人电脑里面一致。
理解帧率我们需要知道计算机游戏中关于运动的第一件事情就是没有什么东西真正在移动。电脑屏幕或电视机展示给我们一系列图片，当两张图片间隔时间够短时，我们的大脑将这些图片混合在一起从而制造了流畅运动的假象。一张图片称为一帧，FPS(Frame Per Second)是每秒的帧数，也就是帧率。产生流畅运动需要的帧数，因">
<meta property="og:type" content="article">
<meta property="og:title" content="Pygame第五章 让画面动起来">
<meta property="og:url" content="https://opensvn.github.io/2015/11/10/pygame-5/index.html">
<meta property="og:site_name" content="opensvn">
<meta property="og:description" content="这一章描述如何以一种可以预测的方式在屏幕上移动对象，和如何使运动在其他人电脑里面一致。
理解帧率我们需要知道计算机游戏中关于运动的第一件事情就是没有什么东西真正在移动。电脑屏幕或电视机展示给我们一系列图片，当两张图片间隔时间够短时，我们的大脑将这些图片混合在一起从而制造了流畅运动的假象。一张图片称为一帧，FPS(Frame Per Second)是每秒的帧数，也就是帧率。产生流畅运动需要的帧数，因">
<meta property="og:updated_time" content="2015-11-19T06:52:09.672Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Pygame第五章 让画面动起来">
<meta name="twitter:description" content="这一章描述如何以一种可以预测的方式在屏幕上移动对象，和如何使运动在其他人电脑里面一致。
理解帧率我们需要知道计算机游戏中关于运动的第一件事情就是没有什么东西真正在移动。电脑屏幕或电视机展示给我们一系列图片，当两张图片间隔时间够短时，我们的大脑将这些图片混合在一起从而制造了流畅运动的假象。一张图片称为一帧，FPS(Frame Per Second)是每秒的帧数，也就是帧率。产生流畅运动需要的帧数，因">

    
    <link rel="alternative" href="/atom.xml" title="opensvn" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/author.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/author.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/author.jpg" alt="opensvn" title="opensvn"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="opensvn">opensvn</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页 | Home</a></li>
					
						<li><a href="/archives">归档 | Archives</a></li>
					
						<li><a href="/about">关于 | About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:opensvn.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/11/10/pygame-5/" title="Pygame第五章 让画面动起来" itemprop="url">Pygame第五章 让画面动起来</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="opensvn" target="_blank" itemprop="author">opensvn</a>
		
  <p class="article-time">
    <time datetime="2015-11-10T12:21:33.000Z" itemprop="datePublished"> 发表于 2015-11-10</time>
    
  </p>
</header>
	<div class="article-content">
		
		<p>这一章描述如何以一种可以预测的方式在屏幕上移动对象，和如何使运动在其他人电脑里面一致。</p>
<h1 id="理解帧率">理解帧率</h1><p>我们需要知道计算机游戏中关于运动的第一件事情就是<strong>没有什么东西真正在移动</strong>。电脑屏幕或电视机展示给我们一系列图片，当两张图片间隔时间够短时，我们的大脑将这些图片混合在一起从而制造了流畅运动的假象。一张图片称为一帧，FPS(Frame Per Second)是每秒的帧数，也就是帧率。产生流畅运动需要的帧数，因人而异。</p>
<p>游戏的帧率也受限于显示设备的刷新速度。比如，显示器的刷新速度为60HZ，也就是每秒刷新60次。产生帧的速度比刷新速度快会导致“tearing”现象，即下一个帧混进前一个帧。电脑要做的事情越多，帧率就会越慢。好消息是现在的桌面电脑已经足以产生你想要的视觉效果。</p>
<p>只需记住几个常量：一般的电视画面是24FPS；30FPS基本可以给玩家提供流畅的体验了；60FPS是LCD常用的刷新率，所以你的游戏的帧率再高也没什么意义了；在70FPS以上，很少有人能察觉任何提升了！</p>
<h1 id="直线运动">直线运动</h1><pre><code>background_image_filename = <span class="string">'sushiplate.jpg'</span>
sprite_image_filename = <span class="string">'fugu.png'</span>

import pygame
<span class="keyword">from</span> pygame.locals import *
<span class="keyword">from</span> sys import <span class="keyword">exit</span>

pygame.init()

screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

background = pygame.image.load(background_image_filename).convert()
sprite = pygame.image.load(sprite_image_filename)

# The x coordinate <span class="keyword">of</span> our sprite
x = <span class="number">0</span>.

<span class="keyword">while</span> <span class="keyword">True</span>:
    <span class="keyword">for</span> <span class="keyword">event</span> <span class="keyword">in</span> pygame.<span class="keyword">event</span>.get():
        <span class="keyword">if</span> <span class="keyword">event</span>.<span class="keyword">type</span> == QUIT:
            <span class="keyword">exit</span>()

    screen.blit(background, (<span class="number">0</span>, <span class="number">0</span>))
    screen.blit(sprite, (x, <span class="number">100</span>))
    x += <span class="number">10</span>.

    # <span class="keyword">If</span> the image goes off the <span class="keyword">end</span> <span class="keyword">of</span> the screen, move it back
    <span class="keyword">if</span> x &gt; <span class="number">640</span>.:
        x -= <span class="number">640</span>.

    pygame.display.update()
</code></pre><p>这段代码有两个问题，第一个是我们不能精确知道画一张图片到屏幕需要多长时间，另一个问题是这个精灵在配置差的机器上移动慢，在配置好的机器上移动更快。</p>
<h3 id="关于时间">关于时间</h3><p>解决第一个问题的技巧是使运动基于时间。我们需要知道距离上一个帧已经过去多长时间，据此我们能相应地在屏幕上放置任何物体。<strong>pygame.time</strong>模块有一个Clock对象可以用来跟踪时间。使用<strong>pygame.time.Clock()</strong>创建clock对象。</p>
<pre><code>clock = pygame<span class="class">.time</span><span class="class">.Clock</span>()
</code></pre><p>一旦创建了clock对象，你应该每一帧调用一次<strong>tick</strong>函数，返回上次调用该函数已过去的时间，单位毫秒。</p>
<pre><code>time_passed = clock.<span class="function"><span class="title">tick</span><span class="params">()</span></span>
</code></pre><p><strong>tick</strong>函数也接收一个可选参数表示最大帧率。</p>
<pre><code><span class="preprocessor"># Game will run at a maximum <span class="number">30</span> frames per second</span>
time_passed = clock.tick(<span class="number">30</span>)
time_passed_seconds = time_passed / <span class="number">1000.0</span>
</code></pre><p>我们要怎样使用这个time_passed_seconds来移动精灵呢？需要做的第一件事就是选择一个精灵移动的速度。接下来只要用这个速度乘于时间就能得出精灵该移动多远。</p>
<pre><code>background_image_filename = <span class="comment">'sushiplate.jpg'</span>
sprite_image_filename = <span class="comment">'fugu.png'</span>

import pygame
<span class="keyword">from</span> pygame.locals import *
<span class="keyword">from</span> sys import <span class="keyword">exit</span>

pygame.init()

screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

background = pygame.image.load(background_image_filename).convert()
sprite = pygame.image.load(sprite_image_filename)

<span class="preprocessor"># Our clock object</span>
clock = pygame.time.Clock()

<span class="preprocessor"># X coordinate of our sprite</span>
x = <span class="number">0.</span>
<span class="preprocessor"># Speed in pixels per second</span>
speed = <span class="number">250.</span>

<span class="keyword">while</span> <span class="literal">True</span>:
    <span class="keyword">for</span> <span class="keyword">event</span> <span class="keyword">in</span> pygame.<span class="keyword">event</span>.<span class="keyword">get</span>():
        <span class="keyword">if</span> <span class="keyword">event</span>.type == QUIT:
            <span class="keyword">exit</span>()

    screen.blit(background, (<span class="number">0</span>, <span class="number">0</span>))
    screen.blit(sprite, (x, <span class="number">100</span>))

    time_passed = clock.tick()
    time_passed_seconds = time_passed / <span class="number">1000.0</span>

    distance_moved = time_passed_seconds * speed
    x += distance_moved

    <span class="keyword">if</span> x &gt; <span class="number">640.</span>:
        x -= <span class="number">640.</span>

    pygame.display.update()
</code></pre><p>理解帧率和精灵移动速度的不同很重要。</p>
<pre><code>background_image_filename = <span class="string">'sushiplate.jpg'</span>
sprite_image_filename = <span class="string">'fugu.png'</span>

import pygame
<span class="built_in">from</span> pygame.locals import *
<span class="built_in">from</span> sys import exit

pygame.init()

screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

background = pygame.image.<span class="built_in">load</span>(background_image_filename).<span class="built_in">convert</span>()
sprite = pygame.image.<span class="built_in">load</span>(sprite_image_filename)

<span class="comment"># Our clock object</span>
clock = pygame.<span class="built_in">time</span>.Clock()

x1 = <span class="number">0.</span>
x2 = <span class="number">0.</span>
<span class="comment"># Speed in pixels per second</span>
speed = <span class="number">250.</span>

frame_no = <span class="number">0</span>

<span class="keyword">while</span> True:
    <span class="keyword">for</span> event <span class="operator">in</span> pygame.event.<span class="built_in">get</span>():
        <span class="keyword">if</span> event.type == QUIT:
            exit()

    screen.blit(background, (<span class="number">0</span>, <span class="number">0</span>))
    screen.blit(sprite, (x1, <span class="number">50</span>))
    screen.blit(sprite, (x2, <span class="number">250</span>))

    time_passed = clock.<span class="built_in">tick</span>(<span class="number">30</span>)
    time_passed_seconds = time_passed / <span class="number">1000.0</span>

    distance_moved = time_passed_seconds * speed
    x1 += distance_moved

    <span class="keyword">if</span> frame_no % <span class="number">5</span> == <span class="number">0</span>:
        distance_moved = time_passed_seconds * speed
        x2 += distance_moved * <span class="number">5</span>

    <span class="comment"># If the image goes off the end of the screen, move it back</span>
    <span class="keyword">if</span> x1 &gt; <span class="number">640.</span>:
        x1 -= <span class="number">640.</span>
    <span class="keyword">if</span> x2 &gt; <span class="number">640.</span>:
        x2 -= <span class="number">640.</span>

    pygame.display.update()
    frame_no += <span class="number">1</span>
</code></pre><h3 id="斜线运动">斜线运动</h3><p>直线运动很有用，但是一个游戏如果所有物体都水平或垂直移动看起来就很笨。我们需要能够在任何方向移动精灵。可以通过调整每个帧的x和y坐标做到。</p>
<pre><code>background_image_filename = <span class="symbol">'sushiplate</span>.jpg'
sprite_image_filename = <span class="symbol">'fugu</span>.png'

import pygame
from pygame.locals import *
from sys import exit

pygame.init<span class="literal">()</span>

screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

background = pygame.image.load(background_image_filename).convert<span class="literal">()</span>
sprite = pygame.image.load(sprite_image_filename).convert_alpha<span class="literal">()</span>

clock = pygame.time.<span class="type">Clock</span><span class="literal">()</span>

x, y = <span class="number">100.</span>, <span class="number">100.</span>
speed_x, speed_y = <span class="number">133.</span>, <span class="number">170.</span>

<span class="keyword">while</span> <span class="type">True</span>:
    for event <span class="keyword">in</span> pygame.event.get<span class="literal">()</span>:
        <span class="keyword">if</span> event.<span class="keyword">type</span> == <span class="type">QUIT</span>:
            exit<span class="literal">()</span>

    screen.blit(background, (<span class="number">0</span>, <span class="number">0</span>))
    screen.blit(sprite, (x, y))

    time_passed = clock.tick(<span class="number">30</span>)
    time_passed_seconds = time_passed / <span class="number">1000.0</span>

    x += speed_x * time_passed_seconds
    y += speed_y * time_passed_seconds

    # <span class="type">If</span> the sprite goes off the edge <span class="keyword">of</span> the screen,
    # make it move <span class="keyword">in</span> the opposite direction
    <span class="keyword">if</span> x &gt; <span class="number">640</span> - sprite.get_width<span class="literal">()</span>:
        speed_x = -speed_x
        x = <span class="number">640</span> - sprite.get_width<span class="literal">()</span>
    elif x &lt; <span class="number">0</span>:
        speed_x = -speed_x
        x = <span class="number">0</span>

    <span class="keyword">if</span> y &gt; <span class="number">480</span> - sprite.get_height<span class="literal">()</span>:
        speed_y = -speed_y
        y = <span class="number">480</span> - sprite.get_height<span class="literal">()</span>
    elif y &lt; <span class="number">0</span>:
        speed_y = -speed_y
        y = <span class="number">0</span>

    pygame.display.update<span class="literal">()</span>
</code></pre><p>为了达到反弹的效果，我们首先必须检查是否撞击到边缘。在坐标上做点简单的算术就行。如果x坐标小于0，则我们超过了屏幕的左边缘。如果x加上精灵的宽度比屏幕的宽度大，则精灵的右边缘超过屏幕的宽度。y坐标的判断类似，只是使用高度而不是宽度。</p>
<h1 id="探索向量">探索向量</h1><p>游戏开发者从数学借来向量并用到很多领域，比如2D和3D游戏。向量和点类似，它们都有x和y值(在2D中)，但是用途不一样。一个点的坐标(10, 20)在屏幕上总是同一个位置，而一个向量(10, 20)意思是从当前位置x坐标加上10，y坐标加上20。因此你可以认为一个点的坐标就是从原点(0, 0)到该点的向量。</p>
<h3 id="创建向量">创建向量</h3><p>你可以从任意2个点计算向量，只要用第二个点坐标减去第一个点坐标。比如点A(10, 20)，点B(30, 35)，则向量AB就是(20, 15)。这个向量告诉我们从A到B需要在x方向移动20个单位，在y方向移动15个单位。</p>
<h3 id="存储向量">存储向量</h3><p>在Python里面没有内置的向量类型，但是你可以将向量存入list，或者自己定义向量类。方便起见，我们选择定义自己的向量类。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Vector2</span><span class="params">(object)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x=<span class="number">0.0</span>, y=<span class="number">0.0</span>)</span>:</span>
        self.x = x
        self.y = y

    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>
        <span class="keyword">return</span> <span class="string">'(%s, %s)'</span> % (self.x, self.y)

<span class="decorator">    @classmethod</span>
    <span class="function"><span class="keyword">def</span> <span class="title">from_points</span><span class="params">(cls, P1, P2)</span>:</span>
        <span class="keyword">return</span> cls(P2[<span class="number">0</span>] - P1[<span class="number">0</span>], P2[<span class="number">1</span>] - P1[<span class="number">1</span>])
</code></pre><p><code>@classmethod</code>装饰使函数from_points变成一个类方法。类方法是通过类调用的，不是通过类实例调用，比如Vector2.from_points(P1, P2)。将from_points定义为一个类方法是因为它创建一个新的Vector2对象，而不是修改已经存在的对象。</p>
<h3 id="向量大小">向量大小</h3><p>从A到B的向量大小就是2个点之间的距离。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">get_magnitude</span><span class="params">(self)</span>:</span>
    <span class="keyword">return</span> math.sqrt(self.x ** <span class="number">2</span> + self.y ** <span class="number">2</span>)
</code></pre><h3 id="单位向量">单位向量</h3><p>向量实际描述了两件事情：大小和方向。通常这两个信息绑定在一个向量里面，但有时候你只需其中一个。有一种特殊的向量叫单位向量，它的大小总是为1。我们可以把任意向量缩放到一个单位向量，这叫向量的规格化。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">normalize</span><span class="params">(self)</span>:</span>
    magnitude = self.get_magnitude()
    self.x /= magnitude
    self.y /= magnitude
</code></pre><h3 id="向量加法">向量加法</h3><p>向量加法是将两个向量组合产生一个向量，它有两个向量组合的效果。也就是AC=AB+BC。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, rhs)</span>:</span>
    <span class="keyword">return</span> Vector2(self.x + rhs.x, self.y + rhs.y)
</code></pre><h3 id="向量减法">向量减法</h3><p>向量减法和加法类似。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">__sub__</span><span class="params">(self, rhs)</span>:</span>
    <span class="keyword">return</span> Vector2(self.x - rhs.x, self.y - rhs.y)
</code></pre><h3 id="否定向量">否定向量</h3><p>如果想要改变向量的方向，使向量AB变成向量BA，需要将向量每个元素都改变符号。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">__neg__</span><span class="params">(self)</span>:</span>
    <span class="keyword">return</span> Vector2(-self.x, -self.y)
</code></pre><h3 id="向量乘法和除法">向量乘法和除法</h3><p>将一个向量乘于或除于一个系数(数字)，效果是改变向量的大小。如果向量乘于一个整数，则产生同一方向的向量，如果乘于一个负数，则产生相反方向的向量。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, scalar)</span>:</span>
    <span class="keyword">return</span> Vector2(self.x * scalar, self.y * scalar)

<span class="function"><span class="keyword">def</span> <span class="title">__div__</span><span class="params">(self, scalar)</span>:</span>
    <span class="keyword">return</span> Vector2(self.x / scalar, self.y / scalar)
</code></pre><blockquote>
<p><strong>注意</strong> 向量乘于向量也是可以的，但是在游戏中不常用，你可能永远都不需要它。</p>
</blockquote>
<p>向量乘法如何使用呢？基于时间把向量分解为很多步，向量乘法很有用。如果我们知道从A到B需要10秒，我们可以计算出每一秒我们到达的坐标。</p>
<pre><code>A = (<span class="number">10.0</span>, <span class="number">20.0</span>)
B = (<span class="number">30.0</span>, <span class="number">35.0</span>)
AB = Vector2.from_points(A, B)
step = AB * <span class="number">.1</span>
<span class="keyword">position</span> = Vector2(A.x, A.y)
for n <span class="type">in</span> <span class="built_in">range</span>(<span class="number">10</span>):
    <span class="keyword">position</span> += step
    <span class="built_in">print</span> <span class="keyword">position</span>
</code></pre><p>当在两个点之间移动，计算中间位置是基本的。你还可以用向量计算在重力，外部作用力和摩擦力作用下很多种现实的运动。</p>
<h3 id="游戏对象向量类">游戏对象向量类</h3><p>作者已经写了一个二维向量类作为游戏对象的一部分。</p>
<pre><code>from gameobjects.vector2 import *
A = (<span class="number">10.0</span>, <span class="number">20.0</span>)
B = (<span class="number">30.0</span>, <span class="number">35.0</span>)
AB = Vector2.from_points(A, B)
print <span class="string">"Vector AB is"</span>, AB
print <span class="string">"AB * 2 is"</span>, AB * <span class="number">2</span>
print <span class="string">"AB / 2 is"</span>, AB / <span class="number">2</span>
print <span class="string">"AB + (-10, 5) is"</span>, AB + (-<span class="number">10</span>, <span class="number">5</span>)
print <span class="string">"Magnitude of AB is"</span>, AB.get_magnitude()
print <span class="string">"AB normalized is"</span>, AB.get_normalized()
</code></pre><h1 id="使用向量创建运动">使用向量创建运动</h1><p>既然我们了解了向量，我们可以使用它以多种方式移动游戏角色，而且可以实现简单的，基于力学的物理现象，使得游戏更加可信。</p>
<h3 id="斜线运动-1">斜线运动</h3><p>让我们使用向量创建更加精确的斜线运动。</p>
<pre><code>background_image_filename = <span class="string">'sushiplate.jpg'</span>
sprite_image_filename = <span class="string">'fugu.png'</span>

from sys <span class="keyword">import</span> exit
<span class="keyword">import</span> pygame
from pygame.locals <span class="keyword">import</span> *
from gameobjects.vector2 <span class="keyword">import</span> Vector2

pygame.init()

screen = pygame.display.set_mode((<span class="number">640</span>, <span class="number">480</span>), <span class="number">0</span>, <span class="number">32</span>)

background = pygame.image.load(background_image_filename).convert()
sprite = pygame.image.load(sprite_image_filename).convert_alpha()

clock = pygame.time.Clock()

position = Vector2(<span class="number">100.0</span>, <span class="number">100.0</span>)
speed = <span class="number">250</span>
heading = Vector2()

<span class="keyword">while</span> True:
    <span class="keyword">for</span> event in pygame.event.<span class="keyword">get</span>():
        <span class="keyword">if</span> event.type == QUIT:
            exit()
        <span class="keyword">if</span> event.type == MOUSEBUTTONDOWN:
            destination = Vector2(*event.pos) - Vector2(*sprite.get_size()) / 2.
            heading = Vector2.from_points(position, destination)
            heading.normalize()

        screen.blit(background, (0, 0))
        screen.blit(sprite, position)

        time_passed = clock.tick()
        time_passed_seconds = time_passed / 1000.0

        distance_moved = time_passed_seconds * speed
        position += heading * distance_moved
        pygame.display.update()
</code></pre><p>目的坐标的计算需要解释一下。星号(<code>*</code>)用在函数的参数时，扩展为一个元组或列表。因此Vector2(*event.pos)相当于Vector2(event.pos[0], event.pos[1])。</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/Pygame/">Pygame</a><a href="/tags/Python/">Python</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://opensvn.github.io/2015/11/10/pygame-5/" data-title="Pygame第五章 让画面动起来 | opensvn" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/11/16/pygame-6/" title="Pygame第六章 接受用户输入">
  <strong>上一篇：</strong><br/>
  <span>
  Pygame第六章 接受用户输入</span>
</a>
</div>


<div class="next">
<a href="/2015/11/10/colleague/"  title="整理代码片段">
 <strong>下一篇：</strong><br/> 
 <span>整理代码片段
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2015/11/10/pygame-5/" data-title="Pygame第五章 让画面动起来" data-url="https://opensvn.github.io/2015/11/10/pygame-5/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  

  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Python/" title="Python">Python<sup>12</sup></a></li>
			
		
			
				<li><a href="/tags/PyQt/" title="PyQt">PyQt<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Pygame/" title="Pygame">Pygame<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/C/" title="C++">C++<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Markdown/" title="Markdown">Markdown<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Project-Euler/" title="Project Euler">Project Euler<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo/" title="Hexo">Hexo<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Linux/" title="Linux">Linux<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/C/" title="C">C<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello, I&#39;m opensvn. <br/>
			Try to do better.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/opensvn" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2015 
		
		<a href="/about" target="_blank" title="opensvn">opensvn</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
        getSize();
        if (myWidth >= 1024) {
          c.click();
        }
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"opensvn"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F86bb0f34aeafce8b9262f5000b269d72' type='text/javascript'%3E%3C/script%3E"));
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
