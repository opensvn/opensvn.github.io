---
layout: post
title: 第2章 变量和基本类型
date: 2016-03-21 20:27:17
categories: C++
excerpt: 这是C++ primer第五版第2章的读书笔记。
---

有几种字符类型，大多数是为了支持国际化而存在。wchar_t，char16_t和char32_t用于扩展字符集。wchar_t保证可以存放机器最大扩展字符集中任意字符。char16_t和char32_t被用于Unicode字符。

新标准引入了long long类型。

**建议：决定使用哪种类型

* 当你知道值不可能是负的时，使用unsigned类型
* 使用int做整形运算。short通常太小，long通常和int一样大小。如果超过int范围，则使用long long。
* 在算术表达式中不要使用char或bool。
* 使用double做浮点计算。float通常精度不够，而且计算double的开销与float相比可以忽略。

# 2.1.2 类型转换

> **注意：不要混合使用signed和unsigned类型
> 需要记住signed值自动转换为unsigned值。

# 2.1.3 字面值

{% highlight cpp %}
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
{% endhighlight %}

新标准引入花括号作为普遍使用的初始化方式。这种初始化方式称为列表初始化。

当使用内置类型的变量时，列表初始化有一个重要的性质：编译器不允许列表初始化内置类型，如果初始化会导致精度损失。

{% highlight cpp %}
long double ld = 3.1415926536;
int a{ld}, b = {ld}; // error: narrowing conversion required
int c(ld), d = ld;   // ok: but value will be truncated
{% endhighlight %}

新标准下，我们可以为数据成员提供类内初始值（in-class initializer）。当我们创建对象时，类内初始值被用来初始化数据成员。没有初始值的成员默认初始化。

# 2.3 复合类型

符合类型是其它类型定义的类型。指针和引用就是复合类型。

{% highlight cpp %}
int *p1 = nullptr; // equivalent to int *p1 = 0;
int *p2 = 0;       // directly initializes p2 from the literal constant 0
// must #include cstdlib
int *p3 = NULL;    // equivalent to int *p3 = 0;
{% endhighlight %}

常量表达式是一个值不能改变且能在编译期间计算出值的表达式。

constexpr变量
由constexpr声明的变量隐式为const并且必须由常量表达式初始化。

指针和constexpr

当我们在constexpr声明中定义一个指针时，constexpr指示符应用到指针，而不是指针指向的对象。

const int *p = nullptr;     // p is a pointer to a const int
constexpr int *q = nullptr; // q is a const pointer to int

constexpr产生一个top-level const。


# 2.5 处理类型

## 2.5.1 类型别名

传统上我们使用typedef定义类型别名

{% highlight cpp %}
const int *p = nullptr;     // p is a pointer to a const int
constexpr int *q = nullptr; // q is a const pointer to int
{% endhighlight %}

C++11引入另一种定义类型别名的方法。别名声明。

{% highlight cpp %}
using SI = Sales_item;  // SI is a synonym for Sales_item

typedef char *pstring;
const pstring cstr = 0; // cstr is a constant pointer to char
const pstring *ps;      // ps is a pointer to a constant pointer to char
{% endhighlight %}

## 2.5.2 auto类型限定符

auto告诉编译器从初始值推导出类型。这暗示了使用auto的变量必须有一个初始值。

auto item = val1 + val2;
auto i = 0, *p = &i;      // ok: i is int and p is a pointer to int
auto sz = 0, pi = 3.14;   // error: inconsistent types for sz and pi

### 复合类型，const和auto

int i = 0, &r = i;
auto a = r;  // a is an int (r is an alias for i, which has type int)

auto一般忽略top-level const。low-level const保留。

const int ci = i, &cr = ci;
auto b = ci;  // b is an int (top-level const in ci is dropped)
auto c = cr;  // c is an int (cr is an alias for ci whose const is top-level)
auto d = &i;  // d is an int*(& of an int object is int*)
auto e = &ci; // e is const int*(& of a const object is low-level const)

如果想要推导的类型有top-level const，必须显式指定
const auto f = ci; // deduced type of ci is int; f has type const int

我们也可以指定自动推导的类型为引用。

auto &g = ci;       // g is a const int& that is bound to ci
auto &h = 42;       // error: we can't bind a plain reference to a literal
const auto &j = 42; // ok: we can bind a const reference to a literal

auto k = ci, &l = i;    // k is int; l is int&
auto &m = ci, *p = &ci; // m is a const int&;p is a pointer to const int
// error: type deduced from i is int; type deduced from &ci is const int
auto &n = i, *p2 = &ci;


## 2.5.3 decltype类型说明符

{% highlight cpp %}
decltype(f()) sum = x; // sum has whatever type f returns
{% endhighlight %}

decltype处理top-level const和引用的方式和auto有着微妙的区别。当给变量应用
decltype时，decltype返回这个变量的类型，包括top-level const和引用。

{% highlight cpp %}
const int ci = 0, &cj = ci;
decltype(ci) x = 0; // x has type const int
decltype(cj) y = x; // y has type const int& and is bound to x
decltype(cj) z;     // error: z is a reference and must be initialized
{% endhighlight %}

### decltype和引用

当我们应用decltype到非变量的表达式时，我们得到表达式产生的类型。decltype返回一个引用当表达式产生可以作为左值的对象时。

{% highlight cpp %}
int i = 42, *p = &i, &r = i;
decltype(r + 0) b;  // ok: addition yields an int; b is an (uninitialized) int
decltype(*p) c;     // error: c is int& and must be initialized

// decltype of a parenthesized variable is always a reference
decltype((i)) d;    // error: d is int& and must be initialized
decltype(i) e;      // ok: e is an (uninitialized) int
{% endhighlight %}

类内初始值 被限制于只能用在花括号里面或等号后面，不能使用圆括号。
头文件通常包含在任意文件里面只能定义一次的实体，比如类定义，const和constexpr变量。
