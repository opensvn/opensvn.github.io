---
layout: post
title: 第12章 动态内存
date: 2016-10-28 14:46:23
categories: C++
excerpt: 这是C++ primer第五版第12章的读书笔记。本章介绍了智能指针和动态数组。
---

全局对象在程序启动时分配内存，在程序结束时销毁。局部对象在其定义的块中创建和销毁。静态局部对象在程序启动时创建，在程序结束时销毁。动态分配的对象一直存在直到被显式释放。

静态内存用来存储静态局部对象，类静态成员和全局对象。栈内存用于定义在函数内的非静态对象。静态内存和栈内存分配的对象由编译器自动创建和销毁。栈对象只当其定义的块在执行时存在。静态对象在被使用之前已经创建，当程序结束时销毁。

除了静态内存和栈内存，每一个程序还有一个自由存储区或叫堆。程序使用堆来动态创建对象。由程序控制动态对象的生命周期。必须显式销毁不再需要的动态对象。

## 12.1 动态内存和智能指针

C++使用`new`和`delete`来管理动态内存。`new`在堆上分配并初始化一个对象，返回指向该对象的指针。`delete`使用指向一个动态对象的指针，销毁该对象，释放相关的内存。

新标准定义了2种智能指针。`shared_ptr`允许多个指针指向同一个对象，`unique_ptr`独占其指向的对象。新标准还定义了一个`weak_ptr`，它是`shared_ptr`管理对象的一个弱引用。这3个都定义在**memory**头文件中。

### 12.1.1 shared_ptr类

和`vector`一样，智能指针是模板。因此当创建智能指针时，需要提供指向的类型信息：

{% highlight cpp %}
shared_ptr<string> p1;    // shared_ptr that can point at a string
shared_ptr<list<int>> p2; // shared_ptr that can point at a list of ints
{% endhighlight %}

默认初始化的智能指针保存一个空指针。智能指针的用法和普通指针类似。解引用智能指针返回所指向的对象，当在条件中使用智能指针时，其效果是测试指针是否为空：

{% highlight cpp %}
// if p1 is not null, check whether it's the empty string
if (p1 && p1->empty())
    *p1 = "hi";  // if so, dereference p1 to assign a new value to that string
{% endhighlight %}

下面是`shared_ptr`和`unique_ptr`共有的操作：

|操作|说明|
|:--|:--|
|shared_ptr<T> sp|指向T的空指针|
|unique_ptr<T> up|指向T的空指针|
|p|使用p作为条件，如果p指向对象则为true|
|*p|解引用p获得p指向的对象|
|p->mem|等同于(*p).mem|
|p.get()|返回p维护的底层指针。小心使用，返回的指针指向的对象可能被智能指针删除|
|swap(p, q)|交换p和q的底层指针|
|p.swap(q)|同上|

特定于`shared_ptr`的操作：

|操作|说明|
|:--|:--|
|make_shared<T>(args)|返回指向动态创建的T类型对象的shared_ptr。使用args初始化该对象|
|shared_ptr<T> p(q)|p是q的一个拷贝，增加q的引用计数。q包含的指针必须能转换成T*|
|p = q|p和q包含的指针可以转换为另一个。减少p的引用计数，增加q的引用计数。如果p的引用计数为0，删除p指向的对象|
|p.unique()|如果p.use_count()为1，返回true，否则返回false|
|p.use_count()|返回引用计数的个数。可能是一个慢操作，主要用于调试|

**make_shared**函数

分配和使用动态内存最安全的方式是调用`make_shared`库函数。它定义在**memory**头文件中，是一个函数模板。这个函数在堆上分配和初始化一个对象并返回指向该对象的`shared_ptr`：

{% highlight cpp %}
// shared_ptr that points to an int with value 42
shared_ptr<int> p3 = make_shared<int>(42);
// p4 points to a string with value 9999999999
shared_ptr<string> p4 = make_shared<string>(10, '9');
// p5 points to an int that is value initialized (§ 3.3.1 (p. 98)) to 0
shared_ptr<int> p5 = make_shared<int>();
{% endhighlight %}

和顺序容器的`emplace`成员函数一样，`make_shared`使用其参数构造一个指定类型的对象。如果不传任何参数，则对象被值初始化。当然通常使用`auto`简化定义保存`make_shared`返回值的对象：

{% highlight cpp %}
// p6 points to a dynamically allocated, empty vector<string>
auto p6 = make_shared<vector<string>>();
{% endhighlight %}

**复制和赋值shared_ptr**

当复制或赋值一个`shared_ptr`时，每一个`shared_ptr`跟踪指向同一个对象的`shared_ptr`的个数：

{% highlight cpp %}
auto p = make_shared<int>(42); // object to which p points has one user
auto q(p); // p and q point to the same object
           // object to which p and q point has two users
{% endhighlight %}

引用计数增加的场景：
* 复制一个`shared_ptr`
* 赋值操作符右边的操作数
* 传值方式传递给函数参数
* 从函数通过值返回

引用计数减少的场景：
* 赋值操作符左边的操作数
* `shared_ptr`本身被销毁

当引用计数为0时，`shared_ptr`自动销毁它管理的对象：

{% highlight cpp %}
auto r = make_shared<int>(42); // int to which r points has one user
r = q;  // assign to r, making it point to a different address
        // increase the use count for the object to which q points
    　　// reduce the use count of the object to which r had pointed
　　　　// the object r had pointed to has no users; that object is automatically　freed
{% endhighlight %}

> **注解**
> 是否使用计数器或其他数据结构来跟踪有多少个指针共享状态取决于实现。关键点是`shared_ptr`类跟踪有多少个`shared_ptr`指针指向相同对象并在合适的时候自动释放该对象。

`shared_ptr`的析构函数减少指向对象的引用计数，当引用计数为0时，`shared_ptr`析构函数销毁指向的对象并释放内存。

> **注解**
> 如果将`shared_ptr`放进容器，记得删除不需要的`shared_ptr`元素以释放内存。

