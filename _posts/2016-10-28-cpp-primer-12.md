---
layout: post
title: 第12章 动态内存
date: 2016-10-28 14:46:23
categories: C++
excerpt: 这是C++ primer第五版第12章的读书笔记。本章介绍了智能指针和动态数组。
---

静态内存用来存储静态局部对象，类静态成员和全局对象。栈内存用于定义在函数内的非静态对象。静态内存和栈内存分配的对象由编译器自动创建和销毁。栈对象只当其定义的块在执行时存在。静态对象在被使用之前已经创建，当程序结束时销毁。

除了静态内存和栈内存，每一个程序还有一个自由存储区或叫堆。程序使用堆来动态创建对象。由程序控制动态对象的生命周期。必须显式销毁不再需要的动态对象。

## 12.1 动态内存和智能指针

C++使用`new`和`delete`来管理动态内存。`new`在堆上分配并初始化一个对象，返回指向该对象的指针。`delete`使用指向一个动态对象的指针，销毁该对象，释放相关的内存。

新标准定义了2种智能指针。`shared_ptr`允许多个指针指向同一个对象，`unique_ptr`独占其指向的对象。新标准还定义了一个`weak_ptr`，它是`shared_ptr`管理对象的一个弱引用。这3个都定义在**memory**头文件中。

### 12.1.1 shared_ptr类

和`vector`一样，智能指针是模板。因此当创建智能指针时，需要提供指向的类型信息：

{% highlight cpp %}
shared_ptr<string> p1;    // shared_ptr that can point at a string
shared_ptr<list<int>> p2; // shared_ptr that can point at a list of ints
{% endhighlight %}

默认初始化的智能指针保存一个空指针。智能指针的用法和普通指针类似。解引用智能指针返回所指向的对象，当在条件中使用智能指针时，其效果是测试指针是否为空：

{% highlight cpp %}
// if p1 is not null, check whether it's the empty string
if (p1 && p1->empty())
    *p1 = "hi";  // if so, dereference p1 to assign a new value to that string
{% endhighlight %}

下面是`shared_ptr`和`unique_ptr`共有的操作：

|操作|说明|
|:--|:--|
|shared_ptr&lt;T&gt; sp<br>unique_ptr&lt;T&gt; up|指向T的空指针|
|p|使用p作为条件，如果p指向对象则为true|
|*p|解引用p获得p指向的对象|
|p->mem|等同于(*p).mem|
|p.get()|返回p维护的底层指针。小心使用，返回指针指向的对象可能被智能指针删除|
|swap(p, q)|交换p和q的底层指针|
|p.swap(q)|同上|

特定于`shared_ptr`的操作：

|操作|说明|
|:--|:--|
|make_shared&lt;T&gt;(args)|返回指向动态创建的T类型对象的shared_ptr，使用args初始化该对象|
|shared_ptr&lt;T&gt; p(q)|p是q的一个拷贝，增加q的引用计数。q包含的指针必须能转换成T*|
|p = q|p和q包含的指针可以转换为另一个。减少p的引用计数，增加q的引用计数。如果p的引用计数为0，删除p指向的对象|
|p.unique()|如果p.use_count()为1，返回true，否则返回false|
|p.use_count()|返回引用计数的个数。可能是一个慢操作，主要用于调试|

**make_shared**函数

分配和使用动态内存最安全的方式是调用`make_shared`库函数。它定义在**memory**头文件中，是一个函数模板。这个函数在堆上分配和初始化一个对象并返回指向该对象的`shared_ptr`：

{% highlight cpp %}
// shared_ptr that points to an int with value 42
shared_ptr<int> p3 = make_shared<int>(42);
// p4 points to a string with value 9999999999
shared_ptr<string> p4 = make_shared<string>(10, '9');
// p5 points to an int that is value initialized (§ 3.3.1 (p. 98)) to 0
shared_ptr<int> p5 = make_shared<int>();
{% endhighlight %}

和顺序容器的`emplace`成员函数一样，`make_shared`使用其参数构造一个指定类型的对象。如果不传任何参数，则对象被值初始化。当然通常使用`auto`可以简化`make_shared`返回指针的定义：

{% highlight cpp %}
// p6 points to a dynamically allocated, empty vector<string>
auto p6 = make_shared<vector<string>>();
{% endhighlight %}

**复制和赋值shared_ptr**

当复制或赋值一个`shared_ptr`时，每一个`shared_ptr`跟踪指向同一个对象的`shared_ptr`的个数：

{% highlight cpp %}
auto p = make_shared<int>(42); // object to which p points has one user
auto q(p); // p and q point to the same object
           // object to which p and q point has two users
{% endhighlight %}

引用计数增加的场景：
* 复制一个`shared_ptr`
* 赋值操作符右边的操作数
* 传值方式传递给函数参数
* 从函数通过值返回

引用计数减少的场景：
* 赋值操作符左边的操作数
* `shared_ptr`本身被销毁

当引用计数为0时，`shared_ptr`自动销毁它管理的对象：

{% highlight cpp %}
auto r = make_shared<int>(42); // int to which r points has one user
r = q;  // assign to r, making it point to a different address
        // increase the use count for the object to which q points
    　　// reduce the use count of the object to which r had pointed
　　　　// the object r had pointed to has no users; that object is automatically　freed
{% endhighlight %}

> **注解**
> 是否使用计数器或其他数据结构来跟踪有多少个指针共享状态取决于实现。关键点是`shared_ptr`类跟踪有多少个`shared_ptr`指针指向相同对象并在合适的时候自动释放该对象。

`shared_ptr`的析构函数减少指向对象的引用计数。当引用计数为0时，`shared_ptr`析构函数销毁指向的对象并释放内存。

> **注解**
> 如果将`shared_ptr`放进容器，记得删除不需要的`shared_ptr`元素以释放内存。

**拥有动态生命周期资源的类**

程序倾向于使用动态内存的3个目的：
1. 不知道需要多少个对象
2. 不知道所需对象的准确类型
3. 想要在多个对象之间共享数据

**定义StrBlob类**

实现一个新的集合类型最简单的方法是使用一个标准库容器管理元素。

{% highlight cpp %}
class StrBlob {
public:
    typedef std::vector<std::string>::size_type size_type;
    StrBlob();
    StrBlob(std::initializer_list<std::string> il);
    size_type size() const { return data->size(); }
    bool empty() const { return data->empty(); }
    // add and remove elements
    void push_back(const std::string&t) {data->push_back(t);}
    void pop_back();
    // element access
    std::string& front();
    std::string& back();
private:
    std::shared_ptr<std::vector<std::string>> data;
    // throws msg if data[i] isn't valid
    void check(size_type i, const std::string &msg) const;
};
{% endhighlight %}

### 12.1.2 直接管理内存

C++定义了2个操作符管理内存。`new`分配内存，`delete`释放由`new`分配的内存。使用`new`和`delete`直接管理内存容易出错，而且直接管理内存的类不能依赖默认定义的复制，赋值和析构成员函数。

**使用new动态分配和初始化对象**

动态分配的对象默认初始化，这意味着内置类型或组合类型的值未定义，类对象的值由默认构造函数初始化。

{% highlight cpp %}
string *ps = new string;  // initialized to empty string
int *pi = new int;        // pi points to an uninitialized int
{% endhighlight %}

可以直接初始化动态分配的对象，可以使用传统的()，也可以使用新标准的列表初始化{}

{% highlight cpp %}
int *pi = new int(1024); // object to which pi points has value 1024
string *ps = new string(10, '9');   // *ps is "9999999999"
// vector with ten elements with values from 0 to 9
vector<int> *pv = new vector<int>{0,1,2,3,4,5,6,7,8,9};
{% endhighlight %}

也可以值初始化动态对象，通过类型名加一对空括号：

{% highlight cpp %}
string *ps1 = new string;  // default initialized to the empty string
string *ps = new string(); // value initialized to the empty string
int *pi1 = new int;        // default initialized; *pi1 is undefined
int *pi2 = new int();      // value initialized to 0; *pi2 is 0
{% endhighlight %}

> 最佳实践
> 和初始化变量的原因一样，最好初始化动态分配的对象

**C++11**：当在括号里面提供初始值时，可以使用`auto`推导出我们要分配的对象。由于编译器使用初始值的类型推导要动态分配的对象类型，因此`auto`只能使用括号初始化，新分配的对象用括号里面的值初始化：

{% highlight cpp %}
auto p1 = new auto(obj);   // p points to an object of the type of obj
                           // that object is initialized from obj
auto p2 = new auto{a,b,c}; // error: must use parentheses for the initializer
{% endhighlight %}

**动态分配的const对象**

使用`new`动态分配const对象合法：

{% highlight cpp %}
// allocate and initialize a const int
const int *pci = new const int(1024);
// allocate a default-initialized const empty string
const string *pcs = new const string;
{% endhighlight %}

**内存耗尽**

如果`new`不能分配内存，默认抛出`bad_alloc`异常。可以使用另一种形式的`new`阻止抛出异常：

{% highlight cpp %}
// if allocation fails, new returns a null pointer
int *p1 = new int; // if allocation fails, new throws std::bad_alloc
int *p2 = new (nothrow) int; // if allocation fails, new returns a null pointer
{% endhighlight %}

这种形式的`new`称为**placement new**。**placement new**表达式允许传递额外的参数给`new`。我们传递标准库定义的`nothrow`对象给`new`，告诉`new`不能抛出异常。如果`new`不能分配内存，则返回空指针。`bad_alloc`和`nothrow`都定义在头文件**new**中。

**释放动态内存**

delete销毁指针指向的对象，并释放相应的内存。传给delete的指针必须是指向动态分配的内存的指针或者是空指针。删除非new返回的指针或删除同一个指针多次是未定义的：

{% highlight cpp %}
int i, *pi1 = &i, *pi2 = nullptr;
double *pd = new double(33), *pd2 = pd;
delete i;   // error: i is not a pointer
delete pi1; // undefined: pi1 refers to a local
delete pd;  // ok
delete pd2; // undefined: the memory pointed to by pd2 was already freed
delete pi2; // ok: it is always ok to delete a null pointer
{% endhighlight %}

**警告：动态内存管理是容易出错的**

1. 忘记释放内存。
2. 使用一个已被释放的对象。
3. 同一片内存释放2次。

**删除时重置指针值**

当删除一个指针时，指针就无效了。尽管指针无效，在多数机器上指针还是保存了被释放内存的地址，即指针成为所谓的**悬垂指针**。悬垂指针拥有未初始化指针的所有问题。可以将`nullptr`赋值给被删除的指针，清晰地指明指针不指向任何对象。

删除时重置指针值只提供有限的保护。如果多个指针指向同一个对象，重置被删除的那个指针值并不影响其他指针。

### 12.1.3 用new使用shared_ptr

可以使用`new`返回的指针初始化智能指针：

{% highlight cpp %}
shared_ptr<double> p1; // shared_ptr that can point at a double
shared_ptr<int> p2(new int(42)); // p2 points to an int with value 42
{% endhighlight %}

其他定义和改变shared_ptr的方式：

|操作|说明|
|:--|:--|
|shared_ptr&lt;T&gt; p(q)|p管理内置指针q指向的对象，q必须是new返回的指针且能转换为T*|
|shared_ptr&lt;T&gt; p(u)|p从unique_ptr指针u接管所有权，使u变成nullptr|
|shared_ptr&lt;T&gt; p(q, d)|p接管内置指针q所指向的对象，q必须能转化为T*，p使用可调用对象d替代delete释放内存|
|shared_ptr&lt;T&gt; p(p2, d)|p是shared_ptr p2的拷贝，使用可调用对象d释放内存|
|p.reset()<br>p.reset(q)<br>p.reset(q, d)|如果p是指向对象的唯一shared_ptr，reset释放指向的对象。如果传递了可选的内置指针q，则使p指向q，否则使p为空指针。如果提供了可调用对象d，则用d释放内存|

智能指针带指针参数的构造函数是`explicit`的，因此不能隐式将内置指针转换为智能指针，必须使用直接初始化形式初始化智能指针：

{% highlight cpp %}
shared_ptr<int> p1 = new int(1024);  // error: must use direct initialization
shared_ptr<int> p2(new int(1024));   // ok: uses direct initialization
{% endhighlight %}

**不要混合使用普通指针和智能指针**

一个shared_ptr只能和其他是自己拷贝的shared_ptr协调销毁操作。这是我们推荐使用`make_shared`的一个原因。它在对象创建的同时绑定到shared_ptr，这样就没有办法将一个地址绑定到多个独立创建的shared_ptr。

考虑下面的代码：

{% highlight cpp %}
// ptr is created and initialized when process is called
void process(shared_ptr<int> ptr)
{
    // use ptr
} // ptr goes out of scope and is destroyed

int *x(new int(1024)); // dangerous: x is a plain pointer, not a smart　pointer
process(x);  // error: cannot convert int* to shared_ptr<int>
process(shared_ptr<int>(x)); // legal, but the memory will be deleted!
int j = *x;  // undefined: x is a dangling pointer!
{% endhighlight %}

> **警告**
> 使用内置指针访问由智能指针管理的对象是非常危险的，因为我们不知道这个对象什么时候被释放了。

**不要使用get初始化或赋值另一个智能指针**

